<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf8"/>
        <title>CM2 (AdminSys)</title>
        <meta name="color-scheme" content="dark light">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link   href="/skeleton/index.css"  rel="stylesheet">
        <script  src="/skeleton/index.js"  type="module"     blocking="render" async></script>
        <style>
todo {
    background-color: yellow;
    color: black;
    float: right;
    &::before {
        content: "todo: "
    }
}
        </style>
    </head>
    <body>
        <main>

<h1 id="les-fichiers">Les fichiers</h1>
<h2 id="le-systÃ¨me-de-fichiers">Le systÃ¨me de fichiers</h2>
<p>Un ordinateur manipule et stocke des donnÃ©es binaires (i.e. suites de 0 et de 1). Ces donnÃ©es peuvent Ãªtre stockÃ©es :</p>
<ul>
<li>sur le disque dur/SSD, pour des donnÃ©es <strong>persistantes</strong> ;</li>
<li>sur la mÃ©moire vive (RAM), pour des donnÃ©es <strong>temporaires</strong>.</li>
</ul>
<p>ğŸ’¡ Les opÃ©rations de lecture et d&#39;Ã©criture sur la RAM sont bien plus rapides que sur le disque, cependant les donnÃ©es stockÃ©es en RAM sont perdues au redÃ©marrage de l&#39;ordinateur.</p>
<p>L&#39;OS ne va pas directement lire/Ã©crire les donnÃ©es sur le disque, mais va utiliser un <strong>systÃ¨me de fichiers</strong> (<em>filesystem</em>) qui dÃ©termine oÃ¹ et comment stocker les donnÃ©es d&#39;un <strong>fichier</strong> (<em>file</em>) sur le disque.</p>
<p>ğŸ’¡ Chaque fichier est identifiÃ© par un entier nommÃ© <strong>inode</strong> (<em><u>i</u>ndex <u>node</u></em>).</p>
<center>
    <img class="svg" src="/assets/admsys/img/filesystem.svg"/>
</center>

<p>Un <strong>volume</strong> est un <em>espace de stockage</em>, il peut ainsi Ãªtre :</p>
<ul>
<li>un disque entier ;</li>
<li>une <em>partie</em> de disque (<strong>partition</strong>) ;</li>
<li>un ensemble de partitions ;</li>
<li>une clef USB ;</li>
<li>etc.</li>
</ul>
<p>Sur un ordinateur personnel, on n&#39;utilise gÃ©nÃ©ralement qu&#39;un seul systÃ¨me de fichier, sur un seul volume (le disque entier).</p>
<h3 id="les-dossiers">Les dossiers</h3>
<p>Un <strong>dossier</strong> (<em>directory</em>), aussi appelÃ© <strong>rÃ©pertoire</strong> (<em>folder</em>), est un fichier spÃ©cial contenant l&#39;inode et le nom des fichiers qu&#39;il inclus.</p>
<div class="flex-2">
<script type="c-text">
â”œâ”€â”€ faa
â”œâ”€â”€ fee
â”œâ”€â”€ fii
â””â”€â”€ fuu
</script>
<script type="c-text">
6577185 faa
6577189 fee
6577187 fii
6577188 fuu
</script></div>

<p>ğŸ’¡ Un mÃªme fichier peut alors Ãªtre prÃ©sent dans plusieurs dossiers Ã  la fois, sous des noms diffÃ©rents.</p>
<p>ğŸ’¡ La commande <script type="c-bash">ls <h>$DIR</h></script> permet de lister le contenu d&#39;un dossier :</p>
<div class="terminal">
<pre>$ ls foo
ğŸ“„  faa  <font color="#0039AA"><b>ğŸ“‚  fee</b></font>  ğŸ“„  fii  ğŸ“„  fuu</pre>
</div>


<p>âš  Les fichiers dont le nom commence par <script type="c-text">.</script> sont des <b>fichiers cachÃ©s</b>, et ne s&#39;afficheront qu&#39;avec l&#39;option <script type="c-bash">-a</script> (<u>a</u>ll).</p>
<h3 id="les-mÃ©ta-donnÃ©es-dun-fichier">Les mÃ©ta-donnÃ©es d&#39;un fichier</h3>
<p>Le systÃ¨me de fichiers enregistre aussi, pour chaque fichier, des mÃ©ta-donnÃ©es. Notamment :</p>
<ul>
<li>son type ;</li>
<li>sa taille ;</li>
<li>sa date de derniÃ¨re modification ;</li>
<li>son propriÃ©taire ;</li>
<li>les droits d&#39;accÃ¨s au fichier.</li>
<li>etc.</li>
</ul>
<p>ğŸ’¡ La commande <script type="c-bash">stat <h>$FILE</h></script> permet d&#39;afficher l&#39;ensemble des mÃ©ta-donnÃ©es d&#39;un fichier :</p>
<div class="terminal">
<pre>$ stat foo
  FichierÂ : foo
   TailleÂ : 4096      	BlocsÂ : 8          Blocs d&apos;E/SÂ : 4096   rÃ©pertoire
PÃ©riphÃ©riqueÂ : fd01h/64769d	InÅ“udÂ : 6577172     LiensÂ : 3
AccÃ¨sÂ : (0775/drwxrwxr-x)  UIDÂ : ( 1000/ demigda)   GIDÂ : ( 1000/ demigda)
AccÃ¨sÂ : 2025-03-29 15:02:50.812405953 +0100
Modif.Â : 2025-03-29 15:02:19.868310502 +0100
ChangtÂ : 2025-03-29 15:02:19.868310502 +0100
  CrÃ©Ã©Â : 2025-03-29 15:01:55.808234278 +0100</pre>
</div>

<p>ğŸ’¡ Cependant, en pratique, on se contente gÃ©nÃ©ralement d&#39;utiliser la commande <script type="c-bash">ls -lh <h>[-d]</h> <h>$FILE[...]</h></script> :</p>
<div class="terminal">
<pre>$ ls -lh -d foo
<u style="text-decoration-style:single">Permissions</u> <u style="text-decoration-style:single"> User  </u> <u style="text-decoration-style:single"> Group </u> <u style="text-decoration-style:single"> Size </u> <u style="text-decoration-style:single">     Date Modified      </u> <u style="text-decoration-style:single"> Name  </u>
<font color="#0039AA"><b>d</b></font><font color="#44AA44">r</font><font color="#AA5500">w</font><font color="#AA0000">x</font><font color="#44AA44">r</font><font color="#AA5500">w</font><font color="#AA0000">x</font><font color="#44AA44">r</font><font color="#8A8A8A">-</font><font color="#AA0000">x</font>  <font color="#FFFFD7">demigda</font> <font color="#D7D7AF">demigda</font> <font color="#FFFFAF">4.0</font> <font color="#FFFFAF">KB</font> <font color="#00D700">Tue Apr  1 09:16:45 2025</font> <font color="#0039AA"><b>ğŸ“‚  foo</b></font></pre>
</div>

<p>âš  Il convient de ne pas confondre ces mÃ©ta-donnÃ©es, stockÃ©es au niveau du systÃ¨me de fichiers, et communes entre tous les fichiers, avec des mÃ©ta-donnÃ©es stockÃ©es dans le fichier, et dÃ©pendant de son format (e.g. png, jpeg, pdf, zip).</p>
<h3 id="les-permissions">Les permissions</h3>
<p>Sous Linux, il est possible d&#39;attribuer 3 types de droits sur un fichier :</p>
<ul>
<li><script type="c-text">r</script> (<u>r</u>ead) : <b>lecture</b> du fichier (ou <b>lister</b> le contenu d'un dossier).</li>
<li><script type="c-text">w</script> (<u>w</u>rite) : <b>Ã©criture</b> du fichier (ou <b>modifier</b> le contenu d'un dossier).</li>
<li><script type="c-text">x</script> (e<u>x</u>ec) : <b>exÃ©cution</b> du fichier script/binaire qui est alors un <i>exÃ©cutable</i> (ou <b>aller dans</b> le dossier).</li>
</ul>
<p>âš  Lorsque vous crÃ©ez un script, il est alors important se donner le droit d&#39;exÃ©cution (et de lecture) sur le fichier de script.</p>
<p>Les droits sont alors dÃ©crits par 3 caractÃ¨res : si le droit est donnÃ©, la lettre correspondante est affichÃ©e (<script type="c-text">r</script>, <script type="c-text">w</script>, <script type="c-text">x</script>).<br/>
Ainsi <script type="c-bash">rw-</script> correspond au droit de lecture et d&#39;Ã©criture, sans le droit d&#39;exÃ©cution.</p>
<p>Par dÃ©faut, ces droits peuvent Ãªtre attribuÃ©s Ã  :</p>
<ul>
<li>l&#39;<strong>utilisateur</strong> (<em>user</em>) propriÃ©taire du fichier (les 3 premiers caractÃ¨res, e.g. <script type="c-text">rwx</script>).</li>
<li>le <strong>groupe</strong> d&#39;utilisateur (<em>group</em>) propriÃ©taire du fichier  (les 3 caractÃ¨res du milieu, e.g. <script type="c-text">rwx</script>);</li>
<li>les <strong>autres</strong> utilisateurs (les 3 derniers caractÃ¨res, e.g. <script type="c-text">r-x</script>).</li>
</ul>
<p>ğŸ’¡ L&#39;utilisateur/groupe d&#39;utilisateur propriÃ©taire d&#39;un fichier peut Ãªtre modifiÃ© grÃ¢ce Ã  la commande <script type="c-bash">chown</script> (<u>ch</u>ange <u>own</u>er) :</p>
<script type="c-bash">
chown <h>[-R]</h> <h>[$USER][:$GROUP]</h> <h>$FILES...</h>
</script>

<p>ğŸ’¡ Les droits attribuÃ©s sur un fichier peuvent Ãªtre modifiÃ©s grÃ¢ce Ã  la commande <script type="c-bash">chmod</script> (<u>ch</u>ange <u>mod</u>e) :</p>
<script type="c-bash">
chmod <h>[-R]</h> <h>$MODE,...</h> <h>$FILES...</h>
</script>

<script type="c-text"><h>$MODE</h></script> s'Ã©crit sous la forme suivante :
<div class="flex-3">
    <div>
        <center><script type="c-text"><h>$QUI</h></script></center>
        <ul>
            <li><script type="c-text">u</script> (<u>u</u>ser) : l'<b>utilisateur</b> propriÃ©taire</li>
            <li><script type="c-text">g</script> (<u>g</u>roup) : le <b>groupe</b> propriÃ©taire</li>
            <li><script type="c-text">o</script> (<u>o</u>ther) : les <b>autres</b></li>
            <li><script type="c-text">a</script> (<u>a</u>ll) : <b>tous</b> les utilisateurs</li>
        </ul>
    </div><div><center><script type="c-text"><h>$OP</h></script></center>
        <ul>
            <li><script type="c-text">+</script> : <b>ajouter</b></li>
            <li><script type="c-text">-</script> : <b>retirer</b></li>
            <li><script type="c-text">=</script> : <b>appliquer</b></li>
        </ul>
    </div><div>
        <center><script type="c-text"><h>$DROITS</h></script></center>
        <ul>
            <li><script type="c-text">r</script></li>
            <li><script type="c-text">x</script></li>
            <li><script type="c-text">w</script></li>
        </ul>
    </div>
</div>

<p>Quelques exemples :</p>
<ul>
<li><script type="c-text">u+x</script> : ajouter le droit d'exÃ©cution Ã  l'utilisateur propriÃ©taire.</li>
<li><script type="c-text">go-r</script> : retire le droit de lecture au groupe propriÃ©taire et aux autres.</li>
<li><script type="c-text">o=rx</script> : donne aux autres uniquement les droits de lecture et d'exÃ©cution (ils n'auront pas le droit de lecture). </li>
<li><script type="c-text">a-x,a+r</script> : retire le droit d'exÃ©cution Ã  tous, et ajoute le droit de lecture.</li>
</ul>
<p>ğŸ’¡ <script type="c-bash">-R</script> (<u>r</u>ecursive) permet d&#39;appliquer les changements de maniÃ¨re rÃ©cursive au dossier.</p>
<h2 id="les-chemins">Les chemins</h2>
<p>Comme nous l&#39;avons vu, l&#39;<em>inode</em> identifie chaque fichier par un numÃ©ro. Cependant il est peu pratique pour un humain :<br/></p>
<ul>
<li>Ã  quoi correspond le fichier <script type="c-text">6577188</script> ?</li>
<li>quel est l&#39;<em>inode</em> du dossier dans lequel j&#39;ai enregistrÃ© mes note de cours ?</li>
</ul>
<p>Ã€ la place, on utilise des <strong>chemins</strong> pour dÃ©signer les fichiers de maniÃ¨re plus explicite et simple Ã  retenir.</p>
<h3 id="chemin-absolu">Chemin absolu</h3>
<p>Sous Linux tous les fichiers sont, directement ou indirectement, contenus dans le dossier <strong>racine</strong> (<em>root directory</em>), notÃ© <script type="c-text">/</script> :</p>
<div class="terminal">
<pre>
<font color="#0039AA"><b>ğŸ“‚ /</b></font>
<font color="#8A8A8A">â””â”€â”€ </font><font color="#0039AA"><b>ğŸ“‚ tmp</b></font>
    <font color="#8A8A8A">â””â”€â”€ </font><font color="#0039AA"><b>ğŸ“‚ foo</b></font>
        <font color="#8A8A8A">â”œâ”€â”€ </font>ğŸ“„ faa
        <font color="#8A8A8A">â”œâ”€â”€ </font><font color="#0039AA"><b>ğŸ“‚ fee</b></font>
        <font color="#8A8A8A">â”œâ”€â”€ </font>ğŸ“„ fii
        <font color="#8A8A8A">â””â”€â”€ </font>ğŸ“„ fuu</pre>
</div>

<p>Le <strong>chemin absolu</strong> (<em>absolute path</em>) identifie alors un fichier par son emplacement par rapport Ã  la <strong>racine</strong>, i.e. en partant de la racine, le chemin Ã  emprunter pour atteindre ce fichier. Ainsi, pour atteindre le fichier <script type="c-text">faa</script>, il faudra partir de la racine <script type="c-text">/</script>, puis aller dans les dossiers <script type="c-text">tmp</script>, puis <script type="c-text">foo</script>, pour enfin atteindre <script type="c-text">faa</script>, donnant ainsi le chemin absolu : <script type="c-text">/tmp/foo/faa</script>.</p>
<p>ğŸ’¡ Par convention, lorsque le chemin dÃ©signe un dossier, on le suffixera par <script type="c-text">/</script>, e.g. <script type="c-text">/tmp/foo/fee/</script>.</p>
<p>âš  Lorsque vous utilisez un chemin absolu dans vos scripts, il n&#39;y a aucune garantie que le fichier visÃ© soit placÃ© exactement au mÃªme endroit d&#39;un ordinateur Ã  l&#39;autre. Il convient ainsi d&#39;Ã©viter les chemins absolus dans vos scripts.</p>
<h3 id="chemin-relatif">Chemin relatif</h3>
<p>Sous Linux, le <strong>dossier de travail</strong> (<em>working directory</em>), notÃ© <script type="c-text">./</script>, dÃ©signe le dossier dans lequel on se trouve actuellement.</p>
<p>ğŸ’¡ La commande <script type="c-bash">pwd</script> (<em><u>p</u>rint <u>w</u>orking <u>d</u>irectory</em>) permet d&#39;afficher le dossier de travail :</p>
<div class="terminal"><pre>$ pwd
/tmp/foo
</pre></div>

<p>ğŸ’¡ Ce dossier est aussi usuellement indiquÃ© dans l&#39;<strong>invite de commande</strong> : <div class="terminal"><pre><font color="#4CE64C"><b>demigda@demigda-Latitude-5400</b></font>:<font color="#295FCC"><b>/tmp/foo</b></font>$</pre></div></p>
<p>ğŸ’¡ La commande <script type="c-bash">cd <h>$DIR</h></script> (<em><u>c</u>hange <u>d</u>irectory</em>) permet de se dÃ©placer dans le dossier <script type="c-bash"><h>$DIR</h></script>.</p>
<p>Le <strong>chemin relatif</strong> (<em>relative path</em>) identifie alors un fichier par son emplacement par rapport au <strong>dossier de travail</strong>, i.e. en partant du dossier de travail, le chemin Ã  emprunter pour atteindre ce fichier. Ainsi, pour atteindre le fichier <script type="c-text">faa</script>, Ã  partir de <script type="c-text">/tmp/</script>, il faudra partir du dossier de travail <script type="c-text">./</script>, puis aller dans le dossier <script type="c-text">foo</script>, pour enfin atteindre <script type="c-text">faa</script>, donnant ainsi le chemin relatif : <script type="c-text">./foo/faa</script>.</p>
<p>ğŸ’¡ <script type="c-text">..</script> reprÃ©sente le parent d&#39;un dossier. Ainsi, Ã  partir de <script type="c-text">/tmp/foo/fee/</script>, <script type="c-text">./../../</script> dÃ©signe le dossier <script type="c-text">tmp/</script>.</p>
<p>âš  Dans un script, les chemins relatifs sont Ã©valuÃ©s relativement au dossier de travail actuel, et non relativement Ã  l&#39;emplacement du script. Il convient donc de faire attention Ã  vos chemins relatifs.</p>
<p>ğŸ’¡ Le code suivant vous permet de placer le dossier de travail Ã  l&#39;emplacement du script :</p>
<div class="flex-2">
    <div>
        <center><b>Python:</b></center>
        <script type="c-python">
            import os
            os.chdir( os.path.dirname(__file__) )
        </script>
    </div><div>
        <center><b>Shell:</b></center>
        <script type="c-python">
            cd $(dirname "$0")
        </script>
    </div>
</div>

<h3 id="manipuler-les-fichiers">Manipuler les fichiers</h3>
<p>Sous Linux, il existe un ensemble de commandes standards permettant de manipuler les fichiers :</p>
<ul>
<li><script type="c-bash">mkdir   <h>$DIR...</h></script> (<i><u>m</u>a<u>k</u>e <u>dir</u>ectory</i>) <b>crÃ©er un dossier</b> vide.</li>
<li><script type="c-bash">touch   <h>$FILE...</h></script> <b>crÃ©er un fichier</b> vide.</li>
<li><script type="c-bash">rm <h>[-r]</h> <h>$FILE...</h></script> (<i><u>r</u>e<u>m</u>ove</i>) <b>supprimer</b> des fichiers.</li>
<li><script type="c-bash">cp <h>[-r]</h> <h>$SRC...</h> <h>$DST</h>/</script> (<i><u>c</u>o<u>p</u>y</i>) <b>copier</b> des fichiers.</li>
<li><script type="c-bash">mv      <h>$SRC...</h> <h>$DST</h>/</script> (<i><u>m</u>o<u>v</u>e</i>) <b>dÃ©placer</b> des fichiers.</li>
<li><script type="c-bash">mv      <h>$SRC</h>    <h>$DST</h>/<h>$NAME</h></script> <b>dÃ©placer et renommer</b> un fichier.</li>
<li><script type="c-bash">find <h>$DIR</h> -name <h>$NAME</h></script> rechercher (rÃ©cursivement) dans le dossier <script type="c-bash"><h>$DIR</h></script> les fichiers correspondant Ã  <script type="c-bash"><h>$NAME</h></script>.</li>
</ul>
<p>ğŸ’¡ L&#39;option <script type="c-bash">-r</script> permet de copier/supprimer des dossiers.<br/>
ğŸ’¡ <script type="c-bash">mkdir -p <h>$DIR</h></script> permet, s&#39;ils n&#39;existent pas, de crÃ©er aussi les dossiers parents de <script type="c-bash"><h>$DIR</h></script>.</p>
<p>âš  Les fichiers supprimÃ©s via <script type="c-bash">rm</script> ne sont pas placÃ©s dans la corbeille et sont donc supprimÃ©s <strong>dÃ©finitivement</strong>.<br/>
Il est ainsi recommandÃ© d&#39;utiliser la commande <script type="c-bash">trash <h>$FILE...</h></script> Ã  la place afin de dÃ©placer les fichiers dans la corbeille.</p>
<h3 id="ensemble-de-chemins">Ensemble de chemins</h3>
<p>Lorsqu&#39;on souhaite manipuler plusieurs fichiers Ã  la fois, e.g. via <script type="c-bash">cp</script>, <script type="c-bash">mv</script>, <script type="c-bash">rm</script>, etc. on prÃ©fÃ¨re Ã©viter d&#39;avoir Ã  Ã©crire leurs chemins uns Ã  uns.</p>
<p>Pour cela on peut reprÃ©senter un ensemble de chemins en utilisant les <strong>caractÃ¨res de remplacements</strong> (<em>wildcard</em>) suivants :</p>
<ul>
<li><script type="c-text">*</script> : reprÃ©sente 0 Ã  plusieurs <b>caractÃ¨res</b>, e.g. <script type='c-bash'>./*.txt</script> : tous les fichiers d'extension ".txt".</li>
<li><script type="c-text">**/</script> : reprÃ©sente 0 Ã  plusieurs <b>dossiers</b>, e.g. <script type='c-bash'>./**/foo.txt</script> : le fichier "foo.txt" dans un des sous dossiers.</li>
<li><script type="c-text">{<h>$VALS,...</h>}</script> : reprÃ©sente une <b>alternative</b>, e.g. <script type="c-bash">./{foo, faa}.txt</script> : "foo.txt" ou "faa.txt" dans le dossier courant.</li>
</ul>
<p>ğŸ’¡ <script type="c-text">~<h>[$USER]</h>/</script> est un alias reprÃ©sentant le chemin absolu du home de l&#39;utilisateur <script type="c-text"><h>$USER</h></script> (utilisateur actuel si non prÃ©cisÃ©).</p>
<p>ğŸ’¡ Afin d&#39;Ã©viter les erreurs dans la saisie d&#39;un chemin, il est trÃ¨s vivement encouragÃ© d&#39;utiliser l&#39;auto-complÃ©tion du shell.</p>
<h2 id="prÃ©voir-des-sauvegardes">PrÃ©voir des sauvegardes</h2>
<h3 id="motivations">Motivations</h3>
<p>Une sauvegarde n&#39;est rÃ©ellement utile que lorsqu&#39;on perd ses donnÃ©es, i.e. lorsqu&#39;il est dÃ©jÃ  trop tard. Il est ainsi nÃ©cessaire d&#39;anticiper et d&#39;effectuer rÃ©guliÃ¨rement des sauvegardes de ses donnÃ©es afin de se prÃ©munir contre d&#39;Ã©ventuelles pertes.</p>
<p>Ces pertes peuvent survenir suite Ã  une erreur de manipulation, Ã  un acte de cyberdÃ©linquance, Ã  une dÃ©faillance du matÃ©riel, Ã  un incendie, etc. Elles sont usuellement rares, mais le coÃ»t d&#39;une perte de donnÃ©es Ã©levÃ©.</p>
<p>Les pertes de donnÃ©es ont un triple coÃ»t :</p>
<ul>
<li>le coÃ»t de la remise en service ;</li>
<li>le coÃ»t de l&#39;interruption des activitÃ©s ;</li>
<li>le coÃ»t de l&#39;impossibilitÃ© d&#39;honorer des obligations contractuelles.</li>
</ul>
<p>Ces coÃ»ts peuvent engendrer la faillite d&#39;une entreprise, en effet 60% des entreprises victimes d&#39;un ranÃ§ongiciel dÃ©posent le bilan peu aprÃ¨s l&#39;attaque. La perte de donnÃ©es peut en effet concerner des <u>dÃ©cennies</u> de travail, que ce soit des donnÃ©es clients ou fournisseurs, des outils dÃ©veloppÃ©s en interne dont les dÃ©veloppeurs ont quittÃ© l&#39;entreprise depuis longtemps, etc. De plus le temps dâ€™interruption et de restauration des services constitue un manque Ã  gagner pour l&#39;entreprise, et impacte sa rÃ©putation.</p>
<p>Plus grave encore, lorsque ces pertes de donnÃ©es touchent des hÃ´pitaux, oÃ¹ une dÃ©gradation des services peut se traduire en vies humaines.</p>
<p>âš  Il est ainsi vital d&#39;effectuer <u>rÃ©guliÃ¨rement</u> des sauvegardes, en s&#39;assurant que la procÃ©dure de restauration est fonctionnelle, et peut Ãªtre rapidement mise en place.</p>
<p>âš  Il est important que les sauvegardes soient stockÃ©es dans des lieux diffÃ©rents afin de se prÃ©munir contre des incidents pouvant toucher toute une zone (e.g. cambriolages, incendies, inondations, etc).</p>
<p>âš  De la mÃªme maniÃ¨re des sauvegardes sur des disques coupÃ©s du rÃ©seau permettent de se protÃ©ger contre des attaques touchant l&#39;intÃ©gralitÃ© du systÃ¨me informatique (e.g. ranÃ§ongiciel).</p>
<h3 id="organiser-ses-fichiers">Organiser ses fichiers</h3>
<p>PrÃ©parer une sauvegarde commence par rÃ©flÃ©chir Ã  :</p>
<ul>
<li><strong>quoi</strong> : que va-t-on sauvegarder ?</li>
<li><strong>comment</strong> et <strong>oÃ¹</strong> va-t-on enregistrer la sauvegarde ?</li>
<li><strong>quand</strong> et <strong>Ã  quelle frÃ©quence</strong> va-t-on effectuer la sauvegarde ?</li>
</ul>
<p>Pour cela, la premiÃ¨re Ã©tape est dÃ©jÃ  de bien organiser ses fichiers. Cela permet non-seulement de facilement pouvoir retrouver un fichier au quotidien, d&#39;identifier les fichiers obsolÃ¨tes, mais aussi de faciliter les sauvegardes. Par exemple :</p>
<ul>
<li><script type="c-text">~/Documents/</script> : mes supports de cours, rendus de TP, etc. Ã  sauvegarder chaque soir.</li>
<li><script type="c-text">~/TÃ©lÃ©chargements/</script> : mes tÃ©lÃ©chargements temporaires, ne nÃ©cessite pas de sauvegardes.</li>
</ul>
<p>Bien organiser ses fichiers demande aussi de conserver une arborescence consistante et cohÃ©rente. Par exemple :</p>
<ul>
<li><script type="c-text">~/Documents/<h>$SEMESTRE</h>/<h>$MODULE</h>/{TP,CM}/</script> : pour les fichiers du module <script type="c-text"><h>$MODULE</h></script></li>
</ul>
<h3 id="les-fichiers-des-applications">Les fichiers des applications</h3>
<p>Afin de garder une arborescence propre et explicite, les logiciels Ã©vitent d&#39;Ã©crire leurs fichiers n&#39;importe oÃ¹. Pour cela on respecte autant que possible des <strong>conventions</strong>. Cela permet notamment d&#39;Ã©viter des conflits, e.g. deux exÃ©cutables souhaitant utiliser le mÃªme chemin pour deux fichiers diffÃ©rents.</p>
<p>Par convention on distingue 3 niveaux :</p>
<ul>
<li><script type="c-text">/usr/</script> : les applications standards installÃ©es, potentiellement partagÃ©es entre plusieurs ordinateurs.</li>
<li><script type="c-text">/usr/local/</script> : les applications installÃ©es localement, spÃ©cifique Ã  cet ordinateur.</li>
<li><script type="c-text">~/.local/</script> : les applications/configurations personnelles, spÃ©cifique Ã  un utilisateur.</li>
</ul>
<p>Par convention, on distingue alors 7 sous-dossiers (pas entiÃ¨rement consistant) :</p>
<table>
    <thead>
        <tr><th></th><th>Standard</th><th>Local</th><th>Personnel</th></tr>
    </thead>
    <tbody>
        <tr>
            <th>Base</th>
            <td><script type="c-text">/usr/</script></td>
            <td><script type="c-text">/usr/local/</script></td>
            <td><script type="c-text">~/.local/</script></td>
        </tr><tr>
            <th>ExÃ©cutables</th>
            <td><script type="c-text">/usr/<h>bin</h>/</script></td>
            <td><script type="c-text">/usr/local/<h>bin</h>/</script></td>
            <td><script type="c-text">~/.local/<h>bin</h>/</script></td>
        </tr><tr>
            <th>ExÃ©cutables (admin)</th>
            <td><script type="c-text">/usr/<h>sbin</h>/</script></td>
            <td><script type="c-text">/usr/local/<h>sbin</h>/</script></td>
        </tr><tr>
            <th>BibliothÃ¨ques</th>
            <td><script type="c-text">/usr/<h>lib</h>/</script></td>
            <td><script type="c-text">/usr/local/<h>lib</h>/</script></td>
            <td><script type="c-text">~/.local/<h>lib</h>/</script></td>
        </tr><tr>
            <th>Ressources</th>
            <td><script type="c-text">/usr/<h>share</h>/</script></td>
            <td><script type="c-text">/usr/local/<h>share</h>/</script></td>
            <td><script type="c-text">~/.local/<h>share</h>/</script></td>
        </tr><tr>
            <th>Configuration</th>
            <td><script type="c-text">/etc/<h>$NAME</h>/</script></td>
            <td><script type="c-text">/usr/local/<h>etc</h>/<h>$NAME</h>/</script></td>
            <td><script type="c-text">~/.config/<h>$NAME</h>/</script></td>
        </tr><tr>
            <th>Cache</th>
            <td><script type="c-text">/var/<h>cache</h>/<h>$NAME</h>/</script></td>
            <td><script type="c-text">/var/local/<h>$NAME</h>/</script></td>
            <td><script type="c-text">~/.cache/<h>$NAME</h>/</script></td>
        </tr>
    </tbody>
</table>

<p>ğŸ’¡ Par dÃ©faut, lorsque vous entrez une commande, le shell va rechercher, puis exÃ©cuter, le fichier de mÃªme nom prÃ©sent dans <script type="c-text">/usr/bin/</script> ou <script type="c-text">/usr/local/bin/</script>.</p>
<p>ğŸ’¡ La commande <script type="c-text">type <h>$CMD</h></script> permet d&#39;afficher le type et l&#39;emplacement de la commande <script type="c-text"><h>$CMD</h></script>.</p>
<p>âš  Les fichiers temporaires sont usuellement enregistrÃ©s dans <script type="c-text">/tmp/</script>. Cependant, il convient d&#39;en gÃ©nÃ©rer alÃ©atoirement les noms afin d&#39;Ã©viter des conflits.</p>
<p>ğŸ’¡ Il est aussi possible d&#39;installer ses applications locales dans <script type="c-text">/opt/<h>$NAME</h>/</script>, Ã©vitant ainsi d&#39;avoir Ã  en disperser le contenu, entre ses executables, bibliothÃ¨ques, et configurations.</p>
<p>âš  Malheureusement, ces conventions ne sont pas toujours trÃ¨s bien respectÃ©es. Par exemple :</p>
<ul>
<li><script type="c-text">~/.ssh/</script> contient la configuration SSH d'un utilisateur (cf TP).</li>
<li><script type="c-text">~/.bashrc</script> contient la configuration du shell d'un utilisateur (cf TP).</li>
</ul>
<h3 id="arborescence-linux">Arborescence Linux</h3>
<p>Sous Linux les fichiers sont organisÃ©s comme suit :</p>
<ul>
<li><script type="c-text">/home/<h>$USER</h>/</script> : les fichiers <b>personnels</b> de l'utilisateur <script type="c-text"><h>$USER</h></script> (donc dossier potentiellement <b>sensible</b>).</li>
<li><script type="c-text">/usr/{lib,bin,sbin}/</script> : logiciels installÃ©s, peut Ãªtre en <b>lecture seule</b> et <b>partagÃ©</b> entre plusieurs ordinateurs.</li>
<li><script type="c-text">/etc/<h>$NAME</h>/</script> : configuration du logiciel <script type="c-text"><h>$NAME</h></script>, donnÃ©es <b>spÃ©cifiques</b> Ã  l'ordinateur, peut Ãªtre en <b>lecture seule</b>.</li>
<li><script type="c-text">/srv/<h>$NAME</h>/</script> : fichiers servis par le serveur (e.g. pour un serveur Web, de fichier, etc), peu utilisÃ© de nos jours.</li>
<li><script type="c-text">/var/</script> : donnÃ©es Ã©crites par les logiciels en cours d'exÃ©cution, <script type="c-text">/var/logs/<h>$NAME</h>/</script> contient les logs.</li>
<li><script type="c-text">/tmp/</script> : les fichiers temporaires, supprimÃ©s au redÃ©marrage de la machine, gÃ©nÃ©ralement stockÃ©s en RAM.</li>
</ul>
<p>ğŸ’¡ Pour de <strong>gros</strong> fichiers temporaire, on utilisera gÃ©nÃ©ralement <script type="c-text">/var/tmp/</script> au lieu de <script type="c-text">/tmp/</script>.</p>
<p>âš  Pour des raisons de sÃ©curitÃ© les utilisateurs ne peuvent (sauf exceptions) modifier que les fichiers contenus dans leur propre home. <script type="c-text">/tmp/</script> et <script type="c-text">/var/tmp/</script> sont deux exceptions Ã  cela.</p>
<h2 id="volumes-et-partitions">Volumes et partitions</h2>
<h3 id="motivations-1">Motivations</h3>
<h4 id="utiliser-diffÃ©rents-systÃ¨mes-de-fichiers">Utiliser diffÃ©rents systÃ¨mes de fichiers</h4>
<p>Comme nous l&#39;avons vu prÃ©cÃ©demment, les diffÃ©rents dossiers d&#39;un systÃ¨me Linux peuvent avoir diffÃ©rents besoins :</p>
<ul>
<li>sauvegardes frÃ©quentes ;</li>
<li>lecture seule ;</li>
<li>partagÃ© sur le rÃ©seau ;</li>
<li>stockÃ© en RAM.</li>
</ul>
<p>Pour cela il nous faudrait utiliser diffÃ©rents systÃ¨mes de fichiers fournissant les fonctionnalitÃ©s dÃ©sirÃ©es :</p>
<ul>
<li>compression des donnÃ©es sur le disque (<script type="c-text">ZFS</script>, <script type="c-text">BTRFS</script>) ;</li>
<li>chiffrement des donnÃ©es sur le disque (via <script type="c-text">cryptosetup</script>) ;</li>
<li>conservation d&#39;un historique des fichiers (via <script type="c-text">ZFS</script>, ou <script type="c-text">LVM</script>) ;</li>
<li>modifications possibles mais non-persistantes (via <script type="c-text">aufs</script>, <script type="c-text">unionfs</script>, <script type="c-text">overlayfs</script>, ou <script type="c-text">mergefs</script>);</li>
<li>donnÃ©es stockÃ©es sur la RAM (<script type="c-text">tmpfs</script>);</li>
<li>donnÃ©es stockÃ©es Ã  distance (<script type="c-text">NFS</script>, <script type="c-text">sshfs</script>);</li>
<li>etc.</li>
</ul>
<p>Or, un volume ne peut contenir qu&#39;un seul systÃ¨me de fichier. Ainsi, si on souhaite utiliser plusieurs systÃ¨mes de fichiers, il nous faut alors dÃ©couper nos ressources de stockages en plusieurs volumes.</p>
<p>ğŸ’¡ Par dÃ©faut, les systÃ¨mes de fichiers suivants sont usuellement utilisÃ©s :</p>
<ul>
<li><script type="c-text">ext4</script> pour Linux ;</li>
<li><script type="c-text">NTFS</script> pour Windows ;</li>
<li><script type="c-text">APFS</script> pour Apple ;</li>
<li><script type="c-text">FAT32</script> pour les clefs USB ;</li>
</ul>
<h4 id="sÃ©parer-les-donnÃ©es-du-systÃ¨me-dexploitation">SÃ©parer les donnÃ©es du systÃ¨me d&#39;exploitation</h4>
<p>Il est possible, et mÃªme recommandÃ©, d&#39;enregistrer les donnÃ©es et le systÃ¨me d&#39;exploitation sur deux volumes diffÃ©rents. Cela permet en effet de (rÃ©)installer le systÃ¨me d&#39;exploitation sans effacer les donnÃ©es dÃ©jÃ  prÃ©sentes.</p>
<p>âš  Il est trÃ¨s vivement recommandÃ© de sauvegarder ses donnÃ©es avant toutes opÃ©rations de ce genre.</p>
<p>Il est aussi possible d&#39;installer plusieurs systÃ¨mes d&#39;exploitations sur un mÃªme ordinateur, qu&#39;on pourra alors choisir au dÃ©marrage. Cela permet :</p>
<ul>
<li>d&#39;avoir un dual boot Linux-Windows ;</li>
<li>d&#39;avoir un systÃ¨me d&#39;exploitation de secours ;</li>
<li>de tester un systÃ¨me d&#39;exploitation.</li>
</ul>
<p>ğŸ’¡ Lorsque le systÃ¨me d&#39;exploitation est installÃ© sur une clef USB, on parle alors de live USB.</p>
<p>âš   Il est trÃ¨s vivement recommandÃ© d&#39;avoir au moins un live USB.</p>
<h3 id="crÃ©er-et-formatter-une-partition">CrÃ©er et formatter une partition</h3>
<p>Un volume peut Ãªtre identifiÃ© par 3 Ã©lÃ©ments :</p>
<ul>
<li>un <strong>chemin</strong> dans <script type="c-text">/dev/</script>, e.g. <script type="c-text">/dev/sda</script>, le nom est susceptible de changer si l&#39;ordre des disques change.</li>
<li>un <strong>UUID</strong> (<em>IDentifiant Universel Unique</em>), e.g. <script type="c-text">42d1660e-e04c-4a76-b40e-61aa62798ed2</script>, peu explicite.</li>
<li>une <strong>Ã©tiquette</strong> (<em>label</em>), e.g. <script type="c-text">DATA</script>, explicite mais pas de garantie d&#39;unicitÃ©.</li>
</ul>
<p>âš  L&#39;UUID et l&#39;Ã©tiquette peuvent Ãªtres placÃ©s au niveau de la partition, ou du systÃ¨me de fichier.</p>
<p>ğŸ’¡ Dans le cadre des TP nous vous fournissons la commande <script type="c-bash">lsvol</script> permettant d&#39;afficher les volumes :</p>
<div class="terminal">
<pre># lsvol
PATH              LABEL TYPE  PARTTYPENAME       SIZE FSUSE% FSTYPE
/dev/nvme0n1            disk                   238,5G                    
â”œâ”€/dev/nvme0n1p1  EFI   part  EFI System         512M     1% vfat
â”œâ”€/dev/nvme0n1p2  BOOT  part  Linux filesystem   732M    36% ext4
</pre>
</div>

<p>Un disque peut Ãªtre dÃ©coupÃ© en 4 partitions appelÃ©es <strong>partitions primaires</strong>, qui peuvent elles-mÃªme Ãªtre dÃ©coupÃ©es en plusieurs <strong>partitions secondaires</strong>.</p>
<p>Pour manipuler les partitions d&#39;un disque, on utilise gÃ©nÃ©ralement un logiciel comme gparted, ou la commande <script type="c-bash">fdisk <h>$DISK</h></script>. Il est ainsi possible d&#39;ajouter une partition au disque s&#39;il lui reste de l&#39;espace disponible :</p>
<div class="terminal">
<pre># lsvol
PATH              LABEL TYPE  PARTTYPENAME       SIZE FSUSE% FSTYPE
/dev/nvme0n1            disk                   238,5G                    
â”œâ”€/dev/nvme0n1p1  EFI   part  EFI System         512M     1% vfat
â”œâ”€/dev/nvme0n1p2  BOOT  part  Linux filesystem   732M    36% ext4
â”œâ”€/dev/nvme0n1p3        part                   237,3G
</pre>
</div>

<p>ğŸ’¡ Dans le cadre des TP, on utilisera la commande TUI <script type="c-bash">cfdisk <h>$DISK</h></script>. Par exemple <script type="c-bash">cfdisk <h>/dev/nvme0n1</h></script>.</p>
<p>Pour le moment la partition est vide, il faut maintenant la <strong>formatter</strong>, i.e. lui attribuer un systÃ¨me de fichier. Cela peut Ãªtre fait via la commande <script type="c-bash">mkfs.<h>$FS</h> <h>$VOL</h></script> :</p>
<div class="terminal">
<pre># mkfs.ext4 /dev/nvme0n1p3
# lsvol
PATH              LABEL TYPE  PARTTYPENAME       SIZE FSUSE% FSTYPE
/dev/nvme0n1            disk                   238,5G                    
â”œâ”€/dev/nvme0n1p1  EFI   part  EFI System         512M     1% vfat
â”œâ”€/dev/nvme0n1p2  BOOT  part  Linux filesystem   732M    36% ext4
â”œâ”€/dev/nvme0n1p3        part  Linux filesystem 237,3G     0% ext4
</pre>
</div>

<p>Il ne nous reste ensuite plus qu&#39;Ã  attribuer une Ã©tiquette au nouveau volume ainsi crÃ©Ã©.</p>
<div class="terminal">
<pre># e2label /dev/nvme0n1p3 DATA
# lsvol
PATH              LABEL TYPE  PARTTYPENAME       SIZE FSUSE% FSTYPE
/dev/nvme0n1            disk                   238,5G                    
â”œâ”€/dev/nvme0n1p1  EFI   part  EFI System         512M     1% vfat
â”œâ”€/dev/nvme0n1p2  BOOT  part  Linux filesystem   732M    36% ext4
â”œâ”€/dev/nvme0n1p3  DATA  part  Linux filesystem 237,3G     0% ext4
</pre>
</div>

<p>âš  La commande permettant d&#39;attribuer une Ã©tiquette au volume change en fonction du systÃ¨me de fichier utilisÃ©.</p>
<h3 id="monter-des-volumes">Monter des volumes</h3>
<p>Maintenant que nous avons un nouveau volume, il nous faut l&#39;ajouter Ã  notre arborescence. C&#39;est Ã  dire choisir un dossier dont le contenu sera celui de notre volume. On appelle cette opÃ©ration <strong>monter</strong> (<em>mount</em>) un volume, et le dossier dans lequel il est montÃ©, le <strong>point de montage</strong> (<em>mountpoint</em>) :</p>
<div class="terminal">
<pre># lsvol
PATH              LABEL TYPE  PARTTYPENAME       SIZE FSUSE% FSTYPE MOUNTPOINT
/dev/nvme0n1            disk                   238,5G                    
â”œâ”€/dev/nvme0n1p1  EFI   part  EFI System         512M     1% vfat   /boot/efi
â”œâ”€/dev/nvme0n1p2  BOOT  part  Linux filesystem   732M    36% ext4   /boot
â”œâ”€/dev/nvme0n1p3  DATA  part  Linux filesystem 237,3G     0% ext4   /
</pre>
</div>

<p>Pour monter un volume, on utilise la commande <script type="c-bash">mount -L <h>$LABEL</h> <h>$DIR</h></script>. Cette derniÃ¨re possÃ¨de de nombreuses options, notamment pour monter le volume en lecture seule (<script type="c-bash">-o ro</script>).</p>
<p>ğŸ’¡ Par dÃ©faut, on monte usuellement les volumes dans les dossiers suivants :</p>
<ul>
<li><script type="c-text">/media/<h>$NAME</h>/</script> : pour les volumes amovibles (e.g. clef USB) ;</li>
<li><script type="c-text">/mnt/<h>$NAME</h>/</script> : pour les volumes montÃ©s manuellement.</li>
</ul>
<p>ğŸ’¡ La commande <script type="c-bash">umount <h>$DIR</h></script> permet l&#39;opÃ©ration inverse, celui de dÃ©monter le volume.</p>
<p>ğŸ’¡ Le fichier <script type="c-text">/etc/fstab</script> (<em>FileSystem TABle</em>) liste les systÃ¨mes de fichiers Ã  monter au dÃ©marrage de la machine :</p>
<script type="c-text">
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
LABEL=DATA      /               ext4    errors=remount-ro 0       1
</script>

<p>Il est alors possible d&#39;indiquer les informations suivantes :</p>
<ul>
<li><script type="c-text"><options></script> : les options Ã  transmettre Ã  la commande <script type="c-bash">mount</script>. (noauto cf TP).</li>
<li><script type="c-text"><dump></script> : obsolÃ¨te.</li>
<li><script type="c-text"><pass></script> : l'ordre dans lequel monter le systÃ¨me de fichier (1 pour la racine, 2+ pour les suivants).</li>
</ul>
<p>ğŸ’¡ Il est aussi possible de monter des volumes NFS (<em>Network FileSystem</em>) distants,<br>cf https://doc.ubuntu-fr.org/disque_reseau</p>
<p>ğŸ’¡ Il est aussi possible de monter des dossiers distants via SSH avec la commande <script type="c-bash">sshfs</script>, cf TP.</p>
<h2 id="techniques-de-sauvegardes">Techniques de sauvegardes</h2>
<h3 id="au-niveau-du-volume">Au niveau du volume</h3>
<p>Une mÃ©thode triviale de sauvegarde est tout simplement de copier le contenu du volume, octets par octets :</p>
<script type="c-bash">
dd <h>[conv=sparse]</h> if=<h>$SRC</h> of=<h>$DST</h>
</script>

<p>Cependant, cette mÃ©thode gÃ©nÃ¨re des sauvegardes volumineuses, bien qu&#39;il soit possible de les compresser ensuite.</p>
<h4 id="raid">RAID</h4>
<p>Le RAID (<i><u>R</u>edundant <u>A</u>rray of <u>I</u>nexpensive <u>D</u>isk</i>) permet de dupliquer, en temps rÃ©el, les donnÃ©es sur plusieurs disques afin d&#39;Ã©viter les pertes de donnÃ©es en cas de dÃ©faillance matÃ©rielle. Il possÃ¨de plusieurs &quot;niveaux&quot; :</p>
<table>
    <thead>
        <tr>
            <th>Nom</th>
            <th>Description</th>
            <th># disques</th>
            <th>RÃ©silience</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>RAID 0 (striping)</td>
            <td>volume sur plusieurs disques</td>
            <td>N</td>
            <td>0</td>
        </tr>
        <tr>
            <td>RAID 1 (mirroring)</td>
            <td>duplique un disque</td>
            <td>1+1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>RAID 5 (distributed parity)</td>
            <td>bloc de paritÃ© b<sub>p</sub> = b<sub>1</sub> âŠ• ... âŠ• b<sub>n</sub></td>
            <td>N+1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>RAID 6 (dual parity)</td>
            <td>2 blocs de paritÃ©</td>
            <td>N+2</td>
            <td>2</td>
        </tr>
    </tbody>
</table>

<p>ğŸ’¡ Il est possible de faire des combinaisons, e.g. RAID 1+0 ou RAID 10.</p>
<h4 id="lvm">LVM</h4>
<b>LVM</b> (<i><u>L</u>ogical <u>V</u>olume <u>M</u>anager</i>) est un logiciel permettant de gÃ©rer les volumes d&#39;un ordinateur. Pour cela :
<ol>
<li>on formate des volumes alors appelÃ©s <b>volumes physiques</b> (<i><u>p</u>hysical <u>v</u>olume</i>) :<br/><script type="c-bash">pvcreate <h>$VOLUME...</h></script></li>
<li>qu&#39;on regroupe ensuite au sein d&#39;un <b>groupe de volume</b> (<i><u>v</u>olume <u>g</u>roup</i> â‰ˆ disque virtuel) :<br/><script type="c-bash">vgcreate <h>$VG_NAME</h> <h>$VOLUME...</h></script></li>
<li>qu&#39;on redÃ©coupe ensuite en <strong>volumes logiques</strong> (<i><u>l</u>ogicial <u>v</u>olume</i> â‰ˆ partition virtuelle) :<br/><script type="c-bash">lvcreate --name <h>$LV_NAME</h> <h>$VG_NAME</h> <h>{-l 100%FREE,--size 10GB}</h></script></li>
</ol>
<p>LVM offre alors diffÃ©rentes fonctionnalitÃ©s :</p>
<ul>
<li>RAID : <script type="c-bash">--type raid1 --nosync</script></li>
<li>instantanÃ©s (<i>snapshots</i>) du systÃ¨me de fichier ;</li>
<li>etc.</li>
</ul>
<p>ğŸ’¡ Bien Ã©videmment LVM possÃ¨de de trÃ¨s nombreuses commandes permettant de manipuler les PV, VG, et LV.</p>
<h3 id="au-niveau-du-systÃ¨me-de-fichier">Au niveau du systÃ¨me de fichier</h3>
<p>Une autre mÃ©thode relativement simple de sauvegarde, est de tout simplement copier les fichiers (<u>a</u>rchive) :</p>
<script type="c-bash">
cp -a <h>$SRC...</h> <h>$DST</h>
</script>

<p>ğŸ’¡ Il est aussi possible de crÃ©er une archive compressÃ©e :</p>
<script type="c-bash">
tar -cf <h>-{z,j}</h> <h>$ARCHIVE</h> <h>$SRC...</h> # compresser
tar -xf <h>-{z,j}</h> <h>$ARCHIVE</h> <h>$DST</h>    # dÃ©compresser
</script>

<p>Pour une copie vers/Ã  partir d&#39;un ordinateur distant, il est bien Ã©videmment possible de monter un volume ou partition distante, puis d&#39;effectuer la copie.</p>
<p>Plus pratique, on peut utiliser <script type="c-bash">scp</script> (<u>s</u>ecure <u>c</u>opy <u>p</u>rotocol), oÃ¹ les chemins sont de la forme <script type="c-text"><h>[$USER@$SERVER:]$PATH</h></script> :</p>
<script type="c-bash">
scp -r <h>$SRC...</h> <h>$DST</h>
</script>

<h4 id="sauvegarde-incrÃ©mentale">Sauvegarde incrÃ©mentale</h4>
<p>Pour le moment on effectuait une <strong>sauvegarde complÃ¨te</strong>, i.e. la sauvegarde de l&#39;ensemble des donnÃ©es.</p>
<p>On se retrouve alors avec des fichiers identiques, dupliquÃ©s dans les diffÃ©rentes sauvegardes. Or si la majoritÃ© des fichiers ne changent pas dâ€™une sauvegarde sur lâ€™autre, cela peut trÃ¨s vite prendre beaucoup de place pour rien.</p>
<p>Afin d&#39;accÃ©lÃ©rer les sauvegardes et d&#39;en rÃ©duire le poids, il est possible d&#39;effectuer des <b>sauvegardes incrÃ©mentales</b>, i.e. de ne sauvegarder que les modifications depuis la derniÃ¨re sauvegarde. Cela est possible avec <script type="c-bash">rsync</script>, similaire Ã  <script type="c-bash">scp</script>, mais offrant bien plus de fonctionnalitÃ©s (dont les sauvegardes incrÃ©mentale).</p>
<p>ğŸ’¡ Son utilisation nâ€™Ã©tant pas simple, nous vous fournirons, un script basÃ© sur <script type="c-bash">rsync</script>, facilitant son usage.</p>
<p>Les sauvegardes incrÃ©mentales utilisent souvent des <strong>liens physiques</strong> (<em>hard links</em>) permettant de placer un mÃªme fichier (inode) Ã  plusieurs endroit diffÃ©rents (donc dans plusieurs sauvegardes), tout en Ã©vitant sa copie.</p>
<p>La commande <script type="c-bash">ln [-s] <h>$SRC</h> <h>$DST</h></script> (<u>l</u>i<u>n</u>k) permet de crÃ©er un lien physique (ou <u>s</u>ymbolique).</p>
<p>ğŸ’¡ Le fichier ne sera rÃ©ellement supprimÃ© que lorsque toutes ses occurrences seront supprimÃ©es.</p>
<p>âš  Il n&#39;est pas possible de faire un lien physique d&#39;un dossier. Pour cela il faudra utiliser un <b>lien symbolique</b>, un fichier spÃ©cial qui contiendra le chemin de la cible.</p>
<p>Le principe est alors simple : pour chaque fichier, sâ€™il nâ€™a pas Ã©tÃ© modifiÃ© depuis la derniÃ¨re sauvegarde, on crÃ©e un lien physique pointant sur sa derniÃ¨re version sauvegardÃ©e, sinon, on copie le fichier. Une sauvegarde sera alors un dossier que vous pourrez parcourir, supprimer, renommer, modifier, etc. comme sâ€™il avait Ã©tÃ© crÃ©Ã© via <script type="c-bash">cp -a</script>.</p>
<h4 id="gestionnaire-de-version">Gestionnaire de version</h4>
<p>Pour des fichiers de configurations, on souhaite gÃ©nÃ©ralement effectuer des sauvegardes plus intelligentes. Pour cela on n&#39;utilise un <b>gestionnaire de version</b>, comme Git (que vous verrez plus tard dans votre formation), permettant de :</p>
<ul>
<li>ajouter une description aux versions.</li>
<li>comparer deux versions.</li>
<li>gÃ©rer, et maintenir plusieurs versions en parallÃ¨le.</li>
<li>annuler une modification prÃ©cise.</li>
<li>intÃ©gration avec des interfaces Web et des fonctionnalitÃ©s comme les issues.</li>
</ul>
<h4 id="synchronisation-de-fichiers">Synchronisation de fichiers</h4>
<p>Dans le cas de dossiers partagÃ©s entre plusieurs utilisateurs, on souhaite gÃ©nÃ©ralement conserver un historique de chaque modifications afin d&#39;en avoir un suivi, et d&#39;Ãªtre capable, lorsque nÃ©cessaire, de restaurer un fichier Ã  une version prÃ©cÃ©dente.</p>
<p>Pour cela on utilisera usuellement un logiciel de synchronisation de fichiers, comme Seafile.</p>
<h4 id="exportationsimportations">Exportations/Importations</h4>
<p>Certains logiciels (e.g. les SGBD) permettent d&#39;exporter et d&#39;importer leurs donnÃ©es, par exemple en faisant un <em>dump</em> d&#39;une base de donnÃ©e. Le format de l&#39;export dÃ©pend du logiciel, et est gÃ©nÃ©ralement adaptÃ© aux besoins spÃ©cifiques du logiciel.</p>
<h3 id="instantanÃ©s">InstantanÃ©s</h3>
<p>Que se passe-t-il aussi si le serveur modifie des fichiers pendant la sauvegarde ?<br/>
La sauvegarde se retrouverait dans un Ã©tat invalide, avec un mix de fichiers prÃ©-modifications et post-modifications.</p>
<p>Une sauvegarde nÃ©cessite ainsi gÃ©nÃ©ralement l&#39;arrÃªt des services du serveur. Or les opÃ©rations de sauvegardes peuvent Ãªtre longues, de plusieurs minutes Ã  plusieurs heures. Ce qui est autant de temps pendant lesquel les services seront indisponibles.</p>
<p>La solution est alors de crÃ©er un instantanÃ© (snapshot) du systÃ¨me de fichier Ã  un instant donnÃ©, et dâ€™effectuer la sauvegarde Ã  partir de cet instantanÃ© :</p>
<script type="c-bash">
# arrÃªt des services
lvcreate -s --name <h>$LV_NAME</h>-snap <h>$LV_NAME</h> <h>{-l 100%FREE,--size 10GB}</h>
# redÃ©marrage des services
# sauvegarde
</script>

<p>Lors de la modifications d&#39;un bloc, l&#39;instantanÃ© enregistrera le bloc original. Ainsi lorsqu&#39;on cherchera Ã  rÃ©cupÃ©rer un bloc, LVM ira le rechercher dans l&#39;instantanÃ©, puis dans le volume originel si non trouvÃ© (i.e. pas modifiÃ©).</p>
<p>âš  Une fois la sauvegarde effectuÃ©e, il faudra bien penser Ã  supprimer l&#39;instantanÃ© :</p>
<script type="c-bash">
lvremove <h>$LV_NAME</h>-snap
</script>

</main>
    </body>
</html>