<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf8"/>
        <title>TP2 (AdminSys)</title>
        <meta name="color-scheme" content="dark light">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link   href="/skeleton/tp/index.css"  rel="stylesheet">
        <script  src="/skeleton/tp/index.js"  type="module"     blocking="render" async></script>
    </head>
    <body>
        <main>

<h1 id="tp2-2h">TP2 (2h)</h1>
<h2 id="commandes-shell-1h">Commandes Shell (1h)</h2>
<p>[TODO] : update ASTerm
[TODO] : doc
[TODO] : lsd + trash</p>
<p>Vous utilisez des lignes de commandes afin d&#39;effectuer les opÃ©rations suivantes.</p>
<h3 id="lister">Lister</h3>
<ol>
<li><q-text> Affichez le rÃ©pertoire de travail actuel.</q-text></li>
<li><q-text> Comment expliquez vous que le rÃ©sultat de la commande soit diffÃ©rente de l&#39;invite ?</q-text></li>
<li><q-text> Affichez le contenu du dossier racine (<strong>sans</strong> les fichiers cachÃ©s).</q-text></li>
<li><q-text> Affichez le contenu du dossier courant (<strong>avec</strong> les fichiers cachÃ©s).</q-text></li>
<li><q-text>Affichez le contenu du dossier courant (<strong>avec</strong> les fichiers cachÃ©s <strong>et</strong> les dÃ©tails).</q-text></li>
<li><q-text>Quelle est la taille et date de derniÃ¨re modification du fichier <script type="c-text">.bashrc</script> ?</q-text></li>
<li><q-text>Recherchez dans le dossier <script type="c-text">/var/log/</script> les fichiers d&#39;extension <script type="c-text">.log</script>.</q-text></li>
</ol>
<h3 id="navigation">Navigation</h3>
<ol>
<li><q-text>Allez dans le dossier racine (chemin <strong>absolu</strong>).</q-text></li>
<li><q-text>Allez dans votre dossier home.</q-text></li>
<li><q-text>Retournez au dossier prÃ©cÃ©dent.</q-text></li>
<li><q-text>Allez dans le home de <script type="c-text">zeus</script> en utilisant <script type="c-text">~<h>$USER</h></script>.</q-text></li>
<li><q-text>Allez dans le dossier <script type="c-text">/var/log/</script> via un chemin <strong>relatif</strong>).</q-text></li>
</ol>
<h3 id="crÃ©ation-et-Ã©dition-de-fichiers">CrÃ©ation et Ã©dition de fichiers</h3>
<ol>
<li><q-text>CrÃ©ez un nouveau fichier <script type="c-text">/tmp/test</script> vide.</q-text></li>
<li><q-text>En <strong>une seule</strong> ligne de commande crÃ©ez l&#39;arborescence ci-dessous :  <script type="c-bash">
 ğŸ“‚ /tmp/
 â”œâ”€â”€ ğŸ“‚ A
 â”‚Â Â  â”œâ”€â”€ ğŸ“‚ 1
 â”‚Â Â  â””â”€â”€ ğŸ“‚ 2
 â””â”€â”€ ğŸ“‚ B
   Â  â”œâ”€â”€ ğŸ“‚ 1
  Â Â  â””â”€â”€ ğŸ“‚ 2
  </script></q-text></li>
</ol>
<h3 id="dÃ©placer-copier-et-renommer">DÃ©placer, copier et renommer</h3>
<ol>
<li><q-text> <strong>Copiez</strong> le <strong>dossier</strong> <script type="c-bash">B/</script> dans le dossier <script type="c-bash">A/</script>.</q-text></li>
<li><q-text> <strong>DÃ©placez</strong> <script type="c-bash">A/B/</script> dans le dossier <script type="c-bash">A/1/</script>.</q-text></li>
<li><q-text> <strong>DÃ©placez et renommez</strong> le dossier <script type="c-bash">A/1/B/</script> en <script type="c-bash">/tmp/C</script>.</q-text></li>
<li><q-text> <strong>Copiez et renommez</strong> le <strong>dossier</strong> <script type="c-bash">C/</script> en <script type="c-bash">/tmp/D</script>.</q-text></li>
<li><q-text> <strong>Copiez</strong> les <strong>dossiers</strong> <script type="c-bash">{A,B,C}/</script> du serveur vers le dossier <script type="c-bash">/tmp/</script> du poste de travail.</q-text></li>
</ol>
<h3 id="supprimer-des-fichiers">Supprimer des fichiers</h3>
<ol>
<li><q-text> Placez les dossiers <script type="c-bash">B/2/</script> et <script type="c-bash">A/2/</script> dans la corbeille.</q-text></li>
<li><q-text> Listez le contenu de la corbeille.</q-text></li>
<li><q-text> Restaurez le dossier <script type="c-bash">A/2/</script>.</q-text></li>
<li><q-text> Videz la corbeille.</q-text></li>
<li><q-text> Avec la commande <script type="c-bash">rm</script>, supprimez le dossier <script type="c-bash">A/2/</script>.</q-text></li>
<li><q-text> Ce dossier apparaÃ®t-il dans la corbeille ? Pourquoi ?</q-text></li>
</ol>
<h2 id="fichiers-de-configuration">Fichiers de configuration</h2>
<h3 id="bashrc"><script type="c-text">.bashrc</script></h3>
<p>Le <script type="c-text">.bashrc</script> est un script Shell exÃ©cutÃ© au dÃ©marrage d&#39;un nouveau Shell. Il permet notamment d&#39;ajouter des alias de maniÃ¨re permanente.</p>
<ol>
<li>Ajoutez une ligne de commande <b>Ã  la fin</b> du fichier <script type="c-text">.bashrc</script> afin d&#39;ajouter l&#39;alias <script type="c-bash">hello</script>.</li>
<li><q-text>Expliquez en quoi le fait qu&#39;un tiers puisse modifier notre <script type="c-text">.bashrc</script> constitue une faille de sÃ©curitÃ©.</q-text></li>
</ol>
<h3 id="crÃ©er-une-commande">CrÃ©er une commande</h3>
<p>La commande <script type="c-bash">type <h>$CMD</h></script> permet d&#39;afficher la nature et l&#39;emplacement d&#39;une commande.</p>
<ol>
<li><q-text>OÃ¹ est enregistrÃ©e la commande <script type="c-bash">mkcmd</script> ?</q-text></li>
<li><q-text>Que faisait exactement la commande <script type="c-bash">mkcmd</script> ?</q-text></li>
<li><q-text>Quel est l&#39;intÃ©rÃªt de faire un lien physique dans <script type="c-bash">mkcmd</script> ?</q-text></li>
<li><q-text>Pourquoi ne pas utiliser ici un lien symbolique ?</q-text></li>
<li><q-text>Pourquoi <script type="c-bash">mkcmd</script> utilise-t-il <script type="c-bash">relpath</script> ?</q-text></li>
<li><q-text>OÃ¹ faudrait-il enregistrer les commandes pour les rendre accessibles Ã  tous ?</q-text></li>
<li><q-text>Quels droits faudrait-il alors donner Ã  ces commandes ?</q-text></li>
<li>Expliquez pourquoi les faits suivants constitueraient une faille de sÃ©curitÃ© :<ul>
<li><q-text>un tiers a le droit d&#39;Ã©criture sur mon script.</q-text></li>
<li><q-text>un tiers a le droit d&#39;Ã©criture sur le dossier contenant mon script.</q-text></li>
</ul>
</li>
</ol>
<h3 id="configuration-de-ssh">Configuration de SSH</h3>
<h4 id="alias-ssh">Alias SSH</h4>
<p>Retenir et Ã©crire lâ€™adresse IP du serveur Ã  chaque connexion au serveur via SSH est
enquiquinant. Pour Ã©viter cela, on utilise des <strong>alias SSH</strong>, permettant d&#39;Ã©crire <script type="c-bash">ssh <h>$ALIAS</h></script> au lieu de <script type="c-bash">ssh <h>$USER</h>@<h>$SERVER</h></script>. Les alias sont dÃ©finis dans la configuration du client SSH (<script type="c-text">~/.ssh/config</script>) comme suit :</p>
<script type="c-bash">
Host <h>$ALIAS</h> # ssh ALIAS => ssh USER@SERVER
  User <h>$USER</h>
  HostName <h>$SERVER</h>
  IdentityFile <h>$PRIVKEY_PATH</h> # si clÃ© SSH
  IdentitiesOnly yes         # si IdentityFile
</script>

<p>ğŸ’¡ Lâ€™autocomplÃ©tion du shell marche aussi pour les alias SSH.</p>
<ol>
<li><q-text><u><b>Sur l&#39;hÃ´te</b></u>, crÃ©ez un nouvel alias <script type="c-text">AdmSys</script> permettant de vous connecter en tant que <script type="c-text">zeus</script>.</q-text></li>
<li><q-text>Connectez au serveur en utilisant cet alias.</q-text></li>
</ol>
<h4 id="clÃ©-ssh">ClÃ© SSH</h4>
<p>Renseigner son un mot de passe Ã  chaque fois quâ€™on utilise SSH est enquiquinant, et potentiellement peu sÃ©curisÃ© si le mot de passe est trop faible. On prÃ©fÃ¨re ainsi gÃ©nÃ©ralement utiliser une <strong>clÃ© SSH</strong> permettant aux utilisateurs de se connecter au serveur sans mot de passe.</p>
<p>Le principe est alors trÃ¨s simple, l&#39;utilisateur :</p>
<ol>
<li>gÃ©nÃ¨re une paire de clÃ©s via <script type="c-bash">ssh-keygen</script>.</li>
<li>enregistre la clef <em>publique</em> dans le serveur (dans <script type="c-text">~/.ssh/authorized_keys</script>).</li>
<li>indique au client SSH la clef <em>privÃ©e</em> Ã  utiliser (cf suite).</li>
</ol>
<p>Ã€ chaque connexion SSH, le client donne alors une preuve qu&#39;il a connaissance de la clef privÃ©e, que le serveur est capable de vÃ©rifier grÃ¢ce Ã  la clef publique.</p>
<ol>
<li><u><b>Sur l&#39;hÃ´te</b></u>, gÃ©nÃ©rez une nouvelle clÃ© SSH grÃ¢ce Ã  la commande <script type="c-bash">ssh-keygen</script>.<br/>
ğŸ’¡ Vous nommerez la clÃ© <script type="c-text">AdmSys</script>.<br/>
âš  Ne renseignez pas de mot de passe.</li>
<li><q-text><u><b>Sur l&#39;hÃ´te</b></u>, dÃ©placez les clÃ©s gÃ©nÃ©rÃ©es dans <script type="c-text">~/.ssh/keys/{priv/,pub/}</script>.</q-text></li>
<li><q-text><u><b>Sur l&#39;hÃ´te</b></u>, ajoutez le chemin de la clef privÃ©e Ã  l&#39;alias <script type="c-text">AdmSys</script>.</q-text></li>
<li><q-text><u><b>Sur le serveur</b></u>, crÃ©ez le dossier <script type="c-text">~zeus/.ssh/</script>.</q-text></li>
<li><q-text>TransfÃ©rez la clÃ© publique dans le fichier <script type="c-text">~zeus/.ssh/authorized_keys</script>.</q-text></li>
<li><q-text>Ouvrez une nouvelle session SSH en tant que <script type="c-text">zeus</script>.</q-text></li>
<li><q-text>Dupliquez l&#39;alias SSH <script type="c-text">AdmSys</script> que vous nommerez <script type="c-text">AdmSysPwd</script>.</q-text></li>
<li><q-text>Ã€ cet alias, ajoutez l&#39;option <script type="c-text">PubkeyAuthentication no</script>.<br/>
âš  Câ€™est Authentication et non Authenti<b><u>fi</u></b>cation.</q-text></li>
<li><q-text>Utilisez <script type="c-text">AdmSysPwd</script> afin de vous connecter via mot de passe.</q-text></li>
</ol>
</main>
    </body>
</html>