<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf8"/>
        <title>CM4 (TW)</title>
        <meta name="color-scheme" content="dark light">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link   href="/skeleton/index.css"  rel="stylesheet">
        <script  src="/skeleton/index.js"  type="module"     blocking="render" async></script>
    </head>
    <body>
        <main>

<h1 id="cm4--architecture-clientserveur">CM4 : Architecture client/serveur</h1>
<p>Un site Web est g√©n√©ralement constitu√© d&#39;au moins 2 parties :</p>
<ul>
<li><em>le c√¥t√© client</em> (<em>front-end</em>) : dans le navigateur, affiche la page Web et g√®re les interactions avec l&#39;utilisateur. Il est usuellement d√©fini par un ensemble de fichiers HTML, CSS, JS, WASM, etc.</li>
<li><em>le c√¥t√© serveur</em> (<em>back-end</em>) : sur le serveur, r√©pond aux requ√™tes du navigateur afin de distribuer les fichiers n√©cessaires √† la page Web.</li>
</ul>
<p>Les √©changes entre le client et le serveur Web utilisent le protocole HTTP(S) :</p>
<ul>
<li>le client demande une ressource via une <em>requ√™te HTTP</em> ;</li>
<li>le serveur retourne la ressource demand√©e via une <em>r√©ponse HTTP</em>.</li>
</ul>
<p>Les requ√™tes et r√©ponses HTTP contiennent :</p>
<ul>
<li>une <em>en-t√™te</em> : contenant des m√©ta-donn√©es ;</li>
<li>un <em>corps</em> (facultatif) : contenant les donn√©es transf√©r√©es.</li>
</ul>
<h2 id="contenus-dynamiques">Contenus dynamiques</h2>
<p>Afin de tester nos pages Web en TP, nous utilisions jusqu&#39;√† pr√©sent <em>Live Server</em> comme serveur Web. Son fonctionnement est tr√®s simple : la racine du site Web est associ√©e √† un dossier <script type="c-bash"><h>$ROOT</h></script> du serveur. Chaque URL est alors associ√©e √† un fichier du serveur. 
<em>Live Server</em> est ainsi un serveur web <em>statique</em> (<em>static web server</em>) distribuant des fichiers/ressources statiques (<em>static files/assets</em>). Ainsi, lorsqu&#39;il re√ßoit une requ√™te HTTP, il retourne le fichier demand√©, e.g. :<br/></p>
<script type="c-bash">http://localhost:5000/<h>$PATHNAME</h></script> est associ√© au fichier <script type="c-bash"><h>$ROOT</h>/<h>$PATHNAME</h></script>.

<p>Il est cependant possible d&#39;avoir des serveurs <em>dynamiques</em> (<em>dynamic server</em>) g√©n√©rant le contenu renvoy√© en fonction de la requ√™te HTTP re√ßue. Imaginez un site vendant 5,000 produits diff√©rents. Il est √©vident qu&#39;on ne va pas s&#39;amuser √† cr√©er 5,000 pages Web √† la main. √Ä la place, on voudrait g√©n√©rer dynamiquement les pages Web √† partir :</p>
<ul>
<li>de l&#39;<strong>identifiant</strong> du produit (i.e. quel produit afficher) ;</li>
<li>des <strong>donn√©es</strong> du produit, stock√©es dans une base de donn√©es ;</li>
<li>d&#39;un <strong>mod√®le</strong> (<em>template</em>) indiquant comment structurer et afficher ces donn√©es.</li>
</ul>
<p>Il serait alors tr√®s ais√© d&#39;ajouter un nouveau produit en ajoutant une entr√©e dans la base de donn√©e, ou de modifier l&#39;affichage des pages produits en modifiant le mod√®le. On aurait ainsi deux parties :</p>
<ul>
<li><em>statique</em> : le mod√®le commun √† tous les produits (HTML/CSS/JS/Brython/etc) ;</li>
<li><em>dynamique</em> : les donn√©es sp√©cifiques √† chaque produit.</li>
</ul>
<p>Les donn√©es ne sont cependant pas directement accessibles √† partir de la page Web. En effet, si les acc√®s √† la base de donn√©es (e.g. SQL) √©taient effectu√©s sur la page Web, i.e. sur le navigateur/c√¥t√© client, n&#39;importe quel visiteur pourrait alors arbitrairement modifier les requ√™tes effectu√©es, ou r√©cup√©rer/r√©utiliser les identifiants utilis√©s pour se connecter √† la base de donn√©es.</p>
<p>Il convient alors envoyer des requ√™tes au serveur Web, qui se chargera de manipuler la base de donn√©es c√¥t√© serveur, puis en retournera les r√©sultats. Le serveur Web fournira ainsi une <em>API</em>.</p>
<h3 id="les-api-rest">Les API REST</h3>
<p>REST (<em><u>RE</u>presentational <u>S</u>tate <u>T</u>ransfer</em>) est un ensemble de principes permettant d&#39;architecturer proprement une API Web de sorte √† √©viter qu&#39;elle devienne chaotique :</p>
<ul>
<li>URL uniformes ;</li>
<li>s√©mantique des requ√™tes HTTP ;</li>
<li>donn√©es structur√©es ;</li>
<li>sans √©tats.</li>
</ul>
<h4 id="uniformiser-les-url">Uniformiser les URL</h4>
<p>Comme vous le savez d√©j√†, les URL identifient les ressources de mani√®re unique.</p>
<p>Afin d&#39;√©viter les collisions, et rendre les URL plus explicites/lisibles, il convient de les uniformiser en suivant un format unique. Pour cela on conserve une logique d&#39;arborescence avec des <em>collections</em>, qui sont des ressources contenant elles-m√™mes d&#39;autres ressources (‚âàdossiers).</p>
<p>Par exemple, un produit sera identifi√© par (et manipul√© via) l&#39;URL <code>/produits/{$ID_PRODUIT}</code>. L&#39;ensemble des URL correspondant √† ce format est appel√© <strong>route</strong> et sera alors trait√© par la m√™me fonction (<em>handler</em>), avec <code>$ID_PRODUIT</code> comme param√®tre. La collection <code>/produits/</code> est alors la liste des produits, et permettra des manipulations d&#39;ensemble.</p>
<p>üí° Il est fr√©quent de pr√©fixer les chemins par <code>/api/v1/</code> et <code>/static/</code> afin d&#39;ais√©ment distinguer l&#39;API REST, des ressources statiques. Le num√©ro de version permet d&#39;assurer la r√©tro-compatibilit√© pour les applications utilisant d&#39;anciennes versions de l&#39;API.</p>
<p>üí° La structuration des URL en routes permet d&#39;ais√©ment visualiser les ressources accessibles via l&#39;API, ainsi que de g√©rer plus facilement les droits d&#39;acc√®s aux donn√©es, en autorisant/interdisant l&#39;acc√®s √† certaines routes.</p>
<h4 id="uniformiser-les-requ√™tes">Uniformiser les requ√™tes</h4>
<p>Les API REST utilisent 5 <em>m√©thodes HTTP</em> :</p>
<ul>
<li><em>GET :</em> lire une ressource.</li>
<li><em>POST :</em> ajouter une ressource √† une collection.</li>
<li><em>PUT :</em> cr√©er une ressource ou la remplacer si elle existe.</li>
<li><em>PATCH :</em> modifier partiellement une ressource.</li>
<li><em>DELETE :</em> supprimer une ressource.</li>
</ul>
<p>Il est ainsi d&#39;usage d&#39;utiliser les requ√™tes suivantes afin d&#39;indiquer le type d&#39;op√©ration effectu√© sur la ressource :</p>
<ul>
<li><script type="c-js">GET    /<h>$COLLECTION</h>/</script> : obtenir la liste des ressources de la collection.</li>
<li><script type="c-js">POST   /<h>$COLLECTION</h>/</script> : cr√©er une nouvelle ressource dans la collection.</li>
<li><script type="c-js">GET    /<h>$COLLECTION</h>/<h>$ID</h></script> : obtenir la ressource d'identifiant <script type="c-js"><h>$ID</h></script>.</li>
<li><script type="c-js">PUT    /<h>$COLLECTION</h>/<h>$ID</h></script> : cr√©er ou remplacer la ressource d'identifiant <script type="c-js"><h>$ID</h></script>.</li>
<li><script type="c-js">PATCH  /<h>$COLLECTION</h>/<h>$ID</h></script> : modifier la ressource d'identifiant <script type="c-js"><h>$ID</h></script>.</li>
<li><script type="c-js">DELETE /<h>$COLLECTION</h>/<h>$ID</h></script> : supprimer la ressource d'identifiant <script type="c-js"><h>$ID</h></script>.</li>
</ul>
<p>‚ö† Les requ√™tes <code>GET</code> et <code>DELETE</code> ne peuvent contenir de corps (<em>body</em>).</p>
<h4 id="query-strings">Query strings</h4>
<p>Les URL peuvent aussi √™tre suffix√©es par une <em>cha√Æne de requ√™te</em> (<em>query string</em>), indiqu√©e par un <code>?</code>. Les query strings sont des paires <code>clefs=valeurs</code> s√©par√©es par un <code>&amp;</code>, e.g. : <code>?limit=10&amp;export=csv</code>. </p>
<p>Elles sont principalement utilis√©es sur les requ√™tes <code>GET</code> afin de :</p>
<ul>
<li>indiquer le format des donn√©es souhait√© ;</li>
<li>filtrer les champs/informations ;</li>
<li>sur une collection, filtrer les entr√©es.</li>
</ul>
<p>‚ö† Il est fr√©quent que les serveurs Web loggent les URL demand√©es. Il est ainsi important de ne pas inclure d&#39;informations sensibles dans les query strings.</p>
<p>Les query strings sont manipul√©es via la classe <code>URLSearchParams</code> :</p>
<center>
<table>
    <thead>
        <tr>
            <th>
                Op√©ration
            </th>
            <th>
                URLSearchParams
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><i>Cr√©er</i></td>
            <td><script type="c-js">new URLSearchParams(<h>$URL</h>.search)</script></td>
        </tr>
        <tr>
            <td><i>G√©n√©rer</i></td>
            <td><script type="c-js">.toString()</script></td>
        </tr>
        <tr>
            <td><i>Lister</i></td>
            <td><script type="c-js">.entries()/.keys()/.values()</script></td>
        </tr>
        <tr>
            <td><i>Obtenir</i></td>
            <td><script type="c-js">.get[All](<h>$N</h>)</script></td>
        </tr>
        <tr>
            <td><i>Ajouter</i></td>
            <td><script type="c-js">.set(<h>$N</h>, <h>$V</h>)/.append(<h>$N</h>, <h>$V</h>)</script></td>
        </tr>
        <tr>
            <td><i>Supprimer</i></td>
            <td><script type="c-js">.delete(<h>$N</h>)</script></td>
        </tr>
        <tr>
            <td><i>Contient ?</i></td>
            <td><script type="c-js">.has(<h>$N</h>)</script></td>
        </tr>
    </tbody>
</table>
</center>

<p>üí° L&#39;URL de la page est stock√©e dans <script type="c-js">document.location</script>.</p>
<h4 id="donn√©es-structur√©es">Donn√©es structur√©es</h4>
<p>Le corps des requ√™tes/r√©ponses REST sont usuellement au format JSON, mais peuvent utiliser n&#39;importe quel format, e.g. :</p>
<ul>
<li>texte brut ;</li>
<li>donn√©es binaires ;</li>
<li>URLSearchParams/FormData ;</li>
<li>XML ;</li>
<li>CSV ;</li>
<li>etc.</li>
</ul>
<p>Le format utilis√©/√† utiliser est potentiellement indiqu√© par la requ√™te REST. Il est cependant important de conserver des donn√©es structur√©es (i.e. √©viter des r√©ponses au format HTML) afin de permettre leur r√©utilisation pour d&#39;autres usages (et potentiellement leur mise en cache). </p>
<p>Notamment, il est fr√©quent d&#39;offrir la possibilit√© aux d√©veloppeurs tiers d&#39;exploiter les donn√©es du site via une API REST (e.g. <em>Open Data</em> avec stats INSEE, donn√©es m√©t√©o, etc). Bien √©videmment, certaines API peuvent √™tre payantes, e.g. en fonction du nombre de requ√™tes autoris√©es √† la seconde.</p>
<h4 id="sans-√©tats">Sans √âtats</h4>
<p>Les API REST se doivent d&#39;√™tre <em>sans √©tat</em> (<em>stateless</em>), cela signifie que :</p>
<ol>
<li>le serveur ne stocke aucun √©tat de la connexion/session HTTP actuelle ;</li>
<li>une requ√™te contient toutes les donn√©es n√©cessaires √† sa r√©ponse ;</li>
<li>une requ√™te ne d√©pend pas d&#39;autres requ√™tes ;</li>
<li>les requ√™tes identiques produisent des r√©ponses identiques <em>(sauf si les donn√©es ont √©t√© modifi√©es)</em>.</li>
</ol>
<p>Cela comporte de nombreux avantages :</p>
<ul>
<li><em>s√©curit√©</em> : l&#39;absence d&#39;√©tat c√¥t√© serveur (1) √©vite des attaques par <em>d√©ni de services</em> (DoS).</li>
<li><em>performance</em> : les requ√™tes ne d√©pendant pas d&#39;un √©tat (2), il ais√© de r√©partir les charges (<em>load balancing</em>).</li>
<li><em>clart√©</em> : les requ√™tes ne d√©pendant pas d&#39;autres requ√™tes (3), les √©changes sont plus simples √† comprendre.</li>
<li><em>tests</em> : les r√©ponses √©tant d√©terministes et reproductibles (4), on peut √©crire des tests unitaires.</li>
</ul>
<h2 id="api-js">API JS</h2>
<h3 id="fetch">Fetch</h3>
<p>Une requ√™te HTTP peut √™tre effectu√©e au sein de la page Web via <code>fetch()</code>:</p>
<script type="c-js">
const response = await fetch(<h>$URL</h>, {
    method: <h>$HTTP_METHOD</h>,
    body  : <h>$BODY</h>
});
</script>

<p>Le corps peut √™tre de diff√©rent type :</p>
<ul>
<li><script type="c-js">string</script></li>
<li><script type="c-js">Blob</script>/<script type="c-js">File</script></li>
<li><script type="c-js">Uint8Array</script>/<script type="c-js">ReadableStream</script></li>
<li><script type="c-js">URLSearchParams</script>/<script type="c-js">FormData</script></li>
<li>etc.</li>
</ul>
<p>üí° Pour envoyer des donn√©es au format, JSON, il convient de les convertir en <script type="c-js">string</script> :</p>
<script type="c-js">
const response = await fetch(<h>$URL</h>, {
    body: JSON.stringify(<h>$DATA</h>)
    headers: {
        "Content-Type": "application/json"
    }
});
</script>

<p>üí° <script type="c-js">"Content-Type"</script> indique le type des donn√©es contenu dans le corps de la requ√™te :</p>
<ul>
<li><script type="c-js">"text/plain"</script> : texte ;</li>
<li><script type="c-js">"application/json"</script> : JSON ;</li>
<li><script type="c-js">"application/octet-stream"</script> : donn√©es binaires.</li>
<li><script type="c-js">"application/x-www-form-urlencoded"</script> : <script type="c-js">URLSearchParams</script>/<script type="c-js">FormData</script> ;</li>
</ul>
<code>fetch()</code> retourne un <code>Response</code>, dont le contenu peut √™tre lu via :
<ul>
<li><script type="c-js">await response.text()</script></li>
<li><script type="c-js">await response.json()</script></li>
<li><script type="c-js">await response.bytes()</script> : Uint8Array</li>
<li><script type="c-js">await response.formData()</script> : FormData</li>
</ul>
<p>‚ö† Le corps d&#39;une r√©ponse ne peut √™tre lue qu&#39;une seule fois.</p>
<ul>
<li><script type="c-js">.bodyUsed</script> : indique si le corps a √©t√© lu.</li>
<li><script type="c-js">.clone()</script> : clone la r√©ponse (permet ainsi plusieurs lectures).</li>
</ul>
<h4 id="status">Status</h4>
<code>Response</code> indique aussi si la requ√™te s&#39;est bien effectu√©e :
<ul>
<li><code>.ok</code> : pas d&#39;erreurs ;</li>
<li><code>.status</code> : code de status HTTP ;</li>
<li><code>.statusText</code> : message pr√©cisant l&#39;erreur.</li>
</ul>
<p>Les codes de status HTTP se divisent en 5 cat√©gories :</p>
<ul>
<li>1XX : requ√™te en cours</li>
<li>2XX : succ√®s</li>
<li>3XX : redirection</li>
<li>4XX : erreur du client</li>
<li>5XX : erreur du serveur.</li>
</ul>
<ul>
<li>cors</li>
<li>cache</li>
</ul>
<p>üö© [TODO] : outils network</p>
<h3 id="sse">SSE</h3>
<p>Contrairement aux WebSockets, les <em>Server Send Events</em> ne permettent qu&#39;une communication unidirectionnelle du serveur vers le client. Il est utilis√© lorsque le serveur doit r√©guli√®rement envoyer des informations au client, sans attendre de r√©ponses, e.g. envoyer des logs en temps r√©el.</p>
<p>Le principe est tr√®s simple, il s&#39;agit d&#39;une requ√™te et d&#39;une r√©ponse HTTP normales, √† l&#39;exception que la r√©ponse HTTP est maintenue en vie (<code>keep-alive</code>) et est √©crite petit √† petit (<code>text/event-stream</code>). Le corps de la r√©ponse suit le format suivant :</p>
<script type="c-text">
event: $EVENT_NAME
data: $DATA

event: $EVENT_NAME
data: $DATA

event: $EVENT_NAME
data: $DATA
</script>

<p>C√¥t√© client, l&#39;utilisation est tr√®s simple, il suffit d&#39;√©couter des √©v√©nements d&#39;un <code>EventSource</code>.</p>
<script type="c-js">
// [JS] JavaScript

// Client
const servEvent = new EventSource($URL);
servEvent.addEventListener($EVENT_NAME, function(ev) {
    console.log(ev.data)
});
servEvent.close(); // termine la communication.


// Serveur (helper)
class SSE {
    constructor(res) {
        this.res = res;
        this.#setHeaders
    }
    #setHeaders() {
        this.res.set({
            'Cache-Control': 'no-cache',
            'Content-Type' : 'text/event-stream',
            'Connection'   : 'keep-alive'
        });
        this.res.flushHeaders();
    }
    dispatchEvent(name, data) {
        this.res.write(`event: ${name}\n${data}\n\n`);
    }
}

// Serveur
app.get($URL, async function(req, res) {

    const sse = new SSE(res);

    sse.dispatchEvent($EVENT_NAME, $DATA); // Envoyer un √©v√©nement.
});
</script>

<h3 id="uploaddownload">Upload/Download</h3>
<p>=&gt; qu&#39;est-ce qu&#39;un Blob/File ?
=&gt; decode/encode</p>
<h3 id="websockets">Websockets</h3>
<p>https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</p>
<h2 id="les-formulaires">Les formulaires</h2>
<p>-&gt; form
    -&gt; input
    -&gt; FormData / URLSearchParams.
    -&gt; clear</p>
<p>-&gt; validation + CSS</p>
<p>/!\ v√©rifier les donn√©s c√¥t√© serveur.</p>
<strong>‚ö†</strong> Vous ne devez <strong><u><em>JAMAIS</em></u></strong> faire confiance client. En effet, il est tr√®s ais√© d&#39;envoyer des donn√©es arbitraires au serveur. Vous devez ainsi <em><u><strong>SYST√âMATIQUEMENT</strong></u></em> v√©rifier la validit√© des donn√©es envoy√©es par le client (format, valeurs, autorisations, etc).
<h2 id="gestion-des-donn√©es">Gestion des donn√©es</h2>
<p>Localstorage/sessionStorage/FileSystem API/cache.</p>
<h2 id="les-diff√©rents-type-de-serveurs-web">Les diff√©rents type de serveurs Web</h2>
<p>La distribution du contenu statique est relativement simple, le serveur lit les fichiers, puis les envoie au client. Bien √©videmment, peut g√©rer des fonctionnalit√©s plus avanc√©es comme mettre les fichiers en RAM pour les distribuer plus rapidement, v√©rifier les droits d&#39;acc√®s aux fichiers (dont authentifications), r√©√©crire les URL, transmettre la requ√™te √† un autre serveur, personnaliser l&#39;en-t√™te de la r√©ponse HTTP, etc.</p>
<p>On utilise alors des serveurs Web, e.g. Apache, Nginx, qui offrent de nombreuses fonctionnalit√©s et possibilit√©s de configurations :</p>
<ul>
<li>r√©√©critures d&#39;URL/redirections ;</li>
<li>transfert du flux / reverse proxy ;</li>
<li>v√©rification des droits d&#39;acc√®s / authentification ;</li>
<li>gestion des caches ;</li>
<li>cgi/fastcgi ;</li>
<li>etc.</li>
</ul>
<p>Pour du contenu dynamique, i.e. g√©n√©r√© sur demande par le serveur, il existe plusieurs fa√ßons de proc√©der :</p>
<ul>
<li><em>CGI :</em>¬†le serveur Web execute le fichier au lieu de transmettre son contenu au client. Il √©crit sur l&#39;entr√©e standard le corps de la requ√™te, et transmet la sortie standard au client. Cette technique est simple mais peu performante.
</li>
<li><em>fastCGI :</em>¬†analogue au CGI, mais plus performant. Un ou plusieurs processus s&#39;executent en contenu et communiquent avec le serveur Web via des sockets IPC, des sockets TCP, ou via des tubes nomm√©s. C&#39;est notamment ce qui est commun√©ment utilis√© pour PHP, Ruby on rails, etc.
</li>
<li><em>impl√©menter son propre serveur</em> qui r√©pondra aux requ√™tes des clients. Le serveur peut alors supporter plusieurs protocoles en sus de HTTP, e.g. des WebSockets, des sockets TCP, etc. Il peut √™tre impl√©ment√© dans n&#39;importe quel langage (e.g. Python, JavaScript,  shell), et a donc acc√®s √† toutes leurs fonctionnalit√©s et biblioth√®ques.
</li>
<li><em>rediriger le flux</em> vers un autre serveur (reverse proxy). Quasi-identique √† la solution pr√©c√©dente, il a l&#39;avantage de pouvoir b√©n√©ficier des fonctionnalit√©s du serveur Web (authentification, cache, etc), ainsi que d&#39;√©viter des probl√®mes de <em>Same Origin Policy</em> (SOP). Il peut aussi permettre de simplifier l&#39;impl√©mentation du serveur, en d√©l√©guant la s√©curisation de la communication au reverse proxy, i.e. le serveur  envoie et re√ßoit des donn√©es en clair, et le reverse proxy les chiffre et les d√©chiffre.
</li>
</ul>
<p>Contr√¥le d&#39;acc√®s :</p>
<ul>
<li>soit au niveau du serveur REST ;</li>
<li>soit via un reverse Proxy se pla√ßant entre le client et le serveur REST (e.g. apache, nginx).</li>
</ul>
<p>Afin de rendre le code plus lisible, il est fr√©quent que les frameworks repr√©sentent les routes par une arborescence de fichiers. Au d√©marrage, le framework va ainsi lire de mani√®re r√©cursive un dossier e.g. <code>/routes/</code> et ajouter les diff√©rents gestionnaires en fonction des fichiers qui s&#39;y trouvent. Ainsi, le fichiers/dossier <code>/routes/dir/{PARAMS}/foo</code> contiendra le gestionnaire √† utiliser pour la route <code>/dir/$PARAM/foo</code>.</p>
<p>-&gt; BDD
-&gt; execute shell commands
-&gt; redirections</p>
<p>-&gt; 403/gestion authentification/.htaccess</p>
<h2 id="opti-cm5-">Opti (CM5 ?)</h2>
<h3 id="architecture-clientserveur">Architecture client/serveur</h3>
<p>L&#39;affichage d&#39;une page Web se d√©roule usuellement de la sorte :</p>
<script type="c-html">
    <!DOCTYPE>
    <html>
        <head>
            <script src='...' defer><xscript>
            <link rel='stylesheet' href='...'></link>
        </head>
        <body>

        <xbody>
    </html>
</script>

<ol>
<li><p>Le navigateur demande au serveur le fichier HTML correspondant √† la page Web √† afficher.</p>
</li>
<li><p>Le navigateur commence √† lire et √† interpr√©ter le fichier HTML re√ßu.</p>
</li>
<li><p>Le navigateur lit la balise <code>&lt;script&gt;</code> et commence √† t√©l√©charger le fichier correspondant. Comme la balise a l&#39;attribut <code>defer</code>, le navigateur continue de lire et interpr√©ter le fichier HTML.</p>
</li>
<li><p>Le navigateur lit la balise <code>&lt;link&gt;</code> et commence √† t√©l√©charger le fichier CSS correspondant.</p>
</li>
<li><p>Le navigateur commence √† construire l&#39;arbre DOM √† partir du contenu de <code>&lt;body&gt;</code>.</p>
</li>
<li><p>Une fois l&#39;arbre DOM construit, il execute le script qui √©tait <code>defer</code>.</p>
</li>
<li><p>Une fois l&#39;ex√©cution du script fini, le navigateur dessine la page Web pour la premi√®re fois.</p>
</li>
</ol>
<h3 id="optimisations">Optimisations</h3>
<p>-&gt; s√©parer static/dynamique pour cache
-&gt; cache : client storage / RAM (dont sqlite)
-&gt; pr√©-g√©n√©rer vs on demand vs lazy
-&gt; calculs
-&gt; async
-&gt; webworker
-&gt; img</p>
<p>-&gt; profiler / lighthouse
-&gt; hoist/+ les 2 autres trucs
-&gt; page parsing
-&gt; HTTP1vs2vs3</p>
<p>L&#39;un des objectifs des d√©veloppeur Web est de dessiner la page Web le plus t√¥t possible. Pour cela, il va user de diverses techniques :</p>
<ul>
<li><em>Compresser les fichiers</em> avant de les transmettre, r√©duisant le temps de t√©l√©chargement des ressources n√©cessaires.
</li>
<li><em>R√©duire la taille des fichiers</em> en
<ul>
<li><p>supprimant le code inutilis√©</p>
</li>
<li><p>le minimifiant (supprime les espaces et retours √† la ligne)</p>
</li>
<li><p>en l&#39;uglifiant (r√©duit la taille du code au prix de sa lisibilit√©, e.g. en renommant les variables).</p>
</li>
<li><p>pour les images, en r√©duisant sa r√©solution/qualit√©, ou en utilisant des formats vectoriels (SVG).</p>
</li>
<li><p>pour les images, afficher un <em>placeholder</em> ou version en basse r√©solution puis progressivement <a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Loading#images">la remplacer une version de plus haute r√©solution</a>.</p>
</li>
</ul>
</li>
<li><em>T√©l√©charger ou ex√©cuter plus tard</em> les ressources non-n√©cessaires √† l&#39;affichage, via :
<ul>
<li><p>du <em>lazy load</em>, e.g. ne t√©l√©charger les images que lorsqu&#39;elles apparaissent √† l&#39;√©cran.</p>
</li>
<li><p>de la <em>pagination</em>, e.g. sur un tableau ne t√©l√©charger/afficher que les X premi√®res entr√©es et proposer des boutons pour afficher les entr√©es suivantes.</p>
</li>
<li><p>en reportant l&#39;execution de certains bouts de codes √† plus tard.</p>
</li>
</ul>
</li>
<li><em>R√©duire le nombre de fichiers t√©l√©charg√©s</em> (on vise g√©n√©ralement 3-4 fichiers par page) :
<ul>
<li><p>remplacer l&#39;URL d&#39;une image par <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">une cha√Æne de charact√®re en base64</a>.</p>
</li>
<li><p>fusionner les fichiers CSS en un seul.</p>
</li>
<li><p>fusionner les fichiers JS en un seul.</p>
</li>
<li><p>int√©grer certaines ressources (e.g. JSON) dans le fichier JS.</p>
</li>
<li><p>int√©grer le JS et/ou le CSS dans le fichier HTML.</p>
</li>
</ul>
</li>
<li><em>Utiliser des caches</em> pour √©viter de re-t√©l√©charger √† chaque fois certaines ressources :
<ul>
<li><p>un cache bas√© le protocole HTTP (cf <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">Cache-Control</a>).</p>
</li>
<li><p>un cache local bas√© sur <code>localStorage</code>, <code>sessionStorage</code>, ou <code>indexDB</code>.</p>
</li>
<li><p>un cache c√¥t√© serveur en enregistrant des donn√©es dans la RAM afin de pouvoir r√©pondre plus rapidement aux requ√™tes qui s&#39;il fallait aller les lire directement sur le disque.</p>
</li>
</ul>
</li>
<li><em>Pr√©-t√©l√©charger les ressources</em>, en commen√ßant √† les t√©l√©charger le plus t√¥t possible :
<ul>
<li><p>dans les balises <code>&lt;script&gt;</code>, l&#39;attribut <code>defer</code>.</p>
</li>
<li><p>pour d&#39;autres ressources utilis√©es plus tard, cf <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/preload"><link rel=preload href='...' as='...'/></a>.</p>
</li>
</ul>
</li>
<li><p>Pour les site Web massivement visit√©s :</p>
<ul>
<li><em>distribuer la charge</em> (load balancing) entre plusieurs serveurs (‚ö† engendre des probl√©matiques de synchronisations).
</li>
<li><em>rapprocher le serveur du client</em>, <em>edge computing</em> (contenu dynamique), <em>content delivery network</em> (contenu statique).
</li>
<li><p>d√©couper son site Web en plusieurs modules/services ind√©pendants h√©berg√©s sur plusieurs serveurs (‚ö† si les services doivent fr√©quemment communiquer entre eux cela peut s&#39;av√©rer contre-productif).</p>
</li>
</ul>
</li>
</ul>
<p>‚ö† L&#39;optimisation pr√©matur√©e est diabolique. Vous n&#39;avez, √† votre niveau, pas besoin d&#39;optimiser vos sites Web. Vous n&#39;avez pas non plus √† impl√©menter vous-m√™mes ces optimisations, de nombreux outils le font d√©j√† pour vous (e.g. Webpack).</p>
<p>üö© [TODO] : outils navigateur pour network / load performances (lighthouse)</p>
<p>üö© [TODO] : archi projet dev vs prod.</p>
</main>
    </body>
</html>