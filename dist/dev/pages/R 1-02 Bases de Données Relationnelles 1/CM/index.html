<!DOCTYPE html>
<html>
    <head>
        <title>CM</title>
        <link rel="stylesheet" href="./index.css">
        <script type="module" src="./index.js" defer></script>
    </head>
    <body>
        <style>
            body {
                display:flex;
                flex-direction: column;
                height: 100vh;
                margin: 0;
                padding: 0;
            }
            main {
                padding: 0 12px;
                position: relative;
                overflow-y: auto;
            }
            header {
                z-index: 1;
                margin-left: 50px;
                font-weight: bold;
                & > span {
                    position: relative;
                }
                & > span:not(:hover) > .menu {
                    display: none;
                }
                & > span > .menu {
                    position: absolute;
                    bottom: 0;
                    transform: translate(0, 100%);
                    left: 0;
                    background-color: black;
                    border: 1px solid gray;
                    border-top: none;
                    & > a {
                        display: block;
                        white-space: nowrap;
                        padding: 5px 10px;
                        &:hover {
                            background-color: #222;
                        }
                    }
                }
                & > span::before {
                    content: " > "
                }
                & > span:hover::before {
                    content: " v "
                }
            }
        </style>
        <header></header>
        <main>
<div id='menu' style="display:none"></div>

<todo> 

<p>Contenu:
    - cf comments
    - corriger exemples JOIN.</p>
<p>D√©tails:</p>
<ul>
<li>publier lib...</li>
<li>split CM into different files.</li>
<li>espace moodle (avec navigation)</li>
<li>slides PDF LaTeX.</li>
<li>cheat-sheet...</li>
</ul>
<!--

CM3

-> √† l'oral appuyer le fait que ex 2 ne marche pas (create table). [desc?]

1. -Pour les sch√©mas de table [plus FK/PK ?] => repr UML ?
  -> (avec cl√© primaire en gras et cl√© etrang√®re soulign√©es, usuellement)

2. - L'id√©e de base √©tant de se servir de la cl√© √©trang√®re comme un moyen l√©ger en m√©moire de r√©f√©rencer les donn√©es d'une table secondaire
3. -Pour les contraintes sur les colonnes, parle par exemple du num√©ro de t√©l√©phone (√ßa a dix chiffres, √ßa commence par 0,...) ?
4. Contraintes : r√©insister important (avantage de SQL)

5. PK : ensemble de champs identifiant de mani√®re unique une entr√©e. C'est un index un peu particulier etc.
  + exemple insert cl√© existante.

CM4

6. op d'ensembles : tables decoup√© e.g. ann√©es (pour des raisons de perfs) => faire des op dessus.

1. UNION : m√™me # colonne et id√©alement m√™me structure (?)

- exemples dynamiques/anim√©s (jointures/cart√©sien).

- ss-rq visu (?)
  - normale : calcul√©e une seule fois.

  - animation : < [P/=] >
    - X in (....)
    - 4 in (....) - 1) curseur sur liste 2) when found, next value and add line.

    - X in (QUERY)
    - 4 in [...] <- (QUERY [replace values ?])
      - 1) liste construite avec le curseur
      - 2) when found, next value.

  - normale
    - X in (liste/value) => once (....). 
      -> build result table below, one line by one.
  - corr√©l√©e, recalcul√©e √† chaque fois.
    - X in |¬†(value change (car calcul√©))
      -> build result table below, one line by one.
-->
</todo>

<h1 id="requ√™ter-une-base-de-donn√©es">Requ√™ter une base de donn√©es</h1>
<h2 id="introduction-√†-sql">Introduction √† SQL</h2>
<h3 id="les-sgbd">Les SGBD</h3>
<p>Il est fr√©quent de devoir traiter de larges quantit√©s de donn√©es :</p>
<ul>
<li>pour une entreprise : des listes de clients, de commandes, de produits, etc.</li>
<li>pour une administration : des listes d&#39;administr√©s, de transactions, etc.</li>
<li>pour un site Web : des logs de consultation de ses diff√©rentes pages, etc.</li>
<li>...</li>
</ul>
<p>Ces donn√©es peuvent repr√©senter des milliers, des millions (voire bien plus), d&#39;√©l√©ments. Il est √©vident qu&#39;on ne peut pas les manipuler &quot;√† la main&quot;. Par exemple, si on souhaite compter le nombre de ventes d&#39;une entreprise √† la main, c&#39;est :</p>
<ul>
<li><strong>chronophage</strong> :<br/>
<em>35 jours pour un million de ventes √† raison de 1 vente/seconde et 8h/jours.</em></li>
<li><strong>source d&#39;erreurs</strong> :<br/>
<em>Ventes compt√©es en double, saut√©es, etc.</em></li>
<li><strong>incomplet</strong> :<br/>
<em>Les ventes peuvent √™tre stock√©es √† plusieurs endroits diff√©rents, certaines perdues.</em></li>
</ul>
<p>Il est alors n√©cessaire d&#39;utiliser un logiciel permettant d&#39;efficacement :</p>
<ul>
<li><strong>stocker et organiser les donn√©es</strong>.</li>
<li><strong>manipuler les donn√©es</strong> : ajouter/modifier/supprimer des donn√©es.</li>
<li><strong>requ√™ter les donn√©es</strong> : e.g. compter le nombre de ventes.</li>
</ul>
<p>Pour r√©pondre √† ces besoins, on utilise un <strong>Syst√®me de Gestion de Bases de Donn√©es</strong> (SGBD). Un SGBD est un logiciel permettant de cr√©er, stocker, manipuler et requ√™ter des bases de donn√©es. Un SGBD r√©pond aussi √† d&#39;autres besoins comme :</p>
<ul>
<li><strong>la coh√©rence des donn√©es :</strong> garantie l&#39;absence de donn√©es invalides.<br/>
<em>e.g. avoir un √¢ge n√©gatif.</em></li>
<li><strong>la robustesse :</strong> r√©sister aux pannes.<br/>
<em>e.g. l&#39;ordinateur plante alors qu&#39;on est en train de modifier une donn√©e.</em></li>
<li><strong>le contr√¥le d&#39;acc√®s :</strong> qui peut faire quoi sur quelles donn√©es ?.<br/>
<em>e.g. l&#39;administrateur peut modifier et les utilisateurs lire les donn√©es.</em></li>
<li><strong>les logs :</strong> que s&#39;est-il pass√© ? qui a fait quoi et quand ?<br/>
<em>e.g. apr√®s une panne, qu&#39;√©tait-il en train de faire ?</em><br/>
<em>e.g. le stagiaire a fait une fausse manipulation, qu&#39;a-t-il r√©ellement fait ?</em></li>
<li><strong>acc√®s concurrent :</strong> modifications simultan√©es de donn√©es.</li>
</ul>
<p>üí° Dans le cadre de ce module, on se concentrera sur <strong>SQL</strong> (<em>Structured Query Language</em>), un langage permettant, entres autres, de structurer et de manipuler des bases de donn√©es.</p>
<h3 id="les-sgbd-sql">Les SGBD SQL</h3>
<p>Le langage SQL est normalis√© par la norme ISO/CEI 9075. Cependant certaines fonctionnalit√©s diff√®rent selon le SGBD utilis√©.</p>
<p>Parmi eux, <strong>SQLite</strong> est un SGBD l√©ger o√π chaque base est stock√©e sous la forme d&#39;un fichier. Il est tr√®s utilis√© pour stocker et g√©rer des donn√©es locales ayant peu d&#39;acc√®s concurrents.</p>
<p>Pour des usages plus intensifs, <strong>PostgreSQL</strong>, <strong>MySQL</strong>, et <strong>MariaDB</strong> sont des SGBD open sources plus complets, sous la forme de <strong>serveurs SQL</strong>. On interagit alors avec le SGBD via un <strong>client</strong> qui se charge de :</p>
<ul>
<li>se connecter au serveur ;</li>
<li>d&#39;envoyer la requ√™te SQL ;</li>
<li>et de r√©ceptionner la r√©ponse.</li>
</ul>
<p>Les clients peuvent prendre plusieurs formes :</p>
<ul>
<li>une interface graphique de requ√™tage (<em>e.g.  ???</em>).</li>
<li>une interface graphique de gestion de bases de donn√©es (<em>e.g. pgAdmin</em>).</li>
<li>une application en ligne de commandes (<em>e.g. psgl, mysql</em>).</li>
<li>une API utilis√©e dans le langage de programmation de votre choix.</li>
</ul>
<h3 id="les-tables-sql">Les tables SQL</h3>
<p>Comme dans un tableur, les donn√©es sont repr√©sent√©es sous forme de <strong>tables</strong> :</p>
<ul>
<li>les lignes correspondent √† des <strong>entr√©es</strong> ;</li>
<li>les colonnes correspondent aux diff√©rentes propri√©t√©s de ces entr√©es.</li>
</ul>
<p>Par exemple, la table suivante contient 2 entr√©es ayant les propri√©t√©s <code>ID</code>, <code>Nom</code>, <code>Prenom</code>, <code>Age</code> :</p>
<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Nom</th>
      <th>Prenom</th>
      <th>Age</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Doe</td>
      <td>John</td>
      <td>32</td>
    </tr><tr>
      <td>2</td>
      <td>Durand</td>
      <td>John</td>
      <td>64</td>
    </tr>
  </tbody>
</table>

<h4 id="vocabulaire">Vocabulaire</h4>
<ul>
<li>Une <strong>base de donn√©e</strong> est compos√©e de plusieurs tables.</li>
<li>Un <strong>sch√©ma</strong> de table d√©crit les colonnes de la table (cf CM3).</li>
<li>Les lignes d&#39;une table sont appel√©es <strong>entr√©es</strong> ou <strong>enregistrements</strong>.</li>
</ul>
<p>üí° Vous pouvez voir la base de donn√©es comme un fichier tableur, et les tables comme les feuilles de calculs contenues dans ce fichier.</p>
<p>üí° Les tables sont aussi parfois appel√©es <strong>relations</strong>, d&#39;o√π le terme <em>base de donn√©es relationnelle</em>.</p>
<h3 id="les-types-sql">Les types SQL</h3>
<p>En SQL chaque colonne a un type, i.e. le type des donn√©es qu&#39;on peut y ins√©rer. SQL supporte en g√©n√©ral 4 familles de types :</p>
<ul>
<li><code>TEXT</code> :¬†une cha√Æne de caract√®re.</li>
<li><code>BLOB</code> : des donn√©es binaires. </li>
<li><code>INT</code>/<code>INTEGER</code> : un nombre entier.</li>
<li><code>REAL</code> : un nombre d√©cimal.</li>
<li><code>ANY</code>  :¬†accepte n&#39;importe quelle valeur.</li>
</ul>
<p>üí° Par d√©faut, chaque type accepte la valeur <code>NULL</code>, qui indique une absence de donn√©es.</p>
<p>En g√©n√©ral, les SGBD (sauf SQLite) offrent une vari√©t√© de sous-types permettant d&#39;optimiser leur stockage. Une table (non-exhaustive) des sous-types les plus communs vous est propos√©e ci-dessous √† titre informatif :</p>
<details>
  <summary><em><strong>Montrer la table des sous-types</strong></em></summary>

  <table>
    <thead>
      <tr>
        <th>Famille</th>
        <th>Type</th>
        <th>Octets</th>
        <th>Description<th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan='9'>TEXT</td>
        <td>CHAR</td>
        <td>1 √† 3</td>
        <td>Caract√®re UTF8</td>
      </tr><tr>
        <td>CHAR(N)</td>
        <td>N*1 √† N*3</td>
        <td>Taille fixe</td>
      </tr><tr>
        <td>VARCHAR(N)</td>
        <td>0 √† N*3</td>
        <td>Taille variable</td>
      </tr>
      <tr><td></td><td></td><td></td></tr>
      <tr>
        <td>NCHAR</td>
        <td>2</td>
        <td>Caract√®re UTF16</td>
      </tr><tr>
        <td>NCHAR(N)</td>
        <td>N*2</td>
        <td>Taille fixe</td>
      </tr><tr>
        <td>NVARCHAR(N)</td>
        <td>0 √† N*2</td>
        <td>Taille variable</td>
      </tr>
      <tr><td></td><td></td><td></td></tr>
      <tr>
        <td>TEXT(N)</td>
        <td>N</td>
        <td>Pour de gros textes.</td>
      </tr>
      <tr><td></td><td></td><td></td><td></td></tr>
      <tr>
        <td rowspan='2'>BLOB</td>
        <td>BIT(N)</td>
        <td>N/8</td>
        <td>Champ de bits</td>
      </tr><tr>
        <td>BLOB(N)</td>
        <td>N</td>
        <td></td>
      </tr>
      <tr><td></td><td></td><td></td><td></td></tr>
      <tr></tr>
        <td rowspan='6'>INT</td>
        <td>BOOLEAN</td>
        <td>1</td>
        <td></td>
      </tr>
        <td>SMALLINT</td>
        <td>2</td>
        <td></td>
      </tr><tr>
        <td>INTEGER</td>
        <td>4</td>
        <td></td>
      </tr><tr>
        <td>BIGINT</td>
        <td>8</td>
        <td></td>
      </tr><tr>
        <td>NUMERIC(N)</td>
        <td>N</td>
        <td></td>
      </tr><tr>
        <td>ENUM(val[,...])</td>
        <td>2</td>
        <td>Peut aussi √™tre TEXT</td>
      </tr>
      <tr><td></td><td></td><td></td><td></td></tr>
      <tr>
        <td rowspan='4'>REAL</td>
        <td>FLOAT</td>
        <td>4</td>
        <td></td>
      </tr>
      <tr>
        <td>DOUBLE</td>
        <td>8</td>
        <td></td>
      </tr>
      <tr>
        <td>FLOAT(N)</td>
        <td>N</td>
        <td>Virgule flottante</td>
      </tr>
      <tr>
        <td>DECIMAL(N,S)</td>
        <td>N</td>
        <td>Pr√©cision fixe</td>
      </tr><tr><td></td><td></td><td></td><td></td></tr>
      <tr>
        <td rowspan='4'>DATE</td>
        <td>DATE</td>
        <td>4</td>
        <td>10 en SQLite (TEXT)</td>
      </tr>
      <tr>
        <td>TIME</td>
        <td>8 √† 12</td>
        <td></td>
      </tr>
      <tr>
        <td>DATETIME</td>
        <td>12 √† 16?</td>
        <td>19 en SQLite (TEXT)</td>
      </tr>
      <tr>
        <td>TIMESTAMP</td>
        <td>8</td>
        <td></td>
      </tr>
    </tbody>
  </table>

<p>  üí° En fonction du SGBD utilis√©, il existe une pl√©thore d&#39;autres types plus ou moins complexes.</p>
</details>

<h3 id="documentation">Documentation</h3>
<p>üí° Vous trouver plus amples documentation via les liens suivants :</p>
<ul>
<li>SQL :<ul>
<li><a href="https://www.w3schools.com/sql/">https://www.w3schools.com/sql/</a></li>
<li><a href="https://sql.sh">https://sql.sh</a></li>
</ul>
</li>
<li>SGBD :<ul>
<li>SQLite¬†:¬†<a href="https://www.sqlite.org">https://www.sqlite.org</a></li>
<li>PostgreSQL¬†:¬†<a href="https://www.postgresql.org/docs/">https://www.postgresql.org/docs/</a></li>
<li>MySQL : <a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></li>
</ul>
</li>
</ul>
<h2 id="requ√™tes-de-bases">Requ√™tes de bases</h2>
<h3 id="les-types-de-requ√™tes">Les types de requ√™tes</h3>
<p>Il existe plusieurs types de commandes SQL permettant d&#39;effectuer diff√©rent types actions :</p>
<ul>
<li><code>SELECT</code> : lire des donn√©es ;</li>
<li><code>UPDATE</code> : modifier des entr√©es ;</li>
<li><code>INSERT</code> : ins√©rer des entr√©es ;</li>
<li><code>DELETE</code> : supprimer des entr√©es.</li>
</ul>
<p>Nous allons dans un premier temps nous concentrer sur le premier, et verrons les 3 autres par la suite.</p>
<h2 id="la-requ√™te-select">La requ√™te SELECT</h2>
<p>La requ√™te SQL <code>SELECT</code> permet de r√©cup√©rer des donn√©es pr√©sentes dans une base de donn√©e, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS[,...] <span class="hljs-keyword">FROM</span> $<span class="hljs-keyword">TABLE</span>; 
</code></pre><ul>
<li><p><code>$TABLE</code> est le nom de la table SQL √† requ√™ter.</p>
</li>
<li><p><code>$COLS[,...]</code> est la liste des colonnes √† r√©cup√©rer s√©par√©es par &quot;,&quot;.</p>
<p>üí° <code>*</code> correspond √† l&#39;ensemble des colonnes.</p>
</li>
</ul>
<p>‚ö† Il est d&#39;usage de ne r√©cup√©rer que les colonnes dont on a r√©ellement besoin. En effet, sur de grandes tables et de grosses requ√™tes, r√©duire le nombre de colonnes r√©cup√©r√©es permet de r√©duire le volume des donn√©es transf√©r√©es. </p>
<h3 id="exemples">Exemples</h3>
<sql-interactive id="col-sql">
  <sql-dymtable slot="post" id="col-table" table="Users"></sql-dymtable>
  <span slot="options" data-cols="*">Retourner toutes les colonnes</span>
  <span slot="options" data-cols="Nom">Retourner une seule colonne</span>
  <span slot="options" data-cols="ID, Prenom">Retourner plusieurs colonnes</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const coltable = await LISS.qs("#col-table");
  const colsql   = await LISS.qs("#col-sql");

  colsql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( colsql.lastDatas );

  function update(datas) {

    const cols = Object.keys(datas[0][0]);

    coltable.highlightCol( (colname) => cols.includes(colname) ); //TODO...
  }

</script>

<h3 id="alias-de-colonnes">Alias de colonnes</h3>
<p>üí° Dans le cadre d&#39;une requ√™te SQL, vous pouvez temporairement associer un alias √† une colonne gr√¢ce au mot cl√© <code>as</code> :</p>
<sql-interactive>
  <span slot="options" data-col_as="">Requ√™te normale</span>
  <span slot="options" data-col_as="as User">Renommer une colonne</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Nom $COL_AS, Age <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<h3 id="trier-par-ordre-croissantd√©croissant-les-lignes">Trier par ordre croissant/d√©croissant les lignes</h3>
<p>La clause <code>ORDER BY $COL [DESC|ASC][,...]</code> permet de trier les lignes retourn√©es par ordre croissant (<code>ASC</code>) ou d√©croissant (<code>DESC</code>).</p>
<sql-interactive>
  <span slot="options" data-row_sort="Age ASC">Trier par Age croissant</span>
  <span slot="options" data-row_sort="Age DESC">Trier par Age d√©croissant</span>
  <span slot="options" data-row_sort="Age DESC, Nom ASC">Trier par Age d√©croissant, puis par Nom croissant</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> $ROW_SORT;
</code></pre></sql-interactive>

<h2 id="selection-des-lignes">Selection des lignes</h2>
<p><code>SELECT</code> retourne l&#39;int√©gralit√© des entr√©es de la table, ce qui peut repr√©senter des milliers de lignes. Or, bien souvent, seules quelques entr√©es nous int√©ressent.</p>
<p>Il est ainsi important de s√©lectionner uniquement les lignes qui nous int√©ressent afin de r√©duire le volume des donn√©es transf√©r√©es, ainsi que de r√©duire la consommation de ressources serveurs (processeur, RAM, disque).</p>
<p>Il est ainsi possible de s√©lectionner des lignes de diff√©rentes mani√®res :</p>
<ul>
<li>via un filtre via la clause <code>WHERE $COND</code> :<br/>
<em>e.g. les entr√©es correspondant aux utilisateurs mineurs.</em></li>
<li>en supprimant les doublons via la clause <code>DISTINCT</code> :<br/>
<em>e.g. les √¢ges sans doublons.</em></li>
<li>en limitant le nombre de lignes retourn√©es via les clauses <code>LIMIT $N OFFSET $O</code> :<br/>
<em>e.g. les 10 plus jeunes utilisateurs.</em></li>
</ul>
<h3 id="clause-where">Clause WHERE</h3>
<p>La mani√®re g√©n√©rique de filter les lignes √† retourner est d&#39;ajouter une clause <code>WHERE¬†$COND</code> √† la requ√™te. Seules les lignes pour lesquelles <code>$COND</code> est vraie seront retourn√©es.</p>
<sql-interactive id="row-sql">
  <sql-dymtable slot="post" id="row-table" table="Users"></sql-dymtable>
  <span slot="options" data-cond="Age > 18">Retourner les entr√©es o√π Age > 18</span>
  <span slot="options" data-cond="Nom == 'Doe'">Retourner les entr√©es o√π Nom est "Doe"</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>


<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const rowtable = await LISS.qs("#row-table");
  const rowsql   = await LISS.qs("#row-sql");

  rowsql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( rowsql.lastDatas );

  function update(datas) {

    const ids = datas[0].map(r => r.ID);

    rowtable.highlightRow( (ID) => ids.includes(+ID) );
  }

</script>

<h4 id="op√©rateurs-de-comparaisons">Op√©rateurs de comparaisons</h4>
<p>üí° La structure d&#39;une condition est tr√®s simple, utilisant les op√©rateurs de comparaison que vous connaissez d√©j√† : <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>.</p>
<sql-interactive>
  <span slot="options" data-cond="ID > 1">Comparaison simple</span>
  <span slot="options" data-cond="Prenom == Nom">Comparaison entre 2 colonnes</span>
  <span slot="options" data-cond="0 < Age < 18">Cha√Æner les op√©rateurs produit un r√©sultat √©trange</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Age, Nom, Prenom <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>üí° Vous pouvez utiliser les noms de colonnes comme op√©randes, m√™me si elles n&#39;apparaissent pas dans les colonnes √† retourner.</p>
<p>‚ö† Comme vous le constatez dans l&#39;exemple ci-dessus, bien que cela soit syntaxiquement valide, <strong>cha√Æner les op√©rateurs de comparaisons ne produira pas le r√©sultat attendu</strong>.<br/>
Vous ne devez ainsi pas √©crire, e.g. <code>0 &lt; Age &lt; 18</code>, mais (cf suite du cours) :</p>
<ul>
  <li>soit <code>0 < Age AND Age < 18</code> ;</li>
  <li>soit <code>Age BETWEEN 0 AND 18</code> .</li>
</ul>

<h4 id="op√©rateurs-logiques">Op√©rateurs logiques</h4>
<p>Vous pouvez composer des conditions √† l&#39;aide d&#39;op√©rateurs logiques que vous connaissez d√©j√† : <code>AND</code>, <code>OR</code>, <code>NOT</code>.</p>
<sql-interactive>
  <span slot="options" data-cond="Age > 18 AND Age < 45">Intersection (et)</span>
  <span slot="options" data-cond="Age > 18 OR Age < 45">Union (ou)</span>
  <span slot="options" data-cond="NOT ( Age > 18 )">N√©gation (non)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Age, Nom, Prenom <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>üí° Vous pouvez aussi utiliser des parenth√®ses.</p>
<h4 id="autres-op√©rateurs">Autres op√©rateurs</h4>
<sql-interactive>
  <span slot="options" data-cond="Age IS NULL">Entr√©es o√π Age vaut null</span>
  <span slot="options" data-cond="Nom IN ('Doe', 'Nescio')">Entr√©es o√π Nom est dans la liste</span>
  <span slot="options" data-cond="Age BETWEEN 0 AND 18">Entr√©es o√π Age est compris entre 0 et 18</span>
  <span slot="options" data-cond="Nom LIKE 'D%'">Entr√©es o√π Nom commence par "D"</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Age, Nom, Prenom <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<ul>
<li><p><code>[NOT] IS NULL</code> : si la valeur est nulle/n&#39;est pas nulle.<br/>
‚ö† En SQL <code>NULL == NULL</code> est g√©n√©ralement √©valu√© √† <code>False</code>.</p>
</li>
<li><p><code>[NOT] IN ($VALS[,...])</code> : si la valeur est/n&#39;est pas dans une liste donn√©e.</p>
</li>
<li><p><code>[NOT] BETWEEN $MIN AND $MAX</code> : si la valeur est/n&#39;est pas entre <code>$MIN</code> et <code>$MAX</code>.<br/>
üí° C&#39;est l&#39;√©quivalant de <code>$VAL &gt;= $MIN AND $VAL &lt;= $MAX</code><br/>
‚ö† Le comportement de l&#39;op√©rateur <code>BETWEEN</code> peut changer en fonction du syst√®me, et peut alors √™tre √©quivalent √† <code>$VAL &gt; $MIN AND $VAL &lt; $MAX</code>.</p>
</li>
<li><p><code>[NOT] LIKE $PATTERN</code> : si la valeur correspond/ne correspond pas √† <code>$PATTERN</code>.<br/>
<code>_</code> correspond √† n&#39;importe quel caract√®re.<br/>
<code>%</code> correspond √† un nombre ind√©termin√© de n&#39;importe quel caract√®re.<br/>
e.g. <code>LIKE &#39;D%&#39;</code>: une valeur commen√ßant par &quot;D&quot;.</p>
</li>
</ul>
<h3 id="supprimer-les-doublons">Supprimer les doublons</h3>
<p>La clause <code>DISTINCT</code> permet de supprimer les doublons dans les lignes retourn√©es :</p>
<sql-interactive>
  <span slot="options" data-row_distinct="">Requ√™te normale</span>
  <span slot="options" data-row_distinct="DISTINCT">Ne pas retourner les doublons</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $ROW_DISTINCT Age <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<h3 id="tops-et-pagination">Tops et pagination</h3>
<h4 id="tops">Tops</h4>
<p>La clause <code>LIMIT $N</code> permet de ne r√©cup√©rer que les <code>$N</code> premi√®res entr√©es retourn√©es. Souvent utilis√©e avec la clause <code>ORDER BY</code>, elle permet notamment de g√©n√©rer des tops, e.g. les X utilisateurs les plus jeunes.</p>
<sql-interactive>
  <span slot="options" data-pagination="1">Ne r√©cup√©rer que la premi√®re entr√©e</span>
  <span slot="options" data-pagination="2">Ne r√©cup√©rer que les deux premi√®res entr√©es</span>
  <span slot="options" data-orderby="ORDER BY Age" data-pagination="1">Ne r√©cup√©rer que l'utilisateur le plus jeune</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users $ORDERBY LIMIT $PAGINATION;
</code></pre></sql-interactive>

<h4 id="pagination">Pagination</h4>
<p>Lorsqu&#39;une requ√™te retourne des milliers de lignes, il peut √™tre co√ªteux de toutes les r√©cup√©rer et les afficher en m√™me temps. On peut alors d√©couper la liste en plusieurs pages, en affichant que e.g. 50 lignes par pages. Ainsi la premi√®re page r√©cup√®re et affiche les 50 premi√®res lignes, la seconde les 50 suivantes, et ainsi de suite.</p>
<p>Pour cela, on utilisera la clause <code>LIMIT 50</code> afin de ne r√©cup√©rer que 50 entr√©es par requ√™tes. En conjonction, on utilisera la clause <code>OFFSET $P*50</code> qui permet de ne pas r√©cup√©rer les <code>$P*50</code> premi√®res entr√©es retourn√©es. <code>$P+1</code> √©tant alors le num√©ro de la page actuelle.</p>
<sql-interactive id="pagination-sql">
  <sql-dymtable slot="post" id="pagination-table" table="Users"></sql-dymtable>
  <span slot="options" data-pagination="1" data-p="0">Page 1 (1 entr√©e par page)</span>
  <span slot="options" data-pagination="1" data-p="1">Page 2 (1 entr√©e par page)</span>
  <span slot="options" data-pagination="1" data-p="2">Page 3 (1 entr√©e par page)</span>
  <span slot="options" data-pagination="2" data-p="0*2">Page 1 (2 entr√©e par page)</span>
  <span slot="options" data-pagination="2" data-p="1*2">Page 2 (2 entr√©e par page)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users LIMIT $PAGINATION <span class="hljs-keyword">OFFSET</span> $P ;
</code></pre></sql-interactive>

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const table = await LISS.qs("#pagination-table");
  const sql   = await LISS.qs("#pagination-sql");

  sql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( sql.lastDatas );

  function update(datas) {

    const ids = datas[0].map(r => r.ID);
    table.highlightRow( (ID) => ids.includes(+ID) );
  }

</script>


<h2 id="ordre-dex√©cution-et-d√©criture">Ordre d&#39;ex√©cution et d&#39;√©criture</h2>
<p>Le diff√©rentes <strong>clauses</strong> des requ√™tes SQL sont g√©n√©ralement √©crites dans leur ordre d&#39;ex√©cution, et ex√©cut√©es dans leur ordre d&#39;√©criture, i.e. de gauche √† droite.</p>
<style>
  .later {
    color: gray;
    font-style: italic;
    opacity: 0.5;
  }
  .warning {
    color: red;
  }

</style>

<p>Par exemple lors d&#39;une requ√™te <code>SELECT</code>:</p>
<div style="display:flex">
  <ol id="order-list">
    <li step="1">On r√©cup√®re la table (clause <code>FROM</code>).</li>
    <li step="2" class="warning"><em>Alias de colonnes d√©finies ici.</em></li>
    <li step="3">On filtre les entr√©es (clause <code>WHERE</code>).</li>
    <li class="later">On groupe les entr√©es en lignes (clause <code>GROUP BY</code>).</li>
    <li class="later warning"><em>Alias de colonnes d'agr√©gats d√©finies ici.</em></li>
    <li class="later">On filtre les lignes agr√©g√©es (clause <code>HAVING</code>).</li>
    <li class="warning" step="4">On supprime les doublons (clause <code>SELECT DISTINCT</code>).</li>
    <li step="5">On trie les lignes (clause <code>ORDER BY</code>).</li>
    <li step="6">On limite le nombre de lignes retourn√©es (clauses <code>LIMIT</code>/<code>OFFSET</code>).</li>
  </ol>
  <div>
    <div style="text-align: center">
      <anim-player speed="1500" id="order-player"></anim-player>
    </div>
    <div style="display:flex;height: fit-content;">
      <style>
        .notyet {
          color: gray;
        }
        .cur {
          color: yellow;
        }
        .warning.cur {
          color: orange;
        }
      </style>
      <pre style="margin:0"><code id="order_sql">SELECT <span class="notyet">DISTINCT</span> Date, Ref, Q as Nb
    FROM Produits
    WHERE Ref = "Gomme"
    ORDER BY Q
    LIMIT 2;</code></pre>
      <sql-dymtable header="" table="Produits" id="order-table"><sql-dym-table>>
    </div>
  </div>
</div>

<script type="module">


  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const player = await LISS.qs("#order-player");
  const table  = await LISS.qs("#order-table");
  const order_sql = document.querySelector("#order_sql");

  const list = document.querySelectorAll("#order-list > li");

  const query = [
`SELECT `, [4, `DISTINCT `], `Date, Ref, Q `, [2, "as Nb"],
    [ 1, `\n    FROM Produits`],
    [ 3, `\n    WHERE Ref = 'Gomme'`],
    [ 5, `\n    ORDER BY Q`],
    [ 6, `\n    LIMIT 2`], ';' ];

  function buildQuery(step) {
    let output = "";
    for(let elem of query) {
      if( Array.isArray(elem) ) {
        if( elem[0] > step && step !== 0 )
          continue;
        elem = elem[1];
      }
      output += elem;
    }

    return output;
  }
  function buildOutput(step) {
    let output = [];
    for(let elem of query) {
      if( Array.isArray(elem) ) {
        const html = document.createElement('span');
        html.textContent = elem[1];
        html.classList.toggle("cur", elem[0] === step);
        
        if( elem[0] > step && step !== 0 )
          html.classList.add("notyet");
        elem = html;
      }
      output.push(elem);
    }

    return output;
  }

  function doStep(i) {

    if( i > 6) {
      player.reset();
      return;
    }

    order_sql.replaceChildren( ...buildOutput(i) ); //TODO highlight
    for(let li of list)
      li.classList.toggle("cur", li.getAttribute("step") === `${i}`);

    table.exec( buildQuery(i) );
  }

  player.host.addEventListener("reset", ()   => { doStep(0)          });
  player.host.addEventListener("step" , (ev) => { doStep( ev.detail) });

  doStep(0);
</script>

<p>üí° Les √©tapes en gris seront √©tudi√©es au CM suivant.</p>
<p>‚ö† En rouge sont indiqu√©s des cas d&#39;exceptions dont l&#39;ordre d&#39;√©criture ne correspond pas √† leur ordre d&#39;ex√©cution. Une autre exception existe dans les requ√™tes <code>UPDATE</code> o√π la clause <code>SET</code> s&#39;√©crit <strong>avant</strong> la clause <code>WHERE</code>.</p>
<h1 id="manipuler-des-entr√©es">Manipuler des entr√©es</h1>
<h2 id="modifier-le-contenu-dune-table">Modifier le contenu d&#39;une table</h2>
<p>Pour rappel, il existe plusieurs types de commandes SQL permettant d&#39;effectuer diff√©rent types actions :</p>
<ul>
<li><code>SELECT</code> : lire des donn√©es ;</li>
<li><code>UPDATE</code> : modifier des entr√©es ;</li>
<li><code>INSERT</code> : ins√©rer des entr√©es ;</li>
<li><code>DELETE</code> : supprimer des entr√©es.</li>
</ul>
<p>Nous allons d√©sormais nous int√©resser aux 3 derni√®res.</p>
<h3 id="ins√©rer-des-lignes">Ins√©rer des lignes</h3>
<p>La requ√™te SQL <code>INSERT</code> permet d&#39;ins√©rer des entr√©es dans une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> $TABLENAME <span class="hljs-keyword">VALUES</span> ($VALS[,...])[,...];
</code></pre><ul>
<li><code>($VALS[,...])</code> repr√©sente une entr√©e √† ins√©rer. Les diff√©rentes valeurs de l&#39;entr√©e sont s√©par√©es par une virgule.<br/>
üí° Vous pouvez ins√©rer plusieurs entr√©es √† la fois en les s√©parant par une virgule.</li>
</ul>
<sql-interactive>
  <span slot='select'>SELECT * FROM Users;</span>
  <span slot="options" data-m_vals="(NULL, 'Doe', 'Jon', 32)">Ins√©rer une entr√©e</span>
  <span slot="options" data-m_vals="      (NULL, 'Doe',    'Jon', 32),
       (NULL, 'Sawyer', 'Tom', 15)">Ins√©rer plusieurs entr√©es</span>
  <span slot="options" data-cols="(Prenom, Nom)" data-m_vals="('Jon', 'Doe')">Ins√©rer une entr√©e sans renseigner Age</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Users $COLS <span class="hljs-keyword">VALUES</span>
$M_VALS;
</code></pre></sql-interactive>

<p>üí° Vous pouvez aussi ne renseigner les valeurs que pour certaines colonnes dont vous indiquez les noms avant <code>VALUES</code>. Dans ce cas, les colonnes non renseign√©es vaudront <code>NULL</code>.</p>
<h3 id="modifier-des-lignes">Modifier des lignes</h3>
<p>La requ√™te SQL <code>UPDATE</code> de modifier des entr√©es dans une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">UPDATE</span> $TABLENAME <span class="hljs-keyword">SET</span> $COL <span class="hljs-operator">=</span> $VAL[,...] <span class="hljs-keyword">WHERE</span> $COND;
</code></pre><ul>
<li><code>$COL</code> est le nom de la colonne √† modifier.</li>
<li><code>$VAL</code> est la nouvelle valeur de cette colonne.</li>
<li><code>$COND</code> indique quelles entr√©es doivent √™tre modifi√©es.</li>
</ul>
<p>üí° Vous pouvez modifier plusieurs colonnes √† la fois en s√©parant les <code>$COL = $VAL</code> par une virgule.</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM Users;</span>
  <span slot="options" data-vals="Nom = 'Durand'" data-cond="Nom == 'Durant'">Modifier une colonne</span>
  <span slot="options" data-vals="Nom = 'Durand', Prenom='Th√©o'" data-cond="ID == 2">Modifier plusieurs colonnes</span>
  <span slot="options" data-vals="Age = 23" data-cond="Age == 43">Plusieurs lignes modifi√©es</span>
  <span slot="options" data-vals="Age = Age + 10" data-cond="Nom LIKE 'D%'">Valeur calcul√©e √† partir de l'entr√©e</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">UPDATE</span> Users
  <span class="hljs-keyword">SET</span> $VALS
  <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>üí° Vous pouvez calculer les nouvelles valeurs √† partir des valeurs initiales de l&#39;entr√©e.</p>
<p>‚ö† Il est possible d&#39;avoir des utilisateurs avec le m√™me nom et/ou pr√©noms. Il est ainsi pr√©f√©rable, autant que possible, d&#39;effectuer la condition <code>$COND</code> les ID pour s&#39;assurer de modifier les bonnes entr√©es, et non celles d&#39;homonymes.</p>
<h3 id="supprimer-des-lignes">Supprimer des lignes</h3>
<p>La requ√™te SQL <code>DELETE</code> de supprimer des entr√©es dans une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> $TABLENAME <span class="hljs-keyword">WHERE</span> $COND;
</code></pre><ul>
<li><code>$COND</code> indique quelles entr√©es doivent √™tre supprim√©es.</li>
</ul>
<sql-interactive>
  <span slot='select'>SELECT * FROM Users;</span>
  <span slot="options" data-cond="Age < 18">Supprimer les entr√©es o√π Age > 18</span>
  <span slot="options" data-cond="Age > 18">Supprimer les entr√©es o√π Age > 18</span>
  <span slot="options" data-cond="ID == 2">Supprimer un utilisateur donn√©</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>‚ö† Il est possible d&#39;avoir des utilisateurs avec le m√™me nom et/ou pr√©noms. Il est ainsi pr√©f√©rable, autant que possible, d&#39;effectuer la condition <code>$COND</code> les ID pour s&#39;assurer de supprimer les bonnes entr√©es, et non celles d&#39;homonymes.</p>
<h2 id="pr√©traitements">Pr√©traitements</h2>
<p>Il est bien souvent important de pr√©-traiter les donn√©es avant de les utiliser (e.g. comparaisons, insertions), ce afin de s&#39;assurer que les informations soient bien repr√©sent√©es de la m√™me mani√®re. Par exemple, un nom de famille peut s&#39;√©crire de plusieurs mani√®res : <code>&quot;Nom&quot;</code>, &quot;<code>NOM</code>&quot;, ou &quot;<code>nom</code>&quot;. Si ces trois cha√Ænes de caract√®res repr√©sentent bien la m√™me information, elles ne sont pas √©gales pour autant. Ainsi, aucune entr√©e ne sera retourn√©e si on recherche <code>&quot;Nom&quot;</code> dans la base de donn√©es, alors qu&#39;il est stock√© en majuscules (i.e. <code>&quot;NOM&quot;</code>).</p>
<p>Pr√©-traiter les donn√©es permet alors de s&#39;assurer de l&#39;uniformit√© des donn√©es, i.e. que les donn√©es manipul√©es suivent le m√™me format, facilitant e.g. leur comparaisons. Pr√©-traiter les donn√©es avant insertions permet aussi de s&#39;assurer de la coh√©rence et consistance de la base de donn√©es.</p>
<p>üí° Il est possible de <strong>tester</strong> les diff√©rentes fonctions de pr√©traitements en effectuant une requ√™te <code>SELECT</code> sans la clause <code>FROM</code> (ou avec <code>FROM DUAL</code> pour certains SGBD) :</p>
<sql-interactive>
  <span slot="options" data-col1="'nom'" data-col2="UPPER('nom')">Mettre en majuscules</span>
  <span slot="options" data-col1="1.2" data-col2="ROUND(1.2)">Arrondir</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COL1 <span class="hljs-keyword">as</span> BEFORE, $COL2 <span class="hljs-keyword">as</span> AFTER;
</code></pre></sql-interactive>

<p>‚ö† Dans les requ√™tes <code>SELECT</code>, il ne faut pas trop abuser de ces pr√©-traitements pour les valeurs retourn√©es. Il est souvent pr√©f√©rable de g√©rer des donn√©es structur√©es en SQL, et de g√©rer leur pr√©-traitement via le langage utilis√© par votre application (e.g. Python, R, JavaScript, etc). Cela permet notamment de pouvoir r√©utiliser une m√™me requ√™te pour diff√©rents usages.</p>
<p>üí° Certains SGBD ont aussi des syst√®mes de cache, permettant de recalculer plus rapidement le r√©sultat d&#39;une requ√™te ex√©cut√©e fr√©quemment.</p>
<h3 id="sur-les-nombres">Sur les nombres</h3>
<p>Avec SQL, vous pouvez utiliser les op√©rateurs et fonctions arithm√©tiques classiques :</p>
<sql-interactive>
  <span slot="options" data-cols="1+1, 4%3, 4/3, 4/3.0">Op√©rations math√©matiques</span>
  <span slot="options" data-cols="FLOOR(1.2), ROUND(1.2), CEIL(1.2)">Arrondis</span>
  <span slot="options" data-cols="ABS(1), ABS(-1)">Valeur absolue</span>
  <span slot="options" data-cols="RANDOM()">Entier al√©atoire</span>
  <span slot="options" data-cols="ABS(RANDOM()) % 10">Entier al√©atoire (dans [[0;10[[)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<p>‚ö† <code>/</code> utilis√© avec des nombres entiers effectuera la division enti√®re. Si vous souhaitez faire la division d√©cimale, vous devez avoir au moins une op√©rande d√©cimale.</p>
<ul>
<li><code>FLOOR/ROUND/CEIL($N[, $D])</code> : arrondir <code>$N</code> √† <code>$D</code> d√©cimales.</li>
<li><code>ABS($N)</code> : la valeur absolue du nombre <code>$N</code>.</li>
<li><code>RANDOM()</code> : g√©n√®re un entier al√©atoire.<br/>
üí° Utilisez <code>ABS(RANDOM()) % $N</code> pour g√©n√©rer un entier dans <code>[[0;$N[[</code>.<br/>
üí° Certains SGBD proposent une fonction <code>RAND()</code> permettant de g√©n√©rer un r√©el dans <code>[0,1[</code>.<br/></li>
</ul>
<p>üí° Vous avez aussi beaucoup d&#39;autres fonctions trigonom√©triques, de logs, etc.</p>
<h3 id="sur-les-dates">Sur les dates</h3>
<p>Les op√©rations sur les dates sont complexes √† effectuer √† la main. En effet, il faut alors g√©rer :</p>
<ul>
<li>les mois avec des nombres de jours diff√©rents ;</li>
<li>les ann√©es bissextiles ;</li>
<li>les fuseaux horaires ;</li>
<li>les heures d&#39;√©t√© et d&#39;hiver.</li>
</ul>
<p>Les SGBD fournissent donc des fonctions permettant de manipuler les dates qui s&#39;occupent de prendre tout cela en compte. Par exemple <code>TIMEDIFF()</code> permet de calculer la dur√©e entre deux dates.</p>
<p>Il est aussi fr√©quent d&#39;utiliser des <strong>timestamps</strong>, e.g. l&#39;unix timestamp, qui repr√©sente une date par le nombre de secondes √©coul√©es depuis le 1er janvier 1970. Il permet notamment d&#39;ais√©ment comparer et stocker des dates.</p>
<sql-interactive>
  <span slot="options" data-cols="DATE(), TIME(), DATETIME()">Date et/ou heure actuelle</span>
  <span slot="options" data-cols="UNIXEPOCH('now')">Timestamp actuel</span>
  <span slot="options" data-cols="DATETIME(10, 'unixepoch')">Convertir un timestamp (10) en date</span>
  <span slot="options" data-cols="TIMEDIFF('now', '2001-01-01')">Calculer la dur√©e entre deux dates</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<ul>
<li><code>DATE()</code>/<code>TIME()</code>/<code>DATETIME()</code> : retourne la date et/ou l&#39;heure actuelle.</li>
<li><code>TIMEDIFF($a, $b)</code> : donne la dur√©e entre deux dates.</li>
<li><code>UNIXEPOCH($d)</code> : donne le nombre de secondes √©coul√©es entre le 1er janvier 1970 et la date <code>$d</code>.</li>
</ul>
<p>üí° Idem, il existe de nombreuses autres op√©rations et formatage sur les dates que nous ne verrons pas dans le cadre de ce cours.</p>
<p>‚ö† Les fonctions de dates ne sont pas normalis√©es et d√©pendent donc du SGBD utilis√©.</p>
<h3 id="sur-les-cha√Ænes-de-caract√®res">Sur les cha√Ænes de caract√®res</h3>
<p>D&#39;un utilisateur √† un autre, la casse des lettres dans les chaines de caract√®res est souvent inconsistante. Lorsque la casse importe peu quant √† l&#39;information stock√©e, il est alors fr√©quent de mettre la cha√Æne de caract√®re en minuscule (ou en majuscule) afin de pouvoir ensuite plus facilement les manipuler/comparer en s&#39;assurant de la consistance des donn√©es (e.g. e-mail, nom, etc.).</p>
<p>Les cha√Ænes de caract√®res sont g√©n√©ralement stock√©es sur des colonnes √† taille variables. Mais il arrive que pour des raisons d&#39;optimisations, elles soient stock√©es sur des colonnes √† tailles fixes. D√®s lors, pour stocker une cha√Æne de caract√®re d&#39;une taille moindre, on lui ajoutera g√©n√©ralement des espaces en d√©but ou fin de cha√Æne (<em>pad</em>). L&#39;op√©ration inverse consiste √† retirer les espaces en d√©but ou fin de cha√Æne (<em>trim</em>).</p>
<sql-interactive>
  <span slot="options" data-cols="LOWER('Hello'), UPPER('Hello')">Transformer la casse</span>
  <span slot="options" data-cols="LENGTH('23'), LENGTH(32)">Taille</span>
  <span slot="options" data-cols="TRIM(' w '), LTRIM(' w '), RTRIM(' w ')">Retirer les espaces en d√©but/fin</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<ul>
<li><code>LOWER($W)</code>/<code>UPPER($W)</code> : transforme tous les caract√®res en minuscules/majuscules.</li>
<li><code>LENGTH($N)</code> : la taille de <code>$N</code>.</li>
<li><code>[L/R]TRIM($W)</code> : enl√®ve les espaces en d√©but et/ou fin de cha√Æne.</li>
<li><code>[L/R]PAD($W, $N, $C)</code> : l&#39;inverse de <code>[L/R]TRIM()</code>, ajoute des caract√®res <code>$C</code> en d√©but/fin de <code>$W</code>, de sorte √† avoir une cha√Æne de caract√®re de taille <code>$N</code>.<br/>
‚ö† Cette fonction n&#39;est pas disponible sur SQLite.</li>
</ul>
<p>Il existe bien d&#39;autres fonctions que nous ne verrons pas dans le cadre de ce cours :</p>
<details>
  <summary>
    <strong><em>Afficher les autres pr√©-traitements</em></strong>
  </summary>

<ul>
<li><code>FORMAT()</code> : formate une cha√Æne de caract√®re comme <code>printf()</code> en C/Python (pas standardis√©).<br>
Cf <a href="https://www.sqlite.org/printf.html">documentation SQLite</a>.<br/>
Cf <a href="https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-FORMAT">documentation PostgreSQL</a>.</li>
<li><code>REVERSE($W)</code> : inverse l&#39;ordre des caract√®res.</li>
<li><code>REPLACE($W, $S, $R)</code> : dans <code>$W</code>, remplace <code>$S</code> par <code>$R</code>.</li>
<li><code>SUBSTR($W, $B[, $L])</code> : retourne la sous-cha√Æne de <code>$W</code> commen√ßant √† l&#39;index <code>$B</code> et de taille <code>$L</code>.</li>
<li><code>LOCATE($W, $S)</code> : retourne l&#39;index √† laquelle se trouve <code>$S</code> dans <code>$W</code>.</li>
</ul>
</details>


<details>
  <summary>

<h2 id="autres-pr√©traitements-en-tp">Autres pr√©traitements (en TP)</h2>
  </summary>

<h3 id="sur-les-valeurs-nulles">Sur les valeurs nulles</h3>
<sql-interactive>
  <span slot="options" data-cols="NULL"></span>
  <span slot="options" data-cols="COALESCE(NULL, 4)"></span>
  <span slot="options" data-cols="COALESCE(NULL, NULL)"></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<ul>
<li><code>COALESCE($args[,...])</code> : renvoie la premi√®re valeur non nulle (ou null si toutes nulles).</li>
</ul>
<h3 id="conversions">Conversions</h3>
<sql-interactive>
  <span slot="options" data-col_cast="'1.2' AS REAL">Convertir en r√©el</span>
  <span slot="options" data-col_cast="'1.2' AS INT">Convertir en entier</span>
  <span slot="options" data-col_cast="1.2 AS TEXT">Convertir en texte</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>( $COL_CAST );
</code></pre></sql-interactive>

<ul>
<li><code>CAST($V AS $T)</code> : converti la valeur <code>$V</code> dans le type <code>$T</code>.<br/>
üí° <code>$T</code> sera ainsi g√©n√©ralement : <code>REAL</code>, <code>INT</code>/<code>INTEGER</code>, ou <code>TEXT</code>.</li>
</ul>
<p>üí° Il existe bien d&#39;autres fonctions de conversions plus ou moins sp√©cifiques aux SGBD.</p>
<h3 id="concat√©ner-des-colonnes">Concat√©ner des colonnes</h3>
<p>üí° Vous pouvez aussi concat√©ner des colonnes en utilisant l&#39;op√©rateur <code>||</code> :</p>
<sql-interactive>
  <span slot="options" data-col_concat="Nom">Nom</span>
  <span slot="options" data-col_concat="Nom || ' ' || Prenom">Nom Prenom</span>
  <span slot="options" data-col_concat="Nom || ' (' || Age || ')'">Nom (Age)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COL_CONCAT <span class="hljs-keyword">as</span> <span class="hljs-keyword">User</span> <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<p>‚ö† Attention √† ne pas abuser des concat√©nations. Il est bien souvent pr√©f√©rable de r√©cup√©rer des donn√©es structur√©es, puis de g√©rer leurs formatages et affichages via le langage utilis√© par votre application (e.g. Python, R, JavaScript, etc). Cela permet notamment de pouvoir r√©utiliser une m√™me requ√™te pour diff√©rents usages.</p>
<p>üí° Certains SGBD ont aussi des syst√®mes de cache, permettant de recalculer plus rapidement le r√©sultat d&#39;une requ√™te ex√©cut√©e fr√©quemment.</p>
<h3 id="conditions">Conditions</h3>
<p>De mani√®re <strong>rare</strong>, il est possible qu&#39;on souhaite effectuer des conditions.</p>
<sql-interactive>
  <span slot="options" data-age='2'>Utilisateur mineur</span>
  <span slot="options" data-age='20'>Utilisateur majeur</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">CASE</span>
  <span class="hljs-keyword">WHEN</span> Age <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>  <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;???&#x27;</span>
  <span class="hljs-keyword">WHEN</span> Age <span class="hljs-operator">&lt;</span> <span class="hljs-number">18</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;mineur&#x27;</span>
                <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;majeur&#x27;</span>
<span class="hljs-keyword">END</span>) <span class="hljs-keyword">as</span> Status <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> $Age <span class="hljs-keyword">as</span> Age);
</code></pre></sql-interactive>

<p>Le format est relativement simple :</p>
<ul>
<li>il commence par <code>(CASE</code> et fini par <code>END)</code>.</li>
<li><code>WHEN $COND THEN $VAL</code> retourne la valeur <code>$VAL</code> si <code>$COND</code> est √©valu√© √† vrai.</li>
<li><code>ELSE $VAL</code> est la valeur par d√©faut si aucune condition n&#39;est vraie.</li>
</ul>
<p>‚ö† Le <code>(SELECT $Age as Age)</code> n&#39;est l√† qu&#39;√† des fins de d√©monstrations, afin de vous permettre de modifier la valeur de l&#39;√¢ge. Pour le moment ignorez-le.</p>
<p>‚ö† Si vous utilisez fr√©quemment la clause <code>CASE</code> dans les <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> pour :</p>
<ul>
<li>calculer la valeur d&#39;une colonne d√©pendant d&#39;autres colonnes : est-il vraiment n√©cessaire de la stocker ?</li>
<li>transformer la valeur d&#39;une colonne : serait-il int√©ressant de plut√¥t stocker la valeur transform√©e ?</li>
</ul>
<details>
  <summary>
  
<h3 id="consid√©rations-de-s√©curit√©">Consid√©rations de s√©curit√©</h3>
  </summary>


<p>Il est possible de hasher certaines donn√©es avant de les ins√©rer dans la base de donn√©es. Cela peut par exemple √™tre utilis√© afin de rapidement comparer deux fichiers, ou de contr√¥ler l&#39;int√©grit√© d&#39;un fichier.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span>¬†<span class="hljs-keyword">INTO</span> Files <span class="hljs-keyword">VALUES</span> ($FILENAME, LENGTH($FILECONTENT), SHA256($FILECONTENT) );
<span class="hljs-keyword">SELECT</span> Filename, Filesize <span class="hljs-keyword">FROM</span> Files <span class="hljs-keyword">WHERE</span> Filehash <span class="hljs-operator">=</span><span class="hljs-operator">=</span> SHA256($FILECONTENT);
</code></pre><p>‚ö† La fonction <code>SHA256($D)</code> permet de hasher les donn√©es <code>$D</code> pass√©es en param√®tre. Elle n&#39;est cependant pas disponible dans tous les SGBD. Sur SQLite, elle requi√®re d&#39;installer une extension.</p>
<p>‚ö† Il faut imp√©rativement hasher ou chiffrer les donn√©es sensibles <strong>AVANT</strong> de les transmettre √† la requ√™te SQL. En effet, si vous hashez/chiffrez des donn√©es sensibles √† l&#39;int√©rieur m√™me d&#39;une requ√™te SQL, il y a de fortes chances qu&#39;elles soient ensuite stock√©es en clair dans les logs du SGBD...</p>
<p>üí° Vous approfondirez les questions de chiffrement et de hashage dans d&#39;autres modules.</p>
</details>

</details>

<h2 id="agr√©gation">Agr√©gation</h2>
<p>Une agr√©gation permet de regrouper, au sein d&#39;une m√™me ligne, plusieurs entr√©es, e.g. pour obtenir la liste des nombres de produits vendus, par dates ou par produits : </p>
<sql-interactive>
  <span slot="options" data-grp='Ref'>Agr√©g√© par r√©f√©rences</span>
  <span slot="options" data-grp='Date'>Agr√©g√© par dates</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, GROUP_CONCAT(Q)
  <span class="hljs-keyword">FROM</span> Produits <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP;
</code></pre></sql-interactive>

<p>Pour cela, on utilise la clause <code>GROUP BY $COLS[,...]</code> qui permet de fusionner, au sein d&#39;une m√™me ligne, les entr√©es dont les valeurs de <code>$COLS[,...]</code> sont √©gales. Vous trouverez ci-dessous une repr√©sentation visuelle d&#39;une agr√©gation :</p>
<div style="display:flex;justify-content: space-around;width:100%">
  <sql-dymtable table="Produits"></sql-dymtable>
  <sql-dymtable id="group-date" table="Produits" header="Group by Date"></sql-dymtable>
  <sql-dymtable id="group-ref"  table="Produits" header="Group by Ref"></sql-dymtable>
</div>

<script type="module">

  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const gdate_table = await LISS.qs("#group-date");
  const  gref_table = await LISS.qs("#group-ref");

  gdate_table.groupBy("Date");
   gref_table.groupBy("Ref");


/*  const rowsql   = await LISS.qs("#row-sql");

  rowsql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( rowsql.lastDatas );

  function update(datas) {

    const ids = datas[0].map(r => r.ID);

    rowtable.highlightRow( (ID) => ids.includes(+ID) );
  }*/
</script>

<p>Vous remarquerez alors que les lignes contiennent plusieurs valeurs pour une m√™me colonne. Il convient alors d&#39;utiliser une <strong>fonction d&#39;agr√©gation</strong> qui prendra la liste des valeurs et retournera une valeur unique. Par exemple, <code>GROUP_CONCAT(Q)</code> concat√®ne, pour chaque ligne, la colonne <code>Q</code> de ses entr√©es :</p>
<sql-interactive>
  <span slot="options" data-op='GROUP_CONCAT(Q)' data-grp="Ref">Concat√©nation</span>
  <span slot="options" data-op='SUM(Q)' data-grp="Date">Somme</span>
  <span slot="options" data-op='AVG(Q)' data-grp="Ref">Moyenne</span>
  <span slot="options" data-op='MIN(Q)' data-grp="Date">Minimum</span>
  <span slot="options" data-op='MAX(Q)' data-grp="Date">Maximum</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, $OP
  <span class="hljs-keyword">FROM</span> Produits <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP;
</code></pre></sql-interactive>

<ul>
<li><code>GROUP_CONCAT($COL)</code> : concat√®ne les valeurs.</li>
<li><code>SUM($COL)</code>/<code>TOTAL($COL)</code> :¬†fait la somme des valeurs.</li>
<li><code>AVG($COL)</code> : fait la moyenne des valeurs.</li>
<li><code>MIN($COL)</code> : retourne la valeur minimale.</li>
<li><code>MAX($COL)</code> : retourne la valeur maximale.</li>
</ul>
<p>üí° Par d√©faut, en l&#39;absence d&#39;une fonction d&#39;agr√©gation, SQL retourne la premi√®re valeur.</p>
<p><todo>Improve example</todo></p>
<p>üí° Il est aussi possible de compter les entr√©es/valeurs de chaque lignes :</p>
<sql-interactive>
  <span slot="options" data-op='COUNT(*)' data-grp="Date">Compte le nombre d'entr√©es</span>
  <span slot="options" data-op='COUNT(Q)' data-grp="Date">Compte les valeurs non-nulles</span>
  <span slot="options" data-op='COUNT(DISTINCT Q)' data-grp="Date">Compte les valeurs distinctes</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, $OP
  <span class="hljs-keyword">FROM</span> Produits <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP;
</code></pre></sql-interactive>

<ul>
<li><code>COUNT(*)</code> : compte le nombre d&#39;entr√©es.</li>
<li><code>COUNT($COL)</code> : compte le nombre de valeurs non-nulles.</li>
<li><code>COUNT(DISTINCT $COL)</code> : permet de ne pas compter les doublons.</li>
</ul>
<h3 id="conditions-sur-les-agr√©gations">Conditions sur les agr√©gations</h3>
<p>Jusqu&#39;√† pr√©sent, nous utilisions la clause <code>WHERE</code> pour s√©lectionner les entr√©es √† r√©cup√©rer. Cependant, la clause <code>WHERE</code> filtre les entr√©es <strong>avant</strong> leur agr√©gation au sein d&#39;une m√™me ligne. Ainsi, l&#39;usage d&#39;une fonction d&#39;agr√©gation dans sa condition g√©n√©rera un message d&#39;erreur :</p>
<sql-interactive>
  <span slot="options" data-aggr=""    data-cond=">=10" data-cols="Q">Retirer des entr√©es avant agr√©gation</span>
  <span slot="options" data-aggr=""    data-cond=">=20" data-cols="Q">Retirer des entr√©es avant agr√©gation</span>
  <span slot="options" data-aggr="SUM" data-cond=">=20" data-cols="Q">Fonction d'agr√©gation g√©n√®re erreur</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">Date</span>, group_concat($COLS) <span class="hljs-keyword">FROM</span> Produits
  <span class="hljs-keyword">WHERE</span> $AGGR($COLS) $COND
  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">Date</span>;
</code></pre></sql-interactive>

<p>Pour filtrer les lignes <strong>apr√®s</strong> l&#39;agr√©gation, il convient alors d&#39;utiliser la clause <code>HAVING $COND</code> :</p>
<sql-interactive>
  <span slot="options" data-grp='Date' data-lcondp="" data-lcond="SUM(Q)" data-rcond =">= 0">Sans alias d'agr√©gat</span>
  <span slot="options" data-grp='Date' data-lcondp="SUM(Q) as" data-lcond="Total" data-rcond =">= 30">Lignes dont la somme est >= 30</span>
  <span slot="options" data-grp='Date' data-lcondp="SUM(Q) as" data-lcond="Total" data-rcond =">= 50">Lignes dont la somme est >= 50</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, $LCONDP $LCOND <span class="hljs-keyword">FROM</span> Produits
  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP <span class="hljs-keyword">HAVING</span> $LCOND $RCOND;
</code></pre></sql-interactive>


<h1 id="tables-et-contraintes">Tables et contraintes</h1>
<h2 id="sch√©mas-de-tables">Sch√©mas de tables</h2>
<p>La structure d&#39;une table, appel√©e <strong>sch√©mas</strong>, est constitu√©e du nom et du type de chaque colonne :</p>
<sql-interactive>
  <span slot="options" data-tablename="'Users'">Sch√©ma de la table Users</span>
  <span slot="options" data-tablename="'Produits'">Sch√©ma de la table Produits</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span>
pragma_table_xinfo($TABLENAME);
</code></pre></sql-interactive>

<ul>
<li><code>cid</code> est l&#39;identifiant de la colonne.</li>
<li><code>name</code> est le nom de la colonne.</li>
<li><code>type</code> est le type de donn√©es stock√©es dans la colonne.</li>
<li><code>notnull</code> indique si la colonne peut contenir des valeurs <code>NULL</code>.</li>
<li><code>dflt_value</code> est la valeur par d√©faut de la colonne (i.e. valeur ins√©r√©e si non sp√©cifi√©e lors de l&#39;insertion).</li>
<li><code>pk</code> indique si la colonne fait partie d&#39;une cl√© primaire (cf suite du cours).</li>
<li><code>hidden</code> indique si la colonne est g√©n√©r√©e (cf suite du cours)</li>
</ul>
<p>‚ö† La mani√®re d&#39;afficher le sch√©ma d&#39;une table diff√®re d&#39;un SGBD √† l&#39;autre :</p>
<table>
  <thead>
    <tr>
      <th>SGBD</th>
      <th>Commande</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SQLite</td>
      <td>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pragma_table_xinfo($TABLENAME);
</code></pre></td>
    </tr><tr>
      <td>PostgreSQL</td>
      <td>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.columns 
<span class="hljs-keyword">WHERE</span> table_name <span class="hljs-operator">=</span><span class="hljs-operator">=</span> $TABLENAME;
</code></pre></td>
    </tr><tr>
      <td>MySQL</td>
      <td>

<pre><code class="hljs language-sql"><span class="hljs-keyword">DESCRIBE</span> $TABLENAME;  
</code></pre></td>
    </tr>
  </tbody>
</table>

<h2 id="op√©rations-sur-les-tables">Op√©rations sur les tables</h2>
<p>Jusqu&#39;√† pr√©sent, nous avons √©crit des requ√™tes SQL pour r√©cup√©rer, ins√©rer, modifier, et supprimer des entr√©es d&#39;une table. De mani√®re analogue est aussi possible de cr√©er, modifier, et supprimer des tables via des commandes SQL :</p>
<ul>
<li><code>CREATE TABLE</code> : cr√©er une table ;</li>
<li><code>ALTER TABLE</code> : modifier une table ;</li>
<li><code>TRUNCATE TABLE</code> : supprimer toutes les entr√©es d&#39;une table ;</li>
<li><code>DELETE TABLE</code> : supprimer une table.</li>
</ul>
<h3 id="cr√©ation-dune-table">Cr√©ation d&#39;une table</h3>
<p>La requ√™te SQL <code>CREATE¬†TABLE</code> permet de cr√©er une nouvelle table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF¬†<span class="hljs-keyword">NOT</span>¬†<span class="hljs-keyword">EXISTS</span>]¬†$TABLENAME ($COLNAME $COLTYPE[,...]);
</code></pre><ul>
<li><code>$COLNAME</code> est le nom de la colonne ;</li>
<li><code>$COLTYPE</code> est le type des donn√©es stock√©es dans la colonne.</li>
</ul>
<p>‚ö† Si vous utilisez SQLite, il faut ajouter <code>STRICT</code> √† la fin de la requ√™te SQL afin de le forcer √† v√©rifier les types des colonnes lors des op√©rations sur la table.</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-m_cols="(Ref TEXT, Q INT)" data-m_vals="('Crayon', 4)">Cr√©ation d'une table</span>
  <span slot="options" data-m_cols="(Ref TEXT, Q INT)" data-m_vals="(4, 'Crayon')">Violation contrainte de type</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T
      $M_COLS STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> T <span class="hljs-keyword">VALUES</span>
      $M_VALS;
</code></pre></sql-interactive>

<h4 id="if-not-exists">IF¬†NOT¬†EXISTS</h4>
<p>Si la table existe d√©j√†, une erreur sera lanc√©e. Pour √©viter cela, vous pouvez ajouter la clause <code>IF¬†NOT¬†EXISTS</code> qui cr√©era la table seulement si elle n&#39;existe pas.</p>
<p>‚ö† Apr√®s un <code>IF¬†NOT¬†EXISTS</code>, la table ne sera pas n√©cessairement vide. Si vous avez besoin que la table soit vide, utilisez une requ√™te <code>TRUNCATE TABLE</code> (cf suite du cours).</p>
<p>‚ö† Si le sch√©ma de table du <code>IF¬†NOT¬†EXISTS</code> est diff√©rent de la table existante, aucune erreur ne sera lanc√©e.</p>
<sql-interactive>
  <span slot="options" data-ifexists="">Re-cr√©ation d'une table</span>
  <span slot="options" data-ifexists="IF NOT EXISTS">Avec IF NOT EXISTS</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T
      (<span class="hljs-type">Date</span> TEXT) STRICT;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> $IFEXISTS T
      (<span class="hljs-type">Date</span> <span class="hljs-type">INT</span>) STRICT;
</code></pre></sql-interactive>

<h4 id="create-table-as">CREATE¬†TABLE¬†AS</h4>
<p>üí° Vous pouvez aussi cr√©er et remplir une nouvelle table √† partir du r√©sultat d&#39;une requ√™te <code>SELECT</code>.</p>
<sql-interactive>
  <span slot="select">SELECT * FROM T;</span>
  <span slot="options" data-cols="*" data-tablename="Produits" data-cond="1==1"></span>
  <span slot="options" data-cols="Date, Q" data-tablename="Produits" data-cond="Ref == 'Gomme'"></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T <span class="hljs-keyword">AS</span>
    <span class="hljs-keyword">SELECT</span> $COLS
    <span class="hljs-keyword">FROM</span> $TABLENAME
    <span class="hljs-keyword">WHERE</span> $COND;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T;
</code></pre></sql-interactive>

<p>‚ö† Sur SQLite, les tables cr√©√©es de cette mani√®re ne sont pas <code>STRICT</code>.</p>
<h4 id="exemples-1">Exemples</h4>
<p>üí° Pour r√©f√©rences, les requ√™tes SQL utilis√©es pour cr√©er les tables des exemples peuvent √™tre visualis√©es ci-dessous :</p>
<sql-interactive>
  <span slot="options" data-tablename="'Produits'">CREATE TABLE pour Produits</span>
  <span slot="options" data-tablename="'Users'">CREATE TABLE pour Users</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">sql</span> <span class="hljs-keyword">FROM</span> sqlite_schema
<span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span><span class="hljs-operator">=</span> $TABLENAME;
</code></pre></sql-interactive>

<h3 id="suppression-dune-table">Suppression d&#39;une table</h3>
<p>Les requ√™tes SQL <code>DROP TABLE</code> et <code>TRUNCATE TABLE</code> permettent, respectivement, de supprimer et de vider une table existantes, et se pr√©sentent usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span>¬†[IF¬†<span class="hljs-keyword">EXISTS</span>] $TABLENAME;
<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span>¬†$TABLENAME;
</code></pre><sql-interactive>
  <span slot="select">SELECT name, type, "notnull", dflt_value, pk, hidden
        FROM pragma_table_xinfo('Produits');
SELECT COUNT(*) as "NB ENTRIES" FROM Produits;</span>
  <span slot="options" data-command="DROP TABLE">Suppression de la table</span>
  <span slot="options" data-command="DELETE FROM">Suppression des entr√©es</span>

<pre><code class="hljs language-sql">$COMMAND Produits;
</code></pre></sql-interactive>

<p>üí° Dans certains SGBD, <code>DROP¬†TABLE</code> supporte une clause <code>IF¬†EXISTS</code>. Ainsi, si vous souhaitez cr√©er une table vide, vous pouvez la <code>DROP¬†TABLE¬†IF¬†EXISTS</code> avant sa cr√©ation pour vous assurer de la construire correctement.</p>
<p>‚ö† <code>TRUNCATE TABLE</code> n&#39;existe pas sur SQLite. Il vous faut alors utiliser <code>DELETE¬†FROM $TABLENAME;</code> √† la place.</p>
<h3 id="modification-dune-table">Modification d&#39;une table</h3>
<p>La requ√™te SQL <code>ALTER TABLE</code> permet de modifier une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span>¬†<span class="hljs-keyword">TABLE</span>¬†$TABLENAME (RENAME<span class="hljs-operator">|</span><span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span>) <span class="hljs-keyword">COLUMN</span> $OPT;
</code></pre><ul>
<li><code>RENAME</code> renomme une colonne (<code>$OPT</code> = <code>$OLD_COLNAME TO $NEW_COLNAME</code>).</li>
<li><code>ADD</code> ajoute une colonne (<code>$OPT</code> = <code>$COLNAME¬†$COLTYPE</code>).</li>
<li><code>DROP</code> supprime une colonne (<code>$OPT</code> = <code>$COLNAME</code>).</li>
</ul>
<sql-interactive>
  <span slot="select">SELECT name, type, "notnull", dflt_value, pk, hidden
        FROM pragma_table_xinfo('Produits');</span>
  <span slot="options" data-command="RENAME" data-opts="Ref TO Prod">Renommer une colonne</span>
  <span slot="options" data-command="ADD" data-opts="Sum INT">Ajouter une colonne</span>
  <span slot="options" data-command="DROP" data-opts="Date">Supprimer une colonne</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Produits
  $COMMAND <span class="hljs-keyword">COLUMN</span> $OPTS;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Produits;
</code></pre></sql-interactive>

<p>‚ö† Renommer ou supprimer la colonne d&#39;une table n&#39;est pas anodin. En effet, si ces colonnes sont utilis√©es ailleurs, e.g. dans des requ√™tes SQL, ces derni√®res ne fonctionneront plus correctement.</p>
<p>üí° Certains SGBD supportent des clauses <code>IF¬†EXISTS</code> et <code>IF¬†NOT¬†EXISTS</code> sur les colonnes.</p>
<p>üí° Vous pouvez aussi renommer une table avec la commande SQL suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>¬†$OLD_TABLENAME RENAME¬†<span class="hljs-keyword">TO</span>¬†$NEW_TABLENAME;
</code></pre><h2 id="les-contraintes">Les contraintes</h2>
<p>Il est possible de d√©finir des contraintes sur les colonnes et sur la table afin de garantir sa coh√©rence et consistence.</p>
<p><todo>Exemple parlant?</todo></p>
<h3 id="contraintes-sur-les-colonnes">Contraintes sur les colonnes</h3>
<p>Lors de la cr√©ation de la table, il est possible de sp√©cifier des contraintes sur des colonnes. Pour ce faire, on ajoute le(s) contrainte(s) apr√®s le type de la colonne :</p>
<sql-interactive>
  <span slot="select">SELECT * FROM T;</span>
  <span slot="options" data-cstrnt="DEFAULT 'D'" data-vals="(1)" data-cols='(A)' >Valeur par d√©faut</span>
  <span slot="options" data-cstrnt="NOT NULL" data-vals="(1, NULL)">Valeur non-nulle</span>
  <span slot="options" data-cstrnt="UNIQUE" data-vals="(1, 2), (1, 2)">Valeur unique</span>
  <span slot="options" data-cstrnt="CHECK(B != 'NA')" data-vals="(1, 'NA')" >Condition sur la valeur</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T ( A TEXT,
    B TEXT $CSTRNT
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T $COLS <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<ul>
<li><code>DEFAULT $VAL</code> : valeur par d√©faut si non renseign√©e lors d&#39;un <code>INSERT</code>.</li>
<li><code>NOT NULL</code> : la valeur ne peut pas √™tre <code>NULL</code>.</li>
<li><code>UNIQUE</code> : il ne peut pas y avoir deux valeurs identiques dans la colonne.<br/>
‚ö† La colonne peut contenir plusieurs valeurs <code>NULL</code>.</li>
<li><code>CHECK($COND)</code> : la valeur de la colonne doit respecter la condition <code>$COND</code>.</li>
</ul>
<h3 id="contraintes-sur-la-table">Contraintes sur la table</h3>
<p>Les contraintes <code>UNIQUE</code> et <code>CHECK</code> peuvent d√©pendre de plusieurs colonnes. Dans ce cas, la contrainte est ajout√©e apr√®s la liste des colonnes :</p>
<sql-interactive>
  <span slot="options" data-cstrnt="UNIQUE(A,B)" data-vals="(1, 2), (1, 2)">Colonnes uniques</span>
  <span slot="options" data-cstrnt="CHECK(B != A)" data-vals="(1, 1)" >Condition</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    A TEXT, B TEXT,
    $CSTRNT
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<h3 id="colonnes-g√©n√©r√©es">Colonnes g√©n√©r√©es</h3>
<p>Il est possible de g√©n√©rer la valeur d&#39;une colonne √† partir des valeurs d&#39;autres colonnes gr√¢ce √† la contrainte <code>AS</code> :</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-cstrnt="(PU*Q )" data-vals="(1,2), (3,4)">Colonne g√©n√©r√©e virtuelle</span>
  <span slot="options" data-cstrnt="(PU*Q) STORED" data-vals="(1,2), (3,4)">Colonne g√©n√©r√©e stock√©e</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    PU <span class="hljs-type">INT</span>, Q <span class="hljs-type">INTEGER</span>,
    T <span class="hljs-type">INT</span> <span class="hljs-keyword">AS</span> $CSTRNT
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° <code>STORED</code> signifie que la valeur sera calcul√©e lors des insertions/modifications puis stock√©es. Si absent, la valeur sera recalcul√©e √† chaque acc√®s.</p>
<h2 id="les-index">Les index</h2>
<p>Il est fr√©quent de vouloir r√©cup√©rer une entr√©e √† partir d&#39;un identifiant donn√©. Cependant, s&#39;il faut √† chaque fois parcourir toutes les entr√©es de la table unes √† unes, cela peut s&#39;av√©rer relativement lent sur de grandes tables.</p>
<p>Un <strong>index</strong> est une structure permettant de trouver tr√®s rapidement la/les entr√©e(s) associ√©e(s) √† un tel identifiant.</p>
<p>üí° Lorsqu&#39;une colonne a la contrainte <code>UNIQUE</code>, il est fr√©quent que le SGBD cr√©√© automatiquement un index.</p>
<h3 id="les-clefs-primaires-pk">Les clefs primaires (PK)</h3>
<p>Une clef primaire est un index un peu sp√©cial acc√©l√©rant encore plus les recherches d&#39;entr√©es √† partir d&#39;un identifiant.</p>
<p>Elle est cr√©√©e via une contrainte <code>PRIMARY KEY</code> et implique les contraintes <code>UNIQUE¬†NOT¬†NULL</code>. Il ne peut y avoir qu&#39;une clef primaire par table.</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-pk="TEXT PRIMARY KEY" data-vals="('1'), ('2')">Cl√© primaire (texte)</span>
  <span slot="options" data-pk="INTEGER
      PRIMARY KEY AUTOINCREMENT" data-vals="(NULL), (NULL)">Cl√© primaire (auto-incr√©ment)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    K $PK
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° La contrainte <code>AUTOINCREMENT</code> permet d&#39;automatiquement incr√©menter la clef primaire des entr√©es ins√©r√©es. Elle ne peut √™tre utilis√©e que sur une colonne <code>INTEGER¬†PRIMARY¬†KEY</code>.</p>
<p>üí° Comme avec la contrainte <code>UNIQUE</code>, il est aussi possible de cr√©er une clef primaire sur plusieurs colonnes via contrainte de table :</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-pk="PRIMARY KEY(ID, CODE)" data-vals="(1, 'E')">Cl√© primaire (multi-cols)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    ID <span class="hljs-type">INT</span>, CODE TEXT,
    $PK
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° Certains SGBD cr√©√©ent automatiquement, pour chaque table, une clef primaire cach√©e nomm√©e <code>ROWID</code>.</p>
<h3 id="les-clefs-√©trang√®res-fk">Les clefs √©trang√®res (FK)</h3>
<p><todo>Motivation</todo></p>
<p>Une cl√© √©trang√®re est compos√©e d&#39;une ou plusieurs colonnes r√©f√©ren√ßant une ou plusieurs colonnes de contraine <code>UNIQUE</code> ou <code>PRIMARY¬†KEY</code>. On l&#39;indique via une contrainte de table sous la forme :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">FOREIGN</span> KEY($COLS_FK[,...]) <span class="hljs-keyword">REFERENCES</span> $T
<span class="hljs-keyword">FOREIGN</span> KEY($COLS_FK[,...]) <span class="hljs-keyword">REFERENCES</span> $T($COLS_PK[,...])
</code></pre><ul>
<li><code>$COL_FK</code> sont les colonnes constituant la cl√© √©trang√®re.</li>
<li><code>$COL_PK</code> sont les colonnes r√©f√©renc√©es.</li>
</ul>
<p>üí° Si la/les colonne(s) de la table r√©f√©renc√©e ne sont pas sp√©cifi√©es, la/les colonne(s) de la clef primaire sont utilis√©e(s).</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;
SELECT * FROM Users;</span>
  <span slot="options" data-fk="FOREIGN KEY(ID)
    REFERENCES Users" data-vals="(1, 'E')">Clef √©trang√®re existante</span>
  <span slot="options" data-fk="FOREIGN KEY(ID)
    REFERENCES Users" data-vals="(4, 'E')">Clef √©trang√®re non-existante</span>
  <span slot="options" data-fk="FOREIGN KEY(ID)
    REFERENCES Users" data-vals="(NULL, 'E')">Clef √©trang√®re nulle</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (ID <span class="hljs-type">INT</span>, C TEXT,
    $FK
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° La cl√© √©trang√®re peut √™tre nulle (sauf si contrainte <code>NOT¬†NULL</code>).</p>
<p>üí° On pr√©f√®re souvent nommer la/les colonne(s) de la clef √©trang√®res avec les noms de la/les colonne(s) r√©f√©renc√©e(s).</p>
<p>‚ö† La v√©rification des clefs √©trang√®res n&#39;est pas activ√© par d√©faut sur SQLite. La commande <code>PRAGMA foreign_keys = ON</code> permet de l&#39;activer.</p>
<h3 id="uml">UML</h3>
<sql-interactive id="uml-sql">
  <span slot="options" data-pk="ID" data-fk="ID" data-cols_a="ID INT, CODE TEXT" data-cols_b="ID INT, CODE TEXT">Clef primaire (uni-col)</span>
  <span slot="options" data-pk="ID, CODE" data-fk="ID, CODE" data-cols_a="CODE TEXT, X INT, ID INT" data-cols_b="ID INT, CODE TEXT">Clef primaire (multi-cols)</span>
  <!-- TODO: LISS -->
  <pre id="uml" slot="post" class="hljs">
    <code>
      <div class="output"></div>
    </code>
  </pre>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> A (
    $COLS_A,
    <span class="hljs-keyword">PRIMARY</span> KEY($PK)
  ) STRICT;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> B (
    $COLS_B,
    <span class="hljs-keyword">FOREIGN</span> KEY($FK)
    <span class="hljs-keyword">REFERENCES</span> B
  ) STRICT;
</code></pre></sql-interactive>

<!-- test -->

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const uml_output = document.querySelector("#uml .output");
  //await LISS.qs("#col-table");
  const umlsql   = await LISS.qs("#uml-sql");

  umlsql.host.addEventListener("change", (ev) => {
    console.warn( umlsql.lastVars );
    update( umlsql.lastVars );
  });
  update( umlsql.lastVars );

  function update({cols_a, cols_b, fk, pk}) {

    fk = fk.split(',').map( k => k.trim() );
    pk = pk.split(',').map( k => k.trim() );

    function buildTable(cols, hcols, isPK) {
      let content = [];

      const hmethod = isPK ? "strong" : "em";

      let max_w  = 0;
      let max_nw = 0;
      let max_cw = 0;

      const cnstr = `${isPK ? "PK" : "FK"}(${(isPK ? pk : fk).join(', ')})`;
      max_w = cnstr.length;

      cols = cols.split(',').map( l => {
          l = l.trim();
          const pos = l.indexOf(' ');
          const colname = l.slice(0, pos);
          const constrainst = l.slice(pos+1);

          const nw = colname.length;
          const cw = constrainst.length;
          if( nw > max_nw)
            max_nw = nw;
          if( cw > max_cw)
            max_cw = cw;

          return [colname, constrainst];
      });

      if( max_w > max_nw + max_cw)
        max_cw = max_w - max_nw;
      if( max_w < max_nw + max_cw )
        max_w = max_nw + max_cw;


      let prefix = "";
      let suffix = "";

      if( isPK )
        suffix = "   ";
      else
        prefix = "   ";


      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);
      const lpad_len = Math.floor( (max_w+2-1)/2);
      let lpad = "".padEnd(lpad_len);
      let rpad = "".padEnd(max_w+2-1 - lpad_len);
      content.push(`${prefix}| ${lpad}<strong>${(isPK ? "A" : "B")}</strong>${rpad} |${suffix}`);
      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);

      for(let col of cols) {

        let w = max_w;

        let lsuffix = suffix;
        let lprefix = prefix

        let colname = col[0].padEnd(max_nw);

        if( hcols.includes(col[0]) ) {
          colname = `<${hmethod}>${colname}</${hmethod}>`;

          if( isPK )
            lsuffix = "---";
          else
            lprefix = "-->";
        }
        
        const line = `${colname}: ${col[1].padEnd(max_cw)}`;
        content.push(`${lprefix}| ${line} |${lsuffix}`);
      }

      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);
      content.push(`${prefix}| ${cnstr.padEnd(max_w+2)} |${suffix}`);
      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);

      return content;
    }

    let tA = buildTable(cols_a, pk, true);
    let tB = buildTable(cols_b, fk, false);

    if( tB.length > tA.length) {
      tA.push(... new Array(tB.length - tA.length).fill("".padEnd(tA[0].length)) );
    }
    if( tA.length > tB.length) { // just to simplify code.
      tB.push(... new Array(tA.length - tB.length).fill("".padEnd(tB[0].length)) );
    }

    let start_idx, end_idx;
    for(let i = 0; i < tA.length; ++i) {
      const idx = tA[i].length-1;
      if(tA[i][idx] === "-" || tB[i][0] === "-") {
        start_idx = i;
        break;
      }
    }
    for(let i = tA.length - 1; i >= 0 ; --i) {
      const idx = tA[i].length-1;
      if(tA[i][idx] === "-" || tB[i][0] === "-") {
        end_idx = i;
        break;
      }
    }

    let content = "";
    for(let i = 0; i < tA.length; ++i) {

      let sep = "   ";

      if( pk.length === 1 && fk.length === 1) { // unique.
        if(start_idx === end_idx) {
          if(i === start_idx)
            sep = "---";
        } else {
          if(i === start_idx || i === end_idx) {
            if(tA[i][ tA[i].length - 1 ] !== " ")
              sep = "-+ ";
            else
              sep = " +-";
          }
          if( i > start_idx && i < end_idx)
            sep = " | ";
        }
      }

      if( pk.length > 1 || fk.length > 1) { // 1 vs N and N vs 1 shouldn't occur ?
        if( i >= start_idx && i <= end_idx) {

          sep = [" ", "|", "¬†"];

          if(tA[i][ tA[i].length - 1 ] !== " ") {
            sep[0] = "-";
            sep[1] = "+";
          }
          if(tB[i][0] !== " ") {
            sep[1] = "+";
            sep[2] = "-";
          }

          sep = sep.join("");
        }
      } 

      content += `${tA[i]}${sep}${i < tB.length ? tB[i] : ""}\n`;
    }

    uml_output.innerHTML = content;
  }

</script>

<h2 id="op√©rations-sur-table-avec-contraintes">Op√©rations sur table avec contraintes</h2>
<h3 id="modificationsuppression-sur-des-colonnes-r√©f√©renc√©es">Modification/Suppression sur des colonnes r√©f√©renc√©es</h3>
<p>Comme nous l&#39;avons vu √† la section pr√©c√©dente, une clef √©trang√®re r√©f√©rence des colonnes d&#39;une autre table. Mais que se passe-t-il lorsqu&#39;on modifie ou supprime des entr√©es dans les colonnes r√©f√©renc√©es ?</p>
<p>C&#39;est √† vous de le d√©finir via les clauses <code>ON DELETE $POLICY</code> et <code>ON UPDATE $POLICY</code> sur la clef primaire :</p>
<p><todo> Exemple </todo></p>
<sql-interactive full-reset="true">
  <span slot='select'>SELECT * FROM T3;</span>
  <span slot="options" data-pol="RESTRICT">Emp√™cher la suppression</span>
  <span slot="options" data-pol="CASCADE">Supprimer l'entr√©e</span>
  <span slot="options" data-pol="SET NULL">Mettre la colonne √† NULL</span>


<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T3 (
    ID <span class="hljs-type">INT</span>, A TEXT,
    <span class="hljs-keyword">FOREIGN</span> KEY(ID) <span class="hljs-keyword">REFERENCES</span> T1
    <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> $POL
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> T3 <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;A&#x27;</span>);
<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">WHERE</span> ID <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
</code></pre></sql-interactive>

<ul>
<li><code>RESTRICT</code>: emp√™che la modification/suppression si les valeurs sont r√©f√©renc√©es par une clef √©trang√®re.</li>
<li><code>CASCADE</code> : modifie/supprime la clef √©trang√®re lorsque des valeurs des colonnes r√©f√©renc√©es sont modifi√©es.</li>
<li><code>SET NULL|DEFAULT</code> : modifie la clef √©trang√®re lorsque des valeurs des colonnes r√©f√©renc√©es sont modifi√©es.</li>
</ul>
<h3 id="merge-mettre-√†-jour-si-existe-sinon-ins√©rer">Merge: mettre √† jour si existe, sinon ins√©rer.</h3>
<p><todo>Pour MERGE dont on avait dit qu&#39;on ne verrais pas au CM2, mais au TP2, finalement, je pense qu&#39;il vaut mieux l&#39;√©voquer au CM3 juste apr√®s les clefs √©trang√®res.</p>
<p>En gros la probl√©matique est d&#39;ajouter si inexistant, et de modifier si existant.</p>
<p>On peut faire un select, puis refaire une requ√™te pour update ou insert, mais c&#39;est pas pratique de faire plusieurs requ√™tes.</p>
<p>On a des choses comme REPLACE (MySQL) supprime l&#39;entr√©e si elle existe, puis ajoute la nouvelle. Sauf que s&#39;il y a des clefs primaires r√©f√©renc√©es par des clefs √©trang√®res √ßa casse tout.</p>
<p>Il faut ainsi faire cela en une seule op√©ration.
Pour cela on a UPSERT et INSERT ON DUPLICATE KEYS UPDATE (d√©pend du SGBD) qui s&#39;utilise comme INSERT et qui sont plut√¥t simples (v√©rifient si la clef primaire existe).</p>
<p>Et pour d&#39;autres, MERGE (SQL2003), qui est plus puissant (on peut personnaliser la condition), et l&#39;utiliser pour d&#39;autres usages (on peut aussi supprimer).</todo></p>
<ul>
<li>√©voquer <a href="https://sql.sh/cours/merge">https://sql.sh/cours/merge</a> (√† la fin d&#39;un TP ?)</li>
</ul>
<p>=&gt; ajouter (ou modifier si existe) =&gt; besoin notion de clef primaire.</p>
<ul>
<li><p>UPSERT.</p>
</li>
<li><p>ajouter ou modifier si existe (seulement mysql)
<a href="https://dev.mysql.com/doc/refman/8.4/en/insert-on-duplicate.html">https://dev.mysql.com/doc/refman/8.4/en/insert-on-duplicate.html</a>
<a href="https://dev.mysql.com/doc/refman/9.0/en/replace.html">https://dev.mysql.com/doc/refman/9.0/en/replace.html</a></p>
</li>
</ul>
<p>Replace √† √©viter ( <a href="https://stackoverflow.com/questions/9168928/what-are-practical-differences-between-replace-and-insert-on-duplicate-key">https://stackoverflow.com/questions/9168928/what-are-practical-differences-between-replace-and-insert-on-duplicate-key</a> ).</p>
<h3 id="modifier-les-contraintes">Modifier les contraintes</h3>
<p>Pour information, certains SGBD (pas sur SQLite) permettent de modifier les contraintes de colonnes et de tables :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span>¬†<span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ALTER</span><span class="hljs-operator">|</span>MODIFY <span class="hljs-keyword">COLUMN</span> $NAME $<span class="hljs-keyword">DESC</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CHECK</span> $<span class="hljs-keyword">DESC</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY ($COL);
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> CONSTRAINST PK_$T <span class="hljs-keyword">PRIMARY</span> KEY ($COL[,...]);
</code></pre><p>‚ö† Modifier le sch√©ma et les contraintes d&#39;une table existante/non-vide n&#39;est pas anodin.</p>
<h1 id="fusions-et-jointures">Fusions et jointures</h1>
<h2 id="op√©rations-densembles">Op√©rations d&#39;ensembles</h2>
<p>Il est possible d&#39;op√©rer des op√©rations d&#39;ensembles sur les <strong>lignes</strong> retourn√©es par deux requ√™te <code>SELECT</code>, √† conditions qu&#39;elles aient le m√™me nombre de colonnes :</p>
<ul>
<li><code>UNION</code>     :¬†concat√©ner les lignes.</li>
<li><code>INTERSECT</code> : les lignes communes aux deux requ√™tes.</li>
<li><code>EXCEPT</code>    : les lignes de la premi√®re requ√™te absentes de la seconde.</li>
</ul>
<p>Ces op√©rations s&#39;utilisent sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $QUERY_1
<span class="hljs-keyword">UNION</span><span class="hljs-operator">|</span><span class="hljs-keyword">INTERSECT</span><span class="hljs-operator">|</span><span class="hljs-keyword">EXCEPT</span> [<span class="hljs-keyword">ALL</span>]
<span class="hljs-keyword">SELECT</span> $QUERY_2
</code></pre><sql-interactive>
  <span slot="options" data-op='UNION'></span>
  <span slot="options" data-op='UNION ALL'></span>
  <span slot="options" data-op='INTERSECT'></span>
  <span slot="options" data-op='EXCEPT'></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Produits
$OP
<span class="hljs-keyword">SELECT</span> Nom, Prenom, Age <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<p><todo>Better example</todo></p>
<p>üí° Par d√©faut, les lignes en doublons sont supprim√©es. L&#39;option <code>ALL</code> permet de conserver l&#39;ensemble des lignes.</p>
<h2 id="sous-requ√™tes">Sous requ√™tes</h2>
<p>Vous pouvez utiliser le r√©sultat d&#39;une requ√™te <code>SELECT</code> (alors appel√©e &quot;sous-requ√™te&quot;) comme valeur dans une autre requ√™te. Par exemple, pour utiliser une sous-requ√™te dans une condition <code>WHERE</code>, il suffit de l&#39;ajouter entre parenth√®ses :</p>
<sql-interactive>
  <span slot="options" data-cond='=' data-subquery='SELECT MAX(Y) FROM T2'></span>
  <span slot="options" data-cond='IN' data-subquery='SELECT Y FROM T2'></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">WHERE</span> X $COND ( $SUBQUERY )
</code></pre></sql-interactive>

<p>‚ö† La sous-requ√™te doit retourner une valeur unique (une seule ligne et colonne) ou, pour <code>IN</code>, une liste (une seule colonne).</p>
<h3 id="sous-requ√™te-corr√©l√©e">Sous-requ√™te corr√©l√©e</h3>
<p>Lorsque la sous-requ√™te d√©pend d&#39;une colonne de la requ√™te principale, elle est dite &quot;corr√©l√©e&quot;, et sera r√©ex√©cut√©e √† chaque ligne de la requ√™te principale.</p>
<p>D√®s lors, pour des raisons de performances on utilisera les op√©rateurs :</p>
<ul>
<li><code>EXISTS</code> √† la place de <code>IN</code>.</li>
<li><code>ANY</code>/<code>SOME</code> ou <code>ALL</code> au lieu d&#39;utiliser certaines fonctions d&#39;agr√©gations.</li>
</ul>
<sql-interactive>
  <span slot="options" data-cond='EXISTS'></span>
  <span slot="options" data-cond='X > ANY'></span>
  <span slot="options" data-cond='X > ALL'></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">WHERE</span> $COND (
  <span class="hljs-keyword">SELECT</span> Y <span class="hljs-keyword">FROM</span> T2 <span class="hljs-keyword">WHERE</span> T2.X <span class="hljs-operator">=</span> T1.X
)
</code></pre></sql-interactive>

<p>En effet, une sous-requ√™te non-corr√©l√©e, n&#39;est ex√©cut√©e qu&#39;une seule fois. Ainsi il est int√©ressant de r√©cup√©rer toutes les lignes (pour <code>IN</code>) ou de calculer des agr√©gats qui seront r√©utilis√©s pour √©valuer la clause <code>WHERE</code> √† chaque entr√©e de la requ√™te principale.</p>
<p>Cependant, quand une sous-requ√™te est corr√©l√©e, il n&#39;est pas utile de calculer l&#39;ensemble des lignes de la sous-requ√™te, car on peut s&#39;arr√™ter √† :</p>
<ul>
<li>la premi√®re ligne existante pour <code>EXISTS</code>.</li>
<li>la premi√®re ligne satisfaisant la condition pour <code>ALL</code>.</li>
<li>la premi√®re ligne ne satisfaisant pas la condition pour <code>ALL</code>.</li>
</ul>
<p>‚ö† Il va de soit qu&#39;il faut √©viter les sous-requ√™tes corr√©l√©es autant que possible...</p>
<h2 id="jointures">Jointures</h2>
<p>[+] rappel clefs √©trang√®res.
[+] motivation pour jointures.</p>
<h3 id="le-produit-cart√©sien">Le produit cart√©sien</h3>
<p>Une m√©thode na√Øve (<strong>et √† ne jamais utiliser</strong>) d&#39;effectuer une jointure est d&#39;utiliser un produit cart√©sien :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> $T1, $T2 <span class="hljs-keyword">WHERE</span> $T1.$KEY <span class="hljs-operator">=</span><span class="hljs-operator">=</span> $T2.$KEY;
</code></pre><p>Pour ex√©cuter cette requ√™te, le SGDB va construire une table interm√©diaire constitu√©e de toutes les combinaisons de lignes possibles entre <code>$T1</code> et <code>$T2</code>, qu&#39;elle va ensuite parcourir pour filtrer les lignes via la clause <code>WHERE</code>.</p>
<style>
  .color1 {
    background-color: red;
  }
  .color2 {
    background-color: blue;
  }
  .color3 {
    background-color: green;
  }
  .color4 {
    background-color: orange;
  }

  .table_flex {
    display: flex;
    align-items: center;
    gap: 10px;
  }
</style>

<div class='table_flex'>

<table>
  <caption>T1</caption>
  <thead>
    <tr>
      <th>ID</th>
      <th>...</th>
    </tr>
  </thead>
  <tbody>
    <tr class='color1'>
      <td>1</td><td>...</td>
    </tr>
    <tr class='color2'>
      <td>2</td><td>...</td>
    </tr>
    <tr class='color3'>
      <td>3</td><td>...</td>
    </tr>
  </tbody>
</table>

<p>x</p>
<table>
  <caption>T2</caption>
  <thead>
    <tr>
      <th>ID</th>
      <th>...</th>
    </tr>
  </thead>
  <tbody>
    <tr class='color1'>
      <td>1</td><td>...</td>
    </tr>
    <tr class='color3'>
      <td>3</td><td>...</td>
    </tr>
    <tr class='color3'>
      <td>3</td><td>...</td>
    </tr>
  </tbody>
</table>

<p>=</p>
<table>
  <caption>T1xT2</caption>
  <thead>
    <tr>
      <th>T1.ID</th>
      <th>...</th>
      <th>T2.ID</th>
      <th>...</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class='color1'>1</td><td class='color1'>...</td>
      <td class='color1'>1</td><td class='color1'>...</td>
    </tr>
    <tr>
      <td class='color1'>1</td><td class='color1'>...</td>
      <td class='color3'>1</td><td class='color3'>...</td>
    </tr>
    <tr>
      <td class='color1'>1</td><td class='color1'>...</td>
      <td class='color3'>1</td><td class='color3'>...</td>
    </tr>
    <tr><td></td><td></td><td></td><td></td></tr>
    <tr>
      <td class='color2'>2</td><td class='color2'>...</td>
      <td class='color1'>1</td><td class='color1'>...</td>
    </tr>
    <tr>
      <td class='color2'>2</td><td class='color2'>...</td>
      <td class='color3'>1</td><td class='color3'>...</td>
    </tr>
    <tr>
      <td class='color2'>2</td><td class='color2'>...</td>
      <td class='color3'>1</td><td class='color3'>...</td>
    </tr>
    <tr><td></td><td></td><td></td><td></td></tr>
    <tr>
      <td class='color3'>2</td><td class='color3'>...</td>
      <td class='color1'>1</td><td class='color1'>...</td>
    </tr>
    <tr>
      <td class='color3'>2</td><td class='color3'>...</td>
      <td class='color3'>1</td><td class='color3'>...</td>
    </tr>
    <tr>
      <td class='color3'>2</td><td class='color3'>...</td>
      <td class='color3'>1</td><td class='color3'>...</td>
    </tr>
  </tbody>
</table>

<p>WHERE -&gt;</p>
<table>
  <caption>T1xT2 + WHERE</caption>
  <thead>
    <tr>
      <th>T1.ID</th>
      <th>...</th>
      <th>T2.ID</th>
      <th>...</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class='color1'>1</td><td class='color1'>...</td>
      <td class='color1'>1</td><td class='color1'>...</td>
    </tr>
    <tr><td></td><td></td><td></td><td></td></tr>
    <tr><td></td><td></td><td></td><td></td></tr>
    <tr>
      <td class='color3'>3</td><td class='color3'>...</td>
      <td class='color3'>3</td><td class='color3'>...</td>
    </tr>
    <tr>
      <td class='color3'>3</td><td class='color3'>...</td>
      <td class='color3'>3</td><td class='color3'>...</td>
    </tr>
  </tbody>
</table>

</div>

<p><todo>construire auto + animation</todo></p>
<p>Ainsi, le produit cart√©sien de deux tables de 3 entr√©es produira une table interm√©diaire de 9 lignes, dont la majorit√© des lignes seront ensuite rejett√©es par la clause <code>WHERE</code>.</p>
<p>M√™me sur de petites tables, la construction de la table interm√©diaire explose tr√®s vite les capacit√©s du SGDB :</p>
<style>
  .danger {
    background-color: red;
  }
</style>

<table>
  <thead>
    <tr>
      <th># Entr√©es</th>
      <th># Tables</th>
      <th># Table interm√©diaire</th>
      <th># R√©sultats</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>E</td>
      <td>T</td>
      <td>E^T</td>
      <td>E</td>
    </tr>
    <tr>
    <tr>
      <td>1 000</td>
      <td>2</td>
      <td>1 000 000</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>1 000</td>
      <td>3</td>
      <td class='danger'>1 000 000 000</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>32 000</td>
      <td>2</td>
      <td class='danger'>1 024 000 000</td>
      <td>32 000</td>
    </tr>
    <tr>
      <td>1 000</td>
      <td>6</td>
      <td class='danger'>10^18</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>1 000 000</td>
      <td>3</td>
      <td class='danger'>10^18</td>
      <td>1 000 000</td>
    </tr>
    <tr>
      <td><input class='join_nbEntries' 
      value='2'
      type=number></input></td>
      <td><input class='join_nbTables' value='2' type=number min='2'></input></td>
      <td class='join_cartesien'></td>
      <td class='join_best'></td>
    </tr>
  </tbody>
</table>

<script>
  const nb_tables_input = document.querySelector('.join_nbTables');
  const nb_entries_input = document.querySelector('.join_nbEntries');

  const result_cartesien = document.querySelector('.join_cartesien');
  const result_mieux = document.querySelector('.join_best');

  function update() {
    const nb_table   = +nb_tables_input.value;
    const nb_entries = +nb_entries_input.value;

    result_cartesien.textContent = Math.pow(nb_entries, nb_table).toLocaleString();

    result_mieux.textContent = nb_entries.toLocaleString();
  }

  nb_tables_input.addEventListener('input', update);
  nb_entries_input.addEventListener('input', update);

  update();
</script>

<span class='complexite_cartesien'>

<p>Pour rappel, 1 milliard de lignes correspondent √† plusieurs Go en m√©moire, et 10^18 √† plusieurs Po !!!</p>
<p>‚ö† Pour cette raison, on n&#39;utilise <strong>JAMAIS</strong> les produits cart√©sien en SQL ! <strong>JA-MAIS !</strong></p>
<h3 id="le-principe-des-jointures">Le principe des jointures</h3>
<p>La bonne mani√®re de proc√©der est d&#39;utiliser la clause <code>JOIN</code> qui s&#39;utilise usuellement de la sorte :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> $T1 <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> $T2;
</code></pre><p>Pour chaque entr√©e de <code>$T1</code>, le SGBD va rechercher les entr√©es de <code>$T2</code> dont les valeurs des colonnes communes sont identiques √† 
celles de l&#39;entr√©e de <code>$T1</code>. Ainsi, contrairement au produit cart√©sien, le SGBD n&#39;a pas besoin de construire une table interm√©diaire colossale, r√©duisant tr√®s fortement la consommation de m√©moire vive.</p>
<p><todo>animation : construction</todo></p>
<p>üí° Si les colonnes en communs constituent un index, la recherche des entr√©es de <code>$T2</code> est plus rapide, encore plus si elles constituent une cl√© primaire/√©trang√®re. Il est ainsi <strong>plus que fortement recommand√©</strong> d&#39;effectuer des jointures sur des cl√©s primaires/√©trang√®res.</p>
<p>üí° Vous pouvez ajouter une clause <code>WHERE</code> √† v√¥tre requ√™te SQL. En th√©orie la clause <code>WHERE</code> est appliqu√©e aux entr√©es <strong>apr√®s</strong> jointures. Cependant, les SGBD sont capables d&#39;optimiser la requ√™te en pr√©filtrant, lorsque possible, les tables avant jointures.</p>
<h3 id="les-types-de-jointures">Les types de jointures</h3>
<p>En r√©alit√©, il existe 3 types de jointures fr√©quemment utilis√©es :</p>
<ul>
<li><code>INNER</code> : par d√©faut.</li>
<li><code>LEFT</code>  : comme <code>INNER</code>, mais ajoute au r√©sultat les entr√©es de <code>$T1</code> dont aucune entr√©e de <code>$T2</code> ne correspond.</li>
<li><code>FULL</code> (plus rare) : comme <code>LEFT</code>, mais ajoute au r√©sultat les entr√©es de <code>$T2</code> dont aucune entr√©e de <code>$T1</code> ne correspond.<br/>
üí° Il est √©quivalant √† l&#39;union de <code>$T1 LEFT JOIN $T2</code> et <code>$T2 LEFT JOIN $T1</code>.</li>
</ul>
<style>
.join_table :is(td,th):last-child {
  border :none;
}
</style>

<div class='table_flex'>

<table>
  <caption>T1</caption>
  <thead>
    <tr>
      <th>ID</th>
      <th>...</th>
    </tr>
  </thead>
  <tbody>
    <tr class='color1'>
      <td>1</td><td>...</td>
    </tr>
    <tr class='color2'>
      <td>2</td><td>...</td>
    </tr>
    <tr class='color3'>
      <td>3</td><td>...</td>
    </tr>
  </tbody>
</table>

<p>JOIN</p>
<table>
  <caption>T2</caption>
  <thead>
    <tr>
      <th>ID</th>
      <th>...</th>
    </tr>
  </thead>
  <tbody>
    <tr class='color1'>
      <td>1</td><td>...</td>
    </tr>
    <tr class='color3'>
      <td>3</td><td>...</td>
    </tr>
    <tr class='color3'>
      <td>3</td><td>...</td>
    </tr>
    <tr class='color4'>
      <td>N/A</td><td>...</td>
    </tr>
  </tbody>
</table>

<p>=</p>
<table class='join_table'>
  <caption>T1 JOIN T2</caption>
  <thead>
    <tr>
      <th>T1.ID</th>
      <th>...</th>
      <th>T2.ID</th>
      <th>...</th>
      <th></th>
    </tr>
  </thead>  <tbody>
    <tr>
      <td class='color1'>1</td><td class='color1'>...</td>
      <td class='color1'>1</td><td class='color1'>...</td><td></td><td></td>
    </tr>
    <tr><td></td><td></td><td></td><td></td><td></td></tr>
    <tr>
      <td class='color2'>2</td><td class='color2'>...</td>
      <td>N/A</td><td>N/A</td><td>Si LEFT ou FULL</td>
    </tr>
    <tr><td></td><td></td><td></td><td></td><td></td></tr>
    <tr>
      <td class='color3'>3</td><td class='color3'>...</td>
      <td class='color3'>3</td><td class='color3'>...</td><td></td>
    </tr>
    <tr>
      <td class='color3'>3</td><td class='color3'>...</td>
      <td class='color3'>3</td><td class='color3'>...</td><td></td>
    </tr>
    <tr><td></td><td></td><td></td><td></td><td></td></tr>
    <tr>
      <td>N/A</td><td>N/A</td>
      <td class='color4'>N/A</td><td class='color4'>...</td><td>Si RIGHT ou FULL</td>
    </tr>
  </tbody>
</table>

</div>

<p><todo>G√©n√©rer tableaux + sync</todo>
<todo>Modifier exemple + parlant</todo></p>
<sql-interactive>
  <span slot="options" data-jointype='INNER' data-tablename1='T1' data-tablename2='T2'></span>
  <span slot="options" data-jointype='LEFT' data-tablename1='T1' data-tablename2='T2'></span>
  <span slot="options" data-jointype='RIGHT' data-tablename1='T1' data-tablename2='T2'></span>
  <span slot="options" data-jointype='FULL' data-tablename1='T1' data-tablename2='T2'></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> $TABLENAME1 <span class="hljs-keyword">NATURAL</span> $JOINTYPE <span class="hljs-keyword">JOIN</span> $TABLENAME2;
</code></pre></sql-interactive>

<p>‚ö† Il existe 2 autres types de jointures, √† √©viter :</p>
<ul>
<li><code>RIGHT</code> : <code>$T1 RIGHT¬†JOIN¬†$T2</code> est √©quivalant √† <code>$T2 LEFT¬†JOIN $T1</code><br/>
‚ö†  Pour des raisons de lisibilit√©, autant que possible, utilisez <code>LEFT</code> √† la place.</li>
<li><code>CROSS</code> : produit cart√©sien (<strong>√† √©viter</strong>).</li>
</ul>
<p>üí° Vous pourrez aussi trouver <code>LEFT/RIGHT/FULL OUTER JOIN</code> dans certaines requ√™tes SQL. Ils sont en r√©alit√© √©quivalents √† <code>LEFT/RIGHT/FULL¬†JOIN</code>.</p>
<h3 id="pr√©ciser-la-condition-de-jointure">Pr√©ciser la condition de jointure</h3>
<p>Il se peut que vous souhaitiez expliciter les colonnes sur lesquelles effectuer la jointure pour :</p>
<ul>
<li>exclure une colonne de la jointure, avec :<br/>
<code>USING($COLS[,...])</code> indiquant les colonnes √† utiliser.</li>
<li>utiliser des colonnes de noms diff√©rents, avec :<br/>
<code>ON T1.$COL1 == T2.$COL2</code> indiquant la condition de jointure.</li>
</ul>
<p>‚ö† Dans les deux cas, il vous faudra retirer le mot clef <code>NATURAL</code>.</p>
<p>üí° Il est recommand√© d&#39;utiliser <code>USING</code> au lieu de jointures naturelles (i.e. avec <code>NATURAL</code>) afin d&#39;√©viter des jointures accidentelles.</p>
<sql-interactive>
  <span slot="options" data-jointype='NATURAL'></span>
  <span slot="options" data-joincond='USING(?)'></span>
  <span slot="options" data-joincond='ON T1.x == T2.X'></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 $JOINTYPE <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> T2 $JOINCOND;
</code></pre></sql-interactive>

<p>‚ö† Si deux colonnes ont le m√™me nom, seule la premi√®re sera affich√©e. Si vous souhaitez afficher la seconde, il est alors n√©cessaire de la renommer :</p>
<sql-interactive>
  <span slot="options" data-cols='*'></span>
  <span slot="options" data-cols='*, T2.? as ?'></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> T2 <span class="hljs-keyword">USING</span>(?);
</code></pre></sql-interactive>

<!--
  Non-correlated:
    - initialState : X in (....) // compute the list/value...
      + [ ] in (...)
    - step (new value)
      - 4 in (....)
    - step (check) => until end or found.
      - 4 in ([.]...)
    - if found : add line.

  - correlated:
    - initialState : X in (QUERY)
      + [ ] in () <- (QUERY [ ] )
    - step (new value)
      - 4 in () <- (QUERY [4])
    - step (check) => until end or found.
      - 4 in ([.]...) <- query [4]
    - if found : add line.

  - cartesian
    -> initial state : show all
    -> empty
    -> 1 line T1 + lines T2 (+empty "line") => produce T1xT2
    -> iterate T1 (+empty "line")
    -> then iterate T1xT2 to build final.

  
  - join
    -> initial state : show all
    -> empty
    -> 1 line T1 + lines T2 => produce final if cond matches.
    -> iterate T1 (+ empty "line")
-->

</main>
    </body>
</html>