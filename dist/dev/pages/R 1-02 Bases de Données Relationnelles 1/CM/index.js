import * as __WEBPACK_EXTERNAL_MODULE_https_raw_githack_com_denis_migdal_LISS_main_index_js_bb6a3cae__ from "https://raw.githack.com/denis-migdal/LISS/main/index.js";
/******/ var __webpack_modules__ = ({

/***/ "./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.css":
/*!*************************************************************************!*\
  !*** ./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.css ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.md":
/*!************************************************************************!*\
  !*** ./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.md ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "pages/R 1-02 Bases de Données Relationnelles 1/CM/index.html");

/***/ }),

/***/ "./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.ts":
/*!************************************************************************!*\
  !*** ./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.ts ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _struct_menu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../struct/menu.js */ "./src/struct/menu.js");
/* harmony import */ var _struct_menu_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_struct_menu_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../struct/sql-interactive.js */ "./src/struct/sql-interactive.js");
/* harmony import */ var _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../struct/sql-dym-table.js */ "./src/struct/sql-dym-table.js");
/* harmony import */ var _struct_anim_player_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../struct/anim-player.js */ "./src/struct/anim-player.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_1__, _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_2__]);
([_struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_1__, _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);




/*
window.addEventListener('beforeprint', () => {
  //...
});
*/ //TODO: links...
const main = document.querySelector("main");
const header = document.querySelector("header");
const titles = document.querySelectorAll("h1, h2, h3, h4");
const htree = {
    html: main,
    level: 0,
    parent: null,
    children: []
};
let htree_cursor = htree;
for (let title of titles){
    const level = +title.tagName.slice(1);
    while(level <= htree_cursor.level)htree_cursor = htree_cursor.parent;
    const elem = {
        html: title,
        level,
        children: [],
        parent: htree_cursor
    };
    htree_cursor.children.push(elem);
    htree_cursor = elem;
}
function searchCurHeader(htree, position) {
    const headers = htree.children;
    for(let i = headers.length - 1; i >= 0; --i)if (headers[i].html.offsetTop <= position + 32) return searchCurHeader(headers[i], position) ?? headers[i];
    return null;
}
const hid = [
    [],
    [
        "I",
        "II",
        "III",
        "IV"
    ],
    [
        "1",
        "2",
        "3",
        "5",
        "6",
        "7",
        "8",
        "9"
    ],
    [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h"
    ]
];
function getTitlePrefix(s) {
    if (s.level >= hid.length) return "";
    const idx = s.parent.children.indexOf(s);
    const num = hid[s.level][idx];
    return `${num}. `;
}
function buildMenu(nodes) {
    const menu = document.createElement("div");
    menu.classList.add("menu");
    menu.append(...nodes.map((s, idx)=>{
        const item = document.createElement("a");
        item.textContent = `${getTitlePrefix(s)}${s.html.textContent}`;
        item.setAttribute("href", `#${s.html.id}`);
        return item;
    }));
    return menu;
}
function updateHeader() {
    const last = searchCurHeader(htree, main.scrollTop);
    let headers = [];
    let cursor = last;
    while(cursor.html !== main){
        headers.push(cursor);
        cursor = cursor.parent;
    }
    const html = headers.reverse().map((hnode, i)=>{
        const h = hnode.html;
        const h_html = document.createElement("span");
        const link = document.createElement("a");
        link.textContent = `${getTitlePrefix(hnode)}${h.textContent}`;
        link.setAttribute('href', `#${h.id}`);
        const menu = buildMenu(hnode.parent.children);
        h_html.append(link, menu);
        return h_html;
    });
    if (last.children.length !== 0) {
        const empty = document.createElement("span");
        empty.append(buildMenu(last.children));
        html.push(empty);
    }
    header.replaceChildren(...html);
}
main.addEventListener('scroll', updateHeader);
updateHeader();

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/SQLite.ts":
/*!******************************!*\
  !*** ./src/struct/SQLite.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   db2: () => (/* binding */ db2)
/* harmony export */ });
/* harmony import */ var _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite/sqlite3.js */ "./src/struct/sqlite/sqlite3.js");
/* harmony import */ var _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__);
//TODO: better

__webpack_require__(/*! ../pages/R 1-02 Bases de Données Relationnelles 1/CM/sqlite3.wasm */ "./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/sqlite3.wasm");
//require("../../../struct/sqlite/sqlite3.wasm");

const sqlite3 = (await _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__()).sqlite3.oo1;
function js2sql(value) {
    if (value === null) return "NULL";
    if (typeof value === "number") return `${value}`;
    if (typeof value === "string") return `'${value}'`;
    throw new Error('???');
}
//TODO merge queries...
class DB {
    #desc;
    #db;
    constructor(name, desc){
        this.#desc = desc;
        // add t for tracing.
        this.#db = new sqlite3.DB(name, 'c');
        this.#db.exec('PRAGMA foreign_keys=ON;');
        this.fullReset();
    }
    #dropTable(name) {
        this.#db.exec(`drop table if exists ${name}`);
    }
    #createTable(name) {
        const desc = this.#desc[name];
        const cols = Object.entries(desc.schema).map(([name, type])=>`${name} ${type}`).join(", ");
        let constraints = "";
        if ("constraints" in desc) constraints = `, ${desc.constraints}`;
        this.#db.exec(`CREATE TABLE IF NOT EXISTS ${name}(${cols}${constraints}) STRICT;`);
        // Populate...
        const values = desc.entries.map((e)=>`(${e.map((c)=>js2sql(c)).join(', ')})`).join(", ");
        this.#db.exec(`INSERT INTO ${name} VALUES ${values};`);
    }
    resetTable(name) {
        this.#dropTable(name);
        this.#createTable(name);
    }
    #created_table = new Set();
    #updated_table = new Set();
    reset() {
        for (let name of [
            ...this.#created_table.values()
        ].reverse())this.#db.exec(`drop table if exists ${name};`);
        for(let name in this.#desc)if (this.#updated_table.has(name)) this.resetTable(name);
        this.#created_table.clear();
        this.#updated_table.clear();
    }
    fullReset() {
        for (let name of [
            ...this.#created_table.values()
        ].reverse())this.#db.exec(`drop table if exists ${name}`);
        const names = Object.keys(this.#desc);
        // required due to FK...
        for (let table of names.reverse())this.#dropTable(table);
        for (let table of names.reverse())this.#createTable(table);
        this.#created_table.clear();
        this.#updated_table.clear();
    }
    #isTableName(c) {
        return c !== " " && c !== ";" && c !== "\n";
    }
    #extractTableNameFromSQL(sql) {
        const types = [
            "CREATE TABLE IF NOT EXISTS ",
            "CREATE TABLE ",
            "ALTER TABLE ",
            "DROP TABLE ",
            "UPDATE ",
            "INSERT INTO ",
            "DELETE FROM "
        ];
        const sql_type = types.find((v)=>sql.startsWith(v));
        let start_pos = sql_type.length;
        while(!this.#isTableName(sql[start_pos]))++start_pos;
        let end_pos = start_pos;
        while(this.#isTableName(sql[end_pos]))++end_pos;
        const table_name = sql.slice(start_pos, end_pos);
        return [
            sql_type,
            table_name
        ];
    }
    exec_one(sql) {
        if (sql.startsWith("SELECT ")) return this.#db.selectObjects(sql);
        this.#db.exec(sql);
        const [type, name] = this.#extractTableNameFromSQL(sql);
        if (name in this.#desc) this.#updated_table.add(name);
        else this.#created_table.add(name);
        return null;
    }
    exec_many(sql) {
        let results = [];
        for(let i = 0; i < sql.length; ++i){
            try {
                results.push(this.exec_one(sql[i]));
            } catch (e) {
                console.warn(e);
                const message = "Error:" + e.message.split(':').slice(2).join(':');
                results.push(message);
                break;
            }
        }
        return results;
    }
}
const db2 = new DB("BDR1_CM", {
    Users: {
        schema: {
            ID: "INTEGER PRIMARY KEY AUTOINCREMENT",
            Nom: "TEXT",
            Prenom: "TEXT",
            Age: "INT"
        },
        entries: [
            [
                null,
                'Doe',
                'John',
                43
            ],
            [
                null,
                'Durant',
                'Paul',
                9
            ],
            [
                null,
                'Nescio',
                'Nomen',
                43
            ]
        ]
    },
    Produits: {
        schema: {
            Date: "TEXT",
            Ref: "TEXT",
            Q: "INT"
        },
        entries: [
            [
                '2023-01-01',
                'Gomme',
                10
            ],
            [
                '2023-02-23',
                'Gomme',
                9
            ],
            [
                '2023-06-13',
                'Gomme',
                24
            ],
            [
                '2023-01-01',
                'Crayon',
                20
            ],
            [
                '2023-02-23',
                'Crayon',
                18
            ],
            [
                '2023-06-13',
                'Crayon',
                50
            ]
        ]
    },
    T1: {
        schema: {
            ID: "INTEGER PRIMARY KEY AUTOINCREMENT",
            T1: "TEXT"
        },
        entries: [
            [
                null,
                '1'
            ],
            [
                null,
                '2'
            ],
            [
                null,
                '3'
            ]
        ]
    },
    T2: {
        schema: {
            ID: "INT",
            T2: "TEXT"
        },
        constraints: "FOREIGN KEY(ID) REFERENCES T1(ID)",
        entries: [
            [
                1,
                '1'
            ],
            [
                3,
                '2'
            ],
            [
                3,
                '3'
            ],
            [
                null,
                '4'
            ]
        ]
    }
});


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./src/struct/anim-player.js":
/*!***********************************!*\
  !*** ./src/struct/anim-player.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https://raw.githack.com/denis-migdal/LISS/main/index.js */ "https://raw.githack.com/denis-migdal/LISS/main/index.js");



const content = `<span class="reset">[Reset]</span><span class="prev">[Prev]</span><span class="play">[Play/Pause]</span><span class="next">[Next]</span>`;

const css = `
`;

const styles = [...document.querySelectorAll('style')].map(s => {
    let style = new CSSStyleSheet();
    style.replaceSync(s.textContent);
    return style;
});

class AnimPlayer extends (0,https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    content,
    css: [css, ...styles],
    attributes: ["speed"]
}) {

    constructor() {
        super();

        this.id = null;
        this.stepID = 0;

        this.content.querySelector(".prev" ).addEventListener("click", () => this.prev());
        this.content.querySelector(".next" ).addEventListener("click", () => this.next());
        this.content.querySelector(".play" ).addEventListener("click", () => this.play());
        this.content.querySelector(".reset").addEventListener("click", () => this.reset());
    }

    nextStep() {
        ++this.stepID;
        this.host.dispatchEvent( new CustomEvent("step", {detail: this.stepID}) );
    }


    cancelAutoPlay() {

        if(this.id === null)
            return false;

        clearInterval(this.id);
        this.id = null;
        return true;
    }

    prev() {
        const newStepID = this.stepID - 1;
        this.reset();
        while(this.stepID !== newStepID)
            this.nextStep();
    }
    next() {
        this.cancelAutoPlay();
        this.nextStep();
    }
    reset() {
        this.cancelAutoPlay();
        this.stepID = 0;
        this.host.dispatchEvent( new CustomEvent("reset") );
    }
    play() {

        if( this.cancelAutoPlay() )
            return;
        this.id = setInterval( () => this.nextStep(), +(this.attrs.speed ?? 500) );
    }
}

https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].define("anim-player", AnimPlayer)

/***/ }),

/***/ "./src/struct/menu.js":
/*!****************************!*\
  !*** ./src/struct/menu.js ***!
  \****************************/
/***/ (() => {

const menu = document.querySelector('#menu');

const isMultiCM = document.querySelectorAll('h1').length > 1;
const titles_selector = isMultiCM ? 'h1,h2,h3' : 'h2,h3';
const H_offset = isMultiCM ? 1 : 0;

const titres = document.querySelectorAll(titles_selector);

const lists = [document.createElement('ol')];

if( isMultiCM )
    lists[0].setAttribute('type', 'I'); 

for(let titre of titres) {

    const item = document.createElement('li');
    const link = document.createElement('a');
    link.textContent = titre.textContent;
    link.setAttribute('href', `#${titre.id}`);
    
    item.append(link);


    let list = null;
    switch(titre.tagName) {
        case 'H1':
            list = lists[0];
            lists[1] = document.createElement('ol');
            lists[1].setAttribute('type', '1'); // ?
            item.append(lists[1]);
        break;
        case 'H2':
            list = lists[H_offset];
            lists[H_offset+1] = document.createElement('ol');
            lists[H_offset+1].setAttribute('type', 'a');
            item.append(lists[H_offset+1]);
        break;
        case 'H3':
            list = lists[H_offset+1];
        break;
    }

    list.append(item);
}


menu.append(lists[0]);

/***/ }),

/***/ "./src/struct/sql-dym-table.js":
/*!*************************************!*\
  !*** ./src/struct/sql-dym-table.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https://raw.githack.com/denis-migdal/LISS/main/index.js */ "https://raw.githack.com/denis-migdal/LISS/main/index.js");
/* harmony import */ var _SQLite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SQLite */ "./src/struct/SQLite.ts");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_SQLite__WEBPACK_IMPORTED_MODULE_1__]);
_SQLite__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




const CSS =
`:host {
    display: inline-block;
}

:host table {
    border-collapse: collapse;

    & caption {
        font-weight: bold;
        font-size: 20px;
        line-height: 26px;
        font-style: italic;
    }
    
    & .highlight {
        background-color: #8B8000;
        print-color-adjust: exact;
    }

    /* TODO: make style adoptable through LISS... */
    .high_1 {
        background-color: red;
    }
    .high_2 {
        background-color: blue;
    }
    .high_3 {
        background-color: green;
    }
    .high_null {
        background-color: orange;
    }
    .hide {
        display: none;
    }
    .cur {
        border : 4px solid yellow;
        opacity: 0.5;
    }
    .lowlight {
        opacity: 0.25;
    }

    & td, & th {
        padding: 5px 10px;
        text-align: left;
    }

    & td {
        font-size: 16px;
        line-height: 22px;
    }

    & th {
        font-size: 20px;
        line-height: 26px;
    }
    
    & > tbody > tr + tr > td {
        border-top: 1px solid;
    }
}`;

class SQLDymTable extends (0,https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    attributes: ["table", "header", "cols"],
    css: CSS
}) {
    constructor() {
        super();

        let cols = this.attrs.cols ?? "*";

        this.exec(`SELECT ${cols} FROM ${this.attrs.table};`)
    }

    get nbRows() {
        return this.rows.length;
    }
    getRow(rowid) {
        return this.rows[rowid];
    }

    exec(query) {

        this.data = _SQLite__WEBPACK_IMPORTED_MODULE_1__.db2.exec_one(query);

        const table = document.createElement('table');

        const caption = document.createElement('caption');

        if( this.attrs.header === null)
            caption.textContent = `Table ${this.attrs.table} :`;
        else
            caption.textContent = this.attrs.header;

        //TODO: colgroup (for highlight).

        const colgroup = document.createElement('colgroup');
        const thead = document.createElement('thead');
        const trhead = document.createElement('tr');

        this.cols = {};

        const colnames =  Object.keys(this.data[0]);
        for(let colname of colnames) {
            const col = document.createElement('col');
            //col.classList.add('highlight');
            colgroup.append(col);

            this.cols[colname] = col;

            const th = document.createElement('th');
            th.textContent = colname;
            trhead.append(th);
        }
        thead.append(trhead);

        this.rows = [];

        const tbody = document.createElement('tbody');
        for(let line of this.data) {

            const tr = document.createElement('tr');
            for(let colname of colnames) {
                const td = document.createElement('td');
                td.textContent = line[colname] ?? "N/A";
                tr.append(td);
            }
            tbody.append(tr);

            this.rows.push([line,tr]);
        }

        table.append(caption, colgroup, thead, tbody);
        this.content.replaceChildren(table);
    }

    groupBy( group_colname ) {

        const tbody = this.content.querySelector("tbody");

        let groups = {};

        for(let line of this.data) {
            const group = line[group_colname];
            (groups[group] ??= []).push( line );
        }

        let rows = [];
        for(let groupname in groups) {

            const group = groups[groupname];

            for(let i = 0; i < group.length; ++i) {

                const entry = group[i];
                const tr = document.createElement('tr');

                for(let col in group[i]) {

                    const cell = document.createElement('td');
                    cell.textContent = entry[col];

                    if( col === group_colname ){
                        if(i !== 0)
                            continue;

                        cell.setAttribute("rowspan", group.length);
                    }

                    tr.append(cell);
                }
                rows.push(tr);
            }
                
            rows.push(document.createElement("tr"));
        }

        tbody.replaceChildren(...rows);
    }

    highlightCol( filter ) {
        for(let colname in this.cols)
            this.#highlight(this.cols[colname], filter(colname) );
    }

    #highlight(target, highlight) { // target: HTMLElement, highlight: boolean|string|Record<string, boolean> ) {

        if( typeof highlight === "boolean")
            return target.classList.toggle('highlight', highlight);
        if( typeof highlight === "string" )
            return target.classList.add(highlight);
        
        for(let name in highlight)
            target.classList.toggle(name, highlight[name]);

    }

    highlightRow( filter ) {
        for(let i = 0; i < this.rows.length; ++i)
            this.#highlight( this.rows[i][1], filter(this.rows[i][0], i) );
    }

    highlightCells( filter ) {

        for(let i = 0; i < this.rows.length; ++i) {

            const [row_data, row_html] = this.rows[i];
            const cols = Object.keys(row_data);

            for(let j = 0; j < cols.length; ++j)
                this.#highlight( row_html.children[j] , filter(row_data, cols[j]) );
        }
    }
};


https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].define("sql-dymtable", SQLDymTable)
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/sql-interactive.js":
/*!***************************************!*\
  !*** ./src/struct/sql-interactive.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SQLite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SQLite */ "./src/struct/SQLite.ts");
/* harmony import */ var https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https://raw.githack.com/denis-migdal/LISS/main/index.js */ "https://raw.githack.com/denis-migdal/LISS/main/index.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_SQLite__WEBPACK_IMPORTED_MODULE_0__]);
_SQLite__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


// LISS



const content = `
    <slot name="select"></slot>
    <slot name="options"></slot>
    <slot></slot>
    <slot name="pre"></slot>
    <div class="choices">
        <div class="options"></div>
        <div class="query"></div>
    </div>
    <pre class="hljs"><code><div class="result"></div></code></pre>
    <div class="spacing"></div>
    <slot name="post"></slot>`;

const css = `
    :host {
        font-size: 14px;
        line-height: 19px;
    }

    .selected, .highlight {
        background-color: gold;
    }
    :host .spacing {
        flex-grow: 1;
    }
    :host .query pre.hljs {
        padding-right: 0;

        & > code > div {
            padding-right: 0;
        }
    }
    :host pre.hljs {

        margin: 2px;

        & > code > div {
           padding: 8px;
        }
    }
    .options pre {
        position: relative;
        padding-bottom: 4px;
        padding-right: 25px;

        &.withdesc {
            padding-top: 20px;
        }
    }
    .options pre::after {
        content: ">";
        position: absolute;
        right: 0px;
        top: 0px;
        height: 100%;
        width: 25px;
        background-color: orange;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        
    }
    .options pre:hover {
        opacity: 0.5;
    }
    :host {
        /*display: inline-flex;*/
        display: flex;
        gap: 5px;
    }
    slot:not([name="post"]) {
        display: none;
    }
    span.value {
        border: 1px solid black;
        padding-left: 5px;
        padding-right: 5px;
    }

    .option {
        cursor: pointer;
    }

    .error {
        background-color: #FFA07A !important;
    }

    .query > pre .value {
        position: relative;
        margin-right: 13px;
    }

    .query > pre .value::after {

        right: -18px;
        position: absolute;
        content: "🖉";
    }

    :host > pre.hljs {
        /*flex-grow: 1;*/
    }

    :host .desc {
        position: absolute;
        top: 0px;
        left: 0px;

        font-size: 14px;
        line-height: 19px;

        width: 100%;
        border-left: none;
        border-top: none;
        padding-left: 5px;
        font-style: italic;

        box-sizing: border-box;

        background-color: lightgray;
        opacity: 0.6;
    }

    pre {
        padding: 0.5em;
        background-color: white;
        color: black;
    }

    code {
        font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
    }

    /* Tomorrow Theme */
    /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
    /* Original theme - https://github.com/chriskempson/tomorrow-theme */

    /* Tomorrow Comment */
    .hljs-comment,
    .hljs-quote {
        color: #8e908c;
    }

    /* Tomorrow Red */
    .hljs-variable,
    .hljs-template-variable,
    .hljs-tag,
    .hljs-name,
    .hljs-selector-id,
    .hljs-selector-class,
    .hljs-regexp,
    .hljs-deletion {
        color: #c82829;
    }

    /* Tomorrow Orange */
    .hljs-number,
    .hljs-built_in,
    .hljs-builtin-name,
    .hljs-literal,
    .hljs-type,
    .hljs-params,
    .hljs-meta,
    .hljs-link {
        color: #f5871f;
    }

    /* Tomorrow Yellow */
    .hljs-attribute {
        color: #eab700;
    }

    /* Tomorrow Green */
    .hljs-string,
    .hljs-symbol,
    .hljs-bullet,
    .hljs-addition {
        color: #718c00;
    }

    /* Tomorrow Blue */
    .hljs-title,
    .hljs-section {
        color: #4271ae;
    }

    /* Tomorrow Purple */
    .hljs-keyword,
    .hljs-selector-tag {
        color: #8959a8;
    }

    .hljs {
        display: block;
        overflow-x: auto;
        color: #4d4d4c;
        padding: 0.5em;
    }

    .hljs-emphasis {
        font-style: italic;
    }

    .hljs-strong {
        font-weight: bold;
    }
`;

/*
const styles = [...document.querySelectorAll('style')].map(s => {
    let style = new CSSStyleSheet();
    style.replaceSync(s.textContent);
    return style;
});*/

class SQLInteractive extends (0,https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    content,
    css: [css],
    attributes: ["full-reset"]
}) {

    #result   = "";
    #query    = null;
    #options  = null;
    #input    = null;
    #selected = null;

    #selectQuery = null;

    constructor() {
        super();

        this.#result   = this.content.querySelector(".result");
        this.#query    = this.content.querySelector(".query");
        this.#options  = this.content.querySelector(".options");
 
        let selectQuery = this.content.querySelector("slot[name='select']").assignedElements();
        if(selectQuery.length === 1)
            this.#selectQuery  = selectQuery[0].textContent;

        this.#options.addEventListener("click", (ev) => {

            let option = ev.target.closest(".option");
            if(option === null)
                return;
            ev.preventDefault();

            if(this.#selected !== null)
                this.#selected.classList.remove('selected');
            option.classList.add('selected');
            this.#selected = option;

            this.lastVars = {};

            const optsvalues = option.querySelectorAll('.value');
            for( let optsvalue of optsvalues) { // not optimal but it works

                this.lastVars[optsvalue.dataset.name] = optsvalue.textContent;

                const values = this.#input.querySelectorAll(`.value[data-name="${optsvalue.dataset.name}"]`);
                for(let value of values)
                    value.textContent = optsvalue.textContent;
            }

            this.#execQuery( );
        });

        let query = this.content.querySelector("slot:not([name])").assignedElements()[0];
        //TODO: find & replace...

        this.#input = query.cloneNode(true);

        this.#query.append(this.#input);

        let options = this.content.querySelector("slot[name='options']").assignedElements();

        const childNodes = [...this.#input.children[0].childNodes];

        for(let i = 0; i < childNodes.length; ++i) {

            const node = childNodes[i];
            if( node.nodeType !== Node.TEXT_NODE)
                continue;

            let text = node.textContent;
            let start = text.indexOf('$');
            if( start === -1)
                continue;

            let result = [];

            while( start !== -1) { // not optimal but it works...
                
                let end = text.slice(start+1).search(/[\W]/);
                
                if( end === -1) {
                    console.log( text, start, text.slice(start+1) );
                    throw new Error('End of SQL variable not found (you likely used a reserved keyword)');
                }
                end += start + 1;

                const value = document.createElement("span");
                value.classList.add("value");
                value.dataset.name = text.slice(start+1, end).toLowerCase();

                result.push(... text.slice(0, start), value );

                text = text.slice(end);
                start = text.indexOf('$');
            }

            result.push(text);

            node.replaceWith(...result);
        }

        let option_template = this.#input.cloneNode(true);

        const values = this.#input.querySelectorAll('.value');
        for(let value of values) {

            value.toggleAttribute('contenteditable');
            if( ! value.dataset.name.startsWith('m_') ) {
                value.addEventListener('keypress', (ev) => {

                    if(ev.key === "Enter") {
                        ev.preventDefault();
                        value.blur();
                        return;
                    }
                });
            }


            value.addEventListener('input', (ev) => {

                if(this.#selected !== null)
                    this.#selected.classList.remove('selected');
                this.#input.classList.add('selected');
                this.#selected = this.#input;

                const syncinputs = this.#input.querySelectorAll(`.value[data-name="${ev.target.dataset.name}"]`);
                for( let input of syncinputs ) {
                    if(input === ev.target)
                        continue;
                    input.textContent = ev.target.textContent;
                }

                this.#execQuery();
            });
        }

        for(let option of options) {

            const opt = option_template.cloneNode(true);
            opt.classList.add("option");

            const values = opt.querySelectorAll('.value');
            for(let value of values) {
                const name  = value.dataset.name;
                value.textContent = option.dataset[ name ];
            }

            if( option.textContent !== "") {
                opt.classList.add('withdesc');

                const desc = document.createElement('div');
                desc.classList.add("desc");
                desc.textContent = option.textContent.trim() + " :";

                opt.append(desc);
            }

            this.#options.append( opt );
        }

        if( this.#selectQuery === null)
            this.#options.firstElementChild.click();
    }

    #getQuery() {

        let query = "";
        for(let elem of this.#input.firstElementChild.childNodes ) {

            const content = elem.textContent;
            if(content === "" && elem instanceof HTMLElement && elem.classList.contains("value")) {
                if( query[query.length-1] === " " )
                    query = query.slice(0,-1);
            }
            query += elem.textContent;
        }

        return query;
    }

    #execQuery() {


        let queries = this.#getQuery().split(';\n').slice(0,-1).map( q => q + ";");

        // build queries to execute...

        const exec_queries = [];
        let show_table = true;

        let show_queries = null;
        if( this.#selectQuery !== null ) {
            show_queries = this.#selectQuery.split(';').slice(0,-1).map( q => q.trim() + ";");
        }

        const show = () => {
            show_table = false;
            if( show_queries === null )
                return;
            exec_queries.push(...show_queries);
        }

        for(let i = 0; i < queries.length; ++i) {
            const query = queries[i];

            if( query.startsWith("SELECT ") ) {
                exec_queries.push(query);
                continue;
            }

            if( query.startsWith("CREATE TABLE ") ) {

                let q = "CREATE TABLE ";
                if( query.startsWith("CREATE TABLE IF EXISTS ") )
                    q = "CREATE TABLE IF EXISTS ";

                exec_queries.push(query);
                const tb_name = query.slice(13, query.indexOf(" ", q.length) );
                exec_queries.push(`SELECT name, type, "notnull", dflt_value, pk, hidden\n        FROM pragma_table_xinfo('${tb_name}');`);
                show_table = false;
                continue;
            }

            if( show_table )
                show();

            exec_queries.push(query);

            show();
        }

        let results = _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.exec_many(exec_queries);
        this.updateResult(exec_queries, results);
        
        if( this.attrs["full-reset"] === "true")
            _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.fullReset();
        else
            _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.reset();
    }


    #hline(colsizes) {
        let result = '+';
        for(let colsize of colsizes)
            result += "".padEnd(colsize + 2, "-") + '+';

        return result;
    }

    #padRow(row, colsizes) {
        return row.map( (_, i) => row[i].padEnd(colsizes[i] + 1, " ") );
    }
    #rawline(row) {
        let result = "|";
        for(let i = 0; i < row.length; ++i)
            result += " " + row[i] + "|";

        result += "\n";
        return result;

    }

    #line(row, colsizes) {
        let result = "|";
        for(let i = 0; i < colsizes.length; ++i)
            result += " " + row[i].padEnd(colsizes[i] + 1, " ") + "|";

        result += "\n";
        return result;
    }

    updateResult(queries, datas) {

        this.#input.classList.remove('error');
        this.#result.classList.remove('error');
        let content = '';

        for(let i = 0; i < datas.length; ++i) {

            let compare_to = null;

            // correct select
            if( datas[i] !== null && typeof datas[i] !== "string") {

                // compare_to last or first
                for(let j = datas.length - 1; j > i; --j)
                    if( queries[j] === queries[i] && datas[j] !== null && typeof datas[j] !== "string" ) {
                        compare_to = datas[j];
                        break;
                    }
                
                if( compare_to === null) {

                    for(let j = 0; j < i; ++j)
                        if( queries[j] === queries[i] && datas[j] !== null && typeof datas[j] !== "string" ) {
                            compare_to = datas[j];
                            break;
                        }
                }
            }

            const query = queries[i];
            const data  = datas[i];

            content += `sqlite> ${query}\n`;

            if( data === null )
                continue;

            if( typeof data === "string") { // exception

                this.#input.classList.add('error');
                this.#result.classList.add('error');

                content += data;

                continue;
            }

            if( data.length === 0 ) {
                content += `No row returned.\n`;
                continue;
            }

            const headers = Object.keys(data[0]);
            const results = [
                ... data.map(entry => Object.values(entry).map(value => {
                        if( value === null )
                            return 'N/A';
                        if(typeof value === 'string')
                            return `'${value}'`;
                        return value.toString()
                    }) )   
            ];
    
            const colsizes = new Array(headers.length);
            for(let i = 0; i < colsizes.length; ++i) {
                colsizes[i] = headers[i].length;
                for(let row of results)
                    if( row[i].length > colsizes[i] )
                        colsizes[i] = row[i].length;
            }
    
    
            let result_text = this.#hline(colsizes) + "\n";
            result_text +=  this.#line(headers, colsizes);
            result_text +=  this.#hline(colsizes) + "\n";
            for(let j = 0; j < results.length; ++j) {

                let row = results[j];

                if( compare_to === null) {
                    result_text += this.#line(row, colsizes);
                    continue;
                }

                // highlight changes

                let key = "ID";
                if( ! (key in data[j]) )
                    key = "name";

                let cmp_line = compare_to.find( e => e[key] === data[j][key]); // h4cky

                console.warn(compare_to === datas[i]);

                row = this.#padRow(row, colsizes);

                if( cmp_line === undefined) {
                    row = row.map( c => `<strong><em>${c}</em></strong>`);
                    let line = this.#rawline(row);
                    result_text += `<span class="highlight">${line}</span>`;
                    continue;
                }

                for(let i = 0; i < headers.length; ++i) {
                    const colname = headers[i];

                    if( data[j][colname] !== cmp_line[colname])
                        row[i] = `<span class=highlight><em><strong>${row[i]}</strong></em></span>`;
                    
                }

                result_text += this.#rawline(row);
            }
            result_text +=  this.#hline(colsizes);
    
            content += result_text + '\n';   
        }

        this.#result.innerHTML = content;

        this.#lastDatas = datas;

        this.host.dispatchEvent( new CustomEvent("change", {detail: {
            datas
        }}) );
    }

    #lastDatas = null;

    get lastDatas() {
        return this.#lastDatas;
    }
}

https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].define("sql-interactive", SQLInteractive)
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/sqlite/sqlite3.js":
/*!**************************************!*\
  !*** ./src/struct/sqlite/sqlite3.js ***!
  \**************************************/
/***/ ((module) => {

/*
** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.
**
** This bundle (typically released as sqlite3.js or sqlite3.mjs)
** is an amalgamation of JavaScript source code from two projects:
**
** 1) https://emscripten.org: the Emscripten "glue code" is covered by
**    the terms of the MIT license and University of Illinois/NCSA
**    Open Source License, as described at:
**
**    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html
**
** 2) https://sqlite.org: all code and documentation labeled as being
**    from this source are released under the same terms as the sqlite3
**    C library:
**
** 2022-10-16
**
** The author disclaims copyright to this source code.  In place of a
** legal notice, here is a blessing:
**
** *   May you do good and not evil.
** *   May you find forgiveness for yourself and forgive others.
** *   May you share freely, never taking more than you give.
*/
/*
** This code was built from sqlite3 version...
**
** SQLITE_VERSION "3.45.2"
** SQLITE_VERSION_NUMBER 3045002
** SQLITE_SOURCE_ID "2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77"
**
** Using the Emscripten SDK version 3.1.30.
*/

var sqlite3InitModule = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  
  return (
function(config) {
  var sqlite3InitModule = config || {};
















var Module = typeof sqlite3InitModule != 'undefined' ? sqlite3InitModule : {};


var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});






const sqlite3InitModuleState = globalThis.sqlite3InitModuleState
      || Object.assign(Object.create(null),{
        debugModule: ()=>{}
      });
delete globalThis.sqlite3InitModuleState;
sqlite3InitModuleState.debugModule('globalThis.location =',globalThis.location);


Module['locateFile'] = function(path, prefix) {
  'use strict';
  let theFile;
  const up = this.urlParams;
  if(up.has(path)){
    theFile = up.get(path);
  }else if(this.sqlite3Dir){
    theFile = this.sqlite3Dir + path;
  }else if(this.scriptDir){
    theFile = this.scriptDir + path;
  }else{
    theFile = prefix + path;
  }
  sqlite3InitModuleState.debugModule(
    "locateFile(",arguments[0], ',', arguments[1],")",
    'sqlite3InitModuleState.scriptDir =',this.scriptDir,
    'up.entries() =',Array.from(up.entries()),
    "result =", theFile
  );
  return theFile;
}.bind(sqlite3InitModuleState);


const xNameOfInstantiateWasm =  false
      ? 0
      : 'emscripten-bug-17951';
Module[xNameOfInstantiateWasm] = function callee(imports,onSuccess){
  imports.env.foo = function(){};
  const uri = Module.locateFile(
    callee.uri, (
      ('undefined'===typeof scriptDirectory)
        ? "" : scriptDirectory)
  );
  sqlite3InitModuleState.debugModule(
    "instantiateWasm() uri =", uri
  );
  const wfetch = ()=>fetch(uri, {credentials: 'same-origin'});
  const loadWasm = WebAssembly.instantiateStreaming
        ? async ()=>{
          return WebAssembly.instantiateStreaming(wfetch(), imports)
            .then((arg)=>onSuccess(arg.instance, arg.module));
        }
        : async ()=>{ 
          return wfetch()
            .then(response => response.arrayBuffer())
            .then(bytes => WebAssembly.instantiate(bytes, imports))
            .then((arg)=>onSuccess(arg.instance, arg.module));
        };
  loadWasm();
  return {};
};

Module[xNameOfInstantiateWasm].uri = 'sqlite3.wasm';








var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};





var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';


var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;


var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}


var read_,
    readAsync,
    readBinary,
    setWindowTitle;




if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { 
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { 
    scriptDirectory = document.currentScript.src;
  }
  
  
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  
  
  
  
  
  
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  
  
  {



  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array((xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { 
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }


  }

  setWindowTitle = (title) => document.title = title;
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);


Object.assign(Module, moduleOverrides);


moduleOverrides = null;






if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];






var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': case 'u8': return 1;
    case 'i16': case 'u16': return 2;
    case 'i32': case 'u32': return 4;
    case 'i64': case 'u64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      }
      if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      }
      return 0;
    }
  }
}



















var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}



var wasmMemory;







var ABORT = false;




var EXITSTATUS;


function assert(condition, text) {
  if (!condition) {
    
    
    
    abort(text);
  }
}







var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;


function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  
  
  
  
  
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  }
  var str = '';
  
  
  while (idx < endPtr) {
    
    
    
    
    var u0 = heapOrArray[idx++];
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    var u1 = heapOrArray[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    var u2 = heapOrArray[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
    }

    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
  return str;
}


function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}


function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  
  
  if (!(maxBytesToWrite > 0))
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; 
  for (var i = 0; i < str.length; ++i) {
    
    
    
    
    
    
    
    var u = str.charCodeAt(i); 
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  
  heap[outIdx] = 0;
  return outIdx - startIdx;
}


function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}


function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    
    
    
    
    var c = str.charCodeAt(i); 
    if (c <= 0x7F) {
      len++;
    } else if (c <= 0x7FF) {
      len += 2;
    } else if (c >= 0xD800 && c <= 0xDFFF) {
      len += 4; ++i;
    } else {
      len += 3;
    }
  }
  return len;
}




var HEAP,

  HEAP8,

  HEAPU8,

  HEAP16,

  HEAPU16,

  HEAP32,

  HEAPU32,

  HEAPF32,

  HEAP64,

  HEAPU64,

  HEAPF64;

function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
  Module['HEAP64'] = HEAP64 = new BigInt64Array(b);
  Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);
}

var STACK_SIZE = 524288;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;







  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      
      
      
      
      
      'maximum': 2147483648 / 65536
    });
  }

updateMemoryViews();



INITIAL_MEMORY = wasmMemory.buffer.byteLength;







var wasmTable;










var __ATPRERUN__  = []; 
var __ATINIT__    = []; 
var __ATEXIT__    = []; 
var __ATPOSTRUN__ = []; 

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}




















var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; 

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); 
    }
  }
}


function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what = 'Aborted(' + what + ')';
  
  
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what += '. Build with -sASSERTIONS for more info.';

  
  
  
  
  
  
  
  

  
  
  
  
  
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  
  
  
  throw e;
}











var dataURIPrefix = 'data:application/octet-stream;base64,';


function isDataURI(filename) {
  
  return filename.startsWith(dataURIPrefix);
}


function isFileURI(filename) {
  return filename.startsWith('file://');
}


var wasmBinaryFile;
  wasmBinaryFile = 'sqlite3.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  
  
  
  
  
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
  }

  
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}



function createWasm() {
  
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  
  
  
  
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  
  addRunDependency('wasm-instantiate');

  
  function receiveInstantiationResult(result) {
    
    
    
    
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        
        
        
        
        
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            
            
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  
  
  
  
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
        
        readyPromiseReject(e);
    }
  }

  
  instantiateAsync().catch(readyPromiseReject);
  return {}; 
}


var tempDouble;
var tempI64;



var ASM_CONSTS = {
  
};





  
  function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = 'Program terminated with exit(' + status + ')';
      this.status = status;
    }

  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        
        callbacks.shift()(Module);
      }
    }

  
    
  function getValue(ptr, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP64[((ptr)>>3)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return HEAPF64[((ptr)>>3)];
        case '*': return HEAPU32[((ptr)>>2)];
        default: abort('invalid type for getValue: ' + type);
      }
      return null;
    }

  
    
  function setValue(ptr, value, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': HEAP8[((ptr)>>0)] = value; break;
        case 'i8': HEAP8[((ptr)>>0)] = value; break;
        case 'i16': HEAP16[((ptr)>>1)] = value; break;
        case 'i32': HEAP32[((ptr)>>2)] = value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)] = value; break;
        case 'double': HEAPF64[((ptr)>>3)] = value; break;
        case '*': HEAPU32[((ptr)>>2)] = value; break;
        default: abort('invalid type for setValue: ' + type);
      }
    }

  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:(parts, allowAboveRoot) => {
        
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          
          return '.';
        }
        if (dir) {
          
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:(path) => {
        
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },join:function() {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join('/'));
      },join2:(l, r) => {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        
        var randomBuffer = new Uint8Array(1);
        return () => { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      
      return () => abort("randomDevice");
    }
  
  
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; 
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        
        
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  
  
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }
  var TTY = {ttys:[],init:function () {
        
        
        
        
        
        
        
        
      },shutdown:function() {
        
        
        
        
        
        
        
        
        
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          
          stream.tty.ops.fsync(stream.tty);
        },fsync:function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },read:function(stream, buffer, offset, length, pos ) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              
              result = window.prompt('Input: ');  
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); 
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
      return address;
    }
  
  function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
  function mmapAlloc(size) {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      return zeroMemory(ptr, size);
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 , 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; 
          
          
          
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); 
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; 
        
        
        
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); 
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); 
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); 
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; 
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); 
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); 
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          
          
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511  | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { 
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          
          
          
          
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { 
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { 
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { 
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; 
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          
          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            
            
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          
          return 0;
        }}};
  
  
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, (arrayBuffer) => {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, (event) => {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  
          throw new FS.ErrnoError(32);
        }
  
        
        var parts = path.split('/').filter((p) => !!p);
  
        
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          
          
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || 
              (flags & 512)) { 
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream =  function() {
            this.shared = { };
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              
              get: function() { return this.node; },
              
              set: function(val) { this.node = val; }
            },
            isRead: {
              
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              
              get: function() { return (this.flags & 1024); }
            },
            flags: {
              
              get: function() { return this.shared.flags; },
              
              set: function(val) { this.shared.flags = val; },
            },
            position : {
              
              get: function() { return this.shared.position; },
              
              set: function(val) { this.shared.position = val; },
            },
          });
        }
        
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          
          stream.stream_ops = device.stream_ops;
          
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          
          node.mounted = mount;
  
          
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        
        node.mounted = null;
  
        
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 ;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 ;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 ;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        
        var lookup, old_dir, new_dir;
  
        
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        
        var old_node = FS.lookupNode(old_dir, old_name);
        
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          
        }
        
        if (old_node === new_node) {
          return;
        }
        
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        
        
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        
        FS.hashRemoveNode(old_node);
        
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          
          
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          
          
          
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438  : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            
          }
        }
        
        var created = false;
        if ((flags & 64)) {
          if (node) {
            
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        
        
        
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        
        flags &= ~(128 | 512 | 131072);
  
        
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          
          ungotten: [],
          error: false
        });
        
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; 
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, length, position, prot, flags) => {
        
        
        
        
        
        
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        
        FS.mkdir('/dev');
        
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        
        
        
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        
        
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        
        
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 , 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; 
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        
        
        
  
        
        
        
        
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError =  function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno =  function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        
        
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },analyzePath:(path, dontResolveLastLink) => {
        
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        
        
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos ) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          
          try {
            
            
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        
        
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; 
        }
        LazyUint8Array.prototype.get =  function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; 
  
          if (!hasByteServing) chunkSize = datalength;
  
          
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array((xhr.response || []));
            }
            return intArrayFromString(xhr.responseText || '', true);
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; 
            end = Math.min(end, datalength-1); 
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            
            chunkSize = datalength = 1; 
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get:  function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get:  function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        
        
        
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        
        Object.defineProperties(node, {
          usedBytes: {
            get:  function() { return this.contents.length; }
          }
        });
        
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { 
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { 
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr: ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        
        
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); 
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; 
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAPU32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        (tempI64 = [Math.floor(atime / 1000)>>>0,(tempDouble=Math.floor(atime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(64))>>2)] = (atime % 1000) * 1000;
        (tempI64 = [Math.floor(mtime / 1000)>>>0,(tempDouble=Math.floor(mtime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(80))>>2)] = (mtime % 1000) * 1000;
        (tempI64 = [Math.floor(ctime / 1000)>>>0,(tempDouble=Math.floor(ctime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(96))>>2)] = (ctime % 1000) * 1000;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(104))>>2)] = tempI64[0],HEAP32[(((buf)+(108))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      }};
  function ___syscall_chmod(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        
        return -28;
      }
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node) {
        return -44;
      }
      var perms = '';
      if (amode & 4) perms += 'r';
      if (amode & 2) perms += 'w';
      if (amode & 1) perms += 'x';
      if (perms  && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchmod(fd, mode) {
  try {
  
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchown32(fd, owner, group) {
  try {
  
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  
  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5:
         {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 6:
        case 7:
        
        
          
          
          return 0; 
        case 16:
        case 8:
          return -28; 
        case 9:
          
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var MAX_INT53 = 9007199254740992;
  
  var MIN_INT53 = -9007199254740992;
  function bigintToI53Checked(num) {
      return (num < MIN_INT53 || num > MAX_INT53) ? NaN : Number(num);
    }
  
  
  
  
  function ___syscall_ftruncate64(fd,  length) {
  try {
  
      length = bigintToI53Checked(length); if (isNaN(length)) return -61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes) return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; 
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; 
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          
          
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          
          
          
          if (!stream.tty) return -59;
          return 0;
        }
        default: return -28; 
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdirat(dirfd, path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      
      
      path = PATH.normalize(path);
      if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~6400);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0) return -28;
      var ret = FS.readlink(path);
  
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf+len];
      stringToUTF8(ret, buf, bufsize+1);
      
      
      HEAP8[buf+len] = endChar;
      return len;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function readI53FromI64(ptr) {
      return HEAPU32[ptr>>2] + HEAP32[ptr+4>>2] * 4294967296;
    }
  
  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[(((times)+(8))>>2)];
        atime = (seconds*1000) + (nanoseconds/(1000*1000));
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[(((times)+(8))>>2)];
        mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var nowIsMonotonic = true;;
  function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

  
  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  var __MONTH_DAYS_LEAP_CUMULATIVE = [0,31,60,91,121,152,182,213,244,274,305,335];
  
  var __MONTH_DAYS_REGULAR_CUMULATIVE = [0,31,59,90,120,151,181,212,243,273,304,334];
  function __yday_from_date(date) {
      var isLeapYear = __isLeapYear(date.getFullYear());
      var monthDaysCumulative = (isLeapYear ? __MONTH_DAYS_LEAP_CUMULATIVE : __MONTH_DAYS_REGULAR_CUMULATIVE);
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; 
  
      return yday;
    }
  function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time)*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var yday = __yday_from_date(date)|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    }

  
  
  function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, off, prot, flags);
      var ptr = res.ptr;
      HEAP32[((allocated)>>2)] = res.allocated;
      HEAPU32[((addr)>>2)] = ptr;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  
  
  function __munmap_js(addr, len, prot, flags, fd, offset) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
      
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }
  function __tzset_js(timezone, daylight, tzname) {
      
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      
      
      
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      
      
      
      
      
      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        
        HEAPU32[((tzname)>>2)] = winterNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = summerNamePtr;
      } else {
        HEAPU32[((tzname)>>2)] = summerNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = winterNamePtr;
      }
    }

  function _emscripten_date_now() {
      return Date.now();
    }

  var _emscripten_get_now;_emscripten_get_now = () => performance.now();
  ;

  function getHeapMax() {
      
      
      
      
      return 2147483648;
    }
  
  function emscripten_realloc_buffer(size) {
      var b = wasmMemory.buffer;
      try {
        
        wasmMemory.grow((size - b.byteLength + 65535) >>> 16); 
        updateMemoryViews();
        return 1 ;
      } catch(e) {
      }
      
      
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      
      
  
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
  
      
      
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
  
      
      
      
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); 
        
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    }

  var ENV = {};
  
  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        
        
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        
        for (var x in ENV) {
          
          
          
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  
  
  function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
      }
      
      if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
    }
  
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  
  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      
      
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)] = type;
      
      
      
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; 
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }
  
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  
  
  
  function _fd_seek(fd,  offset, whence, newOffset) {
  try {
  
      offset = bigintToI53Checked(offset); if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; 
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_sync(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (stream.stream_ops && stream.stream_ops.fsync) {
        return stream.stream_ops.fsync(stream);
      }
      return 0; 
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }
  
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  var FSNode =  function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: function() {
     return (this.mode & readMode) === readMode;
    },
    set: function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
var ASSERTIONS = false;

var asmLibraryArg = {
  "__syscall_chmod": ___syscall_chmod,
  "__syscall_faccessat": ___syscall_faccessat,
  "__syscall_fchmod": ___syscall_fchmod,
  "__syscall_fchown32": ___syscall_fchown32,
  "__syscall_fcntl64": ___syscall_fcntl64,
  "__syscall_fstat64": ___syscall_fstat64,
  "__syscall_ftruncate64": ___syscall_ftruncate64,
  "__syscall_getcwd": ___syscall_getcwd,
  "__syscall_ioctl": ___syscall_ioctl,
  "__syscall_lstat64": ___syscall_lstat64,
  "__syscall_mkdirat": ___syscall_mkdirat,
  "__syscall_newfstatat": ___syscall_newfstatat,
  "__syscall_openat": ___syscall_openat,
  "__syscall_readlinkat": ___syscall_readlinkat,
  "__syscall_rmdir": ___syscall_rmdir,
  "__syscall_stat64": ___syscall_stat64,
  "__syscall_unlinkat": ___syscall_unlinkat,
  "__syscall_utimensat": ___syscall_utimensat,
  "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
  "_localtime_js": __localtime_js,
  "_mmap_js": __mmap_js,
  "_munmap_js": __munmap_js,
  "_tzset_js": __tzset_js,
  "emscripten_date_now": _emscripten_date_now,
  "emscripten_get_now": _emscripten_get_now,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "fd_close": _fd_close,
  "fd_fdstat_get": _fd_fdstat_get,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_sync": _fd_sync,
  "fd_write": _fd_write,
  "memory": wasmMemory
};
var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};


var _sqlite3_status64 = Module["_sqlite3_status64"] = function() {
  return (_sqlite3_status64 = Module["_sqlite3_status64"] = Module["asm"]["sqlite3_status64"]).apply(null, arguments);
};


var _sqlite3_status = Module["_sqlite3_status"] = function() {
  return (_sqlite3_status = Module["_sqlite3_status"] = Module["asm"]["sqlite3_status"]).apply(null, arguments);
};


var _sqlite3_db_status = Module["_sqlite3_db_status"] = function() {
  return (_sqlite3_db_status = Module["_sqlite3_db_status"] = Module["asm"]["sqlite3_db_status"]).apply(null, arguments);
};


var _sqlite3_msize = Module["_sqlite3_msize"] = function() {
  return (_sqlite3_msize = Module["_sqlite3_msize"] = Module["asm"]["sqlite3_msize"]).apply(null, arguments);
};


var _sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = function() {
  return (_sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = Module["asm"]["sqlite3_vfs_find"]).apply(null, arguments);
};


var _sqlite3_initialize = Module["_sqlite3_initialize"] = function() {
  return (_sqlite3_initialize = Module["_sqlite3_initialize"] = Module["asm"]["sqlite3_initialize"]).apply(null, arguments);
};


var _sqlite3_malloc = Module["_sqlite3_malloc"] = function() {
  return (_sqlite3_malloc = Module["_sqlite3_malloc"] = Module["asm"]["sqlite3_malloc"]).apply(null, arguments);
};


var _sqlite3_free = Module["_sqlite3_free"] = function() {
  return (_sqlite3_free = Module["_sqlite3_free"] = Module["asm"]["sqlite3_free"]).apply(null, arguments);
};


var _sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = function() {
  return (_sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = Module["asm"]["sqlite3_vfs_register"]).apply(null, arguments);
};


var _sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = function() {
  return (_sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = Module["asm"]["sqlite3_vfs_unregister"]).apply(null, arguments);
};


var _sqlite3_malloc64 = Module["_sqlite3_malloc64"] = function() {
  return (_sqlite3_malloc64 = Module["_sqlite3_malloc64"] = Module["asm"]["sqlite3_malloc64"]).apply(null, arguments);
};


var _sqlite3_realloc = Module["_sqlite3_realloc"] = function() {
  return (_sqlite3_realloc = Module["_sqlite3_realloc"] = Module["asm"]["sqlite3_realloc"]).apply(null, arguments);
};


var _sqlite3_realloc64 = Module["_sqlite3_realloc64"] = function() {
  return (_sqlite3_realloc64 = Module["_sqlite3_realloc64"] = Module["asm"]["sqlite3_realloc64"]).apply(null, arguments);
};


var _sqlite3_value_text = Module["_sqlite3_value_text"] = function() {
  return (_sqlite3_value_text = Module["_sqlite3_value_text"] = Module["asm"]["sqlite3_value_text"]).apply(null, arguments);
};


var _sqlite3_randomness = Module["_sqlite3_randomness"] = function() {
  return (_sqlite3_randomness = Module["_sqlite3_randomness"] = Module["asm"]["sqlite3_randomness"]).apply(null, arguments);
};


var _sqlite3_stricmp = Module["_sqlite3_stricmp"] = function() {
  return (_sqlite3_stricmp = Module["_sqlite3_stricmp"] = Module["asm"]["sqlite3_stricmp"]).apply(null, arguments);
};


var _sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = function() {
  return (_sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = Module["asm"]["sqlite3_strnicmp"]).apply(null, arguments);
};


var _sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = function() {
  return (_sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = Module["asm"]["sqlite3_uri_parameter"]).apply(null, arguments);
};


var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};


var _sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = function() {
  return (_sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = Module["asm"]["sqlite3_uri_boolean"]).apply(null, arguments);
};


var _sqlite3_serialize = Module["_sqlite3_serialize"] = function() {
  return (_sqlite3_serialize = Module["_sqlite3_serialize"] = Module["asm"]["sqlite3_serialize"]).apply(null, arguments);
};


var _sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = function() {
  return (_sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = Module["asm"]["sqlite3_prepare_v2"]).apply(null, arguments);
};


var _sqlite3_step = Module["_sqlite3_step"] = function() {
  return (_sqlite3_step = Module["_sqlite3_step"] = Module["asm"]["sqlite3_step"]).apply(null, arguments);
};


var _sqlite3_column_int64 = Module["_sqlite3_column_int64"] = function() {
  return (_sqlite3_column_int64 = Module["_sqlite3_column_int64"] = Module["asm"]["sqlite3_column_int64"]).apply(null, arguments);
};


var _sqlite3_reset = Module["_sqlite3_reset"] = function() {
  return (_sqlite3_reset = Module["_sqlite3_reset"] = Module["asm"]["sqlite3_reset"]).apply(null, arguments);
};


var _sqlite3_exec = Module["_sqlite3_exec"] = function() {
  return (_sqlite3_exec = Module["_sqlite3_exec"] = Module["asm"]["sqlite3_exec"]).apply(null, arguments);
};


var _sqlite3_column_int = Module["_sqlite3_column_int"] = function() {
  return (_sqlite3_column_int = Module["_sqlite3_column_int"] = Module["asm"]["sqlite3_column_int"]).apply(null, arguments);
};


var _sqlite3_finalize = Module["_sqlite3_finalize"] = function() {
  return (_sqlite3_finalize = Module["_sqlite3_finalize"] = Module["asm"]["sqlite3_finalize"]).apply(null, arguments);
};


var _sqlite3_file_control = Module["_sqlite3_file_control"] = function() {
  return (_sqlite3_file_control = Module["_sqlite3_file_control"] = Module["asm"]["sqlite3_file_control"]).apply(null, arguments);
};


var _sqlite3_column_name = Module["_sqlite3_column_name"] = function() {
  return (_sqlite3_column_name = Module["_sqlite3_column_name"] = Module["asm"]["sqlite3_column_name"]).apply(null, arguments);
};


var _sqlite3_column_text = Module["_sqlite3_column_text"] = function() {
  return (_sqlite3_column_text = Module["_sqlite3_column_text"] = Module["asm"]["sqlite3_column_text"]).apply(null, arguments);
};


var _sqlite3_column_type = Module["_sqlite3_column_type"] = function() {
  return (_sqlite3_column_type = Module["_sqlite3_column_type"] = Module["asm"]["sqlite3_column_type"]).apply(null, arguments);
};


var _sqlite3_errmsg = Module["_sqlite3_errmsg"] = function() {
  return (_sqlite3_errmsg = Module["_sqlite3_errmsg"] = Module["asm"]["sqlite3_errmsg"]).apply(null, arguments);
};


var _sqlite3_deserialize = Module["_sqlite3_deserialize"] = function() {
  return (_sqlite3_deserialize = Module["_sqlite3_deserialize"] = Module["asm"]["sqlite3_deserialize"]).apply(null, arguments);
};


var _sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = function() {
  return (_sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = Module["asm"]["sqlite3_clear_bindings"]).apply(null, arguments);
};


var _sqlite3_value_blob = Module["_sqlite3_value_blob"] = function() {
  return (_sqlite3_value_blob = Module["_sqlite3_value_blob"] = Module["asm"]["sqlite3_value_blob"]).apply(null, arguments);
};


var _sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = function() {
  return (_sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = Module["asm"]["sqlite3_value_bytes"]).apply(null, arguments);
};


var _sqlite3_value_double = Module["_sqlite3_value_double"] = function() {
  return (_sqlite3_value_double = Module["_sqlite3_value_double"] = Module["asm"]["sqlite3_value_double"]).apply(null, arguments);
};


var _sqlite3_value_int = Module["_sqlite3_value_int"] = function() {
  return (_sqlite3_value_int = Module["_sqlite3_value_int"] = Module["asm"]["sqlite3_value_int"]).apply(null, arguments);
};


var _sqlite3_value_int64 = Module["_sqlite3_value_int64"] = function() {
  return (_sqlite3_value_int64 = Module["_sqlite3_value_int64"] = Module["asm"]["sqlite3_value_int64"]).apply(null, arguments);
};


var _sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = function() {
  return (_sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = Module["asm"]["sqlite3_value_subtype"]).apply(null, arguments);
};


var _sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = function() {
  return (_sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = Module["asm"]["sqlite3_value_pointer"]).apply(null, arguments);
};


var _sqlite3_value_type = Module["_sqlite3_value_type"] = function() {
  return (_sqlite3_value_type = Module["_sqlite3_value_type"] = Module["asm"]["sqlite3_value_type"]).apply(null, arguments);
};


var _sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = function() {
  return (_sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = Module["asm"]["sqlite3_value_nochange"]).apply(null, arguments);
};


var _sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = function() {
  return (_sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = Module["asm"]["sqlite3_value_frombind"]).apply(null, arguments);
};


var _sqlite3_value_dup = Module["_sqlite3_value_dup"] = function() {
  return (_sqlite3_value_dup = Module["_sqlite3_value_dup"] = Module["asm"]["sqlite3_value_dup"]).apply(null, arguments);
};


var _sqlite3_value_free = Module["_sqlite3_value_free"] = function() {
  return (_sqlite3_value_free = Module["_sqlite3_value_free"] = Module["asm"]["sqlite3_value_free"]).apply(null, arguments);
};


var _sqlite3_result_blob = Module["_sqlite3_result_blob"] = function() {
  return (_sqlite3_result_blob = Module["_sqlite3_result_blob"] = Module["asm"]["sqlite3_result_blob"]).apply(null, arguments);
};


var _sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = function() {
  return (_sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = Module["asm"]["sqlite3_result_error_toobig"]).apply(null, arguments);
};


var _sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = function() {
  return (_sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = Module["asm"]["sqlite3_result_error_nomem"]).apply(null, arguments);
};


var _sqlite3_result_double = Module["_sqlite3_result_double"] = function() {
  return (_sqlite3_result_double = Module["_sqlite3_result_double"] = Module["asm"]["sqlite3_result_double"]).apply(null, arguments);
};


var _sqlite3_result_error = Module["_sqlite3_result_error"] = function() {
  return (_sqlite3_result_error = Module["_sqlite3_result_error"] = Module["asm"]["sqlite3_result_error"]).apply(null, arguments);
};


var _sqlite3_result_int = Module["_sqlite3_result_int"] = function() {
  return (_sqlite3_result_int = Module["_sqlite3_result_int"] = Module["asm"]["sqlite3_result_int"]).apply(null, arguments);
};


var _sqlite3_result_int64 = Module["_sqlite3_result_int64"] = function() {
  return (_sqlite3_result_int64 = Module["_sqlite3_result_int64"] = Module["asm"]["sqlite3_result_int64"]).apply(null, arguments);
};


var _sqlite3_result_null = Module["_sqlite3_result_null"] = function() {
  return (_sqlite3_result_null = Module["_sqlite3_result_null"] = Module["asm"]["sqlite3_result_null"]).apply(null, arguments);
};


var _sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = function() {
  return (_sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = Module["asm"]["sqlite3_result_pointer"]).apply(null, arguments);
};


var _sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = function() {
  return (_sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = Module["asm"]["sqlite3_result_subtype"]).apply(null, arguments);
};


var _sqlite3_result_text = Module["_sqlite3_result_text"] = function() {
  return (_sqlite3_result_text = Module["_sqlite3_result_text"] = Module["asm"]["sqlite3_result_text"]).apply(null, arguments);
};


var _sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = function() {
  return (_sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = Module["asm"]["sqlite3_result_zeroblob"]).apply(null, arguments);
};


var _sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = function() {
  return (_sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = Module["asm"]["sqlite3_result_zeroblob64"]).apply(null, arguments);
};


var _sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = function() {
  return (_sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = Module["asm"]["sqlite3_result_error_code"]).apply(null, arguments);
};


var _sqlite3_user_data = Module["_sqlite3_user_data"] = function() {
  return (_sqlite3_user_data = Module["_sqlite3_user_data"] = Module["asm"]["sqlite3_user_data"]).apply(null, arguments);
};


var _sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = function() {
  return (_sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = Module["asm"]["sqlite3_context_db_handle"]).apply(null, arguments);
};


var _sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = function() {
  return (_sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = Module["asm"]["sqlite3_vtab_nochange"]).apply(null, arguments);
};


var _sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = function() {
  return (_sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = Module["asm"]["sqlite3_vtab_in_first"]).apply(null, arguments);
};


var _sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = function() {
  return (_sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = Module["asm"]["sqlite3_vtab_in_next"]).apply(null, arguments);
};


var _sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = function() {
  return (_sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = Module["asm"]["sqlite3_aggregate_context"]).apply(null, arguments);
};


var _sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = function() {
  return (_sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = Module["asm"]["sqlite3_get_auxdata"]).apply(null, arguments);
};


var _sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = function() {
  return (_sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = Module["asm"]["sqlite3_set_auxdata"]).apply(null, arguments);
};


var _sqlite3_column_count = Module["_sqlite3_column_count"] = function() {
  return (_sqlite3_column_count = Module["_sqlite3_column_count"] = Module["asm"]["sqlite3_column_count"]).apply(null, arguments);
};


var _sqlite3_data_count = Module["_sqlite3_data_count"] = function() {
  return (_sqlite3_data_count = Module["_sqlite3_data_count"] = Module["asm"]["sqlite3_data_count"]).apply(null, arguments);
};


var _sqlite3_column_blob = Module["_sqlite3_column_blob"] = function() {
  return (_sqlite3_column_blob = Module["_sqlite3_column_blob"] = Module["asm"]["sqlite3_column_blob"]).apply(null, arguments);
};


var _sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = function() {
  return (_sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = Module["asm"]["sqlite3_column_bytes"]).apply(null, arguments);
};


var _sqlite3_column_double = Module["_sqlite3_column_double"] = function() {
  return (_sqlite3_column_double = Module["_sqlite3_column_double"] = Module["asm"]["sqlite3_column_double"]).apply(null, arguments);
};


var _sqlite3_column_value = Module["_sqlite3_column_value"] = function() {
  return (_sqlite3_column_value = Module["_sqlite3_column_value"] = Module["asm"]["sqlite3_column_value"]).apply(null, arguments);
};


var _sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = function() {
  return (_sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = Module["asm"]["sqlite3_bind_blob"]).apply(null, arguments);
};


var _sqlite3_bind_double = Module["_sqlite3_bind_double"] = function() {
  return (_sqlite3_bind_double = Module["_sqlite3_bind_double"] = Module["asm"]["sqlite3_bind_double"]).apply(null, arguments);
};


var _sqlite3_bind_int = Module["_sqlite3_bind_int"] = function() {
  return (_sqlite3_bind_int = Module["_sqlite3_bind_int"] = Module["asm"]["sqlite3_bind_int"]).apply(null, arguments);
};


var _sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = function() {
  return (_sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = Module["asm"]["sqlite3_bind_int64"]).apply(null, arguments);
};


var _sqlite3_bind_null = Module["_sqlite3_bind_null"] = function() {
  return (_sqlite3_bind_null = Module["_sqlite3_bind_null"] = Module["asm"]["sqlite3_bind_null"]).apply(null, arguments);
};


var _sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = function() {
  return (_sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = Module["asm"]["sqlite3_bind_pointer"]).apply(null, arguments);
};


var _sqlite3_bind_text = Module["_sqlite3_bind_text"] = function() {
  return (_sqlite3_bind_text = Module["_sqlite3_bind_text"] = Module["asm"]["sqlite3_bind_text"]).apply(null, arguments);
};


var _sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = function() {
  return (_sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = Module["asm"]["sqlite3_bind_parameter_count"]).apply(null, arguments);
};


var _sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = function() {
  return (_sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = Module["asm"]["sqlite3_bind_parameter_index"]).apply(null, arguments);
};


var _sqlite3_db_handle = Module["_sqlite3_db_handle"] = function() {
  return (_sqlite3_db_handle = Module["_sqlite3_db_handle"] = Module["asm"]["sqlite3_db_handle"]).apply(null, arguments);
};


var _sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = function() {
  return (_sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = Module["asm"]["sqlite3_stmt_readonly"]).apply(null, arguments);
};


var _sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = function() {
  return (_sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = Module["asm"]["sqlite3_stmt_isexplain"]).apply(null, arguments);
};


var _sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = function() {
  return (_sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = Module["asm"]["sqlite3_stmt_status"]).apply(null, arguments);
};


var _sqlite3_sql = Module["_sqlite3_sql"] = function() {
  return (_sqlite3_sql = Module["_sqlite3_sql"] = Module["asm"]["sqlite3_sql"]).apply(null, arguments);
};


var _sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = function() {
  return (_sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = Module["asm"]["sqlite3_expanded_sql"]).apply(null, arguments);
};


var _sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = function() {
  return (_sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = Module["asm"]["sqlite3_preupdate_old"]).apply(null, arguments);
};


var _sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = function() {
  return (_sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = Module["asm"]["sqlite3_preupdate_count"]).apply(null, arguments);
};


var _sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = function() {
  return (_sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = Module["asm"]["sqlite3_preupdate_depth"]).apply(null, arguments);
};


var _sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = function() {
  return (_sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = Module["asm"]["sqlite3_preupdate_blobwrite"]).apply(null, arguments);
};


var _sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = function() {
  return (_sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = Module["asm"]["sqlite3_preupdate_new"]).apply(null, arguments);
};


var _sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = function() {
  return (_sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = Module["asm"]["sqlite3_value_numeric_type"]).apply(null, arguments);
};


var _sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = function() {
  return (_sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = Module["asm"]["sqlite3_set_authorizer"]).apply(null, arguments);
};


var _sqlite3_strglob = Module["_sqlite3_strglob"] = function() {
  return (_sqlite3_strglob = Module["_sqlite3_strglob"] = Module["asm"]["sqlite3_strglob"]).apply(null, arguments);
};


var _sqlite3_strlike = Module["_sqlite3_strlike"] = function() {
  return (_sqlite3_strlike = Module["_sqlite3_strlike"] = Module["asm"]["sqlite3_strlike"]).apply(null, arguments);
};


var _sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = function() {
  return (_sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = Module["asm"]["sqlite3_auto_extension"]).apply(null, arguments);
};


var _sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = function() {
  return (_sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = Module["asm"]["sqlite3_cancel_auto_extension"]).apply(null, arguments);
};


var _sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = function() {
  return (_sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = Module["asm"]["sqlite3_reset_auto_extension"]).apply(null, arguments);
};


var _sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = function() {
  return (_sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = Module["asm"]["sqlite3_prepare_v3"]).apply(null, arguments);
};


var _sqlite3_create_module = Module["_sqlite3_create_module"] = function() {
  return (_sqlite3_create_module = Module["_sqlite3_create_module"] = Module["asm"]["sqlite3_create_module"]).apply(null, arguments);
};


var _sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = function() {
  return (_sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = Module["asm"]["sqlite3_create_module_v2"]).apply(null, arguments);
};


var _sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = function() {
  return (_sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = Module["asm"]["sqlite3_drop_modules"]).apply(null, arguments);
};


var _sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = function() {
  return (_sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = Module["asm"]["sqlite3_declare_vtab"]).apply(null, arguments);
};


var _sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = function() {
  return (_sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = Module["asm"]["sqlite3_vtab_on_conflict"]).apply(null, arguments);
};


var _sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = function() {
  return (_sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = Module["asm"]["sqlite3_vtab_collation"]).apply(null, arguments);
};


var _sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = function() {
  return (_sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = Module["asm"]["sqlite3_vtab_in"]).apply(null, arguments);
};


var _sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = function() {
  return (_sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = Module["asm"]["sqlite3_vtab_rhs_value"]).apply(null, arguments);
};


var _sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = function() {
  return (_sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = Module["asm"]["sqlite3_vtab_distinct"]).apply(null, arguments);
};


var _sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = function() {
  return (_sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = Module["asm"]["sqlite3_keyword_name"]).apply(null, arguments);
};


var _sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = function() {
  return (_sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = Module["asm"]["sqlite3_keyword_count"]).apply(null, arguments);
};


var _sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = function() {
  return (_sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = Module["asm"]["sqlite3_keyword_check"]).apply(null, arguments);
};


var _sqlite3_complete = Module["_sqlite3_complete"] = function() {
  return (_sqlite3_complete = Module["_sqlite3_complete"] = Module["asm"]["sqlite3_complete"]).apply(null, arguments);
};


var _sqlite3_libversion = Module["_sqlite3_libversion"] = function() {
  return (_sqlite3_libversion = Module["_sqlite3_libversion"] = Module["asm"]["sqlite3_libversion"]).apply(null, arguments);
};


var _sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = function() {
  return (_sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = Module["asm"]["sqlite3_libversion_number"]).apply(null, arguments);
};


var _sqlite3_shutdown = Module["_sqlite3_shutdown"] = function() {
  return (_sqlite3_shutdown = Module["_sqlite3_shutdown"] = Module["asm"]["sqlite3_shutdown"]).apply(null, arguments);
};


var _sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = function() {
  return (_sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = Module["asm"]["sqlite3_last_insert_rowid"]).apply(null, arguments);
};


var _sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = function() {
  return (_sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = Module["asm"]["sqlite3_set_last_insert_rowid"]).apply(null, arguments);
};


var _sqlite3_changes64 = Module["_sqlite3_changes64"] = function() {
  return (_sqlite3_changes64 = Module["_sqlite3_changes64"] = Module["asm"]["sqlite3_changes64"]).apply(null, arguments);
};


var _sqlite3_changes = Module["_sqlite3_changes"] = function() {
  return (_sqlite3_changes = Module["_sqlite3_changes"] = Module["asm"]["sqlite3_changes"]).apply(null, arguments);
};


var _sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = function() {
  return (_sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = Module["asm"]["sqlite3_total_changes64"]).apply(null, arguments);
};


var _sqlite3_total_changes = Module["_sqlite3_total_changes"] = function() {
  return (_sqlite3_total_changes = Module["_sqlite3_total_changes"] = Module["asm"]["sqlite3_total_changes"]).apply(null, arguments);
};


var _sqlite3_txn_state = Module["_sqlite3_txn_state"] = function() {
  return (_sqlite3_txn_state = Module["_sqlite3_txn_state"] = Module["asm"]["sqlite3_txn_state"]).apply(null, arguments);
};


var _sqlite3_close_v2 = Module["_sqlite3_close_v2"] = function() {
  return (_sqlite3_close_v2 = Module["_sqlite3_close_v2"] = Module["asm"]["sqlite3_close_v2"]).apply(null, arguments);
};


var _sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = function() {
  return (_sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = Module["asm"]["sqlite3_busy_handler"]).apply(null, arguments);
};


var _sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = function() {
  return (_sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = Module["asm"]["sqlite3_progress_handler"]).apply(null, arguments);
};


var _sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = function() {
  return (_sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = Module["asm"]["sqlite3_busy_timeout"]).apply(null, arguments);
};


var _sqlite3_create_function = Module["_sqlite3_create_function"] = function() {
  return (_sqlite3_create_function = Module["_sqlite3_create_function"] = Module["asm"]["sqlite3_create_function"]).apply(null, arguments);
};


var _sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = function() {
  return (_sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = Module["asm"]["sqlite3_create_function_v2"]).apply(null, arguments);
};


var _sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = function() {
  return (_sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = Module["asm"]["sqlite3_create_window_function"]).apply(null, arguments);
};


var _sqlite3_overload_function = Module["_sqlite3_overload_function"] = function() {
  return (_sqlite3_overload_function = Module["_sqlite3_overload_function"] = Module["asm"]["sqlite3_overload_function"]).apply(null, arguments);
};


var _sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = function() {
  return (_sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = Module["asm"]["sqlite3_trace_v2"]).apply(null, arguments);
};


var _sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = function() {
  return (_sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = Module["asm"]["sqlite3_commit_hook"]).apply(null, arguments);
};


var _sqlite3_update_hook = Module["_sqlite3_update_hook"] = function() {
  return (_sqlite3_update_hook = Module["_sqlite3_update_hook"] = Module["asm"]["sqlite3_update_hook"]).apply(null, arguments);
};


var _sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = function() {
  return (_sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = Module["asm"]["sqlite3_rollback_hook"]).apply(null, arguments);
};


var _sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = function() {
  return (_sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = Module["asm"]["sqlite3_preupdate_hook"]).apply(null, arguments);
};


var _sqlite3_error_offset = Module["_sqlite3_error_offset"] = function() {
  return (_sqlite3_error_offset = Module["_sqlite3_error_offset"] = Module["asm"]["sqlite3_error_offset"]).apply(null, arguments);
};


var _sqlite3_errcode = Module["_sqlite3_errcode"] = function() {
  return (_sqlite3_errcode = Module["_sqlite3_errcode"] = Module["asm"]["sqlite3_errcode"]).apply(null, arguments);
};


var _sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = function() {
  return (_sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = Module["asm"]["sqlite3_extended_errcode"]).apply(null, arguments);
};


var _sqlite3_errstr = Module["_sqlite3_errstr"] = function() {
  return (_sqlite3_errstr = Module["_sqlite3_errstr"] = Module["asm"]["sqlite3_errstr"]).apply(null, arguments);
};


var _sqlite3_limit = Module["_sqlite3_limit"] = function() {
  return (_sqlite3_limit = Module["_sqlite3_limit"] = Module["asm"]["sqlite3_limit"]).apply(null, arguments);
};


var _sqlite3_open = Module["_sqlite3_open"] = function() {
  return (_sqlite3_open = Module["_sqlite3_open"] = Module["asm"]["sqlite3_open"]).apply(null, arguments);
};


var _sqlite3_open_v2 = Module["_sqlite3_open_v2"] = function() {
  return (_sqlite3_open_v2 = Module["_sqlite3_open_v2"] = Module["asm"]["sqlite3_open_v2"]).apply(null, arguments);
};


var _sqlite3_create_collation = Module["_sqlite3_create_collation"] = function() {
  return (_sqlite3_create_collation = Module["_sqlite3_create_collation"] = Module["asm"]["sqlite3_create_collation"]).apply(null, arguments);
};


var _sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = function() {
  return (_sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = Module["asm"]["sqlite3_create_collation_v2"]).apply(null, arguments);
};


var _sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = function() {
  return (_sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = Module["asm"]["sqlite3_collation_needed"]).apply(null, arguments);
};


var _sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = function() {
  return (_sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = Module["asm"]["sqlite3_get_autocommit"]).apply(null, arguments);
};


var _sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = function() {
  return (_sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = Module["asm"]["sqlite3_table_column_metadata"]).apply(null, arguments);
};


var _sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = function() {
  return (_sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = Module["asm"]["sqlite3_extended_result_codes"]).apply(null, arguments);
};


var _sqlite3_uri_key = Module["_sqlite3_uri_key"] = function() {
  return (_sqlite3_uri_key = Module["_sqlite3_uri_key"] = Module["asm"]["sqlite3_uri_key"]).apply(null, arguments);
};


var _sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = function() {
  return (_sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = Module["asm"]["sqlite3_uri_int64"]).apply(null, arguments);
};


var _sqlite3_db_name = Module["_sqlite3_db_name"] = function() {
  return (_sqlite3_db_name = Module["_sqlite3_db_name"] = Module["asm"]["sqlite3_db_name"]).apply(null, arguments);
};


var _sqlite3_db_filename = Module["_sqlite3_db_filename"] = function() {
  return (_sqlite3_db_filename = Module["_sqlite3_db_filename"] = Module["asm"]["sqlite3_db_filename"]).apply(null, arguments);
};


var _sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = function() {
  return (_sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = Module["asm"]["sqlite3_compileoption_used"]).apply(null, arguments);
};


var _sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = function() {
  return (_sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = Module["asm"]["sqlite3_compileoption_get"]).apply(null, arguments);
};


var _sqlite3session_diff = Module["_sqlite3session_diff"] = function() {
  return (_sqlite3session_diff = Module["_sqlite3session_diff"] = Module["asm"]["sqlite3session_diff"]).apply(null, arguments);
};


var _sqlite3session_attach = Module["_sqlite3session_attach"] = function() {
  return (_sqlite3session_attach = Module["_sqlite3session_attach"] = Module["asm"]["sqlite3session_attach"]).apply(null, arguments);
};


var _sqlite3session_create = Module["_sqlite3session_create"] = function() {
  return (_sqlite3session_create = Module["_sqlite3session_create"] = Module["asm"]["sqlite3session_create"]).apply(null, arguments);
};


var _sqlite3session_delete = Module["_sqlite3session_delete"] = function() {
  return (_sqlite3session_delete = Module["_sqlite3session_delete"] = Module["asm"]["sqlite3session_delete"]).apply(null, arguments);
};


var _sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = function() {
  return (_sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = Module["asm"]["sqlite3session_table_filter"]).apply(null, arguments);
};


var _sqlite3session_changeset = Module["_sqlite3session_changeset"] = function() {
  return (_sqlite3session_changeset = Module["_sqlite3session_changeset"] = Module["asm"]["sqlite3session_changeset"]).apply(null, arguments);
};


var _sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = function() {
  return (_sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = Module["asm"]["sqlite3session_changeset_strm"]).apply(null, arguments);
};


var _sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = function() {
  return (_sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = Module["asm"]["sqlite3session_patchset_strm"]).apply(null, arguments);
};


var _sqlite3session_patchset = Module["_sqlite3session_patchset"] = function() {
  return (_sqlite3session_patchset = Module["_sqlite3session_patchset"] = Module["asm"]["sqlite3session_patchset"]).apply(null, arguments);
};


var _sqlite3session_enable = Module["_sqlite3session_enable"] = function() {
  return (_sqlite3session_enable = Module["_sqlite3session_enable"] = Module["asm"]["sqlite3session_enable"]).apply(null, arguments);
};


var _sqlite3session_indirect = Module["_sqlite3session_indirect"] = function() {
  return (_sqlite3session_indirect = Module["_sqlite3session_indirect"] = Module["asm"]["sqlite3session_indirect"]).apply(null, arguments);
};


var _sqlite3session_isempty = Module["_sqlite3session_isempty"] = function() {
  return (_sqlite3session_isempty = Module["_sqlite3session_isempty"] = Module["asm"]["sqlite3session_isempty"]).apply(null, arguments);
};


var _sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = function() {
  return (_sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = Module["asm"]["sqlite3session_memory_used"]).apply(null, arguments);
};


var _sqlite3session_object_config = Module["_sqlite3session_object_config"] = function() {
  return (_sqlite3session_object_config = Module["_sqlite3session_object_config"] = Module["asm"]["sqlite3session_object_config"]).apply(null, arguments);
};


var _sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = function() {
  return (_sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = Module["asm"]["sqlite3session_changeset_size"]).apply(null, arguments);
};


var _sqlite3changeset_start = Module["_sqlite3changeset_start"] = function() {
  return (_sqlite3changeset_start = Module["_sqlite3changeset_start"] = Module["asm"]["sqlite3changeset_start"]).apply(null, arguments);
};


var _sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = function() {
  return (_sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = Module["asm"]["sqlite3changeset_start_v2"]).apply(null, arguments);
};


var _sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = function() {
  return (_sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = Module["asm"]["sqlite3changeset_start_strm"]).apply(null, arguments);
};


var _sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = function() {
  return (_sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = Module["asm"]["sqlite3changeset_start_v2_strm"]).apply(null, arguments);
};


var _sqlite3changeset_next = Module["_sqlite3changeset_next"] = function() {
  return (_sqlite3changeset_next = Module["_sqlite3changeset_next"] = Module["asm"]["sqlite3changeset_next"]).apply(null, arguments);
};


var _sqlite3changeset_op = Module["_sqlite3changeset_op"] = function() {
  return (_sqlite3changeset_op = Module["_sqlite3changeset_op"] = Module["asm"]["sqlite3changeset_op"]).apply(null, arguments);
};


var _sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = function() {
  return (_sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = Module["asm"]["sqlite3changeset_pk"]).apply(null, arguments);
};


var _sqlite3changeset_old = Module["_sqlite3changeset_old"] = function() {
  return (_sqlite3changeset_old = Module["_sqlite3changeset_old"] = Module["asm"]["sqlite3changeset_old"]).apply(null, arguments);
};


var _sqlite3changeset_new = Module["_sqlite3changeset_new"] = function() {
  return (_sqlite3changeset_new = Module["_sqlite3changeset_new"] = Module["asm"]["sqlite3changeset_new"]).apply(null, arguments);
};


var _sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = function() {
  return (_sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = Module["asm"]["sqlite3changeset_conflict"]).apply(null, arguments);
};


var _sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = function() {
  return (_sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = Module["asm"]["sqlite3changeset_fk_conflicts"]).apply(null, arguments);
};


var _sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = function() {
  return (_sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = Module["asm"]["sqlite3changeset_finalize"]).apply(null, arguments);
};


var _sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = function() {
  return (_sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = Module["asm"]["sqlite3changeset_invert"]).apply(null, arguments);
};


var _sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = function() {
  return (_sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = Module["asm"]["sqlite3changeset_invert_strm"]).apply(null, arguments);
};


var _sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = function() {
  return (_sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = Module["asm"]["sqlite3changeset_apply_v2"]).apply(null, arguments);
};


var _sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = function() {
  return (_sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = Module["asm"]["sqlite3changeset_apply"]).apply(null, arguments);
};


var _sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = function() {
  return (_sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = Module["asm"]["sqlite3changeset_apply_v2_strm"]).apply(null, arguments);
};


var _sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = function() {
  return (_sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = Module["asm"]["sqlite3changeset_apply_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = function() {
  return (_sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = Module["asm"]["sqlite3changegroup_new"]).apply(null, arguments);
};


var _sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = function() {
  return (_sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = Module["asm"]["sqlite3changegroup_add"]).apply(null, arguments);
};


var _sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = function() {
  return (_sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = Module["asm"]["sqlite3changegroup_output"]).apply(null, arguments);
};


var _sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = function() {
  return (_sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = Module["asm"]["sqlite3changegroup_add_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = function() {
  return (_sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = Module["asm"]["sqlite3changegroup_output_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = function() {
  return (_sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = Module["asm"]["sqlite3changegroup_delete"]).apply(null, arguments);
};


var _sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = function() {
  return (_sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = Module["asm"]["sqlite3changeset_concat"]).apply(null, arguments);
};


var _sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = function() {
  return (_sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = Module["asm"]["sqlite3changeset_concat_strm"]).apply(null, arguments);
};


var _sqlite3session_config = Module["_sqlite3session_config"] = function() {
  return (_sqlite3session_config = Module["_sqlite3session_config"] = Module["asm"]["sqlite3session_config"]).apply(null, arguments);
};


var _sqlite3_sourceid = Module["_sqlite3_sourceid"] = function() {
  return (_sqlite3_sourceid = Module["_sqlite3_sourceid"] = Module["asm"]["sqlite3_sourceid"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_ptr = Module["_sqlite3_wasm_pstack_ptr"] = function() {
  return (_sqlite3_wasm_pstack_ptr = Module["_sqlite3_wasm_pstack_ptr"] = Module["asm"]["sqlite3_wasm_pstack_ptr"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_restore = Module["_sqlite3_wasm_pstack_restore"] = function() {
  return (_sqlite3_wasm_pstack_restore = Module["_sqlite3_wasm_pstack_restore"] = Module["asm"]["sqlite3_wasm_pstack_restore"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_alloc = Module["_sqlite3_wasm_pstack_alloc"] = function() {
  return (_sqlite3_wasm_pstack_alloc = Module["_sqlite3_wasm_pstack_alloc"] = Module["asm"]["sqlite3_wasm_pstack_alloc"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_remaining = Module["_sqlite3_wasm_pstack_remaining"] = function() {
  return (_sqlite3_wasm_pstack_remaining = Module["_sqlite3_wasm_pstack_remaining"] = Module["asm"]["sqlite3_wasm_pstack_remaining"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_quota = Module["_sqlite3_wasm_pstack_quota"] = function() {
  return (_sqlite3_wasm_pstack_quota = Module["_sqlite3_wasm_pstack_quota"] = Module["asm"]["sqlite3_wasm_pstack_quota"]).apply(null, arguments);
};


var _sqlite3_wasm_db_error = Module["_sqlite3_wasm_db_error"] = function() {
  return (_sqlite3_wasm_db_error = Module["_sqlite3_wasm_db_error"] = Module["asm"]["sqlite3_wasm_db_error"]).apply(null, arguments);
};


var _sqlite3_wasm_test_struct = Module["_sqlite3_wasm_test_struct"] = function() {
  return (_sqlite3_wasm_test_struct = Module["_sqlite3_wasm_test_struct"] = Module["asm"]["sqlite3_wasm_test_struct"]).apply(null, arguments);
};


var _sqlite3_wasm_enum_json = Module["_sqlite3_wasm_enum_json"] = function() {
  return (_sqlite3_wasm_enum_json = Module["_sqlite3_wasm_enum_json"] = Module["asm"]["sqlite3_wasm_enum_json"]).apply(null, arguments);
};


var _sqlite3_wasm_vfs_unlink = Module["_sqlite3_wasm_vfs_unlink"] = function() {
  return (_sqlite3_wasm_vfs_unlink = Module["_sqlite3_wasm_vfs_unlink"] = Module["asm"]["sqlite3_wasm_vfs_unlink"]).apply(null, arguments);
};


var _sqlite3_wasm_db_vfs = Module["_sqlite3_wasm_db_vfs"] = function() {
  return (_sqlite3_wasm_db_vfs = Module["_sqlite3_wasm_db_vfs"] = Module["asm"]["sqlite3_wasm_db_vfs"]).apply(null, arguments);
};


var _sqlite3_wasm_db_reset = Module["_sqlite3_wasm_db_reset"] = function() {
  return (_sqlite3_wasm_db_reset = Module["_sqlite3_wasm_db_reset"] = Module["asm"]["sqlite3_wasm_db_reset"]).apply(null, arguments);
};


var _sqlite3_wasm_db_export_chunked = Module["_sqlite3_wasm_db_export_chunked"] = function() {
  return (_sqlite3_wasm_db_export_chunked = Module["_sqlite3_wasm_db_export_chunked"] = Module["asm"]["sqlite3_wasm_db_export_chunked"]).apply(null, arguments);
};


var _sqlite3_wasm_db_serialize = Module["_sqlite3_wasm_db_serialize"] = function() {
  return (_sqlite3_wasm_db_serialize = Module["_sqlite3_wasm_db_serialize"] = Module["asm"]["sqlite3_wasm_db_serialize"]).apply(null, arguments);
};


var _sqlite3_wasm_vfs_create_file = Module["_sqlite3_wasm_vfs_create_file"] = function() {
  return (_sqlite3_wasm_vfs_create_file = Module["_sqlite3_wasm_vfs_create_file"] = Module["asm"]["sqlite3_wasm_vfs_create_file"]).apply(null, arguments);
};


var _sqlite3_wasm_posix_create_file = Module["_sqlite3_wasm_posix_create_file"] = function() {
  return (_sqlite3_wasm_posix_create_file = Module["_sqlite3_wasm_posix_create_file"] = Module["asm"]["sqlite3_wasm_posix_create_file"]).apply(null, arguments);
};


var _sqlite3_wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3_wasm_kvvfsMakeKeyOnPstack"] = function() {
  return (_sqlite3_wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3_wasm_kvvfsMakeKeyOnPstack"] = Module["asm"]["sqlite3_wasm_kvvfsMakeKeyOnPstack"]).apply(null, arguments);
};


var _sqlite3_wasm_kvvfs_methods = Module["_sqlite3_wasm_kvvfs_methods"] = function() {
  return (_sqlite3_wasm_kvvfs_methods = Module["_sqlite3_wasm_kvvfs_methods"] = Module["asm"]["sqlite3_wasm_kvvfs_methods"]).apply(null, arguments);
};


var _sqlite3_wasm_vtab_config = Module["_sqlite3_wasm_vtab_config"] = function() {
  return (_sqlite3_wasm_vtab_config = Module["_sqlite3_wasm_vtab_config"] = Module["asm"]["sqlite3_wasm_vtab_config"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_ip = Module["_sqlite3_wasm_db_config_ip"] = function() {
  return (_sqlite3_wasm_db_config_ip = Module["_sqlite3_wasm_db_config_ip"] = Module["asm"]["sqlite3_wasm_db_config_ip"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_pii = Module["_sqlite3_wasm_db_config_pii"] = function() {
  return (_sqlite3_wasm_db_config_pii = Module["_sqlite3_wasm_db_config_pii"] = Module["asm"]["sqlite3_wasm_db_config_pii"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_s = Module["_sqlite3_wasm_db_config_s"] = function() {
  return (_sqlite3_wasm_db_config_s = Module["_sqlite3_wasm_db_config_s"] = Module["asm"]["sqlite3_wasm_db_config_s"]).apply(null, arguments);
};


var _sqlite3_wasm_config_i = Module["_sqlite3_wasm_config_i"] = function() {
  return (_sqlite3_wasm_config_i = Module["_sqlite3_wasm_config_i"] = Module["asm"]["sqlite3_wasm_config_i"]).apply(null, arguments);
};


var _sqlite3_wasm_config_ii = Module["_sqlite3_wasm_config_ii"] = function() {
  return (_sqlite3_wasm_config_ii = Module["_sqlite3_wasm_config_ii"] = Module["asm"]["sqlite3_wasm_config_ii"]).apply(null, arguments);
};


var _sqlite3_wasm_config_j = Module["_sqlite3_wasm_config_j"] = function() {
  return (_sqlite3_wasm_config_j = Module["_sqlite3_wasm_config_j"] = Module["asm"]["sqlite3_wasm_config_j"]).apply(null, arguments);
};


var _sqlite3_wasm_init_wasmfs = Module["_sqlite3_wasm_init_wasmfs"] = function() {
  return (_sqlite3_wasm_init_wasmfs = Module["_sqlite3_wasm_init_wasmfs"] = Module["asm"]["sqlite3_wasm_init_wasmfs"]).apply(null, arguments);
};


var _sqlite3_wasm_test_intptr = Module["_sqlite3_wasm_test_intptr"] = function() {
  return (_sqlite3_wasm_test_intptr = Module["_sqlite3_wasm_test_intptr"] = Module["asm"]["sqlite3_wasm_test_intptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_voidptr = Module["_sqlite3_wasm_test_voidptr"] = function() {
  return (_sqlite3_wasm_test_voidptr = Module["_sqlite3_wasm_test_voidptr"] = Module["asm"]["sqlite3_wasm_test_voidptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_max = Module["_sqlite3_wasm_test_int64_max"] = function() {
  return (_sqlite3_wasm_test_int64_max = Module["_sqlite3_wasm_test_int64_max"] = Module["asm"]["sqlite3_wasm_test_int64_max"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_min = Module["_sqlite3_wasm_test_int64_min"] = function() {
  return (_sqlite3_wasm_test_int64_min = Module["_sqlite3_wasm_test_int64_min"] = Module["asm"]["sqlite3_wasm_test_int64_min"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_times2 = Module["_sqlite3_wasm_test_int64_times2"] = function() {
  return (_sqlite3_wasm_test_int64_times2 = Module["_sqlite3_wasm_test_int64_times2"] = Module["asm"]["sqlite3_wasm_test_int64_times2"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_minmax = Module["_sqlite3_wasm_test_int64_minmax"] = function() {
  return (_sqlite3_wasm_test_int64_minmax = Module["_sqlite3_wasm_test_int64_minmax"] = Module["asm"]["sqlite3_wasm_test_int64_minmax"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64ptr = Module["_sqlite3_wasm_test_int64ptr"] = function() {
  return (_sqlite3_wasm_test_int64ptr = Module["_sqlite3_wasm_test_int64ptr"] = Module["asm"]["sqlite3_wasm_test_int64ptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_stack_overflow = Module["_sqlite3_wasm_test_stack_overflow"] = function() {
  return (_sqlite3_wasm_test_stack_overflow = Module["_sqlite3_wasm_test_stack_overflow"] = Module["asm"]["sqlite3_wasm_test_stack_overflow"]).apply(null, arguments);
};


var _sqlite3_wasm_test_str_hello = Module["_sqlite3_wasm_test_str_hello"] = function() {
  return (_sqlite3_wasm_test_str_hello = Module["_sqlite3_wasm_test_str_hello"] = Module["asm"]["sqlite3_wasm_test_str_hello"]).apply(null, arguments);
};


var _sqlite3_wasm_SQLTester_strglob = Module["_sqlite3_wasm_SQLTester_strglob"] = function() {
  return (_sqlite3_wasm_SQLTester_strglob = Module["_sqlite3_wasm_SQLTester_strglob"] = Module["asm"]["sqlite3_wasm_SQLTester_strglob"]).apply(null, arguments);
};


var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};


var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};


var _realloc = Module["_realloc"] = function() {
  return (_realloc = Module["_realloc"] = Module["asm"]["realloc"]).apply(null, arguments);
};


var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
  return (_emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = Module["asm"]["emscripten_builtin_memalign"]).apply(null, arguments);
};


var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};


var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};


var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};







Module["wasmMemory"] = wasmMemory;


var calledRun;

dependenciesFulfilled = function runCaller() {
  
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; 
};


function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    
    
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();





if(!Module.postRun) Module.postRun = [];
Module.postRun.push(function(Module){
  'use strict';
  










'use strict';
globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(
  apiConfig = (globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig)
){
  if(sqlite3ApiBootstrap.sqlite3){ 
    console.warn("sqlite3ApiBootstrap() called multiple times.",
                 "Config and external initializers are ignored on calls after the first.");
    return sqlite3ApiBootstrap.sqlite3;
  }
  const config = Object.assign(Object.create(null),{
    exports: undefined,
    memory: undefined,
    bigIntEnabled: (()=>{
      if('undefined'!==typeof Module){
        
        return !!Module.HEAPU64;
      }
      return !!globalThis.BigInt64Array;
    })(),
    debug: console.debug.bind(console),
    warn: console.warn.bind(console),
    error: console.error.bind(console),
    log: console.log.bind(console),
    wasmfsOpfsDir: '/opfs',
    
    useStdAlloc: false
  }, apiConfig || {});

  Object.assign(config, {
    allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',
    deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',
    reallocExportName: config.useStdAlloc ? 'realloc' : 'sqlite3_realloc'
  }, config);

  [
    
    
    'exports', 'memory', 'wasmfsOpfsDir'
  ].forEach((k)=>{
    if('function' === typeof config[k]){
      config[k] = config[k]();
    }
  });
  
  const capi = Object.create(null);
  
  const wasm = Object.create(null);

  
  const __rcStr = (rc)=>{
    return (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc))
           || ("Unknown result code #"+rc);
  };

  
  const __isInt = (n)=>'number'===typeof n && n===(n | 0);

  
  class SQLite3Error extends Error {
    
    constructor(...args){
      let rc;
      if(args.length){
        if(__isInt(args[0])){
          rc = args[0];
          if(1===args.length){
            super(__rcStr(args[0]));
          }else{
            const rcStr = __rcStr(rc);
            if('object'===typeof args[1]){
              super(rcStr,args[1]);
            }else{
              args[0] = rcStr+':';
              super(args.join(' '));
            }
          }
        }else{
          if(2===args.length && 'object'===typeof args[1]){
            super(...args);
          }else{
            super(args.join(' '));
          }
        }
      }
      this.resultCode = rc || capi.SQLITE_ERROR;
      this.name = 'SQLite3Error';
    }
  };

  
  SQLite3Error.toss = (...args)=>{
    throw new SQLite3Error(...args);
  };
  const toss3 = SQLite3Error.toss;

  if(config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)){
    toss3("config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.");
  }

  
  const isInt32 = (n)=>{
    return ('bigint'!==typeof n )
      && !!(n===(n|0) && n<=2147483647 && n>=-2147483648);
  };
  
  const bigIntFits64 = function f(b){
    if(!f._max){
      f._max = BigInt("0x7fffffffffffffff");
      f._min = ~f._max;
    }
    return b >= f._min && b <= f._max;
  };

  
  const bigIntFits32 = (b)=>(b >= (-0x7fffffffn - 1n) && b <= 0x7fffffffn);

  
  const bigIntFitsDouble = function f(b){
    if(!f._min){
      f._min = Number.MIN_SAFE_INTEGER;
      f._max = Number.MAX_SAFE_INTEGER;
    }
    return b >= f._min && b <= f._max;
  };

  
  const isTypedArray = (v)=>{
    return (v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)) ? v : false;
  };


  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  
  const isSharedTypedArray = (aTypedArray)=>(aTypedArray.buffer instanceof __SAB);

  
  const typedArrayPart = (aTypedArray, begin, end)=>{
    return isSharedTypedArray(aTypedArray)
      ? aTypedArray.slice(begin, end)
      : aTypedArray.subarray(begin, end);
  };

  
  const isBindableTypedArray = (v)=>{
    return v && (v instanceof Uint8Array
                 || v instanceof Int8Array
                 || v instanceof ArrayBuffer);
  };

  
  const isSQLableTypedArray = (v)=>{
    return v && (v instanceof Uint8Array
                 || v instanceof Int8Array
                 || v instanceof ArrayBuffer);
  };

  
  const affirmBindableTypedArray = (v)=>{
    return isBindableTypedArray(v)
      || toss3("Value is not of a supported TypedArray type.");
  };

  const utf8Decoder = new TextDecoder('utf-8');

  
  const typedArrayToString = function(typedArray, begin, end){
    return utf8Decoder.decode(typedArrayPart(typedArray, begin,end));
  };

  
  const flexibleString = function(v){
    if(isSQLableTypedArray(v)){
      return typedArrayToString(
        (v instanceof ArrayBuffer) ? new Uint8Array(v) : v
      );
    }
    else if(Array.isArray(v)) return v.join("");
    else if(wasm.isPtr(v)) v = wasm.cstrToJs(v);
    return v;
  };

  
  class WasmAllocError extends Error {
    
    constructor(...args){
      if(2===args.length && 'object'===typeof args[1]){
        super(...args);
      }else if(args.length){
        super(args.join(' '));
      }else{
        super("Allocation failed.");
      }
      this.resultCode = capi.SQLITE_NOMEM;
      this.name = 'WasmAllocError';
    }
  };
  
  WasmAllocError.toss = (...args)=>{
    throw new WasmAllocError(...args);
  };

  Object.assign(capi, {
    
    sqlite3_bind_blob: undefined,

    
    sqlite3_bind_text: undefined,

    
    sqlite3_create_function_v2: (
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal, xDestroy
    )=>{},
    
    sqlite3_create_function: (
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal
    )=>{},
    
    sqlite3_create_window_function: (
      pDb, funcName, nArg, eTextRep, pApp,
      xStep, xFinal, xValue, xInverse, xDestroy
    )=>{},
    
    sqlite3_prepare_v3: (dbPtr, sql, sqlByteLen, prepFlags,
                         stmtPtrPtr, strPtrPtr)=>{},

    
    sqlite3_prepare_v2: (dbPtr, sql, sqlByteLen,
                         stmtPtrPtr,strPtrPtr)=>{},

    
    sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg)=>{},

    
    sqlite3_randomness: (n, outPtr)=>{},
  });

  
  const util = {
    affirmBindableTypedArray, flexibleString,
    bigIntFits32, bigIntFits64, bigIntFitsDouble,
    isBindableTypedArray,
    isInt32, isSQLableTypedArray, isTypedArray,
    typedArrayToString,
    isUIThread: ()=>(globalThis.window===globalThis && !!globalThis.document),
    
    isSharedTypedArray,
    toss: function(...args){throw new Error(args.join(' '))},
    toss3,
    typedArrayPart,
    
    affirmDbHeader: function(bytes){
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      const header = "SQLite format 3";
      if( header.length > bytes.byteLength ){
        toss3("Input does not contain an SQLite3 database header.");
      }
      for(let i = 0; i < header.length; ++i){
        if( header.charCodeAt(i) !== bytes[i] ){
          toss3("Input does not contain an SQLite3 database header.");
        }
      }
    },
    
    affirmIsDb: function(bytes){
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      const n = bytes.byteLength;
      if(n<512 || n%512!==0) {
        toss3("Byte array size",n,"is invalid for an SQLite3 db.");
      }
      util.affirmDbHeader(bytes);
    }
  };

  Object.assign(wasm, {
    
    ptrSizeof: config.wasmPtrSizeof || 4,
    
    ptrIR: config.wasmPtrIR || "i32",
    
    bigIntEnabled: !!config.bigIntEnabled,
    
    exports: config.exports
      || toss3("Missing API config.exports (WASM module exports)."),

    
    memory: config.memory || config.exports['memory']
      || toss3("API config object requires a WebAssembly.Memory object",
              "in either config.exports.memory (exported)",
              "or config.memory (imported)."),

    
    alloc: undefined,

    
    realloc: undefined,

    
    dealloc: undefined

    
  });

  
  wasm.allocFromTypedArray = function(srcTypedArray){
    if(srcTypedArray instanceof ArrayBuffer){
      srcTypedArray = new Uint8Array(srcTypedArray);
    }
    affirmBindableTypedArray(srcTypedArray);
    const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
    wasm.heapForSize(srcTypedArray.constructor).set(
      srcTypedArray.byteLength ? srcTypedArray : [0], pRet
    );
    return pRet;
  };

  {
    
    const keyAlloc = config.allocExportName,
          keyDealloc = config.deallocExportName,
          keyRealloc = config.reallocExportName;
    for(const key of [keyAlloc, keyDealloc, keyRealloc]){
      const f = wasm.exports[key];
      if(!(f instanceof Function)) toss3("Missing required exports[",key,"] function.");
    }

    wasm.alloc = function f(n){
      return f.impl(n) || WasmAllocError.toss("Failed to allocate",n," bytes.");
    };
    wasm.alloc.impl = wasm.exports[keyAlloc];
    wasm.realloc = function f(m,n){
      const m2 = f.impl(m,n);
      return n ? (m2 || WasmAllocError.toss("Failed to reallocate",n," bytes.")) : 0;
    };
    wasm.realloc.impl = wasm.exports[keyRealloc];
    wasm.dealloc = wasm.exports[keyDealloc];
  }

  
  wasm.compileOptionUsed = function f(optName){
    if(!arguments.length){
      if(f._result) return f._result;
      else if(!f._opt){
        f._rx = /^([^=]+)=(.+)/;
        f._rxInt = /^-?\d+$/;
        f._opt = function(opt, rv){
          const m = f._rx.exec(opt);
          rv[0] = (m ? m[1] : opt);
          rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;
        };
      }
      const rc = {}, ov = [0,0];
      let i = 0, k;
      while((k = capi.sqlite3_compileoption_get(i++))){
        f._opt(k,ov);
        rc[ov[0]] = ov[1];
      }
      return f._result = rc;
    }else if(Array.isArray(optName)){
      const rc = {};
      optName.forEach((v)=>{
        rc[v] = capi.sqlite3_compileoption_used(v);
      });
      return rc;
    }else if('object' === typeof optName){
      Object.keys(optName).forEach((k)=> {
        optName[k] = capi.sqlite3_compileoption_used(k);
      });
      return optName;
    }
    return (
      'string'===typeof optName
    ) ? !!capi.sqlite3_compileoption_used(optName) : false;
  };

  
  wasm.pstack = Object.assign(Object.create(null),{
    
    restore: wasm.exports.sqlite3_wasm_pstack_restore,
    
    alloc: function(n){
      if('string'===typeof n && !(n = wasm.sizeofIR(n))){
        WasmAllocError.toss("Invalid value for pstack.alloc(",arguments[0],")");
      }
      return wasm.exports.sqlite3_wasm_pstack_alloc(n)
        || WasmAllocError.toss("Could not allocate",n,
                               "bytes from the pstack.");
    },
    
    allocChunks: function(n,sz){
      if('string'===typeof sz && !(sz = wasm.sizeofIR(sz))){
        WasmAllocError.toss("Invalid size value for allocChunks(",arguments[1],")");
      }
      const mem = wasm.pstack.alloc(n * sz);
      const rc = [];
      let i = 0, offset = 0;
      for(; i < n; ++i, offset += sz) rc.push(mem + offset);
      return rc;
    },
    
    allocPtr: (n=1,safePtrSize=true)=>{
      return 1===n
        ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)
        : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);
    },

    
    call: function(f){
      const stackPos = wasm.pstack.pointer;
      try{ return f(sqlite3) } finally{
        wasm.pstack.restore(stackPos);
      }
    }

  });
  Object.defineProperties(wasm.pstack, {
    
    pointer: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_ptr
      
      
      
    },
    
    quota: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_quota
    },
    
    remaining: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_remaining
    }
  });

  capi.sqlite3_randomness = (...args)=>{
    if(1===args.length && util.isTypedArray(args[0])
      && 1===args[0].BYTES_PER_ELEMENT){
      const ta = args[0];
      if(0===ta.byteLength){
        wasm.exports.sqlite3_randomness(0,0);
        return ta;
      }
      const stack = wasm.pstack.pointer;
      try {
        let n = ta.byteLength, offset = 0;
        const r = wasm.exports.sqlite3_randomness;
        const heap = wasm.heap8u();
        const nAlloc = n < 512 ? n : 512;
        const ptr = wasm.pstack.alloc(nAlloc);
        do{
          const j = (n>nAlloc ? nAlloc : n);
          r(j, ptr);
          ta.set(typedArrayPart(heap, ptr, ptr+j), offset);
          n -= j;
          offset += j;
        } while(n > 0);
      }catch(e){
        console.error("Highly unexpected (and ignored!) "+
                      "exception in sqlite3_randomness():",e);
      }finally{
        wasm.pstack.restore(stack);
      }
      return ta;
    }
    wasm.exports.sqlite3_randomness(...args);
  };

  
  let __wasmfsOpfsDir = undefined;
  
  capi.sqlite3_wasmfs_opfs_dir = function(){
    if(undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;
    
    const pdir = config.wasmfsOpfsDir;
    if(!pdir
       || !globalThis.FileSystemHandle
       || !globalThis.FileSystemDirectoryHandle
       || !globalThis.FileSystemFileHandle){
      return __wasmfsOpfsDir = "";
    }
    try{
      if(pdir && 0===wasm.xCallWrapped(
        'sqlite3_wasm_init_wasmfs', 'i32', ['string'], pdir
      )){
        return __wasmfsOpfsDir = pdir;
      }else{
        return __wasmfsOpfsDir = "";
      }
    }catch(e){
      
      return __wasmfsOpfsDir = "";
    }
  };

  
  capi.sqlite3_wasmfs_filename_is_persistent = function(name){
    const p = capi.sqlite3_wasmfs_opfs_dir();
    return (p && name) ? name.startsWith(p+'/') : false;
  };

  
  capi.sqlite3_js_db_uses_vfs = function(pDb,vfsName,dbName=0){
    try{
      const pK = capi.sqlite3_vfs_find(vfsName);
      if(!pK) return false;
      else if(!pDb){
        return pK===capi.sqlite3_vfs_find(0) ? pK : false;
      }else{
        return pK===capi.sqlite3_js_db_vfs(pDb,dbName) ? pK : false;
      }
    }catch(e){
      
      return false;
    }
  };

  
  capi.sqlite3_js_vfs_list = function(){
    const rc = [];
    let pVfs = capi.sqlite3_vfs_find(0);
    while(pVfs){
      const oVfs = new capi.sqlite3_vfs(pVfs);
      rc.push(wasm.cstrToJs(oVfs.$zName));
      pVfs = oVfs.$pNext;
      oVfs.dispose();
    }
    return rc;
  };

  
  capi.sqlite3_js_db_export = function(pDb, schema=0){
    pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);
    if(!pDb) toss3('Invalid sqlite3* argument.');
    if(!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');
    const scope = wasm.scopedAllocPush();
    let pOut;
    try{
      const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
      const ppOut = pSize + 8;
      
      const zSchema = schema
            ? (wasm.isPtr(schema) ? schema : wasm.scopedAllocCString(''+schema))
            : 0;
      let rc = wasm.exports.sqlite3_wasm_db_serialize(
        pDb, zSchema, ppOut, pSize, 0
      );
      if(rc){
        toss3("Database serialization failed with code",
             sqlite3.capi.sqlite3_js_rc_str(rc));
      }
      pOut = wasm.peekPtr(ppOut);
      const nOut = wasm.peek(pSize, 'i64');
      rc = nOut
        ? wasm.heap8u().slice(pOut, pOut + Number(nOut))
        : new Uint8Array();
      return rc;
    }finally{
      if(pOut) wasm.exports.sqlite3_free(pOut);
      wasm.scopedAllocPop(scope);
    }
  };

  
  capi.sqlite3_js_db_vfs =
    (dbPointer, dbName=0)=>wasm.sqlite3_wasm_db_vfs(dbPointer, dbName);

  
  capi.sqlite3_js_aggregate_context = (pCtx, n)=>{
    return capi.sqlite3_aggregate_context(pCtx, n)
      || (n ? WasmAllocError.toss("Cannot allocate",n,
                                  "bytes for sqlite3_aggregate_context()")
          : 0);
  };

  
  capi.sqlite3_js_posix_create_file = function(filename, data, dataLen){
    let pData;
    if(data && wasm.isPtr(data)){
      pData = data;
    }else if(data instanceof ArrayBuffer || data instanceof Uint8Array){
      pData = wasm.allocFromTypedArray(data);
      if(arguments.length<3 || !util.isInt32(dataLen) || dataLen<0){
        dataLen = data.byteLength;
      }
    }else{
      SQLite3Error.toss("Invalid 2nd argument for sqlite3_js_posix_create_file().");
    }
    try{
      if(!util.isInt32(dataLen) || dataLen<0){
        SQLite3Error.toss("Invalid 3rd argument for sqlite3_js_posix_create_file().");
      }
      const rc = wasm.sqlite3_wasm_posix_create_file(filename, pData, dataLen);
      if(rc) SQLite3Error.toss("Creation of file failed with sqlite3 result code",
                               capi.sqlite3_js_rc_str(rc));
    }finally{
       wasm.dealloc(pData);
    }
  };

  
  capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen){
    config.warn("sqlite3_js_vfs_create_file() is deprecated and",
                "should be avoided because it can lead to C-level crashes.",
                "See its documentation for alternative options.");
    let pData;
    if(data){
      if(wasm.isPtr(data)){
        pData = data;
      }else if(data instanceof ArrayBuffer){
        data = new Uint8Array(data);
      }
      if(data instanceof Uint8Array){
        pData = wasm.allocFromTypedArray(data);
        if(arguments.length<4 || !util.isInt32(dataLen) || dataLen<0){
          dataLen = data.byteLength;
        }
      }else{
        SQLite3Error.toss("Invalid 3rd argument type for sqlite3_js_vfs_create_file().");
      }
    }else{
       pData = 0;
    }
    if(!util.isInt32(dataLen) || dataLen<0){
      wasm.dealloc(pData);
      SQLite3Error.toss("Invalid 4th argument for sqlite3_js_vfs_create_file().");
    }
    try{
      const rc = wasm.sqlite3_wasm_vfs_create_file(vfs, filename, pData, dataLen);
      if(rc) SQLite3Error.toss("Creation of file failed with sqlite3 result code",
                               capi.sqlite3_js_rc_str(rc));
    }finally{
       wasm.dealloc(pData);
    }
  };

  
  capi.sqlite3_js_sql_to_string = (sql)=>{
    if('string' === typeof sql){
      return sql;
    }
    const x = flexibleString(v);
    return x===v ? undefined : x;
  }

  if( util.isUIThread() ){
    

    
    const __kvvfsInfo = function(which){
      const rc = Object.create(null);
      rc.prefix = 'kvvfs-'+which;
      rc.stores = [];
      if('session'===which || ""===which) rc.stores.push(globalThis.sessionStorage);
      if('local'===which || ""===which) rc.stores.push(globalThis.localStorage);
      return rc;
    };

    
    capi.sqlite3_js_kvvfs_clear = function(which=""){
      let rc = 0;
      const kvinfo = __kvvfsInfo(which);
      kvinfo.stores.forEach((s)=>{
        const toRm = [] ;
        let i;
        for( i = 0; i < s.length; ++i ){
          const k = s.key(i);
          if(k.startsWith(kvinfo.prefix)) toRm.push(k);
        }
        toRm.forEach((kk)=>s.removeItem(kk));
        rc += toRm.length;
      });
      return rc;
    };

    
    capi.sqlite3_js_kvvfs_size = function(which=""){
      let sz = 0;
      const kvinfo = __kvvfsInfo(which);
      kvinfo.stores.forEach((s)=>{
        let i;
        for(i = 0; i < s.length; ++i){
          const k = s.key(i);
          if(k.startsWith(kvinfo.prefix)){
            sz += k.length;
            sz += s.getItem(k).length;
          }
        }
      });
      return sz * 2 ;
    };

  }

  
  capi.sqlite3_db_config = function(pDb, op, ...args){
    if(!this.s){
      this.s = wasm.xWrap('sqlite3_wasm_db_config_s','int',
                          ['sqlite3*', 'int', 'string:static']
                          );
      this.pii = wasm.xWrap('sqlite3_wasm_db_config_pii', 'int',
                            ['sqlite3*', 'int', '*','int', 'int']);
      this.ip = wasm.xWrap('sqlite3_wasm_db_config_ip','int',
                           ['sqlite3*', 'int', 'int','*']);
    }
    switch(op){
        case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
        case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
        case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
        case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
        case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
        case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
        case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
        case capi.SQLITE_DBCONFIG_RESET_DATABASE:
        case capi.SQLITE_DBCONFIG_DEFENSIVE:
        case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
        case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
        case capi.SQLITE_DBCONFIG_DQS_DML:
        case capi.SQLITE_DBCONFIG_DQS_DDL:
        case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
        case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
        case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
        case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
        case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
          return this.ip(pDb, op, args[0], args[1] || 0);
        case capi.SQLITE_DBCONFIG_LOOKASIDE:
          return this.pii(pDb, op, args[0], args[1], args[2]);
        case capi.SQLITE_DBCONFIG_MAINDBNAME:
          return this.s(pDb, op, args[0]);
        default:
          return capi.SQLITE_MISUSE;
    }
  }.bind(Object.create(null));

  
  capi.sqlite3_value_to_js = function(pVal,throwIfCannotConvert=true){
    let arg;
    const valType = capi.sqlite3_value_type(pVal);
    switch(valType){
        case capi.SQLITE_INTEGER:
          if(wasm.bigIntEnabled){
            arg = capi.sqlite3_value_int64(pVal);
            if(util.bigIntFitsDouble(arg)) arg = Number(arg);
          }
          else arg = capi.sqlite3_value_double(pVal);
          break;
        case capi.SQLITE_FLOAT:
          arg = capi.sqlite3_value_double(pVal);
          break;
        case capi.SQLITE_TEXT:
          arg = capi.sqlite3_value_text(pVal);
          break;
        case capi.SQLITE_BLOB:{
          const n = capi.sqlite3_value_bytes(pVal);
          const pBlob = capi.sqlite3_value_blob(pVal);
          if(n && !pBlob) sqlite3.WasmAllocError.toss(
            "Cannot allocate memory for blob argument of",n,"byte(s)"
          );
          arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;
          break;
        }
        case capi.SQLITE_NULL:
          arg = null; break;
        default:
          if(throwIfCannotConvert){
            toss3(capi.SQLITE_MISMATCH,
                  "Unhandled sqlite3_value_type():",valType);
          }
          arg = undefined;
    }
    return arg;
  };

  
  capi.sqlite3_values_to_js = function(argc,pArgv,throwIfCannotConvert=true){
    let i;
    const tgt = [];
    for(i = 0; i < argc; ++i){
      
      tgt.push(capi.sqlite3_value_to_js(
        wasm.peekPtr(pArgv + (wasm.ptrSizeof * i)),
        throwIfCannotConvert
      ));
    }
    return tgt;
  };

  
  capi.sqlite3_result_error_js = function(pCtx,e){
    if(e instanceof WasmAllocError){
      capi.sqlite3_result_error_nomem(pCtx);
    }else{
      ;
      capi.sqlite3_result_error(pCtx, ''+e, -1);
    }
  };

  
  capi.sqlite3_result_js = function(pCtx,val){
    if(val instanceof Error){
      capi.sqlite3_result_error_js(pCtx, val);
      return;
    }
    try{
      switch(typeof val) {
          case 'undefined':
            
            break;
          case 'boolean':
            capi.sqlite3_result_int(pCtx, val ? 1 : 0);
            break;
          case 'bigint':
            if(util.bigIntFits32(val)){
              capi.sqlite3_result_int(pCtx, Number(val));
            }else if(util.bigIntFitsDouble(val)){
              capi.sqlite3_result_double(pCtx, Number(val));
            }else if(wasm.bigIntEnabled){
              if(util.bigIntFits64(val)) capi.sqlite3_result_int64(pCtx, val);
              else toss3("BigInt value",val.toString(),"is too BigInt for int64.");
            }else{
              toss3("BigInt value",val.toString(),"is too BigInt.");
            }
            break;
          case 'number': {
            let f;
            if(util.isInt32(val)){
              f = capi.sqlite3_result_int;
            }else if(wasm.bigIntEnabled
                     && Number.isInteger(val)
                     && util.bigIntFits64(BigInt(val))){
              f = capi.sqlite3_result_int64;
            }else{
              f = capi.sqlite3_result_double;
            }
            f(pCtx, val);
            break;
          }
          case 'string': {
            const [p, n] = wasm.allocCString(val,true);
            capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);
            break;
          }
          case 'object':
            if(null===val) {
              capi.sqlite3_result_null(pCtx);
              break;
            }else if(util.isBindableTypedArray(val)){
              const pBlob = wasm.allocFromTypedArray(val);
              capi.sqlite3_result_blob(
                pCtx, pBlob, val.byteLength,
                capi.SQLITE_WASM_DEALLOC
              );
              break;
            }
            
          default:
            toss3("Don't not how to handle this UDF result value:",(typeof val), val);
      }
    }catch(e){
      capi.sqlite3_result_error_js(pCtx, e);
    }
  };

  
  capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert=true){
    const v = capi.sqlite3_column_value(pStmt, iCol);
    return (0===v) ? undefined : capi.sqlite3_value_to_js(v, throwIfCannotConvert);
  };

  
  const __newOldValue = function(pObj, iCol, impl){
    impl = capi[impl];
    if(!this.ptr) this.ptr = wasm.allocPtr();
    else wasm.pokePtr(this.ptr, 0);
    const rc = impl(pObj, iCol, this.ptr);
    if(rc) return SQLite3Error.toss(rc,arguments[2]+"() failed with code "+rc);
    const pv = wasm.peekPtr(this.ptr);
    return pv ? capi.sqlite3_value_to_js( pv, true ) : undefined;
  }.bind(Object.create(null));

  
  capi.sqlite3_preupdate_new_js =
    (pDb, iCol)=>__newOldValue(pDb, iCol, 'sqlite3_preupdate_new');

  
  capi.sqlite3_preupdate_old_js =
    (pDb, iCol)=>__newOldValue(pDb, iCol, 'sqlite3_preupdate_old');

  
  capi.sqlite3changeset_new_js =
    (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol,
                                            'sqlite3changeset_new');

  
  capi.sqlite3changeset_old_js =
    (pChangesetIter, iCol)=>__newOldValue(pChangesetIter, iCol,
                                          'sqlite3changeset_old');

  
  const sqlite3 = {
    WasmAllocError: WasmAllocError,
    SQLite3Error: SQLite3Error,
    capi,
    util,
    wasm,
    config,
    
    version: Object.create(null),

    
    client: undefined,

    
    asyncPostInit: async function ff(){
      if(ff.isReady instanceof Promise) return ff.isReady;
      let lia = sqlite3ApiBootstrap.initializersAsync;
      delete sqlite3ApiBootstrap.initializersAsync;
      const postInit = async ()=>{
        if(!sqlite3.__isUnderTest){
          
          delete sqlite3.util;
          
          delete sqlite3.StructBinder;
        }
        return sqlite3;
      };
      const catcher = (e)=>{
        config.error("an async sqlite3 initializer failed:",e);
        throw e;
      };
      if(!lia || !lia.length){
        return ff.isReady = postInit().catch(catcher);
      }
      lia = lia.map((f)=>{
        return (f instanceof Function) ? async x=>f(sqlite3) : f;
      });
      lia.push(postInit);
      let p = Promise.resolve(sqlite3);
      while(lia.length) p = p.then(lia.shift());
      return ff.isReady = p.catch(catcher);
    },
    
    scriptInfo: undefined
  };
  try{
    sqlite3ApiBootstrap.initializers.forEach((f)=>{
      f(sqlite3);
    });
  }catch(e){
    
    console.error("sqlite3 bootstrap initializer threw:",e);
    throw e;
  }
  delete sqlite3ApiBootstrap.initializers;
  sqlite3ApiBootstrap.sqlite3 = sqlite3;
  return sqlite3;
};

globalThis.sqlite3ApiBootstrap.initializers = [];

globalThis.sqlite3ApiBootstrap.initializersAsync = [];

globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);

globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;




globalThis.WhWasmUtilInstaller = function(target){
  'use strict';
  if(undefined===target.bigIntEnabled){
    target.bigIntEnabled = !!globalThis['BigInt64Array'];
  }

  
  const toss = (...args)=>{throw new Error(args.join(' '))};

  if(!target.exports){
    Object.defineProperty(target, 'exports', {
      enumerable: true, configurable: true,
      get: ()=>(target.instance && target.instance.exports)
    });
  }

  
  

  
  const ptrIR = target.pointerIR || 'i32';
  const ptrSizeof = target.ptrSizeof =
        ('i32'===ptrIR ? 4
         : ('i64'===ptrIR
            ? 8 : toss("Unhandled ptrSizeof:",ptrIR)));
  
  const cache = Object.create(null);
  
  cache.heapSize = 0;
  
  cache.memory = null;
  
  cache.freeFuncIndexes = [];
  
  cache.scopedAlloc = [];

  cache.utf8Decoder = new TextDecoder();
  cache.utf8Encoder = new TextEncoder('utf-8');

  
  target.sizeofIR = (n)=>{
    switch(n){
        case 'i8': return 1;
        case 'i16': return 2;
        case 'i32': case 'f32': case 'float': return 4;
        case 'i64': case 'f64': case 'double': return 8;
        case '*': return ptrSizeof;
        default:
          return (''+n).endsWith('*') ? ptrSizeof : undefined;
    }
  };

  
  const heapWrappers = function(){
    if(!cache.memory){
      cache.memory = (target.memory instanceof WebAssembly.Memory)
        ? target.memory : target.exports.memory;
    }else if(cache.heapSize === cache.memory.buffer.byteLength){
      return cache;
    }
    
    const b = cache.memory.buffer;
    cache.HEAP8 = new Int8Array(b); cache.HEAP8U = new Uint8Array(b);
    cache.HEAP16 = new Int16Array(b); cache.HEAP16U = new Uint16Array(b);
    cache.HEAP32 = new Int32Array(b); cache.HEAP32U = new Uint32Array(b);
    if(target.bigIntEnabled){
      cache.HEAP64 = new BigInt64Array(b); cache.HEAP64U = new BigUint64Array(b);
    }
    cache.HEAP32F = new Float32Array(b); cache.HEAP64F = new Float64Array(b);
    cache.heapSize = b.byteLength;
    return cache;
  };

  
  target.heap8 = ()=>heapWrappers().HEAP8;

  
  target.heap8u = ()=>heapWrappers().HEAP8U;

  
  target.heap16 = ()=>heapWrappers().HEAP16;

  
  target.heap16u = ()=>heapWrappers().HEAP16U;

  
  target.heap32 = ()=>heapWrappers().HEAP32;

  
  target.heap32u = ()=>heapWrappers().HEAP32U;

  
  target.heapForSize = function(n,unsigned = true){
    let ctor;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    switch(n){
        case Int8Array: return c.HEAP8; case Uint8Array: return c.HEAP8U;
        case Int16Array: return c.HEAP16; case Uint16Array: return c.HEAP16U;
        case Int32Array: return c.HEAP32; case Uint32Array: return c.HEAP32U;
        case 8:  return unsigned ? c.HEAP8U : c.HEAP8;
        case 16: return unsigned ? c.HEAP16U : c.HEAP16;
        case 32: return unsigned ? c.HEAP32U : c.HEAP32;
        case 64:
          if(c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;
          break;
        default:
          if(target.bigIntEnabled){
            if(n===globalThis['BigUint64Array']) return c.HEAP64U;
            else if(n===globalThis['BigInt64Array']) return c.HEAP64;
            break;
          }
    }
    toss("Invalid heapForSize() size: expecting 8, 16, 32,",
         "or (if BigInt is enabled) 64.");
  };

  
  target.functionTable = function(){
    return target.exports.__indirect_function_table;
    
  };

  
  target.functionEntry = function(fptr){
    const ft = target.functionTable();
    return fptr < ft.length ? ft.get(fptr) : undefined;
  };

  
  target.jsFuncToWasm = function f(func, sig){
    
    if(!f._){
      f._ = {
        
        sigTypes: Object.assign(Object.create(null),{
          i: 'i32', p: 'i32', P: 'i32', s: 'i32',
          j: 'i64', f: 'f32', d: 'f64'
        }),
        
        typeCodes: Object.assign(Object.create(null),{
          f64: 0x7c, f32: 0x7d, i64: 0x7e, i32: 0x7f
        }),
        
        uleb128Encode: function(tgt, method, n){
          if(n<128) tgt[method](n);
          else tgt[method]( (n % 128) | 128, n>>7);
        },
        
        rxJSig: /^(\w)\((\w*)\)$/,
        
        sigParams: function(sig){
          const m = f._.rxJSig.exec(sig);
          return m ? m[2] : sig.substr(1);
        },
        
        letterType: (x)=>f._.sigTypes[x] || toss("Invalid signature letter:",x),
        
        
        
        pushSigType: (dest, letter)=>dest.push(f._.typeCodes[f._.letterType(letter)])
      };
    }
    if('string'===typeof func){
      const x = sig;
      sig = func;
      func = x;
    }
    const sigParams = f._.sigParams(sig);
    const wasmCode = [0x01, 0x60];
    f._.uleb128Encode(wasmCode, 'push', sigParams.length);
    for(const x of sigParams) f._.pushSigType(wasmCode, x);
    if('v'===sig[0]) wasmCode.push(0);
    else{
      wasmCode.push(1);
      f._.pushSigType(wasmCode, sig[0]);
    }
    f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);
    wasmCode.unshift(
      0x00, 0x61, 0x73, 0x6d, 
      0x01, 0x00, 0x00, 0x00, 
      0x01 
    );
    wasmCode.push(
       0x02, 0x07,
      
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
       0x07, 0x05,
      
      0x01, 0x01, 0x66, 0x00, 0x00
    );
    return (new WebAssembly.Instance(
      new WebAssembly.Module(new Uint8Array(wasmCode)), {
        e: { f: func }
      })).exports['f'];
  };

  
  const __installFunction = function f(func, sig, scoped){
    if(scoped && !cache.scopedAlloc.length){
      toss("No scopedAllocPush() scope is active.");
    }
    if('string'===typeof func){
      const x = sig;
      sig = func;
      func = x;
    }
    if('string'!==typeof sig || !(func instanceof Function)){
      toss("Invalid arguments: expecting (function,signature) "+
           "or (signature,function).");
    }
    const ft = target.functionTable();
    const oldLen = ft.length;
    let ptr;
    while(cache.freeFuncIndexes.length){
      ptr = cache.freeFuncIndexes.pop();
      if(ft.get(ptr)){ 
        ptr = null;
        continue;
      }else{
        break;
      }
    }
    if(!ptr){
      ptr = oldLen;
      ft.grow(1);
    }
    try{
      
      ft.set(ptr, func);
      if(scoped){
        cache.scopedAlloc[cache.scopedAlloc.length-1].push(ptr);
      }
      return ptr;
    }catch(e){
      if(!(e instanceof TypeError)){
        if(ptr===oldLen) cache.freeFuncIndexes.push(oldLen);
        throw e;
      }
    }
    
    try {
      const fptr = target.jsFuncToWasm(func, sig);
      ft.set(ptr, fptr);
      if(scoped){
        cache.scopedAlloc[cache.scopedAlloc.length-1].push(ptr);
      }
    }catch(e){
      if(ptr===oldLen) cache.freeFuncIndexes.push(oldLen);
      throw e;
    }
    return ptr;
  };

  
  target.installFunction = (func, sig)=>__installFunction(func, sig, false);

  
  target.scopedInstallFunction = (func, sig)=>__installFunction(func, sig, true);

  
  target.uninstallFunction = function(ptr){
    if(!ptr && 0!==ptr) return undefined;
    const fi = cache.freeFuncIndexes;
    const ft = target.functionTable();
    fi.push(ptr);
    const rc = ft.get(ptr);
    ft.set(ptr, null);
    return rc;
  };

  
  target.peek = function f(ptr, type='i8'){
    if(type.endsWith('*')) type = ptrIR;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    const list = Array.isArray(ptr) ? [] : undefined;
    let rc;
    do{
      if(list) ptr = arguments[0].shift();
      switch(type){
          case 'i1':
          case 'i8': rc = c.HEAP8[ptr>>0]; break;
          case 'i16': rc = c.HEAP16[ptr>>1]; break;
          case 'i32': rc = c.HEAP32[ptr>>2]; break;
          case 'float': case 'f32': rc = c.HEAP32F[ptr>>2]; break;
          case 'double': case 'f64': rc = Number(c.HEAP64F[ptr>>3]); break;
          case 'i64':
            if(target.bigIntEnabled){
              rc = BigInt(c.HEAP64[ptr>>3]);
              break;
            }
            
          default:
            toss('Invalid type for peek():',type);
      }
      if(list) list.push(rc);
    }while(list && arguments[0].length);
    return list || rc;
  };

  
  target.poke = function(ptr, value, type='i8'){
    if (type.endsWith('*')) type = ptrIR;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    for(const p of (Array.isArray(ptr) ? ptr : [ptr])){
      switch (type) {
          case 'i1':
          case 'i8': c.HEAP8[p>>0] = value; continue;
          case 'i16': c.HEAP16[p>>1] = value; continue;
          case 'i32': c.HEAP32[p>>2] = value; continue;
          case 'float': case 'f32': c.HEAP32F[p>>2] = value; continue;
          case 'double': case 'f64': c.HEAP64F[p>>3] = value; continue;
          case 'i64':
            if(c.HEAP64){
              c.HEAP64[p>>3] = BigInt(value);
              continue;
            }
            
          default:
            toss('Invalid type for poke(): ' + type);
      }
    }
    return this;
  };

  
  target.peekPtr = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), ptrIR );

  
  target.pokePtr = (ptr, value=0)=>target.poke(ptr, value, ptrIR);

  
  target.peek8 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i8' );
  
  target.poke8 = (ptr, value)=>target.poke(ptr, value, 'i8');
  
  target.peek16 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i16' );
  
  target.poke16 = (ptr, value)=>target.poke(ptr, value, 'i16');
  
  target.peek32 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i32' );
  
  target.poke32 = (ptr, value)=>target.poke(ptr, value, 'i32');
  
  target.peek64 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i64' );
  
  target.poke64 = (ptr, value)=>target.poke(ptr, value, 'i64');
  
  target.peek32f = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'f32' );
  
  target.poke32f = (ptr, value)=>target.poke(ptr, value, 'f32');
  
  target.peek64f = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'f64' );
  
  target.poke64f = (ptr, value)=>target.poke(ptr, value, 'f64');

  
  target.getMemValue = target.peek;
  
  target.getPtrValue = target.peekPtr;
  
  target.setMemValue = target.poke;
  
  target.setPtrValue = target.pokePtr;

  
  target.isPtr32 = (ptr)=>('number'===typeof ptr && (ptr===(ptr|0)) && ptr>=0);

  
  target.isPtr = target.isPtr32;

  
  target.cstrlen = function(ptr){
    if(!ptr || !target.isPtr(ptr)) return null;
    const h = heapWrappers().HEAP8U;
    let pos = ptr;
    for( ; h[pos] !== 0; ++pos ){}
    return pos - ptr;
  };

  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  const __utf8Decode = function(arrayBuffer, begin, end){
    return cache.utf8Decoder.decode(
      (arrayBuffer.buffer instanceof __SAB)
        ? arrayBuffer.slice(begin, end)
        : arrayBuffer.subarray(begin, end)
    );
  };

  
  target.cstrToJs = function(ptr){
    const n = target.cstrlen(ptr);
    return n ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr+n) : (null===n ? n : "");
  };

  
  target.jstrlen = function(str){
    
    if('string'!==typeof str) return null;
    const n = str.length;
    let len = 0;
    for(let i = 0; i < n; ++i){
      let u = str.charCodeAt(i);
      if(u>=0xd800 && u<=0xdfff){
        u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
      }
      if(u<=0x7f) ++len;
      else if(u<=0x7ff) len += 2;
      else if(u<=0xffff) len += 3;
      else len += 4;
    }
    return len;
  };

  
  target.jstrcpy = function(jstr, tgt, offset = 0, maxBytes = -1, addNul = true){
    
    if(!tgt || (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))){
      toss("jstrcpy() target must be an Int8Array or Uint8Array.");
    }
    if(maxBytes<0) maxBytes = tgt.length - offset;
    if(!(maxBytes>0) || !(offset>=0)) return 0;
    let i = 0, max = jstr.length;
    const begin = offset, end = offset + maxBytes - (addNul ? 1 : 0);
    for(; i < max && offset < end; ++i){
      let u = jstr.charCodeAt(i);
      if(u>=0xd800 && u<=0xdfff){
        u = 0x10000 + ((u & 0x3FF) << 10) | (jstr.charCodeAt(++i) & 0x3FF);
      }
      if(u<=0x7f){
        if(offset >= end) break;
        tgt[offset++] = u;
      }else if(u<=0x7ff){
        if(offset + 1 >= end) break;
        tgt[offset++] = 0xC0 | (u >> 6);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }else if(u<=0xffff){
        if(offset + 2 >= end) break;
        tgt[offset++] = 0xe0 | (u >> 12);
        tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }else{
        if(offset + 3 >= end) break;
        tgt[offset++] = 0xf0 | (u >> 18);
        tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);
        tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }
    }
    if(addNul) tgt[offset++] = 0;
    return offset - begin;
  };

  
  target.cstrncpy = function(tgtPtr, srcPtr, n){
    if(!tgtPtr || !srcPtr) toss("cstrncpy() does not accept NULL strings.");
    if(n<0) n = target.cstrlen(strPtr)+1;
    else if(!(n>0)) return 0;
    const heap = target.heap8u();
    let i = 0, ch;
    for(; i < n && (ch = heap[srcPtr+i]); ++i){
      heap[tgtPtr+i] = ch;
    }
    if(i<n) heap[tgtPtr + i++] = 0;
    return i;
  };

  
  target.jstrToUintArray = (str, addNul=false)=>{
    return cache.utf8Encoder.encode(addNul ? (str+"\0") : str);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  };

  const __affirmAlloc = (obj,funcName)=>{
    if(!(obj.alloc instanceof Function) ||
       !(obj.dealloc instanceof Function)){
      toss("Object is missing alloc() and/or dealloc() function(s)",
           "required by",funcName+"().");
    }
  };

  const __allocCStr = function(jstr, returnWithLength, allocator, funcName){
    __affirmAlloc(target, funcName);
    if('string'!==typeof jstr) return null;
    if(false){}else{
      const u = cache.utf8Encoder.encode(jstr),
            ptr = allocator(u.length+1),
            heap = heapWrappers().HEAP8U;
      heap.set(u, ptr);
      heap[ptr + u.length] = 0;
      return returnWithLength ? [ptr, u.length] : ptr;
    }
  };

  
  target.allocCString =
    (jstr, returnWithLength=false)=>__allocCStr(jstr, returnWithLength,
                                                target.alloc, 'allocCString()');

  
  target.scopedAllocPush = function(){
    __affirmAlloc(target, 'scopedAllocPush');
    const a = [];
    cache.scopedAlloc.push(a);
    return a;
  };

  
  target.scopedAllocPop = function(state){
    __affirmAlloc(target, 'scopedAllocPop');
    const n = arguments.length
          ? cache.scopedAlloc.indexOf(state)
          : cache.scopedAlloc.length-1;
    if(n<0) toss("Invalid state object for scopedAllocPop().");
    if(0===arguments.length) state = cache.scopedAlloc[n];
    cache.scopedAlloc.splice(n,1);
    for(let p; (p = state.pop()); ){
      if(target.functionEntry(p)){
        
        target.uninstallFunction(p);
      }
      else target.dealloc(p);
    }
  };

  
  target.scopedAlloc = function(n){
    if(!cache.scopedAlloc.length){
      toss("No scopedAllocPush() scope is active.");
    }
    const p = target.alloc(n);
    cache.scopedAlloc[cache.scopedAlloc.length-1].push(p);
    return p;
  };

  Object.defineProperty(target.scopedAlloc, 'level', {
    configurable: false, enumerable: false,
    get: ()=>cache.scopedAlloc.length,
    set: ()=>toss("The 'active' property is read-only.")
  });

  
  target.scopedAllocCString =
    (jstr, returnWithLength=false)=>__allocCStr(jstr, returnWithLength,
                                                target.scopedAlloc, 'scopedAllocCString()');

  
  const __allocMainArgv = function(isScoped, list){
    const pList = target[
      isScoped ? 'scopedAlloc' : 'alloc'
    ]((list.length + 1) * target.ptrSizeof);
    let i = 0;
    list.forEach((e)=>{
      target.pokePtr(pList + (target.ptrSizeof * i++),
                         target[
                           isScoped ? 'scopedAllocCString' : 'allocCString'
                         ](""+e));
    });
    target.pokePtr(pList + (target.ptrSizeof * i), 0);
    return pList;
  };

  
  target.scopedAllocMainArgv = (list)=>__allocMainArgv(true, list);

  
  target.allocMainArgv = (list)=>__allocMainArgv(false, list);

  
  target.cArgvToJs = (argc, pArgv)=>{
    const list = [];
    for(let i = 0; i < argc; ++i){
      const arg = target.peekPtr(pArgv + (target.ptrSizeof * i));
      list.push( arg ? target.cstrToJs(arg) : null );
    }
    return list;
  };

  
  target.scopedAllocCall = function(func){
    target.scopedAllocPush();
    try{ return func() } finally{ target.scopedAllocPop() }
  };

  
  const __allocPtr = function(howMany, safePtrSize, method){
    __affirmAlloc(target, method);
    const pIr = safePtrSize ? 'i64' : ptrIR;
    let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
    target.poke(m, 0, pIr)
    if(1===howMany){
      return m;
    }
    const a = [m];
    for(let i = 1; i < howMany; ++i){
      m += (safePtrSize ? 8 : ptrSizeof);
      a[i] = m;
      target.poke(m, 0, pIr);
    }
    return a;
  };

  
  target.allocPtr =
    (howMany=1, safePtrSize=true)=>__allocPtr(howMany, safePtrSize, 'alloc');

  
  target.scopedAllocPtr =
    (howMany=1, safePtrSize=true)=>__allocPtr(howMany, safePtrSize, 'scopedAlloc');

  
  target.xGet = function(name){
    return target.exports[name] || toss("Cannot find exported symbol:",name);
  };

  const __argcMismatch =
        (f,n)=>toss(f+"() requires",n,"argument(s).");

  
  target.xCall = function(fname, ...args){
    const f = target.xGet(fname);
    if(!(f instanceof Function)) toss("Exported symbol",fname,"is not a function.");
    if(f.length!==args.length) __argcMismatch(fname,f.length)
    ;
    return (2===arguments.length && Array.isArray(arguments[1]))
      ? f.apply(null, arguments[1])
      : f.apply(null, args);
  };

  
  cache.xWrap = Object.create(null);
  cache.xWrap.convert = Object.create(null);
  
  cache.xWrap.convert.arg = new Map;
  
  cache.xWrap.convert.result = new Map;
  const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;

  if(target.bigIntEnabled){
    xArg.set('i64', (i)=>BigInt(i));
  }
  const __xArgPtr = 'i32' === ptrIR
        ? ((i)=>(i | 0)) : ((i)=>(BigInt(i) | BigInt(0)));
  xArg.set('i32', __xArgPtr )
    .set('i16', (i)=>((i | 0) & 0xFFFF))
    .set('i8', (i)=>((i | 0) & 0xFF))
    .set('f32', (i)=>Number(i).valueOf())
    .set('float', xArg.get('f32'))
    .set('f64', xArg.get('f32'))
    .set('double', xArg.get('f64'))
    .set('int', xArg.get('i32'))
    .set('null', (i)=>i)
    .set(null, xArg.get('null'))
    .set('**', __xArgPtr)
    .set('*', __xArgPtr);
  xResult.set('*', __xArgPtr)
    .set('pointer', __xArgPtr)
    .set('number', (v)=>Number(v))
    .set('void', (v)=>undefined)
    .set('null', (v)=>v)
    .set(null, xResult.get('null'));

  { 
    const copyToResult = ['i8', 'i16', 'i32', 'int',
                          'f32', 'float', 'f64', 'double'];
    if(target.bigIntEnabled) copyToResult.push('i64');
    const adaptPtr = xArg.get(ptrIR);
    for(const t of copyToResult){
      xArg.set(t+'*', adaptPtr);
      xResult.set(t+'*', adaptPtr);
      xResult.set(t, (xArg.get(t) || toss("Missing arg converter:",t)));
    }
  }

  
  const __xArgString = function(v){
    if('string'===typeof v) return target.scopedAllocCString(v);
    return v ? __xArgPtr(v) : null;
  };
  xArg.set('string', __xArgString)
    .set('utf8', __xArgString)
    .set('pointer', __xArgString);
  

  xResult.set('string', (i)=>target.cstrToJs(i))
    .set('utf8', xResult.get('string'))
    .set('string:dealloc', (i)=>{
      try { return i ? target.cstrToJs(i) : null }
      finally{ target.dealloc(i) }
    })
    .set('utf8:dealloc', xResult.get('string:dealloc'))
    .set('json', (i)=>JSON.parse(target.cstrToJs(i)))
    .set('json:dealloc', (i)=>{
      try{ return i ? JSON.parse(target.cstrToJs(i)) : null }
      finally{ target.dealloc(i) }
    });

  
  const AbstractArgAdapter = class {
    constructor(opt){
      this.name = opt.name || 'unnamed adapter';
    }
    
    convertArg(v,argv,argIndex){
      toss("AbstractArgAdapter must be subclassed.");
    }
  };

  
  xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
    constructor(opt) {
      super(opt);
      if(xArg.FuncPtrAdapter.warnOnUse){
        console.warn('xArg.FuncPtrAdapter is an internal-only API',
                     'and is not intended to be invoked from',
                     'client-level code. Invoked with:',opt);
      }
      this.name = opt.name || "unnamed";
      this.signature = opt.signature;
      if(opt.contextKey instanceof Function){
        this.contextKey = opt.contextKey;
        if(!opt.bindScope) opt.bindScope = 'context';
      }
      this.bindScope = opt.bindScope
        || toss("FuncPtrAdapter options requires a bindScope (explicit or implied).");
      if(FuncPtrAdapter.bindScopes.indexOf(opt.bindScope)<0){
        toss("Invalid options.bindScope ("+opt.bindMod+") for FuncPtrAdapter. "+
             "Expecting one of: ("+FuncPtrAdapter.bindScopes.join(', ')+')');
      }
      this.isTransient = 'transient'===this.bindScope;
      this.isContext = 'context'===this.bindScope;
      this.isPermanent = 'permanent'===this.bindScope;
      this.singleton = ('singleton'===this.bindScope) ? [] : undefined;
      
      this.callProxy = (opt.callProxy instanceof Function)
        ? opt.callProxy : undefined;
    }

    

    
    contextKey(argv,argIndex){
      return this;
    }

    
    contextMap(key){
      const cm = (this.__cmap || (this.__cmap = new Map));
      let rc = cm.get(key);
      if(undefined===rc) cm.set(key, (rc = []));
      return rc;
    }

    
    convertArg(v,argv,argIndex){
      
      let pair = this.singleton;
      if(!pair && this.isContext){
        pair = this.contextMap(this.contextKey(argv,argIndex));
        
      }
      if(pair && pair[0]===v) return pair[1];
      if(v instanceof Function){
        
        
        if(this.callProxy) v = this.callProxy(v);
        const fp = __installFunction(v, this.signature, this.isTransient);
        if(FuncPtrAdapter.debugFuncInstall){
          FuncPtrAdapter.debugOut("FuncPtrAdapter installed", this,
                                  this.contextKey(argv,argIndex), '@'+fp, v);
        }
        if(pair){
          
          if(pair[1]){
            if(FuncPtrAdapter.debugFuncInstall){
              FuncPtrAdapter.debugOut("FuncPtrAdapter uninstalling", this,
                                      this.contextKey(argv,argIndex), '@'+pair[1], v);
            }
            try{
              
              cache.scopedAlloc[cache.scopedAlloc.length-1].push(pair[1]);
            }
            catch(e){}
          }
          pair[0] = v;
          pair[1] = fp;
        }
        return fp;
      }else if(target.isPtr(v) || null===v || undefined===v){
        
        if(pair && pair[1] && pair[1]!==v){
          
          if(FuncPtrAdapter.debugFuncInstall){
            FuncPtrAdapter.debugOut("FuncPtrAdapter uninstalling", this,
                                    this.contextKey(argv,argIndex), '@'+pair[1], v);
          }
          try{ cache.scopedAlloc[cache.scopedAlloc.length-1].push(pair[1]) }
          catch(e){}
          pair[0] = pair[1] = (v | 0);
        }
        return v || 0;
      }else{
        throw new TypeError("Invalid FuncPtrAdapter argument type. "+
                            "Expecting a function pointer or a "+
                            (this.name ? this.name+' ' : '')+
                            "function matching signature "+
                            this.signature+".");
      }
    }
  };

  
  xArg.FuncPtrAdapter.warnOnUse = false;

  
  xArg.FuncPtrAdapter.debugFuncInstall = false;

  
  xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);

  xArg.FuncPtrAdapter.bindScopes = [
    'transient', 'context', 'singleton', 'permanent'
  ];

  const __xArgAdapterCheck =
        (t)=>xArg.get(t) || toss("Argument adapter not found:",t);

  const __xResultAdapterCheck =
        (t)=>xResult.get(t) || toss("Result adapter not found:",t);

  cache.xWrap.convertArg = (t,...args)=>__xArgAdapterCheck(t)(...args);
  cache.xWrap.convertArgNoCheck = (t,...args)=>xArg.get(t)(...args);

  cache.xWrap.convertResult =
    (t,v)=>(null===t ? v : (t ? __xResultAdapterCheck(t)(v) : undefined));
  cache.xWrap.convertResultNoCheck =
    (t,v)=>(null===t ? v : (t ? xResult.get(t)(v) : undefined));

  
  target.xWrap = function(fArg, resultType, ...argTypes){
    if(3===arguments.length && Array.isArray(arguments[2])){
      argTypes = arguments[2];
    }
    if(target.isPtr(fArg)){
      fArg = target.functionEntry(fArg)
        || toss("Function pointer not found in WASM function table.");
    }
    const fIsFunc = (fArg instanceof Function);
    const xf = fIsFunc ? fArg : target.xGet(fArg);
    if(fIsFunc) fArg = xf.name || 'unnamed function';
    if(argTypes.length!==xf.length) __argcMismatch(fArg, xf.length);
    if((null===resultType) && 0===xf.length){
      
      return xf;
    }
    ;
    if(undefined!==resultType && null!==resultType) __xResultAdapterCheck(resultType);
    for(const t of argTypes){
      if(t instanceof AbstractArgAdapter) xArg.set(t, (...args)=>t.convertArg(...args));
      else __xArgAdapterCheck(t);
    }
    const cxw = cache.xWrap;
    if(0===xf.length){
      
      return (...args)=>(args.length
                         ? __argcMismatch(fArg, xf.length)
                         : cxw.convertResult(resultType, xf.call(null)));
    }
    return function(...args){
      if(args.length!==xf.length) __argcMismatch(fArg, xf.length);
      const scope = target.scopedAllocPush();
      try{
        
        for(const i in args) args[i] = cxw.convertArgNoCheck(
          argTypes[i], args[i], args, i
        );
        return cxw.convertResultNoCheck(resultType, xf.apply(null,args));
      }finally{
        target.scopedAllocPop(scope);
      }
    };
  };

  
  const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart){
    if('string'===typeof typeName){
      if(1===argc) return xcvPart.get(typeName);
      else if(2===argc){
        if(!adapter){
          delete xcvPart.get(typeName);
          return func;
        }else if(!(adapter instanceof Function)){
          toss(modeName,"requires a function argument.");
        }
        xcvPart.set(typeName, adapter);
        return func;
      }
    }
    toss("Invalid arguments to",modeName);
  };

  
  target.xWrap.resultAdapter = function f(typeName, adapter){
    return __xAdapter(f, arguments.length, typeName, adapter,
                      'resultAdapter()', xResult);
  };

  
  target.xWrap.argAdapter = function f(typeName, adapter){
    return __xAdapter(f, arguments.length, typeName, adapter,
                      'argAdapter()', xArg);
  };

  target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;

  
  target.xCallWrapped = function(fArg, resultType, argTypes, ...args){
    if(Array.isArray(arguments[3])) args = arguments[3];
    return target.xWrap(fArg, resultType, argTypes||[]).apply(null, args||[]);
  };

  
  target.xWrap.testConvertArg = cache.xWrap.convertArg;

  
  target.xWrap.testConvertResult = cache.xWrap.convertResult;

  return target;
};


globalThis.WhWasmUtilInstaller.yawl = function(config){
  const wfetch = ()=>fetch(config.uri, {credentials: 'same-origin'});
  const wui = this;
  const finalThen = function(arg){
    
    if(config.wasmUtilTarget){
      const toss = (...args)=>{throw new Error(args.join(' '))};
      const tgt = config.wasmUtilTarget;
      tgt.module = arg.module;
      tgt.instance = arg.instance;
      
      if(!tgt.instance.exports.memory){
        
        tgt.memory = (config.imports && config.imports.env
                      && config.imports.env.memory)
          || toss("Missing 'memory' object!");
      }
      if(!tgt.alloc && arg.instance.exports.malloc){
        const exports = arg.instance.exports;
        tgt.alloc = function(n){
          return exports.malloc(n) || toss("Allocation of",n,"bytes failed.");
        };
        tgt.dealloc = function(m){exports.free(m)};
      }
      wui(tgt);
    }
    if(config.onload) config.onload(arg,config);
    return arg ;
  };
  const loadWasm = WebAssembly.instantiateStreaming
        ? function loadWasmStreaming(){
          return WebAssembly.instantiateStreaming(wfetch(), config.imports||{})
            .then(finalThen);
        }
        : function loadWasmOldSchool(){ 
          return wfetch()
            .then(response => response.arrayBuffer())
            .then(bytes => WebAssembly.instantiate(bytes, config.imports||{}))
            .then(finalThen);
        };
  return loadWasm;
}.bind(globalThis.WhWasmUtilInstaller);



'use strict';
globalThis.Jaccwabyt = function StructBinderFactory(config){


  
  const toss = (...args)=>{throw new Error(args.join(' '))};

  
  if(!(config.heap instanceof WebAssembly.Memory)
     && !(config.heap instanceof Function)){
    toss("config.heap must be WebAssembly.Memory instance or a function.");
  }
  ['alloc','dealloc'].forEach(function(k){
    (config[k] instanceof Function) ||
      toss("Config option '"+k+"' must be a function.");
  });
  const SBF = StructBinderFactory;
  const heap = (config.heap instanceof Function)
        ? config.heap : (()=>new Uint8Array(config.heap.buffer)),
        alloc = config.alloc,
        dealloc = config.dealloc,
        log = config.log || console.log.bind(console),
        memberPrefix = (config.memberPrefix || ""),
        memberSuffix = (config.memberSuffix || ""),
        bigIntEnabled = (undefined===config.bigIntEnabled
                         ? !!globalThis['BigInt64Array'] : !!config.bigIntEnabled),
        BigInt = globalThis['BigInt'],
        BigInt64Array = globalThis['BigInt64Array'],
        
        ptrSizeof = config.ptrSizeof || 4,
        ptrIR = config.ptrIR || 'i32'
  ;

  if(!SBF.debugFlags){
    SBF.__makeDebugFlags = function(deriveFrom=null){
      
      if(deriveFrom && deriveFrom.__flags) deriveFrom = deriveFrom.__flags;
      const f = function f(flags){
        if(0===arguments.length){
          return f.__flags;
        }
        if(flags<0){
          delete f.__flags.getter; delete f.__flags.setter;
          delete f.__flags.alloc; delete f.__flags.dealloc;
        }else{
          f.__flags.getter  = 0!==(0x01 & flags);
          f.__flags.setter  = 0!==(0x02 & flags);
          f.__flags.alloc   = 0!==(0x04 & flags);
          f.__flags.dealloc = 0!==(0x08 & flags);
        }
        return f._flags;
      };
      Object.defineProperty(f,'__flags', {
        iterable: false, writable: false,
        value: Object.create(deriveFrom)
      });
      if(!deriveFrom) f(0);
      return f;
    };
    SBF.debugFlags = SBF.__makeDebugFlags();
  }

  const isLittleEndian = (function() {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true );
    
    return new Int16Array(buffer)[0] === 256;
  })();
  

  
  const isFuncSig = (s)=>'('===s[1];
  
  const isPtrSig = (s)=>'p'===s || 'P'===s;
  const isAutoPtrSig = (s)=>'P'===s ;
  const sigLetter = (s)=>isFuncSig(s) ? 'p' : s[0];
  
  const sigIR = function(s){
    switch(sigLetter(s)){
        case 'c': case 'C': return 'i8';
        case 'i': return 'i32';
        case 'p': case 'P': case 's': return ptrIR;
        case 'j': return 'i64';
        case 'f': return 'float';
        case 'd': return 'double';
    }
    toss("Unhandled signature IR:",s);
  };

  const affirmBigIntArray = BigInt64Array
        ? ()=>true : ()=>toss('BigInt64Array is not available.');
  
  const sigDVGetter = function(s){
    switch(sigLetter(s)) {
        case 'p': case 'P': case 's': {
          switch(ptrSizeof){
              case 4: return 'getInt32';
              case 8: return affirmBigIntArray() && 'getBigInt64';
          }
          break;
        }
        case 'i': return 'getInt32';
        case 'c': return 'getInt8';
        case 'C': return 'getUint8';
        case 'j': return affirmBigIntArray() && 'getBigInt64';
        case 'f': return 'getFloat32';
        case 'd': return 'getFloat64';
    }
    toss("Unhandled DataView getter for signature:",s);
  };
  
  const sigDVSetter = function(s){
    switch(sigLetter(s)){
        case 'p': case 'P': case 's': {
          switch(ptrSizeof){
              case 4: return 'setInt32';
              case 8: return affirmBigIntArray() && 'setBigInt64';
          }
          break;
        }
        case 'i': return 'setInt32';
        case 'c': return 'setInt8';
        case 'C': return 'setUint8';
        case 'j': return affirmBigIntArray() && 'setBigInt64';
        case 'f': return 'setFloat32';
        case 'd': return 'setFloat64';
    }
    toss("Unhandled DataView setter for signature:",s);
  };
  
  const sigDVSetWrapper = function(s){
    switch(sigLetter(s)) {
        case 'i': case 'f': case 'c': case 'C': case 'd': return Number;
        case 'j': return affirmBigIntArray() && BigInt;
        case 'p': case 'P': case 's':
          switch(ptrSizeof){
              case 4: return Number;
              case 8: return affirmBigIntArray() && BigInt;
          }
          break;
    }
    toss("Unhandled DataView set wrapper for signature:",s);
  };

  
  const sPropName = (s,k)=>s+'::'+k;

  const __propThrowOnSet = function(structName,propName){
    return ()=>toss(sPropName(structName,propName),"is read-only.");
  };

  
  const __instancePointerMap = new WeakMap();

  
  const xPtrPropName = '(pointer-is-external)';

  
  const __freeStruct = function(ctor, obj, m){
    if(!m) m = __instancePointerMap.get(obj);
    if(m) {
      __instancePointerMap.delete(obj);
      if(Array.isArray(obj.ondispose)){
        let x;
        while((x = obj.ondispose.shift())){
          try{
            if(x instanceof Function) x.call(obj);
            else if(x instanceof StructType) x.dispose();
            else if('number' === typeof x) dealloc(x);
            
            
          }catch(e){
            console.warn("ondispose() for",ctor.structName,'@',
                         m,'threw. NOT propagating it.',e);
          }
        }
      }else if(obj.ondispose instanceof Function){
        try{obj.ondispose()}
        catch(e){
          
          console.warn("ondispose() for",ctor.structName,'@',
                       m,'threw. NOT propagating it.',e);
        }
      }
      delete obj.ondispose;
      if(ctor.debugFlags.__flags.dealloc){
        log("debug.dealloc:",(obj[xPtrPropName]?"EXTERNAL":""),
            ctor.structName,"instance:",
            ctor.structInfo.sizeof,"bytes @"+m);
      }
      if(!obj[xPtrPropName]) dealloc(m);
    }
  };

  
  const rop = (v)=>{return {configurable: false, writable: false,
                            iterable: false, value: v}};

  
  const __allocStruct = function(ctor, obj, m){
    let fill = !m;
    if(m) Object.defineProperty(obj, xPtrPropName, rop(m));
    else{
      m = alloc(ctor.structInfo.sizeof);
      if(!m) toss("Allocation of",ctor.structName,"structure failed.");
    }
    try {
      if(ctor.debugFlags.__flags.alloc){
        log("debug.alloc:",(fill?"":"EXTERNAL"),
            ctor.structName,"instance:",
            ctor.structInfo.sizeof,"bytes @"+m);
      }
      if(fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
      __instancePointerMap.set(obj, m);
    }catch(e){
      __freeStruct(ctor, obj, m);
      throw e;
    }
  };
  
  const __memoryDump = function(){
    const p = this.pointer;
    return p
      ? new Uint8Array(heap().slice(p, p+this.structInfo.sizeof))
      : null;
  };

  const __memberKey = (k)=>memberPrefix + k + memberSuffix;
  const __memberKeyProp = rop(__memberKey);

  
  const __lookupMember = function(structInfo, memberName, tossIfNotFound=true){
    let m = structInfo.members[memberName];
    if(!m && (memberPrefix || memberSuffix)){
      
      for(const v of Object.values(structInfo.members)){
        if(v.key===memberName){ m = v; break; }
      }
      if(!m && tossIfNotFound){
        toss(sPropName(structInfo.name,memberName),'is not a mapped struct member.');
      }
    }
    return m;
  };

  
  const __memberSignature = function f(obj,memberName,emscriptenFormat=false){
    if(!f._) f._ = (x)=>x.replace(/[^vipPsjrdcC]/g,"").replace(/[pPscC]/g,'i');
    const m = __lookupMember(obj.structInfo, memberName, true);
    return emscriptenFormat ? f._(m.signature) : m.signature;
  };

  const __ptrPropDescriptor = {
    configurable: false, enumerable: false,
    get: function(){return __instancePointerMap.get(this)},
    set: ()=>toss("Cannot assign the 'pointer' property of a struct.")
    
    
    
  };

  
  const __structMemberKeys = rop(function(){
    const a = [];
    for(const k of Object.keys(this.structInfo.members)){
      a.push(this.memberKey(k));
    }
    return a;
  });

  const __utf8Decoder = new TextDecoder('utf-8');
  const __utf8Encoder = new TextEncoder();
  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  const __utf8Decode = function(arrayBuffer, begin, end){
    return __utf8Decoder.decode(
      (arrayBuffer.buffer instanceof __SAB)
        ? arrayBuffer.slice(begin, end)
        : arrayBuffer.subarray(begin, end)
    );
  };
  
  const __memberIsString = function(obj,memberName, tossIfNotFound=false){
    const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
    return (m && 1===m.signature.length && 's'===m.signature[0]) ? m : false;
  };

  
  const __affirmCStringSignature = function(member){
    if('s'===member.signature) return;
    toss("Invalid member type signature for C-string value:",
         JSON.stringify(member));
  };

  
  const __memberToJsString = function f(obj,memberName){
    const m = __lookupMember(obj.structInfo, memberName, true);
    __affirmCStringSignature(m);
    const addr = obj[m.key];
    
    if(!addr) return null;
    let pos = addr;
    const mem = heap();
    for( ; mem[pos]!==0; ++pos ) {
      
    };
    
    return (addr===pos) ? "" : __utf8Decode(mem, addr, pos);
  };

  
  const __addOnDispose = function(obj, ...v){
    if(obj.ondispose){
      if(!Array.isArray(obj.ondispose)){
        obj.ondispose = [obj.ondispose];
      }
    }else{
      obj.ondispose = [];
    }
    obj.ondispose.push(...v);
  };

  
  const __allocCString = function(str){
    const u = __utf8Encoder.encode(str);
    const mem = alloc(u.length+1);
    if(!mem) toss("Allocation error while duplicating string:",str);
    const h = heap();
    
    
    h.set(u, mem);
    h[mem + u.length] = 0;
    
    return mem;
  };

  
  const __setMemberCString = function(obj, memberName, str){
    const m = __lookupMember(obj.structInfo, memberName, true);
    __affirmCStringSignature(m);
    
    const mem = __allocCString(str);
    obj[m.key] = mem;
    __addOnDispose(obj, mem);
    return obj;
  };

  
  const StructType = function ctor(structName, structInfo){
    if(arguments[2]!==rop){
      toss("Do not call the StructType constructor",
           "from client-level code.");
    }
    Object.defineProperties(this,{
      
      structName: rop(structName),
      structInfo: rop(structInfo)
    });
  };

  
  StructType.prototype = Object.create(null, {
    dispose: rop(function(){__freeStruct(this.constructor, this)}),
    lookupMember: rop(function(memberName, tossIfNotFound=true){
      return __lookupMember(this.structInfo, memberName, tossIfNotFound);
    }),
    memberToJsString: rop(function(memberName){
      return __memberToJsString(this, memberName);
    }),
    memberIsString: rop(function(memberName, tossIfNotFound=true){
      return __memberIsString(this, memberName, tossIfNotFound);
    }),
    memberKey: __memberKeyProp,
    memberKeys: __structMemberKeys,
    memberSignature: rop(function(memberName, emscriptenFormat=false){
      return __memberSignature(this, memberName, emscriptenFormat);
    }),
    memoryDump: rop(__memoryDump),
    pointer: __ptrPropDescriptor,
    setMemberCString: rop(function(memberName, str){
      return __setMemberCString(this, memberName, str);
    })
  });
  
  Object.assign(StructType.prototype,{
    addOnDispose: function(...v){
      __addOnDispose(this,...v);
      return this;
    }
  });

  
  Object.defineProperties(StructType, {
    allocCString: rop(__allocCString),
    isA: rop((v)=>v instanceof StructType),
    hasExternalPointer: rop((v)=>(v instanceof StructType) && !!v[xPtrPropName]),
    memberKey: __memberKeyProp
  });

  const isNumericValue = (v)=>Number.isFinite(v) || (v instanceof (BigInt || Number));

  
  const makeMemberWrapper = function f(ctor,name, descr){
    if(!f._){
      
      f._ = {getters: {}, setters: {}, sw:{}};
      const a = ['i','c','C','p','P','s','f','d','v()'];
      if(bigIntEnabled) a.push('j');
      a.forEach(function(v){
        
        f._.getters[v] = sigDVGetter(v) ;
        f._.setters[v] = sigDVSetter(v) ;
        f._.sw[v] = sigDVSetWrapper(v)  ;
      });
      const rxSig1 = /^[ipPsjfdcC]$/,
            rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
      f.sigCheck = function(obj, name, key,sig){
        if(Object.prototype.hasOwnProperty.call(obj, key)){
          toss(obj.structName,'already has a property named',key+'.');
        }
        rxSig1.test(sig) || rxSig2.test(sig)
          || toss("Malformed signature for",
                  sPropName(obj.structName,name)+":",sig);
      };
    }
    const key = ctor.memberKey(name);
    f.sigCheck(ctor.prototype, name, key, descr.signature);
    descr.key = key;
    descr.name = name;
    const sigGlyph = sigLetter(descr.signature);
    const xPropName = sPropName(ctor.prototype.structName,key);
    const dbg = ctor.prototype.debugFlags.__flags;
    
    const prop = Object.create(null);
    prop.configurable = false;
    prop.enumerable = false;
    prop.get = function(){
      if(dbg.getter){
        log("debug.getter:",f._.getters[sigGlyph],"for", sigIR(sigGlyph),
            xPropName,'@', this.pointer,'+',descr.offset,'sz',descr.sizeof);
      }
      let rc = (
        new DataView(heap().buffer, this.pointer + descr.offset, descr.sizeof)
      )[f._.getters[sigGlyph]](0, isLittleEndian);
      if(dbg.getter) log("debug.getter:",xPropName,"result =",rc);
      return rc;
    };
    if(descr.readOnly){
      prop.set = __propThrowOnSet(ctor.prototype.structName,key);
    }else{
      prop.set = function(v){
        if(dbg.setter){
          log("debug.setter:",f._.setters[sigGlyph],"for", sigIR(sigGlyph),
              xPropName,'@', this.pointer,'+',descr.offset,'sz',descr.sizeof, v);
        }
        if(!this.pointer){
          toss("Cannot set struct property on disposed instance.");
        }
        if(null===v) v = 0;
        else while(!isNumericValue(v)){
          if(isAutoPtrSig(descr.signature) && (v instanceof StructType)){
            
            v = v.pointer || 0;
            if(dbg.setter) log("debug.setter:",xPropName,"resolved to",v);
            break;
          }
          toss("Invalid value for pointer-type",xPropName+'.');
        }
        (
          new DataView(heap().buffer, this.pointer + descr.offset, descr.sizeof)
        )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);
      };
    }
    Object.defineProperty(ctor.prototype, key, prop);
  };
  
  
  const StructBinder = function StructBinder(structName, structInfo){
    if(1===arguments.length){
      structInfo = structName;
      structName = structInfo.name;
    }else if(!structInfo.name){
      structInfo.name = structName;
    }
    if(!structName) toss("Struct name is required.");
    let lastMember = false;
    Object.keys(structInfo.members).forEach((k)=>{
      
      const m = structInfo.members[k];
      if(!m.sizeof) toss(structName,"member",k,"is missing sizeof.");
      else if(m.sizeof===1){
        (m.signature === 'c' || m.signature === 'C') ||
          toss("Unexpected sizeof==1 member",
               sPropName(structInfo.name,k),
               "with signature",m.signature);
      }else{
        
        
        if(0!==(m.sizeof%4)){
          console.warn("Invalid struct member description =",m,"from",structInfo);
          toss(structName,"member",k,"sizeof is not aligned. sizeof="+m.sizeof);
        }
        if(0!==(m.offset%4)){
          console.warn("Invalid struct member description =",m,"from",structInfo);
          toss(structName,"member",k,"offset is not aligned. offset="+m.offset);
        }
      }
      if(!lastMember || lastMember.offset < m.offset) lastMember = m;
    });
    if(!lastMember) toss("No member property descriptions found.");
    else if(structInfo.sizeof < lastMember.offset+lastMember.sizeof){
      toss("Invalid struct config:",structName,
           "max member offset ("+lastMember.offset+") ",
           "extends past end of struct (sizeof="+structInfo.sizeof+").");
    }
    const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));
    
    const StructCtor = function StructCtor(externalMemory){
      if(!(this instanceof StructCtor)){
        toss("The",structName,"constructor may only be called via 'new'.");
      }else if(arguments.length){
        if(externalMemory!==(externalMemory|0) || externalMemory<=0){
          toss("Invalid pointer value for",structName,"constructor.");
        }
        __allocStruct(StructCtor, this, externalMemory);
      }else{
        __allocStruct(StructCtor, this);
      }
    };
    Object.defineProperties(StructCtor,{
      debugFlags: debugFlags,
      isA: rop((v)=>v instanceof StructCtor),
      memberKey: __memberKeyProp,
      memberKeys: __structMemberKeys,
      methodInfoForKey: rop(function(mKey){
      }),
      structInfo: rop(structInfo),
      structName: rop(structName)
    });
    StructCtor.prototype = new StructType(structName, structInfo, rop);
    Object.defineProperties(StructCtor.prototype,{
      debugFlags: debugFlags,
      constructor: rop(StructCtor)
      
    });
    Object.keys(structInfo.members).forEach(
      (name)=>makeMemberWrapper(StructCtor, name, structInfo.members[name])
    );
    return StructCtor;
  };
  StructBinder.StructType = StructType;
  StructBinder.config = config;
  StructBinder.allocCString = __allocCString;
  if(!StructBinder.debugFlags){
    StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
  }
  return StructBinder;
};



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  'use strict';
  const toss = (...args)=>{throw new Error(args.join(' '))};
  const toss3 = sqlite3.SQLite3Error.toss;
  const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
  globalThis.WhWasmUtilInstaller(wasm);
  delete globalThis.WhWasmUtilInstaller;

  if(false){}

  
  wasm.bindingSignatures = [
    
    ["sqlite3_aggregate_context","void*", "sqlite3_context*", "int"],
    
    
    ["sqlite3_bind_double","int", "sqlite3_stmt*", "int", "f64"],
    ["sqlite3_bind_int","int", "sqlite3_stmt*", "int", "int"],
    ["sqlite3_bind_null",undefined, "sqlite3_stmt*", "int"],
    ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
    ["sqlite3_bind_parameter_index","int", "sqlite3_stmt*", "string"],
    ["sqlite3_bind_pointer", "int",
     "sqlite3_stmt*", "int", "*", "string:static", "*"],
    ["sqlite3_busy_handler","int", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        signature: 'i(pi)',
        contextKey: (argv,argIndex)=>argv[0]
      }),
      "*"
    ]],
    ["sqlite3_busy_timeout","int", "sqlite3*", "int"],
    
    
    ["sqlite3_changes", "int", "sqlite3*"],
    ["sqlite3_clear_bindings","int", "sqlite3_stmt*"],
    ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
    ["sqlite3_column_blob","*", "sqlite3_stmt*", "int"],
    ["sqlite3_column_bytes","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_count", "int", "sqlite3_stmt*"],
    ["sqlite3_column_double","f64", "sqlite3_stmt*", "int"],
    ["sqlite3_column_int","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_name","string", "sqlite3_stmt*", "int"],
    ["sqlite3_column_text","string", "sqlite3_stmt*", "int"],
    ["sqlite3_column_type","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_value","sqlite3_value*", "sqlite3_stmt*", "int"],
    ["sqlite3_commit_hook", "void*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_commit_hook',
        signature: 'i(p)',
        contextKey: (argv)=>argv[0]
      }),
      '*'
    ]],
    ["sqlite3_compileoption_get", "string", "int"],
    ["sqlite3_compileoption_used", "int", "string"],
    ["sqlite3_complete", "int", "string:flexible"],
    ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],

    
    
    ["sqlite3_data_count", "int", "sqlite3_stmt*"],
    ["sqlite3_db_filename", "string", "sqlite3*", "string"],
    ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
    ["sqlite3_db_name", "string", "sqlite3*", "int"],
    ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
    ["sqlite3_errcode", "int", "sqlite3*"],
    ["sqlite3_errmsg", "string", "sqlite3*"],
    ["sqlite3_error_offset", "int", "sqlite3*"],
    ["sqlite3_errstr", "string", "int"],
    ["sqlite3_exec", "int", [
      "sqlite3*", "string:flexible",
      new wasm.xWrap.FuncPtrAdapter({
        signature: 'i(pipp)',
        bindScope: 'transient',
        callProxy: (callback)=>{
          let aNames;
          return (pVoid, nCols, pColVals, pColNames)=>{
            try {
              const aVals = wasm.cArgvToJs(nCols, pColVals);
              if(!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);
              return callback(aVals, aNames) | 0;
            }catch(e){
              
              return e.resultCode || capi.SQLITE_ERROR;
            }
          }
        }
      }),
      "*", "**"
    ]],
    ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
    ["sqlite3_extended_errcode", "int", "sqlite3*"],
    ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
    ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
    ["sqlite3_finalize", "int", "sqlite3_stmt*"],
    ["sqlite3_free", undefined,"*"],
    ["sqlite3_get_autocommit", "int", "sqlite3*"],
    ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
    ["sqlite3_initialize", undefined],
    
    ["sqlite3_keyword_count", "int"],
    ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
    ["sqlite3_keyword_check", "int", ["string", "int"]],
    ["sqlite3_libversion", "string"],
    ["sqlite3_libversion_number", "int"],
    ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
    ["sqlite3_malloc", "*","int"],
    ["sqlite3_open", "int", "string", "*"],
    ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
    
    
    ["sqlite3_progress_handler", undefined, [
      "sqlite3*", "int", new wasm.xWrap.FuncPtrAdapter({
        name: 'xProgressHandler',
        signature: 'i(p)',
        bindScope: 'context',
        contextKey: (argv,argIndex)=>argv[0]
      }), "*"
    ]],
    ["sqlite3_realloc", "*","*","int"],
    ["sqlite3_reset", "int", "sqlite3_stmt*"],
    
    ["sqlite3_result_blob", undefined, "sqlite3_context*", "*", "int", "*"],
    ["sqlite3_result_double", undefined, "sqlite3_context*", "f64"],
    ["sqlite3_result_error", undefined, "sqlite3_context*", "string", "int"],
    ["sqlite3_result_error_code", undefined, "sqlite3_context*", "int"],
    ["sqlite3_result_error_nomem", undefined, "sqlite3_context*"],
    ["sqlite3_result_error_toobig", undefined, "sqlite3_context*"],
    ["sqlite3_result_int", undefined, "sqlite3_context*", "int"],
    ["sqlite3_result_null", undefined, "sqlite3_context*"],
    ["sqlite3_result_pointer", undefined,
     "sqlite3_context*", "*", "string:static", "*"],
    ["sqlite3_result_subtype", undefined, "sqlite3_value*", "int"],
    ["sqlite3_result_text", undefined, "sqlite3_context*", "string", "int", "*"],
    ["sqlite3_result_zeroblob", undefined, "sqlite3_context*", "int"],
    ["sqlite3_rollback_hook", "void*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_rollback_hook',
        signature: 'v(p)',
        contextKey: (argv)=>argv[0]
      }),
      '*'
    ]],
    ["sqlite3_set_authorizer", "int", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: "sqlite3_set_authorizer::xAuth",
        signature: "i(pi"+"ssss)",
        contextKey: (argv, argIndex)=>argv[0],
        callProxy: (callback)=>{
          return (pV, iCode, s0, s1, s2, s3)=>{
            try{
              s0 = s0 && wasm.cstrToJs(s0); s1 = s1 && wasm.cstrToJs(s1);
              s2 = s2 && wasm.cstrToJs(s2); s3 = s3 && wasm.cstrToJs(s3);
              return callback(pV, iCode, s0, s1, s2, s3) || 0;
            }catch(e){
              return e.resultCode || capi.SQLITE_ERROR;
            }
          }
        }
      }),
      "*"
    ]],
    ["sqlite3_set_auxdata", undefined, [
      "sqlite3_context*", "int", "*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'xDestroyAuxData',
        signature: 'v(*)',
        contextKey: (argv, argIndex)=>argv[0]
      })
    ]],
    ["sqlite3_shutdown", undefined],
    ["sqlite3_sourceid", "string"],
    ["sqlite3_sql", "string", "sqlite3_stmt*"],
    ["sqlite3_status", "int", "int", "*", "*", "int"],
    ["sqlite3_step", "int", "sqlite3_stmt*"],
    ["sqlite3_stmt_isexplain", "int", ["sqlite3_stmt*"]],
    ["sqlite3_stmt_readonly", "int", ["sqlite3_stmt*"]],
    ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
    ["sqlite3_strglob", "int", "string","string"],
    ["sqlite3_stricmp", "int", "string", "string"],
    ["sqlite3_strlike", "int", "string", "string","int"],
    ["sqlite3_strnicmp", "int", "string", "string", "int"],
    ["sqlite3_table_column_metadata", "int",
     "sqlite3*", "string", "string", "string",
     "**", "**", "*", "*", "*"],
    ["sqlite3_total_changes", "int", "sqlite3*"],
    ["sqlite3_trace_v2", "int", [
      "sqlite3*", "int",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_trace_v2::callback',
        signature: 'i(ippp)',
        contextKey: (argv,argIndex)=>argv[0]
      }),
      "*"
    ]],
    ["sqlite3_txn_state", "int", ["sqlite3*","string"]],
    
    ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
    ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
    ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
    ["sqlite3_user_data","void*", "sqlite3_context*"],
    ["sqlite3_value_blob", "*", "sqlite3_value*"],
    ["sqlite3_value_bytes","int", "sqlite3_value*"],
    ["sqlite3_value_double","f64", "sqlite3_value*"],
    ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
    ["sqlite3_value_free", undefined, "sqlite3_value*"],
    ["sqlite3_value_frombind", "int", "sqlite3_value*"],
    ["sqlite3_value_int","int", "sqlite3_value*"],
    ["sqlite3_value_nochange", "int", "sqlite3_value*"],
    ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
    ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
    ["sqlite3_value_subtype", "int", "sqlite3_value*"],
    ["sqlite3_value_text", "string", "sqlite3_value*"],
    ["sqlite3_value_type", "int", "sqlite3_value*"],
    ["sqlite3_vfs_find", "*", "string"],
    ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
    ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
  ];

  if(false){}

  if(wasm.exports.sqlite3_activate_see instanceof Function){
    wasm.bindingSignatures.push(
      ["sqlite3_key", "int", "sqlite3*", "string", "int"],
      ["sqlite3_key_v2","int","sqlite3*","string","*","int"],
      ["sqlite3_rekey", "int", "sqlite3*", "string", "int"],
      ["sqlite3_rekey_v2", "int", "sqlite3*", "string", "*", "int"],
      ["sqlite3_activate_see", undefined, "string"]
    );
  }
  
  wasm.bindingSignatures.int64 = [
    ["sqlite3_bind_int64","int", ["sqlite3_stmt*", "int", "i64"]],
    ["sqlite3_changes64","i64", ["sqlite3*"]],
    ["sqlite3_column_int64","i64", ["sqlite3_stmt*", "int"]],
    ["sqlite3_create_module", "int",
     ["sqlite3*","string","sqlite3_module*","*"]],
    ["sqlite3_create_module_v2", "int",
     ["sqlite3*","string","sqlite3_module*","*","*"]],
    ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
    ["sqlite3_deserialize", "int", "sqlite3*", "string", "*", "i64", "i64", "int"]
    ,
    ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
    ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
    ["sqlite3_malloc64", "*","i64"],
    ["sqlite3_msize", "i64", "*"],
    ["sqlite3_overload_function", "int", ["sqlite3*","string","int"]],
    ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
    ["sqlite3_preupdate_count", "int", "sqlite3*"],
    ["sqlite3_preupdate_depth", "int", "sqlite3*"],
    ["sqlite3_preupdate_hook", "*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_preupdate_hook',
        signature: "v(ppippjj)",
        contextKey: (argv)=>argv[0],
        callProxy: (callback)=>{
          return (p,db,op,zDb,zTbl,iKey1,iKey2)=>{
            callback(p, db, op, wasm.cstrToJs(zDb), wasm.cstrToJs(zTbl),
                     iKey1, iKey2);
          };
        }
      }),
      "*"
    ]],
    ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
    ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]],
    ["sqlite3_realloc64", "*","*", "i64"],
    ["sqlite3_result_int64", undefined, "*", "i64"],
    ["sqlite3_result_zeroblob64", "int", "*", "i64"],
    ["sqlite3_serialize","*", "sqlite3*", "string", "*", "int"],
    ["sqlite3_set_last_insert_rowid", undefined, ["sqlite3*", "i64"]],
    ["sqlite3_status64", "int", "int", "*", "*", "int"],
    ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
    ["sqlite3_update_hook", "*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_update_hook',
        signature: "v(iippj)",
        contextKey: (argv)=>argv[0],
        callProxy: (callback)=>{
          return (p,op,z0,z1,rowid)=>{
            callback(p, op, wasm.cstrToJs(z0), wasm.cstrToJs(z1), rowid);
          };
        }
      }),
      "*"
    ]],
    ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
    ["sqlite3_value_int64","i64", "sqlite3_value*"],
    ["sqlite3_vtab_collation","string","sqlite3_index_info*","int"],
    ["sqlite3_vtab_distinct","int", "sqlite3_index_info*"],
    ["sqlite3_vtab_in","int", "sqlite3_index_info*", "int", "int"],
    ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
    ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
    
    ["sqlite3_vtab_nochange","int", "sqlite3_context*"],
    ["sqlite3_vtab_on_conflict","int", "sqlite3*"],
    ["sqlite3_vtab_rhs_value","int", "sqlite3_index_info*", "int", "**"]
  ];

  
  if(wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add){
    
    
    const __ipsProxy = {
      signature: 'i(ps)',
      callProxy:(callback)=>{
        return (p,s)=>{
          try{return callback(p, wasm.cstrToJs(s)) | 0}
          catch(e){return e.resultCode || capi.SQLITE_ERROR}
        }
      }
    };

    wasm.bindingSignatures.int64.push(...[
      ['sqlite3changegroup_add', 'int', ['sqlite3_changegroup*', 'int', 'void*']],
      ['sqlite3changegroup_add_strm', 'int', [
        'sqlite3_changegroup*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changegroup_delete', undefined, ['sqlite3_changegroup*']],
      ['sqlite3changegroup_new', 'int', ['**']],
      ['sqlite3changegroup_output', 'int', ['sqlite3_changegroup*', 'int*', '**']],
      ['sqlite3changegroup_output_strm', 'int', [
        'sqlite3_changegroup*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply', 'int', [
        'sqlite3*', 'int', 'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply_strm', 'int', [
        'sqlite3*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply_v2', 'int', [
        'sqlite3*', 'int', 'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*', '**', 'int*', 'int'

      ]],
      ['sqlite3changeset_apply_v2_strm', 'int', [
        'sqlite3*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*', '**', 'int*', 'int'
      ]],
      ['sqlite3changeset_concat', 'int', ['int','void*', 'int', 'void*', 'int*', '**']],
      ['sqlite3changeset_concat_strm', 'int', [
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInputA', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInputB', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_conflict', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],
      ['sqlite3changeset_fk_conflicts', 'int', ['sqlite3_changeset_iter*', 'int*']],
      ['sqlite3changeset_invert', 'int', ['int', 'void*', 'int*', '**']],
      ['sqlite3changeset_invert_strm', 'int', [
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_new', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],
      ['sqlite3changeset_old', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_op', 'int', [
        'sqlite3_changeset_iter*', '**', 'int*', 'int*','int*'
      ]],
      ['sqlite3changeset_pk', 'int', ['sqlite3_changeset_iter*', '**', 'int*']],
      ['sqlite3changeset_start', 'int', ['**', 'int', '*']],
      ['sqlite3changeset_start_strm', 'int', [
        '**',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],
      ['sqlite3changeset_start_v2_strm', 'int', [
        '**',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*', 'int'
      ]],
      ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],
      ['sqlite3session_changeset', 'int', ['sqlite3_session*', 'int*', '**']],
      ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],
      ['sqlite3session_changeset_strm', 'int', [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3session_config', 'int', ['int', 'void*']],
      ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],
      
      ['sqlite3session_diff', 'int', ['sqlite3_session*', 'string', 'string', '**']],
      ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],
      ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],
      ['sqlite3session_isempty', 'int', ['sqlite3_session*']],
      ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],
      ['sqlite3session_object_config', 'int', ['sqlite3_session*', 'int', 'void*']],
      ['sqlite3session_patchset', 'int', ['sqlite3_session*', '*', '**']],
      ['sqlite3session_patchset_strm', 'int', [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3session_table_filter', undefined, [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', ...__ipsProxy,
          contextKey: (argv,argIndex)=>argv[0]
        }),
        '*'
      ]]
    ]);
  }

  
  wasm.bindingSignatures.wasm = [
    ["sqlite3_wasm_db_reset", "int", "sqlite3*"],
    ["sqlite3_wasm_db_vfs", "sqlite3_vfs*", "sqlite3*","string"],
    ["sqlite3_wasm_vfs_create_file", "int",
     "sqlite3_vfs*","string","*", "int"],
    ["sqlite3_wasm_posix_create_file", "int", "string","*", "int"],
    ["sqlite3_wasm_vfs_unlink", "int", "sqlite3_vfs*","string"]
  ];

  
  sqlite3.StructBinder = globalThis.Jaccwabyt({
    heap:  false ? 0 : wasm.heap8u,
    alloc: wasm.alloc,
    dealloc: wasm.dealloc,
    bigIntEnabled: wasm.bigIntEnabled,
    memberPrefix:  '$'
  });
  delete globalThis.Jaccwabyt;

  {

    
    const __xString = wasm.xWrap.argAdapter('string');
    wasm.xWrap.argAdapter(
      'string:flexible', (v)=>__xString(util.flexibleString(v))
    );

    
    wasm.xWrap.argAdapter(
      'string:static',
      function(v){
        if(wasm.isPtr(v)) return v;
        v = ''+v;
        let rc = this[v];
        return rc || (this[v] = wasm.allocCString(v));
      }.bind(Object.create(null))
    );

    
    const __xArgPtr = wasm.xWrap.argAdapter('*');
    const nilType = function(){};
    wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)
    ('sqlite3_context*', __xArgPtr)
    ('sqlite3_value*', __xArgPtr)
    ('void*', __xArgPtr)
    ('sqlite3_changegroup*', __xArgPtr)
    ('sqlite3_changeset_iter*', __xArgPtr)
    
    ('sqlite3_session*', __xArgPtr)
    ('sqlite3_stmt*', (v)=>
      __xArgPtr((v instanceof (sqlite3?.oo1?.Stmt || nilType))
           ? v.pointer : v))
    ('sqlite3*', (v)=>
      __xArgPtr((v instanceof (sqlite3?.oo1?.DB || nilType))
           ? v.pointer : v))
    ('sqlite3_index_info*', (v)=>
      __xArgPtr((v instanceof (capi.sqlite3_index_info || nilType))
           ? v.pointer : v))
    ('sqlite3_module*', (v)=>
      __xArgPtr((v instanceof (capi.sqlite3_module || nilType))
           ? v.pointer : v))
    
    ('sqlite3_vfs*', (v)=>{
      if('string'===typeof v){
        
        return capi.sqlite3_vfs_find(v)
          || sqlite3.SQLite3Error.toss(
            capi.SQLITE_NOTFOUND,
            "Unknown sqlite3_vfs name:", v
          );
      }
      return __xArgPtr((v instanceof (capi.sqlite3_vfs || nilType))
                       ? v.pointer : v);
    });

    const __xRcPtr = wasm.xWrap.resultAdapter('*');
    wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)
    ('sqlite3_context*', __xRcPtr)
    ('sqlite3_stmt*', __xRcPtr)
    ('sqlite3_value*', __xRcPtr)
    ('sqlite3_vfs*', __xRcPtr)
    ('void*', __xRcPtr);

    
    if(0 === wasm.exports.sqlite3_step.length){
      
      wasm.xWrap.doArgcCheck = false;
      sqlite3.config.warn(
        "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
      );
    }
    for(const e of wasm.bindingSignatures){
      capi[e[0]] = wasm.xWrap.apply(null, e);
    }
    for(const e of wasm.bindingSignatures.wasm){
      wasm[e[0]] = wasm.xWrap.apply(null, e);
    }

    
    const fI64Disabled = function(fname){
      return ()=>toss(fname+"() is unavailable due to lack",
                      "of BigInt support in this build.");
    };
    for(const e of wasm.bindingSignatures.int64){
      capi[e[0]] = wasm.bigIntEnabled
        ? wasm.xWrap.apply(null, e)
        : fI64Disabled(e[0]);
    }

    
    delete wasm.bindingSignatures;

    if(wasm.exports.sqlite3_wasm_db_error){
      const __db_err = wasm.xWrap(
        'sqlite3_wasm_db_error', 'int', 'sqlite3*', 'int', 'string'
      );
      
      util.sqlite3_wasm_db_error = function(pDb, resultCode, message){
        if(resultCode instanceof sqlite3.WasmAllocError){
          resultCode = capi.SQLITE_NOMEM;
          message = 0 ;
        }else if(resultCode instanceof Error){
          message = message || ''+resultCode;
          resultCode = (resultCode.resultCode || capi.SQLITE_ERROR);
        }
        return pDb ? __db_err(pDb, resultCode, message) : resultCode;
      };
    }else{
      util.sqlite3_wasm_db_error = function(pDb,errCode,msg){
        console.warn("sqlite3_wasm_db_error() is not exported.",arguments);
        return errCode;
      };
    }
  }

  {
    const cJson = wasm.xCall('sqlite3_wasm_enum_json');
    if(!cJson){
      toss("Maintenance required: increase sqlite3_wasm_enum_json()'s",
           "static buffer size!");
    }
    
    wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));
    
    const defineGroups = ['access', 'authorizer',
                          'blobFinalizers', 'changeset',
                          'config', 'dataTypes',
                          'dbConfig', 'dbStatus',
                          'encodings', 'fcntl', 'flock', 'ioCap',
                          'limits', 'openFlags',
                          'prepareFlags', 'resultCodes',
                          'sqlite3Status',
                          'stmtStatus', 'syncFlags',
                          'trace', 'txnState', 'udfFlags',
                          'version' ];
    if(wasm.bigIntEnabled){
      defineGroups.push('serialize', 'session', 'vtab');
    }
    for(const t of defineGroups){
      for(const e of Object.entries(wasm.ctype[t])){
        
        
        capi[e[0]] = e[1];
      }
    }
    if(!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)){
      toss("Internal error: cannot resolve exported function",
           "entry SQLITE_WASM_DEALLOC (=="+capi.SQLITE_WASM_DEALLOC+").");
    }
    const __rcMap = Object.create(null);
    for(const t of ['resultCodes']){
      for(const e of Object.entries(wasm.ctype[t])){
        __rcMap[e[1]] = e[0];
      }
    }
    
    capi.sqlite3_js_rc_str = (rc)=>__rcMap[rc];
    
    const notThese = Object.assign(Object.create(null),{
      
      WasmTestStruct: true,
      
      sqlite3_kvvfs_methods: !util.isUIThread(),
      
      sqlite3_index_info: !wasm.bigIntEnabled,
      sqlite3_index_constraint: !wasm.bigIntEnabled,
      sqlite3_index_orderby: !wasm.bigIntEnabled,
      sqlite3_index_constraint_usage: !wasm.bigIntEnabled
    });
    for(const s of wasm.ctype.structs){
      if(!notThese[s.name]){
        capi[s.name] = sqlite3.StructBinder(s);
      }
    }
    if(capi.sqlite3_index_info){
      
      for(const k of ['sqlite3_index_constraint',
                      'sqlite3_index_orderby',
                      'sqlite3_index_constraint_usage']){
        capi.sqlite3_index_info[k] = capi[k];
        delete capi[k];
      }
      capi.sqlite3_vtab_config = wasm.xWrap(
        'sqlite3_wasm_vtab_config','int',[
          'sqlite3*', 'int', 'int']
      );
    }
  }

  
  const __dbArgcMismatch = (pDb,f,n)=>{
    return util.sqlite3_wasm_db_error(pDb, capi.SQLITE_MISUSE,
                                      f+"() requires "+n+" argument"+
                                      (1===n?"":'s')+".");
  };

  
  const __errEncoding = (pDb)=>{
    return util.sqlite3_wasm_db_error(
      pDb, capi.SQLITE_FORMAT, "SQLITE_UTF8 is the only supported encoding."
    );
  };

  
  const __argPDb = (pDb)=>wasm.xWrap.argAdapter('sqlite3*')(pDb);
  const __argStr = (str)=>wasm.isPtr(str) ? wasm.cstrToJs(str) : str;
  const __dbCleanupMap = function(
    pDb, mode
  ){
    pDb = __argPDb(pDb);
    let m = this.dbMap.get(pDb);
    if(!mode){
      this.dbMap.delete(pDb);
      return m;
    }else if(!m && mode>0){
      this.dbMap.set(pDb, (m = Object.create(null)));
    }
    return m;
  }.bind(Object.assign(Object.create(null),{
    dbMap: new Map
  }));

  __dbCleanupMap.addCollation = function(pDb, name){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.collation) m.collation = new Set;
    m.collation.add(__argStr(name).toLowerCase());
  };

  __dbCleanupMap._addUDF = function(pDb, name, arity, map){
    
    name = __argStr(name).toLowerCase();
    let u = map.get(name);
    if(!u) map.set(name, (u = new Set));
    u.add((arity<0) ? -1 : arity);
  };

  __dbCleanupMap.addFunction = function(pDb, name, arity){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.udf) m.udf = new Map;
    this._addUDF(pDb, name, arity, m.udf);
  };

  __dbCleanupMap.addWindowFunc = function(pDb, name, arity){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.wudf) m.wudf = new Map;
    this._addUDF(pDb, name, arity, m.wudf);
  };

  
  __dbCleanupMap.cleanup = function(pDb){
    pDb = __argPDb(pDb);
    
    
    const closeArgs = [pDb];
    for(const name of [
      'sqlite3_busy_handler',
      'sqlite3_commit_hook',
      'sqlite3_preupdate_hook',
      'sqlite3_progress_handler',
      'sqlite3_rollback_hook',
      'sqlite3_set_authorizer',
      'sqlite3_trace_v2',
      'sqlite3_update_hook'
    ]) {
      const x = wasm.exports[name];
      closeArgs.length = x.length
      ;
      try{ capi[name](...closeArgs) }
      catch(e){
        console.warn("close-time call of",name+"(",closeArgs,") threw:",e);
      }
    }
    const m = __dbCleanupMap(pDb, 0);
    if(!m) return;
    if(m.collation){
      for(const name of m.collation){
        try{
          capi.sqlite3_create_collation_v2(
            pDb, name, capi.SQLITE_UTF8, 0, 0, 0
          );
        }catch(e){
          
        }
      }
      delete m.collation;
    }
    let i;
    for(i = 0; i < 2; ++i){ 
      const fmap = i ? m.wudf : m.udf;
      if(!fmap) continue;
      const func = i
            ? capi.sqlite3_create_window_function
            : capi.sqlite3_create_function_v2;
      for(const e of fmap){
        const name = e[0], arities = e[1];
        const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
        if(i) fargs.push(0);
        for(const arity of arities){
          try{ fargs[2] = arity; func.apply(null, fargs); }
          catch(e){}
        }
        arities.clear();
      }
      fmap.clear();
    }
    delete m.udf;
    delete m.wudf;
  };

  {
    const __sqlite3CloseV2 = wasm.xWrap("sqlite3_close_v2", "int", "sqlite3*");
    capi.sqlite3_close_v2 = function(pDb){
      if(1!==arguments.length) return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);
      if(pDb){
        try{__dbCleanupMap.cleanup(pDb)} catch(e){}
      }
      return __sqlite3CloseV2(pDb);
    };
  }

  if(capi.sqlite3session_table_filter){
    const __sqlite3SessionDelete = wasm.xWrap(
      'sqlite3session_delete', undefined, ['sqlite3_session*']
    );
    capi.sqlite3session_delete = function(pSession){
      if(1!==arguments.length){
        return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);
        
      }
      else if(pSession){
        
        capi.sqlite3session_table_filter(pSession, 0, 0);
      }
      __sqlite3SessionDelete(pSession);
    };
  }

  {
    
    const contextKey = (argv,argIndex)=>{
      return 'argv['+argIndex+']:'+argv[0]+
        ':'+wasm.cstrToJs(argv[1]).toLowerCase()
    };
    const __sqlite3CreateCollationV2 = wasm.xWrap(
      'sqlite3_create_collation_v2', 'int', [
        'sqlite3*', 'string', 'int', '*',
        new wasm.xWrap.FuncPtrAdapter({
          
          name: 'xCompare', signature: 'i(pipip)', contextKey
        }),
        new wasm.xWrap.FuncPtrAdapter({
          
          name: 'xDestroy', signature: 'v(p)', contextKey
        })
      ]
    );

    
    capi.sqlite3_create_collation_v2 = function(pDb,zName,eTextRep,pArg,xCompare,xDestroy){
      if(6!==arguments.length) return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);
      else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateCollationV2(pDb, zName, eTextRep, pArg, xCompare, xDestroy);
        if(0===rc && xCompare instanceof Function){
          __dbCleanupMap.addCollation(pDb, zName);
        }
        return rc;
      }catch(e){
        return util.sqlite3_wasm_db_error(pDb, e);
      }
    };

    capi.sqlite3_create_collation = (pDb,zName,eTextRep,pArg,xCompare)=>{
      return (5===arguments.length)
        ? capi.sqlite3_create_collation_v2(pDb,zName,eTextRep,pArg,xCompare,0)
        : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);
    };

  }

  {
    
    const contextKey = function(argv,argIndex){
      return (
        argv[0]
          +':'+(argv[2] < 0 ? -1 : argv[2])
          +':'+argIndex
          +':'+wasm.cstrToJs(argv[1]).toLowerCase()
      )
    };

    
    const __cfProxy = Object.assign(Object.create(null), {
      xInverseAndStep: {
        signature:'v(pip)', contextKey,
        callProxy: (callback)=>{
          return (pCtx, argc, pArgv)=>{
            try{ callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)) }
            catch(e){ capi.sqlite3_result_error_js(pCtx, e) }
          };
        }
      },
      xFinalAndValue: {
        signature:'v(p)', contextKey,
        callProxy: (callback)=>{
          return (pCtx)=>{
            try{ capi.sqlite3_result_js(pCtx, callback(pCtx)) }
            catch(e){ capi.sqlite3_result_error_js(pCtx, e) }
          };
        }
      },
      xFunc: {
        signature:'v(pip)', contextKey,
        callProxy: (callback)=>{
          return (pCtx, argc, pArgv)=>{
            try{
              capi.sqlite3_result_js(
                pCtx,
                callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
              );
            }catch(e){
              
              capi.sqlite3_result_error_js(pCtx, e);
            }
          };
        }
      },
      xDestroy: {
        signature:'v(p)', contextKey,
        
        callProxy: (callback)=>{
          return (pVoid)=>{
            try{ callback(pVoid) }
            catch(e){ console.error("UDF xDestroy method threw:",e) }
          };
        }
      }
    });

    const __sqlite3CreateFunction = wasm.xWrap(
      "sqlite3_create_function_v2", "int", [
        "sqlite3*", "string", "int",
        "int", "*",
        new wasm.xWrap.FuncPtrAdapter({name: 'xFunc', ...__cfProxy.xFunc}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xStep', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xFinal', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xDestroy', ...__cfProxy.xDestroy})
      ]
    );

    const __sqlite3CreateWindowFunction = wasm.xWrap(
      "sqlite3_create_window_function", "int", [
        "sqlite3*", "string", "int",
        "int", "*",
        new wasm.xWrap.FuncPtrAdapter({name: 'xStep', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xFinal', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xValue', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xInverse', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xDestroy', ...__cfProxy.xDestroy})
      ]
    );

    
    capi.sqlite3_create_function_v2 = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc,   
      xStep,   
      xFinal,  
      xDestroy 
    ){
      if( f.length!==arguments.length ){
        return __dbArgcMismatch(pDb,"sqlite3_create_function_v2",f.length);
      }else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateFunction(pDb, funcName, nArg, eTextRep,
                                           pApp, xFunc, xStep, xFinal, xDestroy);
        if(0===rc && (xFunc instanceof Function
                      || xStep instanceof Function
                      || xFinal instanceof Function
                      || xDestroy instanceof Function)){
          __dbCleanupMap.addFunction(pDb, funcName, nArg);
        }
        return rc;
      }catch(e){
        console.error("sqlite3_create_function_v2() setup threw:",e);
        return util.sqlite3_wasm_db_error(pDb, e, "Creation of UDF threw: "+e);
      }
    };

    
    capi.sqlite3_create_function = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal
    ){
      return (f.length===arguments.length)
        ? capi.sqlite3_create_function_v2(pDb, funcName, nArg, eTextRep,
                                          pApp, xFunc, xStep, xFinal, 0)
        : __dbArgcMismatch(pDb,"sqlite3_create_function",f.length);
    };

    
    capi.sqlite3_create_window_function = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xStep,   
      xFinal,  
      xValue,  
      xInverse,
      xDestroy 
    ){
      if( f.length!==arguments.length ){
        return __dbArgcMismatch(pDb,"sqlite3_create_window_function",f.length);
      }else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateWindowFunction(pDb, funcName, nArg, eTextRep,
                                                 pApp, xStep, xFinal, xValue,
                                                 xInverse, xDestroy);
        if(0===rc && (xStep instanceof Function
                      || xFinal instanceof Function
                      || xValue instanceof Function
                      || xInverse instanceof Function
                      || xDestroy instanceof Function)){
          __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);
        }
        return rc;
      }catch(e){
        console.error("sqlite3_create_window_function() setup threw:",e);
        return util.sqlite3_wasm_db_error(pDb, e, "Creation of UDF threw: "+e);
      }
    };
    
    capi.sqlite3_create_function_v2.udfSetResult =
      capi.sqlite3_create_function.udfSetResult =
      capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;

    
    capi.sqlite3_create_function_v2.udfConvertArgs =
      capi.sqlite3_create_function.udfConvertArgs =
      capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;

    
    capi.sqlite3_create_function_v2.udfSetError =
      capi.sqlite3_create_function.udfSetError =
      capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;

  };

  {

    
    const __flexiString = (v,n)=>{
      if('string'===typeof v){
        n = -1;
      }else if(util.isSQLableTypedArray(v)){
        n = v.byteLength;
        v = util.typedArrayToString(
          (v instanceof ArrayBuffer) ? new Uint8Array(v) : v
        );
      }else if(Array.isArray(v)){
        v = v.join("");
        n = -1;
      }
      return [v, n];
    };

    
    const __prepare = {
      
      basic: wasm.xWrap('sqlite3_prepare_v3',
                        "int", ["sqlite3*", "string",
                                "int",
                                "int", "**",
                                "**"]),
      
      full: wasm.xWrap('sqlite3_prepare_v3',
                       "int", ["sqlite3*", "*", "int", "int",
                               "**", "**"])
    };

    
    capi.sqlite3_prepare_v3 = function f(pDb, sql, sqlLen, prepFlags, ppStmt, pzTail){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(pDb,"sqlite3_prepare_v3",f.length);
      }
      const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
      switch(typeof xSql){
          case 'string': return __prepare.basic(pDb, xSql, xSqlLen, prepFlags, ppStmt, null);
          case 'number': return __prepare.full(pDb, xSql, xSqlLen, prepFlags, ppStmt, pzTail);
          default:
            return util.sqlite3_wasm_db_error(
              pDb, capi.SQLITE_MISUSE,
              "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
            );
      }
    };

    
    capi.sqlite3_prepare_v2 = function f(pDb, sql, sqlLen, ppStmt, pzTail){
      return (f.length===arguments.length)
        ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)
        : __dbArgcMismatch(pDb,"sqlite3_prepare_v2",f.length);
    };

  }

  {
    const __bindText = wasm.xWrap("sqlite3_bind_text", "int", [
      "sqlite3_stmt*", "int", "string", "int", "*"
    ]);
    const __bindBlob = wasm.xWrap("sqlite3_bind_blob", "int", [
      "sqlite3_stmt*", "int", "*", "int", "*"
    ]);

    
    capi.sqlite3_bind_text = function f(pStmt, iCol, text, nText, xDestroy){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(capi.sqlite3_db_handle(pStmt),
                                "sqlite3_bind_text", f.length);
      }else if(wasm.isPtr(text) || null===text){
        return __bindText(pStmt, iCol, text, nText, xDestroy);
      }else if(text instanceof ArrayBuffer){
        text = new Uint8Array(text);
      }else if(Array.isArray(pMem)){
        text = pMem.join('');
      }
      let p, n;
      try{
        if(util.isSQLableTypedArray(text)){
          p = wasm.allocFromTypedArray(text);
          n = text.byteLength;
        }else if('string'===typeof text){
          [p, n] = wasm.allocCString(text);
        }else{
          return util.sqlite3_wasm_db_error(
            capi.sqlite3_db_handle(pStmt), capi.SQLITE_MISUSE,
            "Invalid 3rd argument type for sqlite3_bind_text()."
          );
        }
        return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
      }catch(e){
        wasm.dealloc(p);
        return util.sqlite3_wasm_db_error(
          capi.sqlite3_db_handle(pStmt), e
        );
      }
    };

    
    capi.sqlite3_bind_blob = function f(pStmt, iCol, pMem, nMem, xDestroy){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(capi.sqlite3_db_handle(pStmt),
                                "sqlite3_bind_blob", f.length);
      }else if(wasm.isPtr(pMem) || null===pMem){
        return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);
      }else if(pMem instanceof ArrayBuffer){
        pMem = new Uint8Array(pMem);
      }else if(Array.isArray(pMem)){
        pMem = pMem.join('');
      }
      let p, n;
      try{
        if(util.isBindableTypedArray(pMem)){
          p = wasm.allocFromTypedArray(pMem);
          n = nMem>=0 ? nMem : pMem.byteLength;
        }else if('string'===typeof pMem){
          [p, n] = wasm.allocCString(pMem);
        }else{
          return util.sqlite3_wasm_db_error(
            capi.sqlite3_db_handle(pStmt), capi.SQLITE_MISUSE,
            "Invalid 3rd argument type for sqlite3_bind_blob()."
          );
        }
        return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
      }catch(e){
        wasm.dealloc(p);
        return util.sqlite3_wasm_db_error(
          capi.sqlite3_db_handle(pStmt), e
        );
      }
    };

  }

  {
    
    capi.sqlite3_config = function(op, ...args){
      if(arguments.length<2) return capi.SQLITE_MISUSE;
      switch(op){
          case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN: 
          case capi.SQLITE_CONFIG_MEMSTATUS:
          case capi.SQLITE_CONFIG_SMALL_MALLOC: 
          case capi.SQLITE_CONFIG_SORTERREF_SIZE: 
          case capi.SQLITE_CONFIG_STMTJRNL_SPILL: 
          case capi.SQLITE_CONFIG_URI:
            return wasm.exports.sqlite3_wasm_config_i(op, args[0]);
          case capi.SQLITE_CONFIG_LOOKASIDE: 
            return wasm.exports.sqlite3_wasm_config_ii(op, args[0], args[1]);
          case capi.SQLITE_CONFIG_MEMDB_MAXSIZE: 
            return wasm.exports.sqlite3_wasm_config_j(op, args[0]);
          case capi.SQLITE_CONFIG_GETMALLOC: 
          case capi.SQLITE_CONFIG_GETMUTEX: 
          case capi.SQLITE_CONFIG_GETPCACHE2: 
          case capi.SQLITE_CONFIG_GETPCACHE: 
          case capi.SQLITE_CONFIG_HEAP: 
          case capi.SQLITE_CONFIG_LOG: 
          case capi.SQLITE_CONFIG_MALLOC:
          case capi.SQLITE_CONFIG_MMAP_SIZE: 
          case capi.SQLITE_CONFIG_MULTITHREAD: 
          case capi.SQLITE_CONFIG_MUTEX: 
          case capi.SQLITE_CONFIG_PAGECACHE: 
          case capi.SQLITE_CONFIG_PCACHE2: 
          case capi.SQLITE_CONFIG_PCACHE: 
          case capi.SQLITE_CONFIG_PCACHE_HDRSZ: 
          case capi.SQLITE_CONFIG_PMASZ: 
          case capi.SQLITE_CONFIG_SERIALIZED: 
          case capi.SQLITE_CONFIG_SINGLETHREAD: 
          case capi.SQLITE_CONFIG_SQLLOG: 
          case capi.SQLITE_CONFIG_WIN32_HEAPSIZE: 
          default:
            return capi.SQLITE_NOTFOUND;
      }
    };
  }

  {
    const __autoExtFptr = new Set;

    capi.sqlite3_auto_extension = function(fPtr){
      if( fPtr instanceof Function ){
        fPtr = wasm.installFunction('i(ppp)', fPtr);
      }else if( 1!==arguments.length || !wasm.isPtr(fPtr) ){
        return capi.SQLITE_MISUSE;
      }
      const rc = wasm.exports.sqlite3_auto_extension(fPtr);
      if( fPtr!==arguments[0] ){
        if(0===rc) __autoExtFptr.add(fPtr);
        else wasm.uninstallFunction(fPtr);
      }
      return rc;
    };

    capi.sqlite3_cancel_auto_extension = function(fPtr){
     ;
      if(!fPtr || 1!==arguments.length || !wasm.isPtr(fPtr)) return 0;
      return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
      
    };

    capi.sqlite3_reset_auto_extension = function(){
      wasm.exports.sqlite3_reset_auto_extension();
      for(const fp of __autoExtFptr) wasm.uninstallFunction(fp);
      __autoExtFptr.clear();
    };
  }

  const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
  if( pKvvfs ){
    if(util.isUIThread()){
      const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
        wasm.exports.sqlite3_wasm_kvvfs_methods()
      );
      delete capi.sqlite3_kvvfs_methods;

      const kvvfsMakeKey = wasm.exports.sqlite3_wasm_kvvfsMakeKeyOnPstack,
            pstack = wasm.pstack;

      const kvvfsStorage = (zClass)=>
            ((115===wasm.peek(zClass))
             ? sessionStorage : localStorage);

      
      const kvvfsImpls = {
        xRead: (zClass, zKey, zBuf, nBuf)=>{
          const stack = pstack.pointer,
                astack = wasm.scopedAllocPush();
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return -3;
            const jKey = wasm.cstrToJs(zXKey);
            const jV = kvvfsStorage(zClass).getItem(jKey);
            if(!jV) return -1;
            const nV = jV.length ;
            if(nBuf<=0) return nV;
            else if(1===nBuf){
              wasm.poke(zBuf, 0);
              return nV;
            }
            const zV = wasm.scopedAllocCString(jV);
            if(nBuf > nV + 1) nBuf = nV + 1;
            wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
            wasm.poke(zBuf + nBuf - 1, 0);
            return nBuf - 1;
          }catch(e){
            console.error("kvstorageRead()",e);
            return -2;
          }finally{
            pstack.restore(stack);
            wasm.scopedAllocPop(astack);
          }
        },
        xWrite: (zClass, zKey, zData)=>{
          const stack = pstack.pointer;
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return 1;
            const jKey = wasm.cstrToJs(zXKey);
            kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
            return 0;
          }catch(e){
            console.error("kvstorageWrite()",e);
            return capi.SQLITE_IOERR;
          }finally{
            pstack.restore(stack);
          }
        },
        xDelete: (zClass, zKey)=>{
          const stack = pstack.pointer;
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return 1;
            kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
            return 0;
          }catch(e){
            console.error("kvstorageDelete()",e);
            return capi.SQLITE_IOERR;
          }finally{
            pstack.restore(stack);
          }
        }
      };
      for(const k of Object.keys(kvvfsImpls)){
        kvvfsMethods[kvvfsMethods.memberKey(k)] =
          wasm.installFunction(
            kvvfsMethods.memberSignature(k),
            kvvfsImpls[k]
          );
      }
    }else{
      
      capi.sqlite3_vfs_unregister(pKvvfs);
    }
  }

  wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
});


globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  sqlite3.version = {"libVersion": "3.45.2", "libVersionNumber": 3045002, "sourceId": "2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77","downloadVersion": 3450200};
});



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  const toss = (...args)=>{throw new Error(args.join(' '))};
  const toss3 = (...args)=>{throw new sqlite3.SQLite3Error(...args)};

  const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
  

  
  const __ptrMap = new WeakMap();
  
  const __stmtMap = new WeakMap();

  
  const getOwnOption = (opts, p, dflt)=>{
    const d = Object.getOwnPropertyDescriptor(opts,p);
    return d ? d.value : dflt;
  };

  
  const checkSqlite3Rc = function(dbPtr, sqliteResultCode){
    if(sqliteResultCode){
      if(dbPtr instanceof DB) dbPtr = dbPtr.pointer;
      toss3(
        sqliteResultCode,
        "sqlite3 result code",sqliteResultCode+":",
        (dbPtr
         ? capi.sqlite3_errmsg(dbPtr)
         : capi.sqlite3_errstr(sqliteResultCode))
      );
    }
    return arguments[0];
  };

  
  const __dbTraceToConsole =
        wasm.installFunction('i(ippp)', function(t,c,p,x){
          if(capi.SQLITE_TRACE_STMT===t){
            
            console.log("SQL TRACE #"+(++this.counter)+' via sqlite3@'+c+':',
                        wasm.cstrToJs(x));
          }
        }.bind({counter: 0}));

  
  const __vfsPostOpenSql = Object.create(null);

  
  const dbCtorHelper = function ctor(...args){
    if(!ctor._name2vfs){
      
      ctor._name2vfs = Object.create(null);
      const isWorkerThread = ('function'===typeof importScripts)
            ? (n)=>toss3("The VFS for",n,"is only available in the main window thread.")
            : false;
      ctor._name2vfs[':localStorage:'] = {
        vfs: 'kvvfs', filename: isWorkerThread || (()=>'local')
      };
      ctor._name2vfs[':sessionStorage:'] = {
        vfs: 'kvvfs', filename: isWorkerThread || (()=>'session')
      };
    }
    const opt = ctor.normalizeArgs(...args);
    let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
    if(('string'!==typeof fn && 'number'!==typeof fn)
       || 'string'!==typeof flagsStr
       || (vfsName && ('string'!==typeof vfsName && 'number'!==typeof vfsName))){
      sqlite3.config.error("Invalid DB ctor args",opt,arguments);
      toss3("Invalid arguments for DB constructor.");
    }
    let fnJs = ('number'===typeof fn) ? wasm.cstrToJs(fn) : fn;
    const vfsCheck = ctor._name2vfs[fnJs];
    if(vfsCheck){
      vfsName = vfsCheck.vfs;
      fn = fnJs = vfsCheck.filename(fnJs);
    }
    let pDb, oflags = 0;
    if( flagsStr.indexOf('c')>=0 ){
      oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
    }
    if( flagsStr.indexOf('w')>=0 ) oflags |= capi.SQLITE_OPEN_READWRITE;
    if( 0===oflags ) oflags |= capi.SQLITE_OPEN_READONLY;
    oflags |= capi.SQLITE_OPEN_EXRESCODE;
    const stack = wasm.pstack.pointer;
    try {
      const pPtr = wasm.pstack.allocPtr() ;
      let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
      pDb = wasm.peekPtr(pPtr);
      checkSqlite3Rc(pDb, rc);
      capi.sqlite3_extended_result_codes(pDb, 1);
      if(flagsStr.indexOf('t')>=0){
        capi.sqlite3_trace_v2(pDb, capi.SQLITE_TRACE_STMT,
                              __dbTraceToConsole, pDb);
      }
    }catch( e ){
      if( pDb ) capi.sqlite3_close_v2(pDb);
      throw e;
    }finally{
      wasm.pstack.restore(stack);
    }
    this.filename = fnJs;
    __ptrMap.set(this, pDb);
    __stmtMap.set(this, Object.create(null));
    try{
      
      const pVfs = capi.sqlite3_js_db_vfs(pDb);
      if(!pVfs) toss3("Internal error: cannot get VFS for new db handle.");
      const postInitSql = __vfsPostOpenSql[pVfs];
      if(postInitSql instanceof Function){
        postInitSql(this, sqlite3);
      }else if(postInitSql){
        checkSqlite3Rc(
          pDb, capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0)
        );
      }
    }catch(e){
      this.close();
      throw e;
    }
  };

  
  dbCtorHelper.setVfsPostOpenSql = function(pVfs, sql){
    __vfsPostOpenSql[pVfs] = sql;
  };

  
  dbCtorHelper.normalizeArgs = function(filename=':memory:',flags = 'c',vfs = null){
    const arg = {};
    if(1===arguments.length && arguments[0] && 'object'===typeof arguments[0]){
      Object.assign(arg, arguments[0]);
      if(undefined===arg.flags) arg.flags = 'c';
      if(undefined===arg.vfs) arg.vfs = null;
      if(undefined===arg.filename) arg.filename = ':memory:';
    }else{
      arg.filename = filename;
      arg.flags = flags;
      arg.vfs = vfs;
    }
    return arg;
  };
  
  const DB = function(...args){
    dbCtorHelper.apply(this, args);
  };
  DB.dbCtorHelper = dbCtorHelper;

  
  const BindTypes = {
    null: 1,
    number: 2,
    string: 3,
    boolean: 4,
    blob: 5
  };
  BindTypes['undefined'] == BindTypes.null;
  if(wasm.bigIntEnabled){
    BindTypes.bigint = BindTypes.number;
  }

  
  const Stmt = function(){
    if(BindTypes!==arguments[2]){
      toss3(capi.SQLITE_MISUSE, "Do not call the Stmt constructor directly. Use DB.prepare().");
    }
    this.db = arguments[0];
    __ptrMap.set(this, arguments[1]);
    this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
  };

  
  const affirmDbOpen = function(db){
    if(!db.pointer) toss3("DB has been closed.");
    return db;
  };

  
  const affirmColIndex = function(stmt,ndx){
    if((ndx !== (ndx|0)) || ndx<0 || ndx>=stmt.columnCount){
      toss3("Column index",ndx,"is out of range.");
    }
    return stmt;
  };

  
  const parseExecArgs = function(db, args){
    const out = Object.create(null);
    out.opt = Object.create(null);
    switch(args.length){
        case 1:
          if('string'===typeof args[0] || util.isSQLableTypedArray(args[0])){
            out.sql = args[0];
          }else if(Array.isArray(args[0])){
            out.sql = args[0];
          }else if(args[0] && 'object'===typeof args[0]){
            out.opt = args[0];
            out.sql = out.opt.sql;
          }
          break;
        case 2:
          out.sql = args[0];
          out.opt = args[1];
          break;
        default: toss3("Invalid argument count for exec().");
    };
    out.sql = util.flexibleString(out.sql);
    if('string'!==typeof out.sql){
      toss3("Missing SQL argument or unsupported SQL value type.");
    }
    const opt = out.opt;
    switch(opt.returnValue){
        case 'resultRows':
          if(!opt.resultRows) opt.resultRows = [];
          out.returnVal = ()=>opt.resultRows;
          break;
        case 'saveSql':
          if(!opt.saveSql) opt.saveSql = [];
          out.returnVal = ()=>opt.saveSql;
          break;
        case undefined:
        case 'this':
          out.returnVal = ()=>db;
          break;
        default:
          toss3("Invalid returnValue value:",opt.returnValue);
    }
    if(!opt.callback && !opt.returnValue && undefined!==opt.rowMode){
      if(!opt.resultRows) opt.resultRows = [];
      out.returnVal = ()=>opt.resultRows;
    }
    if(opt.callback || opt.resultRows){
      switch((undefined===opt.rowMode)
             ? 'array' : opt.rowMode) {
          case 'object': out.cbArg = (stmt)=>stmt.get(Object.create(null)); break;
          case 'array': out.cbArg = (stmt)=>stmt.get([]); break;
          case 'stmt':
            if(Array.isArray(opt.resultRows)){
              toss3("exec(): invalid rowMode for a resultRows array: must",
                    "be one of 'array', 'object',",
                    "a result column number, or column name reference.");
            }
            out.cbArg = (stmt)=>stmt;
            break;
          default:
            if(util.isInt32(opt.rowMode)){
              out.cbArg = (stmt)=>stmt.get(opt.rowMode);
              break;
            }else if('string'===typeof opt.rowMode
                     && opt.rowMode.length>1
                     && '$'===opt.rowMode[0]){
              
              const $colName = opt.rowMode.substr(1);
              out.cbArg = (stmt)=>{
                const rc = stmt.get(Object.create(null))[$colName];
                return (undefined===rc)
                  ? toss3(capi.SQLITE_NOTFOUND,
                          "exec(): unknown result column:",$colName)
                  : rc;
              };
              break;
            }
            toss3("Invalid rowMode:",opt.rowMode);
      }
    }
    return out;
  };

  
  const __selectFirstRow = (db, sql, bind, ...getArgs)=>{
    const stmt = db.prepare(sql);
    try {
      const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : undefined;
      stmt.reset();
      return rc;
    }finally{
      stmt.finalize();
    }
  };

  
  const __selectAll =
        (db, sql, bind, rowMode)=>db.exec({
          sql, bind, rowMode, returnValue: 'resultRows'
        });

  
  DB.checkRc = (db,resultCode)=>checkSqlite3Rc(db,resultCode);

  DB.prototype = {
    
    isOpen: function(){
      return !!this.pointer;
    },
    
    affirmOpen: function(){
      return affirmDbOpen(this);
    },
    
    close: function(){
      if(this.pointer){
        if(this.onclose && (this.onclose.before instanceof Function)){
          try{this.onclose.before(this)}
          catch(e){}
        }
        const pDb = this.pointer;
        Object.keys(__stmtMap.get(this)).forEach((k,s)=>{
          if(s && s.pointer){
            try{s.finalize()}
            catch(e){}
          }
        });
        __ptrMap.delete(this);
        __stmtMap.delete(this);
        capi.sqlite3_close_v2(pDb);
        if(this.onclose && (this.onclose.after instanceof Function)){
          try{this.onclose.after(this)}
          catch(e){}
        }
        delete this.filename;
      }
    },
    
    changes: function(total=false,sixtyFour=false){
      const p = affirmDbOpen(this).pointer;
      if(total){
        return sixtyFour
          ? capi.sqlite3_total_changes64(p)
          : capi.sqlite3_total_changes(p);
      }else{
        return sixtyFour
          ? capi.sqlite3_changes64(p)
          : capi.sqlite3_changes(p);
      }
    },
    
    dbFilename: function(dbName='main'){
      return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
    },
    
    dbName: function(dbNumber=0){
      return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
    },
    
    dbVfsName: function(dbName=0){
      let rc;
      const pVfs = capi.sqlite3_js_db_vfs(
        affirmDbOpen(this).pointer, dbName
      );
      if(pVfs){
        const v = new capi.sqlite3_vfs(pVfs);
        try{ rc = wasm.cstrToJs(v.$zName) }
        finally { v.dispose() }
      }
      return rc;
    },
    
    prepare: function(sql){
      affirmDbOpen(this);
      const stack = wasm.pstack.pointer;
      let ppStmt, pStmt;
      try{
        ppStmt = wasm.pstack.alloc(8);
        DB.checkRc(this, capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null));
        pStmt = wasm.peekPtr(ppStmt);
      }
      finally {
        wasm.pstack.restore(stack);
      }
      if(!pStmt) toss3("Cannot prepare empty SQL.");
      const stmt = new Stmt(this, pStmt, BindTypes);
      __stmtMap.get(this)[pStmt] = stmt;
      return stmt;
    },
    
    exec: function(){
      affirmDbOpen(this);
      const arg = parseExecArgs(this, arguments);
      if(!arg.sql){
        return toss3("exec() requires an SQL string.");
      }
      const opt = arg.opt;
      const callback = opt.callback;
      const resultRows =
            Array.isArray(opt.resultRows) ? opt.resultRows : undefined;
      let stmt;
      let bind = opt.bind;
      let evalFirstResult = !!(
        arg.cbArg || opt.columnNames || resultRows
      ) ;
      const stack = wasm.scopedAllocPush();
      const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : undefined;
      try{
        const isTA = util.isSQLableTypedArray(arg.sql)
        ;
        
        let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);
        const ppStmt  = wasm.scopedAlloc(
          
          (2 * wasm.ptrSizeof) + (sqlByteLen + 1)
        );
        const pzTail = ppStmt + wasm.ptrSizeof ;
        let pSql = pzTail + wasm.ptrSizeof;
        const pSqlEnd = pSql + sqlByteLen;
        if(isTA) wasm.heap8().set(arg.sql, pSql);
        else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
        wasm.poke(pSql + sqlByteLen, 0);
        while(pSql && wasm.peek(pSql, 'i8')
               ){
          wasm.pokePtr([ppStmt, pzTail], 0);
          DB.checkRc(this, capi.sqlite3_prepare_v3(
            this.pointer, pSql, sqlByteLen, 0, ppStmt, pzTail
          ));
          const pStmt = wasm.peekPtr(ppStmt);
          pSql = wasm.peekPtr(pzTail);
          sqlByteLen = pSqlEnd - pSql;
          if(!pStmt) continue;
          if(saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
          stmt = new Stmt(this, pStmt, BindTypes);
          if(bind && stmt.parameterCount){
            stmt.bind(bind);
            bind = null;
          }
          if(evalFirstResult && stmt.columnCount){
            
            let gotColNames = Array.isArray(
              opt.columnNames
              ) ? 0 : 1;
            evalFirstResult = false;
            if(arg.cbArg || resultRows){
              for(; stmt.step(); stmt._lockedByExec = false){
                if(0===gotColNames++) stmt.getColumnNames(opt.columnNames);
                stmt._lockedByExec = true;
                const row = arg.cbArg(stmt);
                if(resultRows) resultRows.push(row);
                if(callback && false === callback.call(opt, row, stmt)){
                  break;
                }
              }
              stmt._lockedByExec = false;
            }
            if(0===gotColNames){
              
              stmt.getColumnNames(opt.columnNames);
            }
          }else{
            stmt.step();
          }
          stmt.reset(
            ).finalize();
          stmt = null;
        }
      }finally{
        wasm.scopedAllocPop(stack);
        if(stmt){
          delete stmt._lockedByExec;
          stmt.finalize();
        }
      }
      return arg.returnVal();
    },

    
    createFunction: function f(name, xFunc, opt){
      const isFunc = (f)=>(f instanceof Function);
      switch(arguments.length){
          case 1: 
            opt = name;
            name = opt.name;
            xFunc = opt.xFunc || 0;
            break;
          case 2: 
            if(!isFunc(xFunc)){
              opt = xFunc;
              xFunc = opt.xFunc || 0;
            }
            break;
          case 3: 
            break;
          default: break;
      }
      if(!opt) opt = {};
      if('string' !== typeof name){
        toss3("Invalid arguments: missing function name.");
      }
      let xStep = opt.xStep || 0;
      let xFinal = opt.xFinal || 0;
      const xValue = opt.xValue || 0;
      const xInverse = opt.xInverse || 0;
      let isWindow = undefined;
      if(isFunc(xFunc)){
        isWindow = false;
        if(isFunc(xStep) || isFunc(xFinal)){
          toss3("Ambiguous arguments: scalar or aggregate?");
        }
        xStep = xFinal = null;
      }else if(isFunc(xStep)){
        if(!isFunc(xFinal)){
          toss3("Missing xFinal() callback for aggregate or window UDF.");
        }
        xFunc = null;
      }else if(isFunc(xFinal)){
        toss3("Missing xStep() callback for aggregate or window UDF.");
      }else{
        toss3("Missing function-type properties.");
      }
      if(false === isWindow){
        if(isFunc(xValue) || isFunc(xInverse)){
          toss3("xValue and xInverse are not permitted for non-window UDFs.");
        }
      }else if(isFunc(xValue)){
        if(!isFunc(xInverse)){
          toss3("xInverse must be provided if xValue is.");
        }
        isWindow = true;
      }else if(isFunc(xInverse)){
        toss3("xValue must be provided if xInverse is.");
      }
      const pApp = opt.pApp;
      if(undefined!==pApp &&
         null!==pApp &&
         (('number'!==typeof pApp) || !util.isInt32(pApp))){
        toss3("Invalid value for pApp property. Must be a legal WASM pointer value.");
      }
      const xDestroy = opt.xDestroy || 0;
      if(xDestroy && !isFunc(xDestroy)){
        toss3("xDestroy property must be a function.");
      }
      let fFlags = 0 ;
      if(getOwnOption(opt, 'deterministic')) fFlags |= capi.SQLITE_DETERMINISTIC;
      if(getOwnOption(opt, 'directOnly')) fFlags |= capi.SQLITE_DIRECTONLY;
      if(getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;
      name = name.toLowerCase();
      const xArity = xFunc || xStep;
      const arity = getOwnOption(opt, 'arity');
      const arityArg = ('number'===typeof arity
                        ? arity
                        : (xArity.length ? xArity.length-1 : 0));
      let rc;
      if( isWindow ){
        rc = capi.sqlite3_create_window_function(
          this.pointer, name, arityArg,
          capi.SQLITE_UTF8 | fFlags, pApp || 0,
          xStep, xFinal, xValue, xInverse, xDestroy);
      }else{
        rc = capi.sqlite3_create_function_v2(
          this.pointer, name, arityArg,
          capi.SQLITE_UTF8 | fFlags, pApp || 0,
          xFunc, xStep, xFinal, xDestroy);
      }
      DB.checkRc(this, rc);
      return this;
    },
    
    selectValue: function(sql,bind,asType){
      return __selectFirstRow(this, sql, bind, 0, asType);
    },

    
    selectValues: function(sql,bind,asType){
      const stmt = this.prepare(sql), rc = [];
      try {
        stmt.bind(bind);
        while(stmt.step()) rc.push(stmt.get(0,asType));
        stmt.reset();
      }finally{
        stmt.finalize();
      }
      return rc;
    },

    
    selectArray: function(sql,bind){
      return __selectFirstRow(this, sql, bind, []);
    },

    
    selectObject: function(sql,bind){
      return __selectFirstRow(this, sql, bind, {});
    },

    
    selectArrays: function(sql,bind){
      return __selectAll(this, sql, bind, 'array');
    },

    
    selectObjects: function(sql,bind){
      return __selectAll(this, sql, bind, 'object');
    },

    
    openStatementCount: function(){
      return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
    },

    
    transaction: function(callback){
      let opener = 'BEGIN';
      if(arguments.length>1){
        if(/[^a-zA-Z]/.test(arguments[0])){
          toss3(capi.SQLITE_MISUSE, "Invalid argument for BEGIN qualifier.");
        }
        opener += ' '+arguments[0];
        callback = arguments[1];
      }
      affirmDbOpen(this).exec(opener);
      try {
        const rc = callback(this);
        this.exec("COMMIT");
        return rc;
      }catch(e){
        this.exec("ROLLBACK");
        throw e;
      }
    },

    
    savepoint: function(callback){
      affirmDbOpen(this).exec("SAVEPOINT oo1");
      try {
        const rc = callback(this);
        this.exec("RELEASE oo1");
        return rc;
      }catch(e){
        this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
        throw e;
      }
    },

    
    checkRc: function(resultCode){
      return checkSqlite3Rc(this, resultCode);
    }
  };


  
  const affirmStmtOpen = function(stmt){
    if(!stmt.pointer) toss3("Stmt has been closed.");
    return stmt;
  };

  
  const isSupportedBindType = function(v){
    let t = BindTypes[(null===v||undefined===v) ? 'null' : typeof v];
    switch(t){
        case BindTypes.boolean:
        case BindTypes.null:
        case BindTypes.number:
        case BindTypes.string:
          return t;
        case BindTypes.bigint:
          if(wasm.bigIntEnabled) return t;
          
        default:
          return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;
    }
  };

  
  const affirmSupportedBindType = function(v){
    
    return isSupportedBindType(v) || toss3("Unsupported bind() argument type:",typeof v);
  };

  
  const affirmParamIndex = function(stmt,key){
    const n = ('number'===typeof key)
          ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
    if(0===n || !util.isInt32(n)){
      toss3("Invalid bind() parameter name: "+key);
    }
    else if(n<1 || n>stmt.parameterCount) toss3("Bind index",key,"is out of range.");
    return n;
  };

  
  const affirmNotLockedByExec = function(stmt,currentOpName){
    if(stmt._lockedByExec){
      toss3("Operation is illegal when statement is locked:",currentOpName);
    }
    return stmt;
  };

  
  const bindOne = function f(stmt,ndx,bindType,val){
    affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');
    if(!f._){
      f._tooBigInt = (v)=>toss3(
        "BigInt value is too big to store without precision loss:", v
      );
      f._ = {
        string: function(stmt, ndx, val, asBlob){
          const [pStr, n] = wasm.allocCString(val, true);
          const f = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
          return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);
        }
      };
    }
    affirmSupportedBindType(val);
    ndx = affirmParamIndex(stmt,ndx);
    let rc = 0;
    switch((null===val || undefined===val) ? BindTypes.null : bindType){
        case BindTypes.null:
          rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
          break;
        case BindTypes.string:
          rc = f._.string(stmt, ndx, val, false);
          break;
        case BindTypes.number: {
          let m;
          if(util.isInt32(val)) m = capi.sqlite3_bind_int;
          else if('bigint'===typeof val){
            if(!util.bigIntFits64(val)){
              f._tooBigInt(val);
            }else if(wasm.bigIntEnabled){
              m = capi.sqlite3_bind_int64;
            }else if(util.bigIntFitsDouble(val)){
              val = Number(val);
              m = capi.sqlite3_bind_double;
            }else{
              f._tooBigInt(val);
            }
          }else{ 
            val = Number(val);
            if(wasm.bigIntEnabled && Number.isInteger(val)){
              m = capi.sqlite3_bind_int64;
            }else{
              m = capi.sqlite3_bind_double;
            }
          }
          rc = m(stmt.pointer, ndx, val);
          break;
        }
        case BindTypes.boolean:
          rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
          break;
        case BindTypes.blob: {
          if('string'===typeof val){
            rc = f._.string(stmt, ndx, val, true);
            break;
          }else if(val instanceof ArrayBuffer){
            val = new Uint8Array(val);
          }else if(!util.isBindableTypedArray(val)){
            toss3("Binding a value as a blob requires",
                  "that it be a string, Uint8Array, Int8Array, or ArrayBuffer.");
          }
          const pBlob = wasm.alloc(val.byteLength || 1);
          wasm.heap8().set(val.byteLength ? val : [0], pBlob)
          rc = capi.sqlite3_bind_blob(stmt.pointer, ndx, pBlob, val.byteLength,
                                      capi.SQLITE_WASM_DEALLOC);
          break;
        }
        default:
          sqlite3.config.warn("Unsupported bind() argument type:",val);
          toss3("Unsupported bind() argument type: "+(typeof val));
    }
    if(rc) DB.checkRc(stmt.db.pointer, rc);
    stmt._mayGet = false;
    return stmt;
  };

  Stmt.prototype = {
    
    finalize: function(){
      if(this.pointer){
        affirmNotLockedByExec(this,'finalize()');
        const rc = capi.sqlite3_finalize(this.pointer);
        delete __stmtMap.get(this.db)[this.pointer];
        __ptrMap.delete(this);
        delete this._mayGet;
        delete this.parameterCount;
        delete this._lockedByExec;
        delete this.db;
        return rc;
      }
    },
    
    clearBindings: function(){
      affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()')
      capi.sqlite3_clear_bindings(this.pointer);
      this._mayGet = false;
      return this;
    },
    
    reset: function(alsoClearBinds){
      affirmNotLockedByExec(this,'reset()');
      if(alsoClearBinds) this.clearBindings();
      const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
      this._mayGet = false;
      checkSqlite3Rc(this.db, rc);
      return this;
    },
    
    bind: function(){
      affirmStmtOpen(this);
      let ndx, arg;
      switch(arguments.length){
          case 1: ndx = 1; arg = arguments[0]; break;
          case 2: ndx = arguments[0]; arg = arguments[1]; break;
          default: toss3("Invalid bind() arguments.");
      }
      if(undefined===arg){
        
        return this;
      }else if(!this.parameterCount){
        toss3("This statement has no bindable parameters.");
      }
      this._mayGet = false;
      if(null===arg){
        
        return bindOne(this, ndx, BindTypes.null, arg);
      }
      else if(Array.isArray(arg)){
        
        if(1!==arguments.length){
          toss3("When binding an array, an index argument is not permitted.");
        }
        arg.forEach((v,i)=>bindOne(this, i+1, affirmSupportedBindType(v), v));
        return this;
      }else if(arg instanceof ArrayBuffer){
        arg = new Uint8Array(arg);
      }
      if('object'===typeof arg
              && !util.isBindableTypedArray(arg)){
        
        if(1!==arguments.length){
          toss3("When binding an object, an index argument is not permitted.");
        }
        Object.keys(arg)
          .forEach(k=>bindOne(this, k,
                              affirmSupportedBindType(arg[k]),
                              arg[k]));
        return this;
      }else{
        return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
      }
      toss3("Should not reach this point.");
    },
    
    bindAsBlob: function(ndx,arg){
      affirmStmtOpen(this);
      if(1===arguments.length){
        arg = ndx;
        ndx = 1;
      }
      const t = affirmSupportedBindType(arg);
      if(BindTypes.string !== t && BindTypes.blob !== t
         && BindTypes.null !== t){
        toss3("Invalid value type for bindAsBlob()");
      }
      return bindOne(this, ndx, BindTypes.blob, arg);
    },
    
    step: function(){
      affirmNotLockedByExec(this, 'step()');
      const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
      switch(rc){
          case capi.SQLITE_DONE: return this._mayGet = false;
          case capi.SQLITE_ROW: return this._mayGet = true;
          default:
            this._mayGet = false;
            sqlite3.config.warn("sqlite3_step() rc=",rc,
                         capi.sqlite3_js_rc_str(rc),
                         "SQL =", capi.sqlite3_sql(this.pointer));
            DB.checkRc(this.db.pointer, rc);
      }
    },
    
    stepReset: function(){
      this.step();
      return this.reset();
    },
    
    stepFinalize: function(){
      try{
        const rc = this.step();
        this.reset();
        return rc;
      }finally{
        try{this.finalize()}
        catch(e){}
      }
    },
    
    get: function(ndx,asType){
      if(!affirmStmtOpen(this)._mayGet){
        toss3("Stmt.step() has not (recently) returned true.");
      }
      if(Array.isArray(ndx)){
        let i = 0;
        const n = this.columnCount;
        while(i<n){
          ndx[i] = this.get(i++);
        }
        return ndx;
      }else if(ndx && 'object'===typeof ndx){
        let i = 0;
        const n = this.columnCount;
        while(i<n){
          ndx[capi.sqlite3_column_name(this.pointer,i)] = this.get(i++);
        }
        return ndx;
      }
      affirmColIndex(this, ndx);
      switch(undefined===asType
             ? capi.sqlite3_column_type(this.pointer, ndx)
             : asType){
          case capi.SQLITE_NULL: return null;
          case capi.SQLITE_INTEGER:{
            if(wasm.bigIntEnabled){
              const rc = capi.sqlite3_column_int64(this.pointer, ndx);
              if(rc>=Number.MIN_SAFE_INTEGER && rc<=Number.MAX_SAFE_INTEGER){
                
                return Number(rc).valueOf();
              }
              return rc;
            }else{
              const rc = capi.sqlite3_column_double(this.pointer, ndx);
              if(rc>Number.MAX_SAFE_INTEGER || rc<Number.MIN_SAFE_INTEGER){
                
                toss3("Integer is out of range for JS integer range: "+rc);
              }
              
              return util.isInt32(rc) ? (rc | 0) : rc;
            }
          }
          case capi.SQLITE_FLOAT:
            return capi.sqlite3_column_double(this.pointer, ndx);
          case capi.SQLITE_TEXT:
            return capi.sqlite3_column_text(this.pointer, ndx);
          case capi.SQLITE_BLOB: {
            const n = capi.sqlite3_column_bytes(this.pointer, ndx),
                  ptr = capi.sqlite3_column_blob(this.pointer, ndx),
                  rc = new Uint8Array(n);
            
            if(n) rc.set(wasm.heap8u().slice(ptr, ptr+n), 0);
            
            if(n && this.db._blobXfer instanceof Array){
              
              this.db._blobXfer.push(rc.buffer);
            }
            return rc;
          }
          default: toss3("Don't know how to translate",
                         "type of result column #"+ndx+".");
      }
      toss3("Not reached.");
    },
    
    getInt: function(ndx){return this.get(ndx,capi.SQLITE_INTEGER)},
    
    getFloat: function(ndx){return this.get(ndx,capi.SQLITE_FLOAT)},
    
    getString: function(ndx){return this.get(ndx,capi.SQLITE_TEXT)},
    
    getBlob: function(ndx){return this.get(ndx,capi.SQLITE_BLOB)},
    
    getJSON: function(ndx){
      const s = this.get(ndx, capi.SQLITE_STRING);
      return null===s ? s : JSON.parse(s);
    },
    
    
    
    
    
    getColumnName: function(ndx){
      return capi.sqlite3_column_name(
        affirmColIndex(affirmStmtOpen(this),ndx).pointer, ndx
      );
    },
    
    getColumnNames: function(tgt=[]){
      affirmColIndex(affirmStmtOpen(this),0);
      const n = this.columnCount;
      for(let i = 0; i < n; ++i){
        tgt.push(capi.sqlite3_column_name(this.pointer, i));
      }
      return tgt;
    },
    
    getParamIndex: function(name){
      return (affirmStmtOpen(this).parameterCount
              ? capi.sqlite3_bind_parameter_index(this.pointer, name)
              : undefined);
    }
  };

  {
    const prop = {
      enumerable: true,
      get: function(){return __ptrMap.get(this)},
      set: ()=>toss3("The pointer property is read-only.")
    }
    Object.defineProperty(Stmt.prototype, 'pointer', prop);
    Object.defineProperty(DB.prototype, 'pointer', prop);
  }
  
  Object.defineProperty(Stmt.prototype, 'columnCount', {
    enumerable: false,
    get: function(){return capi.sqlite3_column_count(this.pointer)},
    set: ()=>toss3("The columnCount property is read-only.")
  });

  
  sqlite3.oo1 = {
    DB,
    Stmt
  };

  if(util.isUIThread()){
    
    sqlite3.oo1.JsStorageDb = function(storageName='session'){
      if('session'!==storageName && 'local'!==storageName){
        toss3("JsStorageDb db name must be one of 'session' or 'local'.");
      }
      dbCtorHelper.call(this, {
        filename: storageName,
        flags: 'c',
        vfs: "kvvfs"
      });
    };
    const jdb = sqlite3.oo1.JsStorageDb;
    jdb.prototype = Object.create(DB.prototype);
    
    jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
    
    jdb.prototype.clearStorage = function(){
      return jdb.clearStorage(affirmDbOpen(this).filename);
    };
    
    jdb.storageSize = capi.sqlite3_js_kvvfs_size;
    
    jdb.prototype.storageSize = function(){
      return jdb.storageSize(affirmDbOpen(this).filename);
    };
  }

});





globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
sqlite3.initWorker1API = function(){
  'use strict';
  const toss = (...args)=>{throw new Error(args.join(' '))};
  if(!(globalThis.WorkerGlobalScope instanceof Function)){
    toss("initWorker1API() must be run from a Worker thread.");
  }
  const sqlite3 = this.sqlite3 || toss("Missing this.sqlite3 object.");
  const DB = sqlite3.oo1.DB;

  
  const getDbId = function(db){
    let id = wState.idMap.get(db);
    if(id) return id;
    id = 'db#'+(++wState.idSeq)+'@'+db.pointer;
    
    wState.idMap.set(db, id);
    return id;
  };

  
  const wState = {
    
    dbList: [],
    
    idSeq: 0,
    
    idMap: new WeakMap,
    
    xfer: [],
    open: function(opt){
      const db = new DB(opt);
      this.dbs[getDbId(db)] = db;
      if(this.dbList.indexOf(db)<0) this.dbList.push(db);
      return db;
    },
    close: function(db,alsoUnlink){
      if(db){
        delete this.dbs[getDbId(db)];
        const filename = db.filename;
        const pVfs = sqlite3.wasm.sqlite3_wasm_db_vfs(db.pointer, 0);
        db.close();
        const ddNdx = this.dbList.indexOf(db);
        if(ddNdx>=0) this.dbList.splice(ddNdx, 1);
        if(alsoUnlink && filename && pVfs){
          sqlite3.wasm.sqlite3_wasm_vfs_unlink(pVfs, filename);
        }
      }
    },
    
    post: function(msg,xferList){
      if(xferList && xferList.length){
        globalThis.postMessage( msg, Array.from(xferList) );
        xferList.length = 0;
      }else{
        globalThis.postMessage(msg);
      }
    },
    
    dbs: Object.create(null),
    
    getDb: function(id,require=true){
      return this.dbs[id]
        || (require ? toss("Unknown (or closed) DB ID:",id) : undefined);
    }
  };

  
  const affirmDbOpen = function(db = wState.dbList[0]){
    return (db && db.pointer) ? db : toss("DB is not opened.");
  };

  
  const getMsgDb = function(msgData,affirmExists=true){
    const db = wState.getDb(msgData.dbId,false) || wState.dbList[0];
    return affirmExists ? affirmDbOpen(db) : db;
  };

  const getDefaultDbId = function(){
    return wState.dbList[0] && getDbId(wState.dbList[0]);
  };

  const guessVfs = function(filename){
    const m = /^file:.+(vfs=(\w+))/.exec(filename);
    return sqlite3.capi.sqlite3_vfs_find(m ? m[2] : 0);
  };

  const isSpecialDbFilename = (n)=>{
    return ""===n || ':'===n[0];
  };

  
  const wMsgHandler = {
    open: function(ev){
      const oargs = Object.create(null), args = (ev.args || Object.create(null));
      if(args.simulateError){ 
        toss("Throwing because of simulateError flag.");
      }
      const rc = Object.create(null);
      let byteArray, pVfs;
      oargs.vfs = args.vfs;
      if(isSpecialDbFilename(args.filename)){
        oargs.filename = args.filename || "";
      }else{
        oargs.filename = args.filename;
        byteArray = args.byteArray;
        if(byteArray) pVfs = guessVfs(args.filename);
      }
      if(pVfs){
        
        let pMem;
        try{
          pMem = sqlite3.wasm.allocFromTypedArray(byteArray);
          const rc = sqlite3.wasm.sqlite3_wasm_vfs_create_file(
            pVfs, oargs.filename, pMem, byteArray.byteLength
          );
          if(rc) sqlite3.SQLite3Error.toss(rc);
        }catch(e){
          throw new sqlite3.SQLite3Error(
            e.name+' creating '+args.filename+": "+e.message, {
              cause: e
            }
          );
        }finally{
          if(pMem) sqlite3.wasm.dealloc(pMem);
        }
      }
      const db = wState.open(oargs);
      rc.filename = db.filename;
      rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(db.pointer, "opfs");
      rc.dbId = getDbId(db);
      rc.vfs = db.dbVfsName();
      return rc;
    },

    close: function(ev){
      const db = getMsgDb(ev,false);
      const response = {
        filename: db && db.filename
      };
      if(db){
        const doUnlink = ((ev.args && 'object'===typeof ev.args)
                         ? !!ev.args.unlink : false);
        wState.close(db, doUnlink);
      }
      return response;
    },

    exec: function(ev){
      const rc = (
        'string'===typeof ev.args
      ) ? {sql: ev.args} : (ev.args || Object.create(null));
      if('stmt'===rc.rowMode){
        toss("Invalid rowMode for 'exec': stmt mode",
             "does not work in the Worker API.");
      }else if(!rc.sql){
        toss("'exec' requires input SQL.");
      }
      const db = getMsgDb(ev);
      if(rc.callback || Array.isArray(rc.resultRows)){
        
        db._blobXfer = wState.xfer;
      }
      const theCallback = rc.callback;
      let rowNumber = 0;
      const hadColNames = !!rc.columnNames;
      if('string' === typeof theCallback){
        if(!hadColNames) rc.columnNames = [];
        
        rc.callback = function(row,stmt){
          wState.post({
            type: theCallback,
            columnNames: rc.columnNames,
            rowNumber: ++rowNumber,
            row: row
          }, wState.xfer);
        }
      }
      try {
        const changeCount = !!rc.countChanges
              ? db.changes(true,(64===rc.countChanges))
              : undefined;
        db.exec(rc);
        if(undefined !== changeCount){
          rc.changeCount = db.changes(true,64===rc.countChanges) - changeCount;
        }
        if(rc.callback instanceof Function){
          rc.callback = theCallback;
          
          wState.post({
            type: theCallback,
            columnNames: rc.columnNames,
            rowNumber: null ,
            row: undefined 
          });
        }
      }finally{
        delete db._blobXfer;
        if(rc.callback) rc.callback = theCallback;
      }
      return rc;
    },

    'config-get': function(){
      const rc = Object.create(null), src = sqlite3.config;
      [
        'bigIntEnabled'
      ].forEach(function(k){
        if(Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
      });
      rc.version = sqlite3.version;
      rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();
      rc.opfsEnabled = !!sqlite3.opfs;
      return rc;
    },

    
    export: function(ev){
      const db = getMsgDb(ev);
      const response = {
        byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),
        filename: db.filename,
        mimetype: 'application/x-sqlite3'
      };
      wState.xfer.push(response.byteArray.buffer);
      return response;
    },

    toss: function(ev){
      toss("Testing worker exception");
    },

    'opfs-tree': async function(ev){
      if(!sqlite3.opfs) toss("OPFS support is unavailable.");
      const response = await sqlite3.opfs.treeList();
      return response;
    }
  };

  globalThis.onmessage = async function(ev){
    ev = ev.data;
    let result, dbId = ev.dbId, evType = ev.type;
    const arrivalTime = performance.now();
    try {
      if(wMsgHandler.hasOwnProperty(evType) &&
         wMsgHandler[evType] instanceof Function){
        result = await wMsgHandler[evType](ev);
      }else{
        toss("Unknown db worker message type:",ev.type);
      }
    }catch(err){
      evType = 'error';
      result = {
        operation: ev.type,
        message: err.message,
        errorClass: err.name,
        input: ev
      };
      if(err.stack){
        result.stack = ('string'===typeof err.stack)
          ? err.stack.split(/\n\s*/) : err.stack;
      }
      if(false) {}
    }
    if(!dbId){
      dbId = result.dbId
        || getDefaultDbId();
    }
    
    
    wState.post({
      type: evType,
      dbId: dbId,
      messageId: ev.messageId,
      workerReceivedTime: arrivalTime,
      workerRespondTime: performance.now(),
      departureTime: ev.departureTime,
      
      
      
      
      
      
      result: result
    }, wState.xfer);
  };
  globalThis.postMessage({type:'sqlite3-api',result:'worker1-ready'});
}.bind({sqlite3});
});





'use strict';
globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  const wasm = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
  const vfs = Object.create(null), vtab = Object.create(null);

  const StructBinder = sqlite3.StructBinder
  ;
  sqlite3.vfs = vfs;
  sqlite3.vtab = vtab;

  const sii = capi.sqlite3_index_info;
  
  sii.prototype.nthConstraint = function(n, asPtr=false){
    if(n<0 || n>=this.$nConstraint) return false;
    const ptr = this.$aConstraint + (
      sii.sqlite3_index_constraint.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
  };

  
  sii.prototype.nthConstraintUsage = function(n, asPtr=false){
    if(n<0 || n>=this.$nConstraint) return false;
    const ptr = this.$aConstraintUsage + (
      sii.sqlite3_index_constraint_usage.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
  };

  
  sii.prototype.nthOrderBy = function(n, asPtr=false){
    if(n<0 || n>=this.$nOrderBy) return false;
    const ptr = this.$aOrderBy + (
      sii.sqlite3_index_orderby.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
  };

  
  const installMethod = function callee(
    tgt, name, func, applyArgcCheck = callee.installMethodArgcCheck
  ){
    if(!(tgt instanceof StructBinder.StructType)){
      toss("Usage error: target object is-not-a StructType.");
    }else if(!(func instanceof Function) && !wasm.isPtr(func)){
      toss("Usage errror: expecting a Function or WASM pointer to one.");
    }
    if(1===arguments.length){
      return (n,f)=>callee(tgt, n, f, applyArgcCheck);
    }
    if(!callee.argcProxy){
      callee.argcProxy = function(tgt, funcName, func,sig){
        return function(...args){
          if(func.length!==arguments.length){
            toss("Argument mismatch for",
                 tgt.structInfo.name+"::"+funcName
                 +": Native signature is:",sig);
          }
          return func.apply(this, args);
        }
      };
      
      callee.removeFuncList = function(){
        if(this.ondispose.__removeFuncList){
          this.ondispose.__removeFuncList.forEach(
            (v,ndx)=>{
              if('number'===typeof v){
                try{wasm.uninstallFunction(v)}
                catch(e){}
              }
              
            }
          );
          delete this.ondispose.__removeFuncList;
        }
      };
    }
    const sigN = tgt.memberSignature(name);
    if(sigN.length<2){
      toss("Member",name,"does not have a function pointer signature:",sigN);
    }
    const memKey = tgt.memberKey(name);
    const fProxy = (applyArgcCheck && !wasm.isPtr(func))
    
          ? callee.argcProxy(tgt, memKey, func, sigN)
          : func;
    if(wasm.isPtr(fProxy)){
      if(fProxy && !wasm.functionEntry(fProxy)){
        toss("Pointer",fProxy,"is not a WASM function table entry.");
      }
      tgt[memKey] = fProxy;
    }else{
      const pFunc = wasm.installFunction(fProxy, tgt.memberSignature(name, true));
      tgt[memKey] = pFunc;
      if(!tgt.ondispose || !tgt.ondispose.__removeFuncList){
        tgt.addOnDispose('ondispose.__removeFuncList handler',
                         callee.removeFuncList);
        tgt.ondispose.__removeFuncList = [];
      }
      tgt.ondispose.__removeFuncList.push(memKey, pFunc);
    }
    return (n,f)=>callee(tgt, n, f, applyArgcCheck);
  };
  installMethod.installMethodArgcCheck = false;

  
  const installMethods = function(
    structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    const seen = new Map ;
    for(const k of Object.keys(methods)){
      const m = methods[k];
      const prior = seen.get(m);
      if(prior){
        const mkey = structInstance.memberKey(k);
        structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
      }else{
        installMethod(structInstance, k, m, applyArgcCheck);
        seen.set(m, k);
      }
    }
    return structInstance;
  };

  
  StructBinder.StructType.prototype.installMethod = function callee(
    name, func, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    return (arguments.length < 3 && name && 'object'===typeof name)
      ? installMethods(this, ...arguments)
      : installMethod(this, ...arguments);
  };

  
  StructBinder.StructType.prototype.installMethods = function(
    methods, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    return installMethods(this, methods, applyArgcCheck);
  };

  
  capi.sqlite3_vfs.prototype.registerVfs = function(asDefault=false){
    if(!(this instanceof sqlite3.capi.sqlite3_vfs)){
      toss("Expecting a sqlite3_vfs-type argument.");
    }
    const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
    if(rc){
      toss("sqlite3_vfs_register(",this,") failed with rc",rc);
    }
    if(this.pointer !== capi.sqlite3_vfs_find(this.$zName)){
      toss("BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
           this);
    }
    return this;
  };

  
  vfs.installVfs = function(opt){
    let count = 0;
    const propList = ['io','vfs'];
    for(const key of propList){
      const o = opt[key];
      if(o){
        ++count;
        installMethods(o.struct, o.methods, !!o.applyArgcCheck);
        if('vfs'===key){
          if(!o.struct.$zName && 'string'===typeof o.name){
            o.struct.addOnDispose(
              o.struct.$zName = wasm.allocCString(o.name)
            );
          }
          o.struct.registerVfs(!!o.asDefault);
        }
      }
    }
    if(!count) toss("Misuse: installVfs() options object requires at least",
                    "one of:", propList);
    return this;
  };

  
  const __xWrapFactory = function(methodName,StructType){
    return function(ptr,removeMapping=false){
      if(0===arguments.length) ptr = new StructType;
      if(ptr instanceof StructType){
        
        this.set(ptr.pointer, ptr);
        return ptr;
      }else if(!wasm.isPtr(ptr)){
        sqlite3.SQLite3Error.toss("Invalid argument to",methodName+"()");
      }
      let rc = this.get(ptr);
      if(removeMapping) this.delete(ptr);
      return rc;
    }.bind(new Map);
  };

  
  const StructPtrMapper = function(name, StructType){
    const __xWrap = __xWrapFactory(name,StructType);
    
    return Object.assign(Object.create(null),{
      
      StructType,
      
      create: (ppOut)=>{
        const rc = __xWrap();
        wasm.pokePtr(ppOut, rc.pointer);
        return rc;
      },
      
      get: (pCObj)=>__xWrap(pCObj),
      
      unget: (pCObj)=>__xWrap(pCObj,true),
      
      dispose: (pCObj)=>{
        const o = __xWrap(pCObj,true);
        if(o) o.dispose();
      }
    });
  };

  
  vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);

  
  vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);

  
  vtab.xIndexInfo = (pIdxInfo)=>new capi.sqlite3_index_info(pIdxInfo);

  
  

  
  vtab.xError = function f(methodName, err, defaultRc){
    if(f.errorReporter instanceof Function){
      try{f.errorReporter("sqlite3_module::"+methodName+"(): "+err.message);}
      catch(e){}
    }
    let rc;
    if(err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;
    else if(arguments.length>2) rc = defaultRc;
    else if(err instanceof sqlite3.SQLite3Error) rc = err.resultCode;
    return rc || capi.SQLITE_ERROR;
  };
  vtab.xError.errorReporter =  true ? console.error.bind(console) : 0;

  
  

  
  vtab.xRowid = (ppRowid64, value)=>wasm.poke(ppRowid64, value, 'i64');

  
  vtab.setupModule = function(opt){
    let createdMod = false;
    const mod = (this instanceof capi.sqlite3_module)
          ? this : (opt.struct || (createdMod = new capi.sqlite3_module()));
    try{
      const methods = opt.methods || toss("Missing 'methods' object.");
      for(const e of Object.entries({
        
        
        xConnect: 'xCreate', xDisconnect: 'xDestroy'
      })){
        
        const k = e[0], v = e[1];
        if(true === methods[k]) methods[k] = methods[v];
        else if(true === methods[v]) methods[v] = methods[k];
      }
      if(opt.catchExceptions){
        const fwrap = function(methodName, func){
          if(['xConnect','xCreate'].indexOf(methodName) >= 0){
            return function(pDb, pAux, argc, argv, ppVtab, pzErr){
              try{return func(...arguments) || 0}
              catch(e){
                if(!(e instanceof sqlite3.WasmAllocError)){
                  wasm.dealloc(wasm.peekPtr(pzErr));
                  wasm.pokePtr(pzErr, wasm.allocCString(e.message));
                }
                return vtab.xError(methodName, e);
              }
            };
          }else{
            return function(...args){
              try{return func(...args) || 0}
              catch(e){
                return vtab.xError(methodName, e);
              }
            };
          }
        };
        const mnames = [
          'xCreate', 'xConnect', 'xBestIndex', 'xDisconnect',
          'xDestroy', 'xOpen', 'xClose', 'xFilter', 'xNext',
          'xEof', 'xColumn', 'xRowid', 'xUpdate',
          'xBegin', 'xSync', 'xCommit', 'xRollback',
          'xFindFunction', 'xRename', 'xSavepoint', 'xRelease',
          'xRollbackTo', 'xShadowName'
        ];
        const remethods = Object.create(null);
        for(const k of mnames){
          const m = methods[k];
          if(!(m instanceof Function)) continue;
          else if('xConnect'===k && methods.xCreate===m){
            remethods[k] = methods.xCreate;
          }else if('xCreate'===k && methods.xConnect===m){
            remethods[k] = methods.xConnect;
          }else{
            remethods[k] = fwrap(k, m);
          }
        }
        installMethods(mod, remethods, false);
      }else{
        
        
        installMethods(
          mod, methods, !!opt.applyArgcCheck
        );
      }
      if(0===mod.$iVersion){
        let v;
        if('number'===typeof opt.iVersion) v = opt.iVersion;
        else if(mod.$xShadowName) v = 3;
        else if(mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo) v = 2;
        else v = 1;
        mod.$iVersion = v;
      }
    }catch(e){
      if(createdMod) createdMod.dispose();
      throw e;
    }
    return mod;
  };

  
  capi.sqlite3_module.prototype.setupModule = function(opt){
    return vtab.setupModule.call(this, opt);
  };
});



'use strict';
globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){

const installOpfsVfs = function callee(options){
  if(!globalThis.SharedArrayBuffer
    || !globalThis.Atomics){
    return Promise.reject(
      new Error("Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. "+
                "The server must emit the COOP/COEP response headers to enable those. "+
                "See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep")
    );
  }else if('undefined'===typeof WorkerGlobalScope){
    return Promise.reject(
      new Error("The OPFS sqlite3_vfs cannot run in the main thread "+
                "because it requires Atomics.wait().")
    );
  }else if(!globalThis.FileSystemHandle ||
           !globalThis.FileSystemDirectoryHandle ||
           !globalThis.FileSystemFileHandle ||
           !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
           !navigator?.storage?.getDirectory){
    return Promise.reject(
      new Error("Missing required OPFS APIs.")
    );
  }
  if(!options || 'object'!==typeof options){
    options = Object.create(null);
  }
  const urlParams = new URL(globalThis.location.href).searchParams;
  if(urlParams.has('opfs-disable')){
    
    return Promise.resolve(sqlite3);
  }
  if(undefined===options.verbose){
    options.verbose = urlParams.has('opfs-verbose')
      ? (+urlParams.get('opfs-verbose') || 2) : 1;
  }
  if(undefined===options.sanityChecks){
    options.sanityChecks = urlParams.has('opfs-sanity-check');
  }
  if(undefined===options.proxyUri){
    options.proxyUri = callee.defaultProxyUri;
  }

  

  if('function' === typeof options.proxyUri){
    options.proxyUri = options.proxyUri();
  }
  const thePromise = new Promise(function(promiseResolve_, promiseReject_){
    const loggers = [
      sqlite3.config.error,
      sqlite3.config.warn,
      sqlite3.config.log
    ];
    const logImpl = (level,...args)=>{
      if(options.verbose>level) loggers[level]("OPFS syncer:",...args);
    };
    const log =    (...args)=>logImpl(2, ...args);
    const warn =   (...args)=>logImpl(1, ...args);
    const error =  (...args)=>logImpl(0, ...args);
    const toss = sqlite3.util.toss;
    const capi = sqlite3.capi;
    const util = sqlite3.util;
    const wasm = sqlite3.wasm;
    const sqlite3_vfs = capi.sqlite3_vfs;
    const sqlite3_file = capi.sqlite3_file;
    const sqlite3_io_methods = capi.sqlite3_io_methods;
    
    const opfsUtil = Object.create(null);

    
    const thisThreadHasOPFS = ()=>{
      return globalThis.FileSystemHandle &&
        globalThis.FileSystemDirectoryHandle &&
        globalThis.FileSystemFileHandle &&
        globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle &&
        navigator?.storage?.getDirectory;
    };

    
    opfsUtil.metrics = {
      dump: function(){
        let k, n = 0, t = 0, w = 0;
        for(k in state.opIds){
          const m = metrics[k];
          n += m.count;
          t += m.time;
          w += m.wait;
          m.avgTime = (m.count && m.time) ? (m.time / m.count) : 0;
          m.avgWait = (m.count && m.wait) ? (m.wait / m.count) : 0;
        }
        sqlite3.config.log(globalThis.location.href,
                    "metrics for",globalThis.location.href,":",metrics,
                    "\nTotal of",n,"op(s) for",t,
                    "ms (incl. "+w+" ms of waiting on the async side)");
        sqlite3.config.log("Serialization metrics:",metrics.s11n);
        W.postMessage({type:'opfs-async-metrics'});
      },
      reset: function(){
        let k;
        const r = (m)=>(m.count = m.time = m.wait = 0);
        for(k in state.opIds){
          r(metrics[k] = Object.create(null));
        }
        let s = metrics.s11n = Object.create(null);
        s = s.serialize = Object.create(null);
        s.count = s.time = 0;
        s = metrics.s11n.deserialize = Object.create(null);
        s.count = s.time = 0;
      }
    };
    const opfsIoMethods = new sqlite3_io_methods();
    const opfsVfs = new sqlite3_vfs()
          .addOnDispose( ()=>opfsIoMethods.dispose());
    let promiseWasRejected = undefined;
    const promiseReject = (err)=>{
      promiseWasRejected = true;
      opfsVfs.dispose();
      return promiseReject_(err);
    };
    const promiseResolve = ()=>{
      promiseWasRejected = false;
      return promiseResolve_(sqlite3);
    };
    const W =
    new Worker(options.proxyUri);
    setTimeout(()=>{
      
      if(undefined===promiseWasRejected){
        promiseReject(
          new Error("Timeout while waiting for OPFS async proxy worker.")
        );
      }
    }, 4000);
    W._originalOnError = W.onerror ;
    W.onerror = function(err){
      
      
      error("Error initializing OPFS asyncer:",err);
      promiseReject(new Error("Loading OPFS async Worker failed for unknown reasons."));
    };
    const pDVfs = capi.sqlite3_vfs_find(null);
    const dVfs = pDVfs
          ? new sqlite3_vfs(pDVfs)
          : null ;
    opfsIoMethods.$iVersion = 1;
    opfsVfs.$iVersion = 2;
    opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
    opfsVfs.$mxPathname = 1024;
    opfsVfs.$zName = wasm.allocCString("opfs");
    
    opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
    opfsVfs.addOnDispose(
      '$zName', opfsVfs.$zName,
      'cleanup default VFS wrapper', ()=>(dVfs ? dVfs.dispose() : null)
    );
    
    
    const state = Object.create(null);
    state.verbose = options.verbose;
    state.littleEndian = (()=>{
      const buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true );
      
      return new Int16Array(buffer)[0] === 256;
    })();
    
    state.asyncIdleWaitTime = 150;

    
    state.asyncS11nExceptions = 1;
    
    state.fileBufferSize = 1024 * 64;
    state.sabS11nOffset = state.fileBufferSize;
    
    state.sabS11nSize = opfsVfs.$mxPathname * 2;
    
    state.sabIO = new SharedArrayBuffer(
      state.fileBufferSize
      + state.sabS11nSize
    );
    state.opIds = Object.create(null);
    const metrics = Object.create(null);
    {
      
      let i = 0;
      
      state.opIds.whichOp = i++;
      
      state.opIds.rc = i++;
      
      state.opIds.xAccess = i++;
      state.opIds.xClose = i++;
      state.opIds.xDelete = i++;
      state.opIds.xDeleteNoWait = i++;
      state.opIds.xFileSize = i++;
      state.opIds.xLock = i++;
      state.opIds.xOpen = i++;
      state.opIds.xRead = i++;
      state.opIds.xSleep = i++;
      state.opIds.xSync = i++;
      state.opIds.xTruncate = i++;
      state.opIds.xUnlock = i++;
      state.opIds.xWrite = i++;
      state.opIds.mkdir = i++;
      state.opIds['opfs-async-metrics'] = i++;
      state.opIds['opfs-async-shutdown'] = i++;
      
      state.opIds.retry = i++;
      state.sabOP = new SharedArrayBuffer(
        i * 4);
      opfsUtil.metrics.reset();
    }
    
    state.sq3Codes = Object.create(null);
    [
      'SQLITE_ACCESS_EXISTS',
      'SQLITE_ACCESS_READWRITE',
      'SQLITE_BUSY',
      'SQLITE_ERROR',
      'SQLITE_IOERR',
      'SQLITE_IOERR_ACCESS',
      'SQLITE_IOERR_CLOSE',
      'SQLITE_IOERR_DELETE',
      'SQLITE_IOERR_FSYNC',
      'SQLITE_IOERR_LOCK',
      'SQLITE_IOERR_READ',
      'SQLITE_IOERR_SHORT_READ',
      'SQLITE_IOERR_TRUNCATE',
      'SQLITE_IOERR_UNLOCK',
      'SQLITE_IOERR_WRITE',
      'SQLITE_LOCK_EXCLUSIVE',
      'SQLITE_LOCK_NONE',
      'SQLITE_LOCK_PENDING',
      'SQLITE_LOCK_RESERVED',
      'SQLITE_LOCK_SHARED',
      'SQLITE_LOCKED',
      'SQLITE_MISUSE',
      'SQLITE_NOTFOUND',
      'SQLITE_OPEN_CREATE',
      'SQLITE_OPEN_DELETEONCLOSE',
      'SQLITE_OPEN_MAIN_DB',
      'SQLITE_OPEN_READONLY'
    ].forEach((k)=>{
      if(undefined === (state.sq3Codes[k] = capi[k])){
        toss("Maintenance required: not found:",k);
      }
    });
    state.opfsFlags = Object.assign(Object.create(null),{
      
      OPFS_UNLOCK_ASAP: 0x01,
      
      defaultUnlockAsap: false
    });

    
    const opRun = (op,...args)=>{
      const opNdx = state.opIds[op] || toss("Invalid op ID:",op);
      state.s11n.serialize(...args);
      Atomics.store(state.sabOPView, state.opIds.rc, -1);
      Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
      Atomics.notify(state.sabOPView, state.opIds.whichOp)
      ;
      const t = performance.now();
      Atomics.wait(state.sabOPView, state.opIds.rc, -1)
      ;
      const rc = Atomics.load(state.sabOPView, state.opIds.rc);
      metrics[op].wait += performance.now() - t;
      if(rc && state.asyncS11nExceptions){
        const err = state.s11n.deserialize();
        if(err) error(op+"() async error:",...err);
      }
      return rc;
    };

    
    opfsUtil.debug = {
      asyncShutdown: ()=>{
        warn("Shutting down OPFS async listener. The OPFS VFS will no longer work.");
        opRun('opfs-async-shutdown');
      },
      asyncRestart: ()=>{
        warn("Attempting to restart OPFS VFS async listener. Might work, might not.");
        W.postMessage({type: 'opfs-async-restart'});
      }
    };

    const initS11n = ()=>{
      
      if(state.s11n) return state.s11n;
      const textDecoder = new TextDecoder(),
            textEncoder = new TextEncoder('utf-8'),
            viewU8 = new Uint8Array(state.sabIO, state.sabS11nOffset, state.sabS11nSize),
            viewDV = new DataView(state.sabIO, state.sabS11nOffset, state.sabS11nSize);
      state.s11n = Object.create(null);
      
      const TypeIds = Object.create(null);
      TypeIds.number  = { id: 1, size: 8, getter: 'getFloat64', setter: 'setFloat64' };
      TypeIds.bigint  = { id: 2, size: 8, getter: 'getBigInt64', setter: 'setBigInt64' };
      TypeIds.boolean = { id: 3, size: 4, getter: 'getInt32', setter: 'setInt32' };
      TypeIds.string =  { id: 4 };

      const getTypeId = (v)=>(
        TypeIds[typeof v]
          || toss("Maintenance required: this value type cannot be serialized.",v)
      );
      const getTypeIdById = (tid)=>{
        switch(tid){
            case TypeIds.number.id: return TypeIds.number;
            case TypeIds.bigint.id: return TypeIds.bigint;
            case TypeIds.boolean.id: return TypeIds.boolean;
            case TypeIds.string.id: return TypeIds.string;
            default: toss("Invalid type ID:",tid);
        }
      };

      
      state.s11n.deserialize = function(clear=false){
        ++metrics.s11n.deserialize.count;
        const t = performance.now();
        const argc = viewU8[0];
        const rc = argc ? [] : null;
        if(argc){
          const typeIds = [];
          let offset = 1, i, n, v;
          for(i = 0; i < argc; ++i, ++offset){
            typeIds.push(getTypeIdById(viewU8[offset]));
          }
          for(i = 0; i < argc; ++i){
            const t = typeIds[i];
            if(t.getter){
              v = viewDV[t.getter](offset, state.littleEndian);
              offset += t.size;
            }else{
              n = viewDV.getInt32(offset, state.littleEndian);
              offset += 4;
              v = textDecoder.decode(viewU8.slice(offset, offset+n));
              offset += n;
            }
            rc.push(v);
          }
        }
        if(clear) viewU8[0] = 0;
        
        metrics.s11n.deserialize.time += performance.now() - t;
        return rc;
      };

      
      state.s11n.serialize = function(...args){
        const t = performance.now();
        ++metrics.s11n.serialize.count;
        if(args.length){
          
          const typeIds = [];
          let i = 0, offset = 1;
          viewU8[0] = args.length & 0xff ;
          for(; i < args.length; ++i, ++offset){
            
            typeIds.push(getTypeId(args[i]));
            viewU8[offset] = typeIds[i].id;
          }
          for(i = 0; i < args.length; ++i) {
            
            const t = typeIds[i];
            if(t.setter){
              viewDV[t.setter](offset, args[i], state.littleEndian);
              offset += t.size;
            }else{
              const s = textEncoder.encode(args[i]);
              viewDV.setInt32(offset, s.byteLength, state.littleEndian);
              offset += 4;
              viewU8.set(s, offset);
              offset += s.byteLength;
            }
          }
          
        }else{
          viewU8[0] = 0;
        }
        metrics.s11n.serialize.time += performance.now() - t;
      };
      return state.s11n;
    };

    
    const randomFilename = function f(len=16){
      if(!f._chars){
        f._chars = "abcdefghijklmnopqrstuvwxyz"+
          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"+
          "012346789";
        f._n = f._chars.length;
      }
      const a = [];
      let i = 0;
      for( ; i < len; ++i){
        const ndx = Math.random() * (f._n * 64) % f._n | 0;
        a[i] = f._chars[ndx];
      }
      return a.join("");
      
    };

    
    const __openFiles = Object.create(null);

    const opTimer = Object.create(null);
    opTimer.op = undefined;
    opTimer.start = undefined;
    const mTimeStart = (op)=>{
      opTimer.start = performance.now();
      opTimer.op = op;
      ++metrics[op].count;
    };
    const mTimeEnd = ()=>(
      metrics[opTimer.op].time += performance.now() - opTimer.start
    );

    
    const ioSyncWrappers = {
      xCheckReservedLock: function(pFile,pOut){
        
        const f = __openFiles[pFile];
        wasm.poke(pOut, f.lockType ? 1 : 0, 'i32');
        return 0;
      },
      xClose: function(pFile){
        mTimeStart('xClose');
        let rc = 0;
        const f = __openFiles[pFile];
        if(f){
          delete __openFiles[pFile];
          rc = opRun('xClose', pFile);
          if(f.sq3File) f.sq3File.dispose();
        }
        mTimeEnd();
        return rc;
      },
      xDeviceCharacteristics: function(pFile){
        
        return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
      },
      xFileControl: function(pFile, opId, pArg){
        
        return capi.SQLITE_NOTFOUND;
      },
      xFileSize: function(pFile,pSz64){
        mTimeStart('xFileSize');
        let rc = opRun('xFileSize', pFile);
        if(0==rc){
          try {
            const sz = state.s11n.deserialize()[0];
            wasm.poke(pSz64, sz, 'i64');
          }catch(e){
            error("Unexpected error reading xFileSize() result:",e);
            rc = state.sq3Codes.SQLITE_IOERR;
          }
        }
        mTimeEnd();
        return rc;
      },
      xLock: function(pFile,lockType){
        mTimeStart('xLock');
        const f = __openFiles[pFile];
        let rc = 0;
        
        if( !f.lockType ) {
          rc = opRun('xLock', pFile, lockType);
          if( 0===rc ) f.lockType = lockType;
        }else{
          f.lockType = lockType;
        }
        mTimeEnd();
        return rc;
      },
      xRead: function(pFile,pDest,n,offset64){
        mTimeStart('xRead');
        const f = __openFiles[pFile];
        let rc;
        try {
          rc = opRun('xRead',pFile, n, Number(offset64));
          if(0===rc || capi.SQLITE_IOERR_SHORT_READ===rc){
            
            wasm.heap8u().set(f.sabView.subarray(0, n), pDest);
          }
        }catch(e){
          error("xRead(",arguments,") failed:",e,f);
          rc = capi.SQLITE_IOERR_READ;
        }
        mTimeEnd();
        return rc;
      },
      xSync: function(pFile,flags){
        mTimeStart('xSync');
        ++metrics.xSync.count;
        const rc = opRun('xSync', pFile, flags);
        mTimeEnd();
        return rc;
      },
      xTruncate: function(pFile,sz64){
        mTimeStart('xTruncate');
        const rc = opRun('xTruncate', pFile, Number(sz64));
        mTimeEnd();
        return rc;
      },
      xUnlock: function(pFile,lockType){
        mTimeStart('xUnlock');
        const f = __openFiles[pFile];
        let rc = 0;
        if( capi.SQLITE_LOCK_NONE === lockType
          && f.lockType ){
          rc = opRun('xUnlock', pFile, lockType);
        }
        if( 0===rc ) f.lockType = lockType;
        mTimeEnd();
        return rc;
      },
      xWrite: function(pFile,pSrc,n,offset64){
        mTimeStart('xWrite');
        const f = __openFiles[pFile];
        let rc;
        try {
          f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc+n));
          rc = opRun('xWrite', pFile, n, Number(offset64));
        }catch(e){
          error("xWrite(",arguments,") failed:",e,f);
          rc = capi.SQLITE_IOERR_WRITE;
        }
        mTimeEnd();
        return rc;
      }
    };

    
    const vfsSyncWrappers = {
      xAccess: function(pVfs,zName,flags,pOut){
        mTimeStart('xAccess');
        const rc = opRun('xAccess', wasm.cstrToJs(zName));
        wasm.poke( pOut, (rc ? 0 : 1), 'i32' );
        mTimeEnd();
        return 0;
      },
      xCurrentTime: function(pVfs,pOut){
        
        wasm.poke(pOut, 2440587.5 + (new Date().getTime()/86400000),
                  'double');
        return 0;
      },
      xCurrentTimeInt64: function(pVfs,pOut){
        wasm.poke(pOut, (2440587.5 * 86400000) + new Date().getTime(),
                  'i64');
        return 0;
      },
      xDelete: function(pVfs, zName, doSyncDir){
        mTimeStart('xDelete');
        const rc = opRun('xDelete', wasm.cstrToJs(zName), doSyncDir, false);
        mTimeEnd();
        return rc;
      },
      xFullPathname: function(pVfs,zName,nOut,pOut){
        
        const i = wasm.cstrncpy(pOut, zName, nOut);
        return i<nOut ? 0 : capi.SQLITE_CANTOPEN
        ;
      },
      xGetLastError: function(pVfs,nOut,pOut){
        
        warn("OPFS xGetLastError() has nothing sensible to return.");
        return 0;
      },
      
      xOpen: function f(pVfs, zName, pFile, flags, pOutFlags){
        mTimeStart('xOpen');
        let opfsFlags = 0;
        if(0===zName){
          zName = randomFilename();
        }else if('number'===typeof zName){
          if(capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)){
            
            opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
          }
          zName = wasm.cstrToJs(zName);
        }
        const fh = Object.create(null);
        fh.fid = pFile;
        fh.filename = zName;
        fh.sab = new SharedArrayBuffer(state.fileBufferSize);
        fh.flags = flags;
        const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);
        if(!rc){
          
          if(fh.readOnly){
            wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');
          }
          __openFiles[pFile] = fh;
          fh.sabView = state.sabFileBufView;
          fh.sq3File = new sqlite3_file(pFile);
          fh.sq3File.$pMethods = opfsIoMethods.pointer;
          fh.lockType = capi.SQLITE_LOCK_NONE;
        }
        mTimeEnd();
        return rc;
      }
    };

    if(dVfs){
      opfsVfs.$xRandomness = dVfs.$xRandomness;
      opfsVfs.$xSleep = dVfs.$xSleep;
    }
    if(!opfsVfs.$xRandomness){
      
      vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut){
        const heap = wasm.heap8u();
        let i = 0;
        for(; i < nOut; ++i) heap[pOut + i] = (Math.random()*255000) & 0xFF;
        return i;
      };
    }
    if(!opfsVfs.$xSleep){
      
      vfsSyncWrappers.xSleep = function(pVfs,ms){
        Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
        return 0;
      };
    }

    
    opfsUtil.getResolvedPath = function(filename,splitIt){
      const p = new URL(filename, "file://irrelevant").pathname;
      return splitIt ? p.split('/').filter((v)=>!!v) : p;
    };

    
    opfsUtil.getDirForFilename = async function f(absFilename, createDirs = false){
      const path = opfsUtil.getResolvedPath(absFilename, true);
      const filename = path.pop();
      let dh = opfsUtil.rootDirectory;
      for(const dirName of path){
        if(dirName){
          dh = await dh.getDirectoryHandle(dirName, {create: !!createDirs});
        }
      }
      return [dh, filename];
    };

    
    opfsUtil.mkdir = async function(absDirName){
      try {
        await opfsUtil.getDirForFilename(absDirName+"/filepart", true);
        return true;
      }catch(e){
        
        return false;
      }
    };
    
    opfsUtil.entryExists = async function(fsEntryName){
      try {
        const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
        await dh.getFileHandle(fn);
        return true;
      }catch(e){
        return false;
      }
    };

    
    opfsUtil.randomFilename = randomFilename;

    
    opfsUtil.registerVfs = (asDefault=false)=>{
      return wasm.exports.sqlite3_vfs_register(
        opfsVfs.pointer, asDefault ? 1 : 0
      );
    };

    
    opfsUtil.treeList = async function(){
      const doDir = async function callee(dirHandle,tgt){
        tgt.name = dirHandle.name;
        tgt.dirs = [];
        tgt.files = [];
        for await (const handle of dirHandle.values()){
          if('directory' === handle.kind){
            const subDir = Object.create(null);
            tgt.dirs.push(subDir);
            await callee(handle, subDir);
          }else{
            tgt.files.push(handle.name);
          }
        }
      };
      const root = Object.create(null);
      await doDir(opfsUtil.rootDirectory, root);
      return root;
    };

    
    opfsUtil.rmfr = async function(){
      const dir = opfsUtil.rootDirectory, opt = {recurse: true};
      for await (const handle of dir.values()){
        dir.removeEntry(handle.name, opt);
      }
    };

    
    opfsUtil.unlink = async function(fsEntryName, recursive = false,
                                     throwOnError = false){
      try {
        const [hDir, filenamePart] =
              await opfsUtil.getDirForFilename(fsEntryName, false);
        await hDir.removeEntry(filenamePart, {recursive});
        return true;
      }catch(e){
        if(throwOnError){
          throw new Error("unlink(",arguments[0],") failed: "+e.message,{
            cause: e
          });
        }
        return false;
      }
    };

    
    opfsUtil.traverse = async function(opt){
      const defaultOpt = {
        recursive: true,
        directory: opfsUtil.rootDirectory
      };
      if('function'===typeof opt){
        opt = {callback:opt};
      }
      opt = Object.assign(defaultOpt, opt||{});
      const doDir = async function callee(dirHandle, depth){
        for await (const handle of dirHandle.values()){
          if(false === opt.callback(handle, dirHandle, depth)) return false;
          else if(opt.recursive && 'directory' === handle.kind){
            if(false === await callee(handle, depth + 1)) break;
          }
        }
      };
      doDir(opt.directory, 0);
    };

    
    const importDbChunked = async function(filename, callback){
      const [hDir, fnamePart] = await opfsUtil.getDirForFilename(filename, true);
      const hFile = await hDir.getFileHandle(fnamePart, {create:true});
      let sah = await hFile.createSyncAccessHandle();
      let nWrote = 0, chunk, checkedHeader = false, err = false;
      try{
        sah.truncate(0);
        while( undefined !== (chunk = await callback()) ){
          if(chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
          if( 0===nWrote && chunk.byteLength>=15 ){
            util.affirmDbHeader(chunk);
            checkedHeader = true;
          }
          sah.write(chunk, {at: nWrote});
          nWrote += chunk.byteLength;
        }
        if( nWrote < 512 || 0!==nWrote % 512 ){
          toss("Input size",nWrote,"is not correct for an SQLite database.");
        }
        if( !checkedHeader ){
          const header = new Uint8Array(20);
          sah.read( header, {at: 0} );
          util.affirmDbHeader( header );
        }
        sah.write(new Uint8Array([1,1]), {at: 18});
        return nWrote;
      }catch(e){
        await sah.close();
        sah = undefined;
        await hDir.removeEntry( fnamePart ).catch(()=>{});
        throw e;
      }finally {
        if( sah ) await sah.close();
      }
    };

    
    opfsUtil.importDb = async function(filename, bytes){
      if( bytes instanceof Function ){
        return importDbChunked(filename, bytes);
      }
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      util.affirmIsDb(bytes);
      const n = bytes.byteLength;
      const [hDir, fnamePart] = await opfsUtil.getDirForFilename(filename, true);
      let sah, err, nWrote = 0;
      try {
        const hFile = await hDir.getFileHandle(fnamePart, {create:true});
        sah = await hFile.createSyncAccessHandle();
        sah.truncate(0);
        nWrote = sah.write(bytes, {at: 0});
        if(nWrote != n){
          toss("Expected to write "+n+" bytes but wrote "+nWrote+".");
        }
        sah.write(new Uint8Array([1,1]), {at: 18}) ;
        return nWrote;
      }catch(e){
        if( sah ){ await sah.close(); sah = undefined; }
        await hDir.removeEntry( fnamePart ).catch(()=>{});
        throw e;
      }finally{
        if( sah ) await sah.close();
      }
    };

    if(sqlite3.oo1){
      const OpfsDb = function(...args){
        const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
        opt.vfs = opfsVfs.$zName;
        sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
      };
      OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
      sqlite3.oo1.OpfsDb = OpfsDb;
      OpfsDb.importDb = opfsUtil.importDb;
      sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
        opfsVfs.pointer,
        function(oo1Db, sqlite3){
          
          sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);
          sqlite3.capi.sqlite3_exec(oo1Db, [
            
            "pragma journal_mode=DELETE;",
            
            "pragma cache_size=-16384;"
          ], 0, 0, 0);
        }
      );
    }

    const sanityCheck = function(){
      const scope = wasm.scopedAllocPush();
      const sq3File = new sqlite3_file();
      try{
        const fid = sq3File.pointer;
        const openFlags = capi.SQLITE_OPEN_CREATE
              | capi.SQLITE_OPEN_READWRITE
        
              | capi.SQLITE_OPEN_MAIN_DB;
        const pOut = wasm.scopedAlloc(8);
        const dbFile = "/sanity/check/file"+randomFilename(8);
        const zDbFile = wasm.scopedAllocCString(dbFile);
        let rc;
        state.s11n.serialize("This is ä string.");
        rc = state.s11n.deserialize();
        log("deserialize() says:",rc);
        if("This is ä string."!==rc[0]) toss("String d13n error.");
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        log("xAccess(",dbFile,") exists ?=",rc);
        rc = vfsSyncWrappers.xOpen(opfsVfs.pointer, zDbFile,
                                   fid, openFlags, pOut);
        log("open rc =",rc,"state.sabOPView[xOpen] =",
            state.sabOPView[state.opIds.xOpen]);
        if(0!==rc){
          error("open failed with code",rc);
          return;
        }
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        if(!rc) toss("xAccess() failed to detect file.");
        rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
        if(rc) toss('sync failed w/ rc',rc);
        rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
        if(rc) toss('truncate failed w/ rc',rc);
        wasm.poke(pOut,0,'i64');
        rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
        if(rc) toss('xFileSize failed w/ rc',rc);
        log("xFileSize says:",wasm.peek(pOut, 'i64'));
        rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
        if(rc) toss("xWrite() failed!");
        const readBuf = wasm.scopedAlloc(16);
        rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
        wasm.poke(readBuf+6,0);
        let jRead = wasm.cstrToJs(readBuf);
        log("xRead() got:",jRead);
        if("sanity"!==jRead) toss("Unexpected xRead() value.");
        if(vfsSyncWrappers.xSleep){
          log("xSleep()ing before close()ing...");
          vfsSyncWrappers.xSleep(opfsVfs.pointer,2000);
          log("waking up from xSleep()");
        }
        rc = ioSyncWrappers.xClose(fid);
        log("xClose rc =",rc,"sabOPView =",state.sabOPView);
        log("Deleting file:",dbFile);
        vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        if(rc) toss("Expecting 0 from xAccess(",dbFile,") after xDelete().");
        warn("End of OPFS sanity checks.");
      }finally{
        sq3File.dispose();
        wasm.scopedAllocPop(scope);
      }
    };

    W.onmessage = function({data}){
      
      switch(data.type){
          case 'opfs-unavailable':
            
            promiseReject(new Error(data.payload.join(' ')));
            break;
          case 'opfs-async-loaded':
            
            W.postMessage({type: 'opfs-async-init',args: state});
            break;
          case 'opfs-async-inited': {
            
            if(true===promiseWasRejected){
              break ;
            }
            try {
              sqlite3.vfs.installVfs({
                io: {struct: opfsIoMethods, methods: ioSyncWrappers},
                vfs: {struct: opfsVfs, methods: vfsSyncWrappers}
              });
              state.sabOPView = new Int32Array(state.sabOP);
              state.sabFileBufView = new Uint8Array(state.sabIO, 0, state.fileBufferSize);
              state.sabS11nView = new Uint8Array(state.sabIO, state.sabS11nOffset, state.sabS11nSize);
              initS11n();
              if(options.sanityChecks){
                warn("Running sanity checks because of opfs-sanity-check URL arg...");
                sanityCheck();
              }
              if(thisThreadHasOPFS()){
                navigator.storage.getDirectory().then((d)=>{
                  W.onerror = W._originalOnError;
                  delete W._originalOnError;
                  sqlite3.opfs = opfsUtil;
                  opfsUtil.rootDirectory = d;
                  log("End of OPFS sqlite3_vfs setup.", opfsVfs);
                  promiseResolve();
                }).catch(promiseReject);
              }else{
                promiseResolve();
              }
            }catch(e){
              error(e);
              promiseReject(e);
            }
            break;
          }
          default: {
            const errMsg = (
              "Unexpected message from the OPFS async worker: " +
              JSON.stringify(data)
            );
            error(errMsg);
            promiseReject(new Error(errMsg));
            break;
          }
      }
    };
  });
  return thePromise;
};
installOpfsVfs.defaultProxyUri =
  "sqlite3-opfs-async-proxy.js";
globalThis.sqlite3ApiBootstrap.initializersAsync.push(async (sqlite3)=>{
  try{
    let proxyJs = installOpfsVfs.defaultProxyUri;
    if(sqlite3.scriptInfo.sqlite3Dir){
      installOpfsVfs.defaultProxyUri =
        sqlite3.scriptInfo.sqlite3Dir + proxyJs;
      
    }
    return installOpfsVfs().catch((e)=>{
      sqlite3.config.warn("Ignoring inability to install OPFS sqlite3_vfs:",e.message);
    });
  }catch(e){
    sqlite3.config.error("installOpfsVfs() exception:",e);
    return Promise.reject(e);
  }
});
});



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  'use strict';
  const toss = sqlite3.util.toss;
  const toss3 = sqlite3.util.toss3;
  const initPromises = Object.create(null);
  const capi = sqlite3.capi;
  const util = sqlite3.util;
  const wasm = sqlite3.wasm;
  
  const SECTOR_SIZE = 4096;
  const HEADER_MAX_PATH_SIZE = 512;
  const HEADER_FLAGS_SIZE = 4;
  const HEADER_DIGEST_SIZE = 8;
  const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
  const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
  const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
  const HEADER_OFFSET_DATA = SECTOR_SIZE;
  
  const PERSISTENT_FILE_TYPES =
        capi.SQLITE_OPEN_MAIN_DB |
        capi.SQLITE_OPEN_MAIN_JOURNAL |
        capi.SQLITE_OPEN_SUPER_JOURNAL |
        capi.SQLITE_OPEN_WAL ;

  
  const OPAQUE_DIR_NAME = ".opaque";

  
  const getRandomName = ()=>Math.random().toString(36).slice(2);

  const textDecoder = new TextDecoder();
  const textEncoder = new TextEncoder();

  const optionDefaults = Object.assign(Object.create(null),{
    name: 'opfs-sahpool',
    directory: undefined ,
    initialCapacity: 6,
    clearOnInit: false,
    
    verbosity: 2
  });

  
  const loggers = [
    sqlite3.config.error,
    sqlite3.config.warn,
    sqlite3.config.log
  ];
  const log = sqlite3.config.log;
  const warn = sqlite3.config.warn;
  const error = sqlite3.config.error;

  
  const __mapVfsToPool = new Map();
  const getPoolForVfs = (pVfs)=>__mapVfsToPool.get(pVfs);
  const setPoolForVfs = (pVfs,pool)=>{
    if(pool) __mapVfsToPool.set(pVfs, pool);
    else __mapVfsToPool.delete(pVfs);
  };
  
  const __mapSqlite3File = new Map();
  const getPoolForPFile = (pFile)=>__mapSqlite3File.get(pFile);
  const setPoolForPFile = (pFile,pool)=>{
    if(pool) __mapSqlite3File.set(pFile, pool);
    else __mapSqlite3File.delete(pFile);
  };

  
  const ioMethods = {
    xCheckReservedLock: function(pFile,pOut){
      const pool = getPoolForPFile(pFile);
      pool.log('xCheckReservedLock');
      pool.storeErr();
      wasm.poke32(pOut, 1);
      return 0;
    },
    xClose: function(pFile){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      if(file) {
        try{
          pool.log(`xClose ${file.path}`);
          pool.mapS3FileToOFile(pFile, false);
          file.sah.flush();
          if(file.flags & capi.SQLITE_OPEN_DELETEONCLOSE){
            pool.deletePath(file.path);
          }
        }catch(e){
          return pool.storeErr(e, capi.SQLITE_IOERR);
        }
      }
      return 0;
    },
    xDeviceCharacteristics: function(pFile){
      return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
    },
    xFileControl: function(pFile, opId, pArg){
      return capi.SQLITE_NOTFOUND;
    },
    xFileSize: function(pFile,pSz64){
      const pool = getPoolForPFile(pFile);
      pool.log(`xFileSize`);
      const file = pool.getOFileForS3File(pFile);
      const size = file.sah.getSize() - HEADER_OFFSET_DATA;
      
      wasm.poke64(pSz64, BigInt(size));
      return 0;
    },
    xLock: function(pFile,lockType){
      const pool = getPoolForPFile(pFile);
      pool.log(`xLock ${lockType}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      file.lockType = lockType;
      return 0;
    },
    xRead: function(pFile,pDest,n,offset64){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      pool.log(`xRead ${file.path} ${n} @ ${offset64}`);
      try {
        const nRead = file.sah.read(
          wasm.heap8u().subarray(pDest, pDest+n),
          {at: HEADER_OFFSET_DATA + Number(offset64)}
        );
        if(nRead < n){
          wasm.heap8u().fill(0, pDest + nRead, pDest + n);
          return capi.SQLITE_IOERR_SHORT_READ;
        }
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xSectorSize: function(pFile){
      return SECTOR_SIZE;
    },
    xSync: function(pFile,flags){
      const pool = getPoolForPFile(pFile);
      pool.log(`xSync ${flags}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      
      try{
        file.sah.flush();
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xTruncate: function(pFile,sz64){
      const pool = getPoolForPFile(pFile);
      pool.log(`xTruncate ${sz64}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      
      try{
        file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xUnlock: function(pFile,lockType){
      const pool = getPoolForPFile(pFile);
      pool.log('xUnlock');
      const file = pool.getOFileForS3File(pFile);
      file.lockType = lockType;
      return 0;
    },
    xWrite: function(pFile,pSrc,n,offset64){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      pool.log(`xWrite ${file.path} ${n} ${offset64}`);
      try{
        const nBytes = file.sah.write(
          wasm.heap8u().subarray(pSrc, pSrc+n),
          { at: HEADER_OFFSET_DATA + Number(offset64) }
        );
        return n===nBytes ? 0 : toss("Unknown write() failure.");
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    }
  };

  const opfsIoMethods = new capi.sqlite3_io_methods();
  opfsIoMethods.$iVersion = 1;
  sqlite3.vfs.installVfs({
    io: {struct: opfsIoMethods, methods: ioMethods}
  });

  
  const vfsMethods = {
    xAccess: function(pVfs,zName,flags,pOut){
      
      const pool = getPoolForVfs(pVfs);
      pool.storeErr();
      try{
        const name = pool.getPath(zName);
        wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
      }catch(e){
        
        wasm.poke32(pOut, 0);
      }
      return 0;
    },
    xCurrentTime: function(pVfs,pOut){
      wasm.poke(pOut, 2440587.5 + (new Date().getTime()/86400000),
                'double');
      return 0;
    },
    xCurrentTimeInt64: function(pVfs,pOut){
      wasm.poke(pOut, (2440587.5 * 86400000) + new Date().getTime(),
                'i64');
      return 0;
    },
    xDelete: function(pVfs, zName, doSyncDir){
      const pool = getPoolForVfs(pVfs);
      pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
      pool.storeErr();
      try{
        pool.deletePath(pool.getPath(zName));
        return 0;
      }catch(e){
        pool.storeErr(e);
        return capi.SQLITE_IOERR_DELETE;
      }
    },
    xFullPathname: function(pVfs,zName,nOut,pOut){
      
      
      const i = wasm.cstrncpy(pOut, zName, nOut);
      return i<nOut ? 0 : capi.SQLITE_CANTOPEN;
    },
    xGetLastError: function(pVfs,nOut,pOut){
      const pool = getPoolForVfs(pVfs);
      const e = pool.popErr();
      pool.log(`xGetLastError ${nOut} e =`,e);
      if(e){
        const scope = wasm.scopedAllocPush();
        try{
          const [cMsg, n] = wasm.scopedAllocCString(e.message, true);
          wasm.cstrncpy(pOut, cMsg, nOut);
          if(n > nOut) wasm.poke8(pOut + nOut - 1, 0);
        }catch(e){
          return capi.SQLITE_NOMEM;
        }finally{
          wasm.scopedAllocPop(scope);
        }
      }
      return e ? (e.sqlite3Rc || capi.SQLITE_IOERR) : 0;
    },
    
    xOpen: function f(pVfs, zName, pFile, flags, pOutFlags){
      const pool = getPoolForVfs(pVfs);
      try{
        pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);
        
        const path = (zName && wasm.peek8(zName))
              ? pool.getPath(zName)
              : getRandomName();
        let sah = pool.getSAHForPath(path);
        if(!sah && (flags & capi.SQLITE_OPEN_CREATE)) {
          
          if(pool.getFileCount() < pool.getCapacity()) {
            
            sah = pool.nextAvailableSAH();
            pool.setAssociatedPath(sah, path, flags);
          }else{
            
            toss('SAH pool is full. Cannot create file',path);
          }
        }
        if(!sah){
          toss('file not found:',path);
        }
        
        
        const file = {path, flags, sah};
        pool.mapS3FileToOFile(pFile, file);
        file.lockType = capi.SQLITE_LOCK_NONE;
        const sq3File = new capi.sqlite3_file(pFile);
        sq3File.$pMethods = opfsIoMethods.pointer;
        sq3File.dispose();
        wasm.poke32(pOutFlags, flags);
        return 0;
      }catch(e){
        pool.storeErr(e);
        return capi.SQLITE_CANTOPEN;
      }
    }
  };

  
  const createOpfsVfs = function(vfsName){
    if( sqlite3.capi.sqlite3_vfs_find(vfsName)){
      toss3("VFS name is already registered:", vfsName);
    }
    const opfsVfs = new capi.sqlite3_vfs();
    
    const pDVfs = capi.sqlite3_vfs_find(null);
    const dVfs = pDVfs
          ? new capi.sqlite3_vfs(pDVfs)
          : null ;
    opfsVfs.$iVersion = 2;
    opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
    opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
    opfsVfs.addOnDispose(
      opfsVfs.$zName = wasm.allocCString(vfsName),
      ()=>setPoolForVfs(opfsVfs.pointer, 0)
    );

    if(dVfs){
      
      opfsVfs.$xRandomness = dVfs.$xRandomness;
      opfsVfs.$xSleep = dVfs.$xSleep;
      dVfs.dispose();
    }
    if(!opfsVfs.$xRandomness && !vfsMethods.xRandomness){
      
      vfsMethods.xRandomness = function(pVfs, nOut, pOut){
        const heap = wasm.heap8u();
        let i = 0;
        for(; i < nOut; ++i) heap[pOut + i] = (Math.random()*255000) & 0xFF;
        return i;
      };
    }
    if(!opfsVfs.$xSleep && !vfsMethods.xSleep){
      vfsMethods.xSleep = (pVfs,ms)=>0;
    }
    sqlite3.vfs.installVfs({
      vfs: {struct: opfsVfs, methods: vfsMethods}
    });
    return opfsVfs;
  };

  
  class OpfsSAHPool {
    
    vfsDir;
    
    #dhVfsRoot;
    
    #dhOpaque;
    
    #dhVfsParent;
    
    #mapSAHToName = new Map();
    
    #mapFilenameToSAH = new Map();
    
    #availableSAH = new Set();
    
    #mapS3FileToOFile_ = new Map();

    
    

    
    #apBody = new Uint8Array(HEADER_CORPUS_SIZE);
    
    #dvBody;

    
    #cVfs;

    
    #verbosity;

    constructor(options = Object.create(null)){
      this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
      this.vfsName = options.name || optionDefaults.name;
      this.#cVfs = createOpfsVfs(this.vfsName);
      setPoolForVfs(this.#cVfs.pointer, this);
      this.vfsDir = options.directory || ("."+this.vfsName);
      this.#dvBody =
        new DataView(this.#apBody.buffer, this.#apBody.byteOffset);
      this.isReady = this
        .reset(!!(options.clearOnInit ?? optionDefaults.clearOnInit))
        .then(()=>{
          if(this.$error) throw this.$error;
          return this.getCapacity()
            ? Promise.resolve(undefined)
            : this.addCapacity(options.initialCapacity
                               || optionDefaults.initialCapacity);
        });
    }

    #logImpl(level,...args){
      if(this.#verbosity>level) loggers[level](this.vfsName+":",...args);
    };
    log(...args){this.#logImpl(2, ...args)};
    warn(...args){this.#logImpl(1, ...args)};
    error(...args){this.#logImpl(0, ...args)};

    getVfs(){return this.#cVfs}

    
    getCapacity(){return this.#mapSAHToName.size}

    
    getFileCount(){return this.#mapFilenameToSAH.size}

    
    getFileNames(){
      const rc = [];
      const iter = this.#mapFilenameToSAH.keys();
      for(const n of iter) rc.push(n);
      return rc;
    }












    
    async addCapacity(n){
      for(let i = 0; i < n; ++i){
        const name = getRandomName();
        const h = await this.#dhOpaque.getFileHandle(name, {create:true});
        const ah = await h.createSyncAccessHandle();
        this.#mapSAHToName.set(ah,name);
        this.setAssociatedPath(ah, '', 0);
        
      }
      return this.getCapacity();
    }

    
    async reduceCapacity(n){
      let nRm = 0;
      for(const ah of Array.from(this.#availableSAH)){
        if(nRm === n || this.getFileCount() === this.getCapacity()){
          break;
        }
        const name = this.#mapSAHToName.get(ah);
        
        ah.close();
        await this.#dhOpaque.removeEntry(name);
        this.#mapSAHToName.delete(ah);
        this.#availableSAH.delete(ah);
        ++nRm;
      }
      return nRm;
    }

    
    releaseAccessHandles(){
      for(const ah of this.#mapSAHToName.keys()) ah.close();
      this.#mapSAHToName.clear();
      this.#mapFilenameToSAH.clear();
      this.#availableSAH.clear();
    }

    
    async acquireAccessHandles(clearFiles){
      const files = [];
      for await (const [name,h] of this.#dhOpaque){
        if('file'===h.kind){
          files.push([name,h]);
        }
      }
      return Promise.all(files.map(async([name,h])=>{
        try{
          const ah = await h.createSyncAccessHandle()
          this.#mapSAHToName.set(ah, name);
          if(clearFiles){
            ah.truncate(HEADER_OFFSET_DATA);
            this.setAssociatedPath(ah, '', 0);
          }else{
            const path = this.getAssociatedPath(ah);
            if(path){
              this.#mapFilenameToSAH.set(path, ah);
            }else{
              this.#availableSAH.add(ah);
            }
          }
        }catch(e){
          this.storeErr(e);
          this.releaseAccessHandles();
          throw e;
        }
      }));
    }

    
    getAssociatedPath(sah){
      sah.read(this.#apBody, {at: 0});
      
      
      const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
      if(this.#apBody[0] &&
         ((flags & capi.SQLITE_OPEN_DELETEONCLOSE) ||
          (flags & PERSISTENT_FILE_TYPES)===0)){
        warn(`Removing file with unexpected flags ${flags.toString(16)}`,
             this.#apBody);
        this.setAssociatedPath(sah, '', 0);
        return '';
      }

      const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
      sah.read(fileDigest, {at: HEADER_OFFSET_DIGEST});
      const compDigest = this.computeDigest(this.#apBody);
      if(fileDigest.every((v,i) => v===compDigest[i])){
        
        const pathBytes = this.#apBody.findIndex((v)=>0===v);
        if(0===pathBytes){
          
          
          sah.truncate(HEADER_OFFSET_DATA);
        }
        return pathBytes
          ? textDecoder.decode(this.#apBody.subarray(0,pathBytes))
          : '';
      }else{
        
        warn('Disassociating file with bad digest.');
        this.setAssociatedPath(sah, '', 0);
        return '';
      }
    }

    
    setAssociatedPath(sah, path, flags){
      const enc = textEncoder.encodeInto(path, this.#apBody);
      if(HEADER_MAX_PATH_SIZE <= enc.written + 1){
        toss("Path too long:",path);
      }
      this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
      this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);

      const digest = this.computeDigest(this.#apBody);
      sah.write(this.#apBody, {at: 0});
      sah.write(digest, {at: HEADER_OFFSET_DIGEST});
      sah.flush();

      if(path){
        this.#mapFilenameToSAH.set(path, sah);
        this.#availableSAH.delete(sah);
      }else{
        
        sah.truncate(HEADER_OFFSET_DATA);
        this.#availableSAH.add(sah);
      }
    }

    
    computeDigest(byteArray){
      let h1 = 0xdeadbeef;
      let h2 = 0x41c6ce57;
      for(const v of byteArray){
        h1 = 31 * h1 + (v * 307);
        h2 = 31 * h2 + (v * 307);
      }
      return new Uint32Array([h1>>>0, h2>>>0]);
    }

    
    async reset(clearFiles){
      await this.isReady;
      let h = await navigator.storage.getDirectory();
      let prev, prevName;
      for(const d of this.vfsDir.split('/')){
        if(d){
          prev = h;
          h = await h.getDirectoryHandle(d,{create:true});
        }
      }
      this.#dhVfsRoot = h;
      this.#dhVfsParent = prev;
      this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
        OPAQUE_DIR_NAME,{create:true}
      );
      this.releaseAccessHandles();
      return this.acquireAccessHandles(clearFiles);
    }

    
    getPath(arg) {
      if(wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);
      return ((arg instanceof URL)
              ? arg
              : new URL(arg, 'file://localhost/')).pathname;
    }

    
    deletePath(path) {
      const sah = this.#mapFilenameToSAH.get(path);
      if(sah) {
        
        this.#mapFilenameToSAH.delete(path);
        this.setAssociatedPath(sah, '', 0);
      }
      return !!sah;
    }

    
    storeErr(e,code){
      if(e){
        e.sqlite3Rc = code || capi.SQLITE_IOERR;
        this.error(e);
      }
      this.$error = e;
      return code;
    }
    
    popErr(){
      const rc = this.$error;
      this.$error = undefined;
      return rc;
    }

    
    nextAvailableSAH(){
      const [rc] = this.#availableSAH.keys();
      return rc;
    }

    
    getOFileForS3File(pFile){
      return this.#mapS3FileToOFile_.get(pFile);
    }
    
    mapS3FileToOFile(pFile,file){
      if(file){
        this.#mapS3FileToOFile_.set(pFile, file);
        setPoolForPFile(pFile, this);
      }else{
        this.#mapS3FileToOFile_.delete(pFile);
        setPoolForPFile(pFile, false);
      }
    }

    
    hasFilename(name){
      return this.#mapFilenameToSAH.has(name)
    }

    
    getSAHForPath(path){
      return this.#mapFilenameToSAH.get(path);
    }

    
    async removeVfs(){
      if(!this.#cVfs.pointer || !this.#dhOpaque) return false;
      capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
      this.#cVfs.dispose();
      try{
        this.releaseAccessHandles();
        await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {recursive: true});
        this.#dhOpaque = undefined;
        await this.#dhVfsParent.removeEntry(
          this.#dhVfsRoot.name, {recursive: true}
        );
        this.#dhVfsRoot = this.#dhVfsParent = undefined;
      }catch(e){
        sqlite3.config.error(this.vfsName,"removeVfs() failed:",e);
        
      }
      return true;
    }


    
    exportFile(name){
      const sah = this.#mapFilenameToSAH.get(name) || toss("File not found:",name);
      const n = sah.getSize() - HEADER_OFFSET_DATA;
      const b = new Uint8Array(n>0 ? n : 0);
      if(n>0){
        const nRead = sah.read(b, {at: HEADER_OFFSET_DATA});
        if(nRead != n){
          toss("Expected to read "+n+" bytes but read "+nRead+".");
        }
      }
      return b;
    }

    
    async importDbChunked(name, callback){
      const sah = this.#mapFilenameToSAH.get(name)
            || this.nextAvailableSAH()
            || toss("No available handles to import to.");
      sah.truncate(0);
      let nWrote = 0, chunk, checkedHeader = false, err = false;
      try{
        while( undefined !== (chunk = await callback()) ){
          if(chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
          if( 0===nWrote && chunk.byteLength>=15 ){
            util.affirmDbHeader(chunk);
            checkedHeader = true;
          }
          sah.write(chunk, {at:  HEADER_OFFSET_DATA + nWrote});
          nWrote += chunk.byteLength;
        }
        if( nWrote < 512 || 0!==nWrote % 512 ){
          toss("Input size",nWrote,"is not correct for an SQLite database.");
        }
        if( !checkedHeader ){
          const header = new Uint8Array(20);
          sah.read( header, {at: 0} );
          util.affirmDbHeader( header );
        }
        sah.write(new Uint8Array([1,1]), {
          at: HEADER_OFFSET_DATA + 18
        });
      }catch(e){
        this.setAssociatedPath(sah, '', 0);
        throw e;
      }
      this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
      return nWrote;
    }

    
    importDb(name, bytes){
      if( bytes instanceof ArrayBuffer ) bytes = new Uint8Array(bytes);
      else if( bytes instanceof Function ) return this.importDbChunked(name, bytes);
      const sah = this.#mapFilenameToSAH.get(name)
            || this.nextAvailableSAH()
            || toss("No available handles to import to.");
      const n = bytes.byteLength;
      if(n<512 || n%512!=0){
        toss("Byte array size is invalid for an SQLite db.");
      }
      const header = "SQLite format 3";
      for(let i = 0; i < header.length; ++i){
        if( header.charCodeAt(i) !== bytes[i] ){
          toss("Input does not contain an SQLite database header.");
        }
      }
      const nWrote = sah.write(bytes, {at: HEADER_OFFSET_DATA});
      if(nWrote != n){
        this.setAssociatedPath(sah, '', 0);
        toss("Expected to write "+n+" bytes but wrote "+nWrote+".");
      }else{
        sah.write(new Uint8Array([1,1]), {at: HEADER_OFFSET_DATA+18}
                   );
        this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
      }
      return nWrote;
    }

  };


  
  class OpfsSAHPoolUtil {
    
    #p;

    constructor(sahPool){
      this.#p = sahPool;
      this.vfsName = sahPool.vfsName;
    }

    async addCapacity(n){ return this.#p.addCapacity(n) }

    async reduceCapacity(n){ return this.#p.reduceCapacity(n) }

    getCapacity(){ return this.#p.getCapacity(this.#p) }

    getFileCount(){ return this.#p.getFileCount() }
    getFileNames(){ return this.#p.getFileNames() }

    async reserveMinimumCapacity(min){
      const c = this.#p.getCapacity();
      return (c < min) ? this.#p.addCapacity(min - c) : c;
    }

    exportFile(name){ return this.#p.exportFile(name) }

    importDb(name, bytes){ return this.#p.importDb(name,bytes) }

    async wipeFiles(){ return this.#p.reset(true) }

    unlink(filename){ return this.#p.deletePath(filename) }

    async removeVfs(){ return this.#p.removeVfs() }

  };

  
  const apiVersionCheck = async ()=>{
    const dh = await navigator.storage.getDirectory();
    const fn = '.opfs-sahpool-sync-check-'+getRandomName();
    const fh = await dh.getFileHandle(fn, { create: true });
    const ah = await fh.createSyncAccessHandle();
    const close = ah.close();
    await close;
    await dh.removeEntry(fn);
    if(close?.then){
      toss("The local OPFS API is too old for opfs-sahpool:",
           "it has an async FileSystemSyncAccessHandle.close() method.");
    }
    return true;
  };

  
  let instanceCounter = 0;

  
  sqlite3.installOpfsSAHPoolVfs = async function(options=Object.create(null)){
    const vfsName = options.name || optionDefaults.name;
    if(false){}
    if(initPromises[vfsName]){
      
      return initPromises[vfsName];
    }
    if(!globalThis.FileSystemHandle ||
       !globalThis.FileSystemDirectoryHandle ||
       !globalThis.FileSystemFileHandle ||
       !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
       !navigator?.storage?.getDirectory){
      return (initPromises[vfsName] = Promise.reject(new Error("Missing required OPFS APIs.")));
    }

    
    return initPromises[vfsName] = apiVersionCheck().then(async function(){
      if(options.$testThrowInInit){
        throw options.$testThrowInInit;
      }
      const thePool = new OpfsSAHPool(options);
      return thePool.isReady.then(async()=>{
        
        const poolUtil = new OpfsSAHPoolUtil(thePool);
        if(sqlite3.oo1){
          const oo1 = sqlite3.oo1;
          const theVfs = thePool.getVfs();
          const OpfsSAHPoolDb = function(...args){
            const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
            opt.vfs = theVfs.$zName;
            oo1.DB.dbCtorHelper.call(this, opt);
          };
          OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
          
          poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
          oo1.DB.dbCtorHelper.setVfsPostOpenSql(
            theVfs.pointer,
            function(oo1Db, sqlite3){
              sqlite3.capi.sqlite3_exec(oo1Db, [
                
                "pragma journal_mode=DELETE;",
                "pragma cache_size=-16384;"
              ], 0, 0, 0);
            }
          );
        }
        thePool.log("VFS initialized.");
        return poolUtil;
      }).catch(async (e)=>{
        await thePool.removeVfs().catch(()=>{});
        return e;
      });
    }).catch((err)=>{
      
      return initPromises[vfsName] = Promise.reject(err);
    });
  };
});



'use strict';
if('undefined' !== typeof Module){ 
  
  const SABC = Object.assign(
    Object.create(null), {
      exports: ('undefined'===typeof wasmExports)
        ? Module['asm']
        : wasmExports  ,
      memory: Module.wasmMemory 
    },
    globalThis.sqlite3ApiConfig || {}
  );

  
  
  globalThis.sqlite3ApiConfig = SABC;
  let sqlite3;
  try{
    sqlite3 = globalThis.sqlite3ApiBootstrap();
  }catch(e){
    console.error("sqlite3ApiBootstrap() error:",e);
    throw e;
  }finally{
    delete globalThis.sqlite3ApiBootstrap;
    delete globalThis.sqlite3ApiConfig;
  }

  Module.sqlite3 = sqlite3 ;
}else{
  console.warn("This is not running in an Emscripten module context, so",
               "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
               "of config info for the WASM environment.",
               "It must be called manually.");
}




});



  return sqlite3InitModule.ready
}
);
})();
if (true)
  module.exports = sqlite3InitModule;
else {}



(function(){
  
  const originalInit = sqlite3InitModule;
  if(!originalInit){
    throw new Error("Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.");
  }
  
  const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(Object.create(null),{
    moduleScript: globalThis?.document?.currentScript,
    isWorker: ('undefined' !== typeof WorkerGlobalScope),
    location: globalThis.location,
    urlParams:  globalThis?.location?.href
      ? new URL(globalThis.location.href).searchParams
      : new URLSearchParams()
  });
  initModuleState.debugModule =
    initModuleState.urlParams.has('sqlite3.debugModule')
    ? (...args)=>console.warn('sqlite3.debugModule:',...args)
    : ()=>{};

  if(initModuleState.urlParams.has('sqlite3.dir')){
    initModuleState.sqlite3Dir = initModuleState.urlParams.get('sqlite3.dir') +'/';
  }else if(initModuleState.moduleScript){
    const li = initModuleState.moduleScript.src.split('/');
    li.pop();
    initModuleState.sqlite3Dir = li.join('/') + '/';
  }

  globalThis.sqlite3InitModule = function ff(...args){
    
    return originalInit(...args).then((EmscriptenModule)=>{
      
      const s = EmscriptenModule.sqlite3;
      s.scriptInfo = initModuleState;
      
      if(ff.__isUnderTest) s.__isUnderTest = true;
      const f = s.asyncPostInit;
      delete s.asyncPostInit;
      return f();
    }).catch((e)=>{
      console.error("Exception loading sqlite3 module:",e);
      throw e;
    });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;

  if(globalThis.sqlite3InitModuleState.moduleScript){
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split('/');
    src.pop();
    sim.scriptDir = src.join('/') + '/';
  }
  initModuleState.debugModule('sqlite3InitModuleState =',initModuleState);
  if(false){}



  
  if (true){
    module.exports = sqlite3InitModule;
  }else {}
  
  return globalThis.sqlite3InitModule ;
})();


/***/ }),

/***/ "./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/sqlite3.wasm":
/*!****************************************************************************!*\
  !*** ./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/sqlite3.wasm ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "pages/R 1-02 Bases de Données Relationnelles 1/CM/sqlite3.wasm";

/***/ }),

/***/ "https://raw.githack.com/denis-migdal/LISS/main/index.js":
/*!**************************************************************************!*\
  !*** external "https://raw.githack.com/denis-migdal/LISS/main/index.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_https_raw_githack_com_denis_migdal_LISS_main_index_js_bb6a3cae__;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/async module */
/******/ (() => {
/******/ 	var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 	var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 	var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 	var resolveQueue = (queue) => {
/******/ 		if(queue && queue.d < 1) {
/******/ 			queue.d = 1;
/******/ 			queue.forEach((fn) => (fn.r--));
/******/ 			queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 		}
/******/ 	}
/******/ 	var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 		if(dep !== null && typeof dep === "object") {
/******/ 			if(dep[webpackQueues]) return dep;
/******/ 			if(dep.then) {
/******/ 				var queue = [];
/******/ 				queue.d = 0;
/******/ 				dep.then((r) => {
/******/ 					obj[webpackExports] = r;
/******/ 					resolveQueue(queue);
/******/ 				}, (e) => {
/******/ 					obj[webpackError] = e;
/******/ 					resolveQueue(queue);
/******/ 				});
/******/ 				var obj = {};
/******/ 				obj[webpackQueues] = (fn) => (fn(queue));
/******/ 				return obj;
/******/ 			}
/******/ 		}
/******/ 		var ret = {};
/******/ 		ret[webpackQueues] = x => {};
/******/ 		ret[webpackExports] = dep;
/******/ 		return ret;
/******/ 	}));
/******/ 	__webpack_require__.a = (module, body, hasAwait) => {
/******/ 		var queue;
/******/ 		hasAwait && ((queue = []).d = -1);
/******/ 		var depQueues = new Set();
/******/ 		var exports = module.exports;
/******/ 		var currentDeps;
/******/ 		var outerResolve;
/******/ 		var reject;
/******/ 		var promise = new Promise((resolve, rej) => {
/******/ 			reject = rej;
/******/ 			outerResolve = resolve;
/******/ 		});
/******/ 		promise[webpackExports] = exports;
/******/ 		promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 		module.exports = promise;
/******/ 		body((deps) => {
/******/ 			currentDeps = wrapDeps(deps);
/******/ 			var fn;
/******/ 			var getResult = () => (currentDeps.map((d) => {
/******/ 				if(d[webpackError]) throw d[webpackError];
/******/ 				return d[webpackExports];
/******/ 			}))
/******/ 			var promise = new Promise((resolve) => {
/******/ 				fn = () => (resolve(getResult));
/******/ 				fn.r = 0;
/******/ 				var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 				currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 			});
/******/ 			return fn.r ? promise : getResult();
/******/ 		}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 		queue && queue.d < 0 && (queue.d = 0);
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	__webpack_require__.p = "";
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module used 'module' so it can't be inlined
/******/ __webpack_require__("./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.ts");
/******/ __webpack_require__("./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.css");
/******/ var __webpack_exports__ = __webpack_require__("./src/pages/R 1-02 Bases de Données Relationnelles 1/CM/index.md");
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZXMvUiAxLTAyIEJhc2VzIGRlIERvbm7DqWVzIFJlbGF0aW9ubmVsbGVzIDEvQ00vL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FDQUEsaUVBQWUscUJBQXVCLGlFQUFpRTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0F0RTtBQUNXO0FBQ0Y7QUFDRjtBQUV4Qzs7OztBQUlBLEdBRUEsZ0JBQWdCO0FBQ2hCLE1BQU1BLE9BQVNDLFNBQVNDLGFBQWEsQ0FBQztBQUN0QyxNQUFNQyxTQUFTRixTQUFTQyxhQUFhLENBQUM7QUFFdEMsTUFBTUUsU0FBU0gsU0FBU0ksZ0JBQWdCLENBQWM7QUFTdEQsTUFBTUMsUUFBYztJQUNoQkMsTUFBVVA7SUFDVlEsT0FBVTtJQUNWQyxRQUFVO0lBQ1ZDLFVBQVUsRUFBRTtBQUNoQjtBQUNBLElBQUlDLGVBQWVMO0FBQ25CLEtBQUksSUFBSU0sU0FBU1IsT0FBUTtJQUNyQixNQUFNSSxRQUFRLENBQUNJLE1BQU1DLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDO0lBRW5DLE1BQU9OLFNBQVNHLGFBQWFILEtBQUssQ0FDOUJHLGVBQWVBLGFBQWFGLE1BQU07SUFFdEMsTUFBTU0sT0FBYTtRQUNmUixNQUFNSztRQUNOSjtRQUNBRSxVQUFVLEVBQUU7UUFDWkQsUUFBUUU7SUFDWjtJQUdBQSxhQUFhRCxRQUFRLENBQUNNLElBQUksQ0FBQ0Q7SUFFM0JKLGVBQWVJO0FBQ25CO0FBRUEsU0FBU0UsZ0JBQWdCWCxLQUFXLEVBQUVZLFFBQWdCO0lBRWxELE1BQU1DLFVBQVViLE1BQU1JLFFBQVE7SUFFOUIsSUFBSSxJQUFJVSxJQUFJRCxRQUFRRSxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHLEVBQUVBLEVBQ3RDLElBQUlELE9BQU8sQ0FBQ0MsRUFBRSxDQUFDYixJQUFJLENBQUNlLFNBQVMsSUFBSUosV0FBVyxJQUN4QyxPQUFPRCxnQkFBZ0JFLE9BQU8sQ0FBQ0MsRUFBRSxFQUFFRixhQUFhQyxPQUFPLENBQUNDLEVBQUU7SUFFbEUsT0FBTztBQUNYO0FBRUEsTUFBTUcsTUFBTTtJQUNSLEVBQUU7SUFDRjtRQUFDO1FBQUs7UUFBTTtRQUFPO0tBQUs7SUFDeEI7UUFBQztRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO0tBQUk7SUFDbEM7UUFBQztRQUFLO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO0tBQUk7Q0FDckM7QUFFRCxTQUFTQyxlQUFlQyxDQUFPO0lBRTNCLElBQUlBLEVBQUVqQixLQUFLLElBQUllLElBQUlGLE1BQU0sRUFDckIsT0FBTztJQUVYLE1BQU1LLE1BQU1ELEVBQUVoQixNQUFNLENBQUVDLFFBQVEsQ0FBQ2lCLE9BQU8sQ0FBQ0Y7SUFFdkMsTUFBTUcsTUFBTUwsR0FBRyxDQUFDRSxFQUFFakIsS0FBSyxDQUFDLENBQUNrQixJQUFJO0lBRTdCLE9BQU8sQ0FBQyxFQUFFRSxJQUFJLEVBQUUsQ0FBQztBQUNyQjtBQUVBLFNBQVNDLFVBQVVDLEtBQWE7SUFFNUIsTUFBTUMsT0FBTzlCLFNBQVMrQixhQUFhLENBQUM7SUFDcENELEtBQUtFLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO0lBRW5CSCxLQUFLSSxNQUFNLElBQU1MLE1BQU1NLEdBQUcsQ0FBRSxDQUFDWCxHQUFFQztRQUMzQixNQUFNVyxPQUFPcEMsU0FBUytCLGFBQWEsQ0FBQztRQUNwQ0ssS0FBS0MsV0FBVyxHQUFFLENBQUMsRUFBRWQsZUFBZUMsR0FBRyxFQUFFQSxFQUFFbEIsSUFBSSxDQUFDK0IsV0FBVyxDQUFDLENBQUM7UUFDN0RELEtBQUtFLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFZCxFQUFFbEIsSUFBSSxDQUFDaUMsRUFBRSxDQUFDLENBQUM7UUFDekMsT0FBT0g7SUFDWDtJQUVBLE9BQU9OO0FBQ1g7QUFFQSxTQUFTVTtJQUVMLE1BQU1DLE9BQU96QixnQkFBaUJYLE9BQU9OLEtBQUsyQyxTQUFTO0lBRW5ELElBQUl4QixVQUFVLEVBQUU7SUFDaEIsSUFBSXlCLFNBQVVGO0lBRWQsTUFBTUUsT0FBT3JDLElBQUksS0FBS1AsS0FBTTtRQUN4Qm1CLFFBQVFILElBQUksQ0FBQzRCO1FBQ2JBLFNBQVNBLE9BQU9uQyxNQUFNO0lBQzFCO0lBRUEsTUFBTUYsT0FBT1ksUUFBUTBCLE9BQU8sR0FBR1QsR0FBRyxDQUFFLENBQUNVLE9BQU0xQjtRQUV2QyxNQUFNMkIsSUFBSUQsTUFBTXZDLElBQUk7UUFDcEIsTUFBTXlDLFNBQVMvQyxTQUFTK0IsYUFBYSxDQUFDO1FBRXRDLE1BQU1pQixPQUFPaEQsU0FBUytCLGFBQWEsQ0FBQztRQUNwQ2lCLEtBQUtYLFdBQVcsR0FBRyxDQUFDLEVBQUVkLGVBQWVzQixPQUFPLEVBQUVDLEVBQUVULFdBQVcsQ0FBQyxDQUFDO1FBQzdEVyxLQUFLVixZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRVEsRUFBRVAsRUFBRSxDQUFDLENBQUM7UUFFcEMsTUFBTVQsT0FBT0YsVUFBVWlCLE1BQU1yQyxNQUFNLENBQUVDLFFBQVE7UUFDN0NzQyxPQUFPYixNQUFNLENBQUNjLE1BQU1sQjtRQUVwQixPQUFPaUI7SUFDWDtJQUVBLElBQUlOLEtBQUtoQyxRQUFRLENBQUNXLE1BQU0sS0FBSyxHQUFHO1FBQzVCLE1BQU02QixRQUFRakQsU0FBUytCLGFBQWEsQ0FBQztRQUVyQ2tCLE1BQU1mLE1BQU0sQ0FBRU4sVUFBVWEsS0FBS2hDLFFBQVE7UUFFckNILEtBQUtTLElBQUksQ0FBQ2tDO0lBQ2Q7SUFFQS9DLE9BQU9nRCxlQUFlLElBQUk1QztBQUM5QjtBQUVBUCxLQUFLb0QsZ0JBQWdCLENBQUMsVUFBVVg7QUFDaENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJQSxjQUFjO0FBQ2U7QUFDN0JZLG1CQUFPQSxDQUFDLCtJQUFtRTtBQUMzRSxpREFBaUQ7QUFFUjtBQUN6QyxNQUFNQyxVQUFVLENBQUMsTUFBTTdCLCtDQUFDQSxFQUFDLEVBQUc2QixPQUFPLENBQUNDLEdBQUc7QUFXdkMsU0FBU0MsT0FBT0MsS0FBeUI7SUFDckMsSUFBR0EsVUFBVSxNQUNULE9BQU87SUFDWCxJQUFJLE9BQU9BLFVBQVUsVUFDakIsT0FBTyxDQUFDLEVBQUVBLE1BQU0sQ0FBQztJQUNyQixJQUFJLE9BQU9BLFVBQVUsVUFDakIsT0FBTyxDQUFDLENBQUMsRUFBRUEsTUFBTSxDQUFDLENBQUM7SUFDdkIsTUFBTSxJQUFJQyxNQUFNO0FBQ3BCO0FBRUEsdUJBQXVCO0FBQ3ZCLE1BQU1DO0lBRU8sS0FBSyxDQUFVO0lBQ2YsR0FBRyxDQUFRO0lBRXBCQyxZQUFZQyxJQUFZLEVBQUVDLElBQWEsQ0FBRTtRQUVyQyxJQUFJLENBQUMsS0FBSyxHQUFHQTtRQUViLHFCQUFxQjtRQUNyQixJQUFJLENBQUMsR0FBRyxHQUFHLElBQUlSLFFBQVFLLEVBQUUsQ0FBQ0UsTUFBSztRQUMvQixJQUFJLENBQUMsR0FBRyxDQUFDRSxJQUFJLENBQUM7UUFFZCxJQUFJLENBQUNDLFNBQVM7SUFDbEI7SUFFQSxVQUFVLENBQUNILElBQVk7UUFDbkIsSUFBSSxDQUFDLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDLENBQUMscUJBQXFCLEVBQUVGLEtBQUssQ0FBQztJQUNoRDtJQUNBLFlBQVksQ0FBQ0EsSUFBWTtRQUVyQixNQUFNQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUNELEtBQUs7UUFFN0IsTUFBTUksT0FBT0MsT0FBT0MsT0FBTyxDQUFDTCxLQUFLTSxNQUFNLEVBQUVoQyxHQUFHLENBQUUsQ0FBQyxDQUFDeUIsTUFBTVEsS0FBSyxHQUFLLENBQUMsRUFBRVIsS0FBSyxDQUFDLEVBQUVRLEtBQUssQ0FBQyxFQUFFQyxJQUFJLENBQUM7UUFDeEYsSUFBSUMsY0FBYztRQUNsQixJQUFJLGlCQUFpQlQsTUFDakJTLGNBQWMsQ0FBQyxFQUFFLEVBQUVULEtBQUtTLFdBQVcsQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUNSLElBQUksQ0FBQyxDQUFDLDJCQUEyQixFQUFFRixLQUFLLENBQUMsRUFBRUksS0FBSyxFQUFFTSxZQUFZLFNBQVMsQ0FBQztRQUVqRixjQUFjO1FBQ2QsTUFBTUMsU0FBU1YsS0FBS0ssT0FBTyxDQUFDL0IsR0FBRyxDQUFFcUMsQ0FBQUEsSUFBSyxDQUFDLENBQUMsRUFBR0EsRUFBRXJDLEdBQUcsQ0FBQ3NDLENBQUFBLElBQUtsQixPQUFPa0IsSUFBSUosSUFBSSxDQUFDLE1BQU8sQ0FBQyxDQUFDLEVBQUVBLElBQUksQ0FBQztRQUN0RixJQUFJLENBQUMsR0FBRyxDQUFDUCxJQUFJLENBQUMsQ0FBQyxZQUFZLEVBQUVGLEtBQUssUUFBUSxFQUFFVyxPQUFPLENBQUMsQ0FBQztJQUN6RDtJQUVBRyxXQUFXZCxJQUFZLEVBQUU7UUFDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQ0E7UUFDaEIsSUFBSSxDQUFDLFlBQVksQ0FBQ0E7SUFDdEI7SUFFQSxjQUFjLEdBQUcsSUFBSWUsTUFBYztJQUNuQyxjQUFjLEdBQUcsSUFBSUEsTUFBYztJQUVuQ0MsUUFBUTtRQUVKLEtBQUssSUFBSWhCLFFBQVE7ZUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDVyxNQUFNO1NBQUcsQ0FBQzNCLE9BQU8sR0FDdEQsSUFBSSxDQUFDLEdBQUcsQ0FBQ2tCLElBQUksQ0FBQyxDQUFDLHFCQUFxQixFQUFFRixLQUFLLENBQUMsQ0FBQztRQUVqRCxJQUFJLElBQUlBLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FDdEIsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDaUIsR0FBRyxDQUFDakIsT0FDeEIsSUFBSSxDQUFDYyxVQUFVLENBQUNkO1FBRXhCLElBQUksQ0FBQyxjQUFjLENBQUNrQixLQUFLO1FBQ3pCLElBQUksQ0FBQyxjQUFjLENBQUNBLEtBQUs7SUFDN0I7SUFFQWYsWUFBWTtRQUNSLEtBQUssSUFBSUgsUUFBUTtlQUFJLElBQUksQ0FBQyxjQUFjLENBQUNXLE1BQU07U0FBRyxDQUFDM0IsT0FBTyxHQUN0RCxJQUFJLENBQUMsR0FBRyxDQUFDa0IsSUFBSSxDQUFDLENBQUMscUJBQXFCLEVBQUVGLEtBQUssQ0FBQztRQUVoRCxNQUFNbUIsUUFBUWQsT0FBT2UsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLO1FBRXBDLHdCQUF3QjtRQUN4QixLQUFJLElBQUlDLFNBQVNGLE1BQU1uQyxPQUFPLEdBQzFCLElBQUksQ0FBQyxVQUFVLENBQUNxQztRQUNwQixLQUFJLElBQUlBLFNBQVNGLE1BQU1uQyxPQUFPLEdBQzFCLElBQUksQ0FBQyxZQUFZLENBQUNxQztRQUV0QixJQUFJLENBQUMsY0FBYyxDQUFDSCxLQUFLO1FBQ3pCLElBQUksQ0FBQyxjQUFjLENBQUNBLEtBQUs7SUFDN0I7SUFFQSxZQUFZLENBQUNMLENBQVM7UUFDbEIsT0FBT0EsTUFBTSxPQUFPQSxNQUFNLE9BQU9BLE1BQU07SUFDM0M7SUFFQSx3QkFBd0IsQ0FBQ1MsR0FBVztRQUVoQyxNQUFNQyxRQUFRO1lBQ1Y7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDSDtRQUVELE1BQU1DLFdBQVdELE1BQU1FLElBQUksQ0FBRUMsQ0FBQUEsSUFBS0osSUFBSUssVUFBVSxDQUFDRDtRQUVqRCxJQUFJRSxZQUFhSixTQUFTaEUsTUFBTTtRQUNoQyxNQUFPLENBQUUsSUFBSSxDQUFDLFlBQVksQ0FBRThELEdBQUcsQ0FBQ00sVUFBVSxFQUN0QyxFQUFFQTtRQUVOLElBQUlDLFVBQVVEO1FBQ2QsTUFBTyxJQUFJLENBQUMsWUFBWSxDQUFFTixHQUFHLENBQUNPLFFBQVEsRUFDbEMsRUFBRUE7UUFFTixNQUFNQyxhQUFhUixJQUFJckUsS0FBSyxDQUFDMkUsV0FBV0M7UUFDeEMsT0FBTztZQUFFTDtZQUFVTTtTQUFXO0lBQ2xDO0lBRUFDLFNBQVNULEdBQVcsRUFBRTtRQUVsQixJQUFJQSxJQUFJSyxVQUFVLENBQUMsWUFDZixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUNLLGFBQWEsQ0FBQ1Y7UUFFbEMsSUFBSSxDQUFDLEdBQUcsQ0FBQ3BCLElBQUksQ0FBQ29CO1FBRWQsTUFBTSxDQUFDZCxNQUFNUixLQUFLLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFDc0I7UUFFbkQsSUFBSXRCLFFBQVEsSUFBSSxDQUFDLEtBQUssRUFDbEIsSUFBSSxDQUFDLGNBQWMsQ0FBQzNCLEdBQUcsQ0FBQzJCO2FBRXhCLElBQUksQ0FBQyxjQUFjLENBQUMzQixHQUFHLENBQUMyQjtRQUU1QixPQUFPO0lBQ1g7SUFFQWlDLFVBQVVYLEdBQWEsRUFBRTtRQUVyQixJQUFJWSxVQUFVLEVBQUU7UUFFaEIsSUFBSSxJQUFJM0UsSUFBSSxHQUFHQSxJQUFJK0QsSUFBSTlELE1BQU0sRUFBRSxFQUFFRCxFQUFHO1lBRWhDLElBQUk7Z0JBRUEyRSxRQUFRL0UsSUFBSSxDQUFFLElBQUksQ0FBQzRFLFFBQVEsQ0FBQ1QsR0FBRyxDQUFDL0QsRUFBRTtZQUV0QyxFQUFFLE9BQU1xRCxHQUFHO2dCQUNQdUIsUUFBUUMsSUFBSSxDQUFDeEI7Z0JBQ2IsTUFBTXlCLFVBQVUsV0FBVyxFQUFhQSxPQUFPLENBQUNDLEtBQUssQ0FBQyxLQUFLckYsS0FBSyxDQUFDLEdBQUd3RCxJQUFJLENBQUM7Z0JBQ3pFeUIsUUFBUS9FLElBQUksQ0FBQ2tGO2dCQUNiO1lBQ0o7UUFDSjtRQUNBLE9BQU9IO0lBQ1g7QUFDSjtBQUVBLE1BQU1LLE1BQU0sSUFBSXpDLEdBQUcsV0FDZjtJQUNJMEMsT0FBTztRQUNIakMsUUFBUztZQUNMa0MsSUFBUTtZQUNSQyxLQUFRO1lBQ1JDLFFBQVE7WUFDUkMsS0FBUTtRQUNaO1FBQ0F0QyxTQUFTO1lBQ0w7Z0JBQUM7Z0JBQU07Z0JBQVU7Z0JBQVU7YUFBRztZQUM5QjtnQkFBQztnQkFBTTtnQkFBVTtnQkFBVzthQUFFO1lBQzlCO2dCQUFDO2dCQUFNO2dCQUFVO2dCQUFVO2FBQUc7U0FDakM7SUFDTDtJQUNBdUMsVUFBVTtRQUNOdEMsUUFBUztZQUNMdUMsTUFBTTtZQUNOQyxLQUFNO1lBQ05DLEdBQU07UUFDVjtRQUNBMUMsU0FBUztZQUNMO2dCQUFDO2dCQUFjO2dCQUFVO2FBQUc7WUFDNUI7Z0JBQUM7Z0JBQWM7Z0JBQVc7YUFBRTtZQUM1QjtnQkFBQztnQkFBYztnQkFBVTthQUFHO1lBQzVCO2dCQUFDO2dCQUFjO2dCQUFVO2FBQUc7WUFDNUI7Z0JBQUM7Z0JBQWM7Z0JBQVU7YUFBRztZQUM1QjtnQkFBQztnQkFBYztnQkFBVTthQUFHO1NBQy9CO0lBQ0w7SUFDQTJDLElBQUk7UUFDQTFDLFFBQVM7WUFDTGtDLElBQUk7WUFDSlEsSUFBSTtRQUNSO1FBQ0EzQyxTQUFTO1lBQ0w7Z0JBQUM7Z0JBQU07YUFBSTtZQUNYO2dCQUFDO2dCQUFNO2FBQUk7WUFDWDtnQkFBQztnQkFBTTthQUFJO1NBQ2Q7SUFDTDtJQUNBNEMsSUFBSTtRQUNBM0MsUUFBUztZQUNMa0MsSUFBSTtZQUNKUyxJQUFJO1FBQ1I7UUFDQXhDLGFBQWE7UUFDYkosU0FBUztZQUNMO2dCQUFDO2dCQUFNO2FBQUk7WUFDWDtnQkFBQztnQkFBTTthQUFJO1lBQ1g7Z0JBQUM7Z0JBQU07YUFBSTtZQUNYO2dCQUFDO2dCQUFNO2FBQUk7U0FDZDtJQUNMO0FBQ0o7QUFFUzs7Ozs7Ozs7Ozs7Ozs7O0FDL042RDs7O0FBRzFFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHlCQUF5QixpR0FBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CO0FBQzlFOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0dBQVc7Ozs7Ozs7Ozs7QUN2RVg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QzBFOztBQUU3Qzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsMEJBQTBCLGlHQUFJO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsTUFBTSxPQUFPLGtCQUFrQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHdDQUFHOztBQUV2Qjs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsa0JBQWtCOztBQUU3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBOztBQUVBOztBQUVBLHVCQUF1QixzQkFBc0I7O0FBRTdDO0FBQ0E7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esb0dBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlOa0I7O0FBRTdCOztBQUUwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUgsNkJBQTZCLGlHQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDs7QUFFQSxpRkFBaUYsdUJBQXVCO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsdUJBQXVCOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFGQUFxRix1QkFBdUI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLCtDQUErQyxpQ0FBaUM7O0FBRWhGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxzQ0FBc0M7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0SEFBNEgsUUFBUSxHQUFHO0FBQ3ZJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLHdDQUFHO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQUc7QUFDZjtBQUNBLFlBQVksd0NBQUc7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtCQUFrQjs7QUFFekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsTUFBTTs7QUFFeEM7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtFQUErRTs7QUFFL0U7O0FBRUE7O0FBRUE7QUFDQSx1REFBdUQsRUFBRTtBQUN6RDtBQUNBLDhEQUE4RCxLQUFLO0FBQ25FO0FBQ0E7O0FBRUEsK0JBQStCLG9CQUFvQjtBQUNuRDs7QUFFQTtBQUNBLHNFQUFzRSxPQUFPO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvR0FBVzs7Ozs7Ozs7Ozs7O0FDcm5CWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUFPRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELCtCQUErQixNQUFLO0FBQ3BDLFFBQVEsQ0FBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR0E7Ozs7Ozs7QUFPQTs7QUFFQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7Ozs7Ozs7O0FBUUE7Ozs7O0FBS0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0EsK0JBQStCLG1EQUFtRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixnQkFBZ0I7QUFDaEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUEsbURBQW1EOzs7QUFHbkQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxtQ0FBbUM7QUFDaEY7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsaVdBQWlXO0FBQ2pXLG1EQUFtRDtBQUNuRCxvREFBb0Q7QUFDcEQsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsbURBQW1ELElBQUk7QUFDdkQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQkFBMEI7QUFDMUI7QUFDQSxPQUFPLGFBQWE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxXQUFXO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QixnSUFBZ0ksOERBQThEO0FBQ3hPO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsdUNBQXVDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyxZQUFZLGlEQUFpRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0EsbUNBQW1DO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0EsbUNBQW1DLDZCQUE2QjtBQUNoRSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTyxvQkFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1EQUFtRCxxQkFBcUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBCQUEwQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8saUNBQWlDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0MsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw2QkFBNkI7QUFDN0IsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQseUNBQXlDLFFBQVE7QUFDakQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQSx1Q0FBdUM7QUFDdkMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDREQUE0RDtBQUM1RCxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsNkRBQTZEO0FBQzdELDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFDLENBQUMsRUFLSjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQixTQUFTO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTs7O0FBR0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVyxhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxLQUFDLENBQUMsRUFnQko7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUssS0FBMEQsQ0FBQyxFQUc3RDs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBQyxHQUFHLENBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RSx1Q0FBdUMsNENBQTRDO0FBQ25GLHVDQUF1Qyw0Q0FBNEM7QUFDbkYsdUNBQXVDLHdDQUF3QztBQUMvRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRix1Q0FBdUMsNENBQTRDO0FBQ25GLHVDQUF1Qyw0Q0FBNEM7QUFDbkYsdUNBQXVDLCtDQUErQztBQUN0Rix1Q0FBdUMsd0NBQXdDO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQzs7OztBQUlEO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTyxXQUFXOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0Msc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFlBQVk7QUFDWjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQix5Q0FBeUM7QUFDbkU7QUFDQSw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0EsNkJBQTZCLHNDQUFzQztBQUNuRTtBQUNBLDJCQUEyQixzQ0FBc0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBK0M7QUFDbkU7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7O0FBTUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBQyxFQUFFLEVBQzJFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEUsQ0FBQyxPQUFPLFFBQVE7QUFDaEIsQ0FBQzs7Ozs7O0FBTUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFDLGlDQUFpQyxDQUFLOztBQUVyRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CLG1CQUFtQjtBQUN0Qyx3REFBd0Q7QUFDeEQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRSxzQkFBc0I7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXLEVBQUUsR0FBRyxJQUFJLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxFQUFFLEdBQUcsRUFBRSxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCLEVBQUUsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLG1CQUFtQjs7QUFFbkIsYUFBYTs7QUFFYjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1CQUFtQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLE1BQU07QUFDckMseUJBQXlCLHlCQUF5QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCLDZCQUE2Qjs7QUFFN0IsbUJBQW1COztBQUVuQixvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCLDJCQUEyQjs7QUFFM0IsdUJBQXVCOztBQUV2QixzQkFBc0I7O0FBRXRCLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sS0FBMEIsQ0FBQyxFQUU3QjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEM7QUFDOUM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsS0FBSyxFQUc4Qzs7OztBQUluRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUMsQ0FBQyxFQU9KOzs7O0FBSUg7QUFDQSxNQUFNLElBQXlEO0FBQy9EO0FBQ0EsR0FBRyxLQUFLLEVBRUw7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMW1aRDs7Ozs7O1NDQUE7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQSxJQUFJO1VBQ0o7VUFDQTtVQUNBLElBQUk7VUFDSjtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQSxDQUFDO1VBQ0Q7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLEVBQUU7VUFDRjtVQUNBLHNHQUFzRztVQUN0RztVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLEdBQUc7VUFDSDtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsR0FBRztVQUNIO1VBQ0EsRUFBRTtVQUNGO1VBQ0E7Ozs7O1VDaEVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQSxpQ0FBaUMsV0FBVztVQUM1QztVQUNBOzs7OztVQ1BBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EseUNBQXlDLHdDQUF3QztVQUNqRjtVQUNBO1VBQ0E7Ozs7O1VDUEE7Ozs7O1VDQUE7VUFDQTtVQUNBO1VBQ0EsdURBQXVELGlCQUFpQjtVQUN4RTtVQUNBLGdEQUFnRCxhQUFhO1VBQzdEOzs7OztVQ05BOzs7OztTRUFBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NvdXJzLy4vc3JjL3BhZ2VzL1IgMS0wMiBCYXNlcyBkZSBEb25uw6llcyBSZWxhdGlvbm5lbGxlcyAxL0NNL2luZGV4LmNzcyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9wYWdlcy9SIDEtMDIgQmFzZXMgZGUgRG9ubsOpZXMgUmVsYXRpb25uZWxsZXMgMS9DTS9pbmRleC5tZCIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9wYWdlcy9SIDEtMDIgQmFzZXMgZGUgRG9ubsOpZXMgUmVsYXRpb25uZWxsZXMgMS9DTS9pbmRleC50cyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3QvU1FMaXRlLnRzIiwid2VicGFjazovL0NvdXJzLy4vc3JjL3N0cnVjdC9hbmltLXBsYXllci5qcyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3QvbWVudS5qcyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3Qvc3FsLWR5bS10YWJsZS5qcyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3Qvc3FsLWludGVyYWN0aXZlLmpzIiwid2VicGFjazovL0NvdXJzLy4vc3JjL3N0cnVjdC9zcWxpdGUvc3FsaXRlMy5qcyIsIndlYnBhY2s6Ly9Db3Vycy9leHRlcm5hbCBtb2R1bGUgXCJodHRwczovL3Jhdy5naXRoYWNrLmNvbS9kZW5pcy1taWdkYWwvTElTUy9tYWluL2luZGV4LmpzXCIiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ydW50aW1lL2FzeW5jIG1vZHVsZSIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwicGFnZXMvUiAxLTAyIEJhc2VzIGRlIERvbm7DqWVzIFJlbGF0aW9ubmVsbGVzIDEvQ00vaW5kZXguaHRtbFwiOyIsImltcG9ydCBcIi4uLy4uLy4uL3N0cnVjdC9tZW51LmpzXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9zdHJ1Y3Qvc3FsLWludGVyYWN0aXZlLmpzXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9zdHJ1Y3Qvc3FsLWR5bS10YWJsZS5qc1wiO1xuaW1wb3J0IFwiLi4vLi4vLi4vc3RydWN0L2FuaW0tcGxheWVyLmpzXCI7XG5cbi8qXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlcHJpbnQnLCAoKSA9PiB7XG4gIC8vLi4uXG59KTtcbiovXG5cbi8vVE9ETzogbGlua3MuLi5cbmNvbnN0IG1haW4gICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtYWluXCIpITtcbmNvbnN0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkZXJcIikhO1xuXG5jb25zdCB0aXRsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxFbGVtZW50PihcImgxLCBoMiwgaDMsIGg0XCIpO1xuXG50eXBlIE5vZGUgPSB7XG4gICAgaHRtbCAgICA6IEhUTUxFbGVtZW50LFxuICAgIGxldmVsICAgOiBudW1iZXIsXG4gICAgcGFyZW50ICA6IG51bGx8Tm9kZSxcbiAgICBjaGlsZHJlbjogTm9kZVtdXG59O1xuXG5jb25zdCBodHJlZTogTm9kZSA9IHtcbiAgICBodG1sICAgIDogbWFpbixcbiAgICBsZXZlbCAgIDogMCxcbiAgICBwYXJlbnQgIDogbnVsbCxcbiAgICBjaGlsZHJlbjogW10sXG59O1xubGV0IGh0cmVlX2N1cnNvciA9IGh0cmVlO1xuZm9yKGxldCB0aXRsZSBvZiB0aXRsZXMpIHtcbiAgICBjb25zdCBsZXZlbCA9ICt0aXRsZS50YWdOYW1lLnNsaWNlKDEpO1xuICAgIFxuICAgIHdoaWxlKCBsZXZlbCA8PSBodHJlZV9jdXJzb3IubGV2ZWwgKVxuICAgICAgICBodHJlZV9jdXJzb3IgPSBodHJlZV9jdXJzb3IucGFyZW50ITtcblxuICAgIGNvbnN0IGVsZW06IE5vZGUgPSB7XG4gICAgICAgIGh0bWw6IHRpdGxlLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBwYXJlbnQ6IGh0cmVlX2N1cnNvclxuICAgIH07XG5cblxuICAgIGh0cmVlX2N1cnNvci5jaGlsZHJlbi5wdXNoKGVsZW0pO1xuXG4gICAgaHRyZWVfY3Vyc29yID0gZWxlbTtcbn1cblxuZnVuY3Rpb24gc2VhcmNoQ3VySGVhZGVyKGh0cmVlOiBOb2RlLCBwb3NpdGlvbjogbnVtYmVyKTogbnVsbCB8IE5vZGUge1xuXG4gICAgY29uc3QgaGVhZGVycyA9IGh0cmVlLmNoaWxkcmVuO1xuXG4gICAgZm9yKGxldCBpID0gaGVhZGVycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSlcbiAgICAgICAgaWYoIGhlYWRlcnNbaV0uaHRtbC5vZmZzZXRUb3AgPD0gcG9zaXRpb24gKyAzMiApXG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoQ3VySGVhZGVyKGhlYWRlcnNbaV0sIHBvc2l0aW9uKSA/PyBoZWFkZXJzW2ldO1xuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGhpZCA9IFtcbiAgICBbXSxcbiAgICBbXCJJXCIsIFwiSUlcIiwgXCJJSUlcIiwgXCJJVlwiXSxcbiAgICBbXCIxXCIsIFwiMlwiLFwiM1wiLFwiNVwiLFwiNlwiLFwiN1wiLFwiOFwiLFwiOVwiXSxcbiAgICBbXCJhXCIsIFwiYlwiLFwiY1wiLFwiZFwiLFwiZVwiLFwiZlwiLFwiZ1wiLFwiaFwiXSxcbl1cblxuZnVuY3Rpb24gZ2V0VGl0bGVQcmVmaXgoczogTm9kZSkge1xuXG4gICAgaWYoIHMubGV2ZWwgPj0gaGlkLmxlbmd0aCApXG4gICAgICAgIHJldHVybiBcIlwiO1xuXG4gICAgY29uc3QgaWR4ID0gcy5wYXJlbnQhLmNoaWxkcmVuLmluZGV4T2Yocyk7XG5cbiAgICBjb25zdCBudW0gPSBoaWRbcy5sZXZlbF1baWR4XTtcblxuICAgIHJldHVybiBgJHtudW19LiBgO1xufVxuXG5mdW5jdGlvbiBidWlsZE1lbnUobm9kZXM6IE5vZGVbXSkge1xuXG4gICAgY29uc3QgbWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbWVudS5jbGFzc0xpc3QuYWRkKFwibWVudVwiKTtcblxuICAgIG1lbnUuYXBwZW5kKCAuLi4gbm9kZXMubWFwKCAocyxpZHgpID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBpdGVtLnRleHRDb250ZW50PSBgJHtnZXRUaXRsZVByZWZpeChzKX0ke3MuaHRtbC50ZXh0Q29udGVudH1gO1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3MuaHRtbC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkgKTtcblxuICAgIHJldHVybiBtZW51O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIZWFkZXIoKSB7XG5cbiAgICBjb25zdCBsYXN0ID0gc2VhcmNoQ3VySGVhZGVyKCBodHJlZSwgbWFpbi5zY3JvbGxUb3ApITtcblxuICAgIGxldCBoZWFkZXJzID0gW107XG4gICAgbGV0IGN1cnNvciAgPSBsYXN0O1xuXG4gICAgd2hpbGUoY3Vyc29yLmh0bWwgIT09IG1haW4pIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGN1cnNvcik7XG4gICAgICAgIGN1cnNvciA9IGN1cnNvci5wYXJlbnQhO1xuICAgIH1cblxuICAgIGNvbnN0IGh0bWwgPSBoZWFkZXJzLnJldmVyc2UoKS5tYXAoIChobm9kZSxpKSA9PiB7XG5cbiAgICAgICAgY29uc3QgaCA9IGhub2RlLmh0bWw7XG4gICAgICAgIGNvbnN0IGhfaHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgbGluay50ZXh0Q29udGVudCA9IGAke2dldFRpdGxlUHJlZml4KGhub2RlKX0ke2gudGV4dENvbnRlbnR9YDtcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBgIyR7aC5pZH1gKTtcblxuICAgICAgICBjb25zdCBtZW51ID0gYnVpbGRNZW51KGhub2RlLnBhcmVudCEuY2hpbGRyZW4pO1xuICAgICAgICBoX2h0bWwuYXBwZW5kKGxpbmssIG1lbnUpO1xuXG4gICAgICAgIHJldHVybiBoX2h0bWw7XG4gICAgfSk7XG5cbiAgICBpZiggbGFzdC5jaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgZW1wdHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgICBlbXB0eS5hcHBlbmQoIGJ1aWxkTWVudShsYXN0LmNoaWxkcmVuKSApO1xuXG4gICAgICAgIGh0bWwucHVzaChlbXB0eSlcbiAgICB9XG4gICAgXG4gICAgaGVhZGVyLnJlcGxhY2VDaGlsZHJlbiguLi5odG1sKTtcbn1cblxubWFpbi5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGVIZWFkZXIpO1xudXBkYXRlSGVhZGVyKCk7IiwiLy9UT0RPOiBiZXR0ZXJcbmltcG9ydCBcIi4vc3FsaXRlL3NxbGl0ZTMuanNcIjtcbnJlcXVpcmUoXCIuLi9wYWdlcy9SIDEtMDIgQmFzZXMgZGUgRG9ubsOpZXMgUmVsYXRpb25uZWxsZXMgMS9DTS9zcWxpdGUzLndhc21cIik7XG4vL3JlcXVpcmUoXCIuLi8uLi8uLi9zdHJ1Y3Qvc3FsaXRlL3NxbGl0ZTMud2FzbVwiKTtcblxuaW1wb3J0ICogYXMgcyBmcm9tIFwiLi9zcWxpdGUvc3FsaXRlMy5qc1wiO1xuY29uc3Qgc3FsaXRlMyA9IChhd2FpdCBzKCkpLnNxbGl0ZTMub28xO1xuXG4vLyBAdHMtaWdub3JlXG4vLyBjb25zdCBzcWxpdGUzID0gKGF3YWl0IHNxbGl0ZTNJbml0TW9kdWxlISgpKS5vbzE7XG50eXBlIFRBQkxFX0RFU0MgPSB7XG4gICAgc2NoZW1hICAgICAgOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGNvbnN0cmFpbnRzPzogc3RyaW5nLFxuICAgIGVudHJpZXMgICAgIDogKG51bGx8c3RyaW5nfG51bWJlcilbXVtdXG59O1xudHlwZSBEQl9ERVNDID0gUmVjb3JkPHN0cmluZywgVEFCTEVfREVTQz47XG5cbmZ1bmN0aW9uIGpzMnNxbCh2YWx1ZTogbnVsbHxzdHJpbmd8bnVtYmVyKSB7XG4gICAgaWYodmFsdWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBcIk5VTExcIjtcbiAgICBpZiggdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgICBpZiggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSdgO1xuICAgIHRocm93IG5ldyBFcnJvcignPz8/Jyk7XG59XG5cbi8vVE9ETyBtZXJnZSBxdWVyaWVzLi4uXG5jbGFzcyBEQiB7XG5cbiAgICByZWFkb25seSAjZGVzYzogREJfREVTQztcbiAgICByZWFkb25seSAjZGIgIDogYW55O1xuXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBkZXNjOiBEQl9ERVNDKSB7XG5cbiAgICAgICAgdGhpcy4jZGVzYyA9IGRlc2M7XG5cbiAgICAgICAgLy8gYWRkIHQgZm9yIHRyYWNpbmcuXG4gICAgICAgIHRoaXMuI2RiID0gbmV3IHNxbGl0ZTMuREIobmFtZSwnYycpOyBcbiAgICAgICAgdGhpcy4jZGIuZXhlYygnUFJBR01BIGZvcmVpZ25fa2V5cz1PTjsnKTtcblxuICAgICAgICB0aGlzLmZ1bGxSZXNldCgpO1xuICAgIH1cblxuICAgICNkcm9wVGFibGUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuI2RiLmV4ZWMoYGRyb3AgdGFibGUgaWYgZXhpc3RzICR7bmFtZX1gKTtcbiAgICB9XG4gICAgI2NyZWF0ZVRhYmxlKG5hbWU6IHN0cmluZykge1xuXG4gICAgICAgIGNvbnN0IGRlc2MgPSB0aGlzLiNkZXNjW25hbWVdO1xuXG4gICAgICAgIGNvbnN0IGNvbHMgPSBPYmplY3QuZW50cmllcyhkZXNjLnNjaGVtYSkubWFwKCAoW25hbWUsIHR5cGVdKSA9PiBgJHtuYW1lfSAke3R5cGV9YCkuam9pbihcIiwgXCIpO1xuICAgICAgICBsZXQgY29uc3RyYWludHMgPSBcIlwiO1xuICAgICAgICBpZiggXCJjb25zdHJhaW50c1wiIGluIGRlc2MpXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGAsICR7ZGVzYy5jb25zdHJhaW50c31gOyBcbiAgICAgICAgdGhpcy4jZGIuZXhlYyhgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHtuYW1lfSgke2NvbHN9JHtjb25zdHJhaW50c30pIFNUUklDVDtgKTtcblxuICAgICAgICAvLyBQb3B1bGF0ZS4uLlxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXNjLmVudHJpZXMubWFwKCBlID0+IGAoJHsgZS5tYXAoYyA9PiBqczJzcWwoYykpLmpvaW4oJywgJykgfSlgKS5qb2luKFwiLCBcIik7XG4gICAgICAgIHRoaXMuI2RiLmV4ZWMoYElOU0VSVCBJTlRPICR7bmFtZX0gVkFMVUVTICR7dmFsdWVzfTtgKTtcbiAgICB9XG5cbiAgICByZXNldFRhYmxlKG5hbWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLiNkcm9wVGFibGUobmFtZSk7XG4gICAgICAgIHRoaXMuI2NyZWF0ZVRhYmxlKG5hbWUpO1xuICAgIH1cblxuICAgICNjcmVhdGVkX3RhYmxlID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgI3VwZGF0ZWRfdGFibGUgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIGZvciggbGV0IG5hbWUgb2YgWy4uLnRoaXMuI2NyZWF0ZWRfdGFibGUudmFsdWVzKCldLnJldmVyc2UoKSApXG4gICAgICAgICAgICB0aGlzLiNkYi5leGVjKGBkcm9wIHRhYmxlIGlmIGV4aXN0cyAke25hbWV9O2ApO1xuXG4gICAgICAgIGZvcihsZXQgbmFtZSBpbiB0aGlzLiNkZXNjKVxuICAgICAgICAgICAgaWYoIHRoaXMuI3VwZGF0ZWRfdGFibGUuaGFzKG5hbWUpIClcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VGFibGUobmFtZSk7XG5cbiAgICAgICAgdGhpcy4jY3JlYXRlZF90YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLiN1cGRhdGVkX3RhYmxlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZnVsbFJlc2V0KCkge1xuICAgICAgICBmb3IoIGxldCBuYW1lIG9mIFsuLi50aGlzLiNjcmVhdGVkX3RhYmxlLnZhbHVlcygpXS5yZXZlcnNlKCkgKVxuICAgICAgICAgICAgdGhpcy4jZGIuZXhlYyhgZHJvcCB0YWJsZSBpZiBleGlzdHMgJHtuYW1lfWApO1xuXG4gICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXModGhpcy4jZGVzYyk7XG5cbiAgICAgICAgLy8gcmVxdWlyZWQgZHVlIHRvIEZLLi4uXG4gICAgICAgIGZvcihsZXQgdGFibGUgb2YgbmFtZXMucmV2ZXJzZSgpIClcbiAgICAgICAgICAgIHRoaXMuI2Ryb3BUYWJsZSh0YWJsZSlcbiAgICAgICAgZm9yKGxldCB0YWJsZSBvZiBuYW1lcy5yZXZlcnNlKCkgKVxuICAgICAgICAgICAgdGhpcy4jY3JlYXRlVGFibGUodGFibGUpXG5cbiAgICAgICAgdGhpcy4jY3JlYXRlZF90YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLiN1cGRhdGVkX3RhYmxlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgI2lzVGFibGVOYW1lKGM6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gYyAhPT0gXCIgXCIgJiYgYyAhPT0gXCI7XCIgJiYgYyAhPT0gXCJcXG5cIjtcbiAgICB9XG5cbiAgICAjZXh0cmFjdFRhYmxlTmFtZUZyb21TUUwoc3FsOiBzdHJpbmcpIHtcblxuICAgICAgICBjb25zdCB0eXBlcyA9IFtcbiAgICAgICAgICAgIFwiQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgXCIsXG4gICAgICAgICAgICBcIkNSRUFURSBUQUJMRSBcIixcbiAgICAgICAgICAgIFwiQUxURVIgVEFCTEUgXCIsXG4gICAgICAgICAgICBcIkRST1AgVEFCTEUgXCIsXG4gICAgICAgICAgICBcIlVQREFURSBcIixcbiAgICAgICAgICAgIFwiSU5TRVJUIElOVE8gXCIsXG4gICAgICAgICAgICBcIkRFTEVURSBGUk9NIFwiXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3Qgc3FsX3R5cGUgPSB0eXBlcy5maW5kKCB2ID0+IHNxbC5zdGFydHNXaXRoKHYpICkhO1xuXG4gICAgICAgIGxldCBzdGFydF9wb3MgID0gc3FsX3R5cGUubGVuZ3RoO1xuICAgICAgICB3aGlsZSggISB0aGlzLiNpc1RhYmxlTmFtZSggc3FsW3N0YXJ0X3Bvc10gKSApXG4gICAgICAgICAgICArK3N0YXJ0X3BvcztcblxuICAgICAgICBsZXQgZW5kX3BvcyA9IHN0YXJ0X3BvcztcbiAgICAgICAgd2hpbGUoIHRoaXMuI2lzVGFibGVOYW1lKCBzcWxbZW5kX3Bvc10gKSApXG4gICAgICAgICAgICArK2VuZF9wb3M7XG4gICAgXG4gICAgICAgIGNvbnN0IHRhYmxlX25hbWUgPSBzcWwuc2xpY2Uoc3RhcnRfcG9zLCBlbmRfcG9zICk7XG4gICAgICAgIHJldHVybiBbIHNxbF90eXBlLCB0YWJsZV9uYW1lXTtcbiAgICB9XG5cbiAgICBleGVjX29uZShzcWw6IHN0cmluZykge1xuXG4gICAgICAgIGlmKCBzcWwuc3RhcnRzV2l0aChcIlNFTEVDVCBcIikgKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2RiLnNlbGVjdE9iamVjdHMoc3FsKTtcblxuICAgICAgICB0aGlzLiNkYi5leGVjKHNxbCk7XG5cbiAgICAgICAgY29uc3QgW3R5cGUsIG5hbWVdID0gdGhpcy4jZXh0cmFjdFRhYmxlTmFtZUZyb21TUUwoc3FsKTtcblxuICAgICAgICBpZiggbmFtZSBpbiB0aGlzLiNkZXNjIClcbiAgICAgICAgICAgIHRoaXMuI3VwZGF0ZWRfdGFibGUuYWRkKG5hbWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLiNjcmVhdGVkX3RhYmxlLmFkZChuYW1lKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBleGVjX21hbnkoc3FsOiBzdHJpbmdbXSkge1xuXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHNxbC5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCB0aGlzLmV4ZWNfb25lKHNxbFtpXSkgKTtcblxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIkVycm9yOlwiICsgKGUgYXMgRXJyb3IpLm1lc3NhZ2Uuc3BsaXQoJzonKS5zbGljZSgyKS5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn1cblxuY29uc3QgZGIyID0gbmV3IERCKFwiQkRSMV9DTVwiLFxuICAgIHtcbiAgICAgICAgVXNlcnM6IHtcbiAgICAgICAgICAgIHNjaGVtYSA6IHtcbiAgICAgICAgICAgICAgICBJRCAgICA6IFwiSU5URUdFUiBQUklNQVJZIEtFWSBBVVRPSU5DUkVNRU5UXCIsXG4gICAgICAgICAgICAgICAgTm9tICAgOiBcIlRFWFRcIixcbiAgICAgICAgICAgICAgICBQcmVub206IFwiVEVYVFwiLFxuICAgICAgICAgICAgICAgIEFnZSAgIDogXCJJTlRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICBbbnVsbCwgJ0RvZScsICAgICdKb2huJywgICA0M10sXG4gICAgICAgICAgICAgICAgW251bGwsICdEdXJhbnQnLCAnUGF1bCcsICAgIDldLFxuICAgICAgICAgICAgICAgIFtudWxsLCAnTmVzY2lvJywgJ05vbWVuJywgIDQzXVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBQcm9kdWl0czoge1xuICAgICAgICAgICAgc2NoZW1hIDoge1xuICAgICAgICAgICAgICAgIERhdGU6IFwiVEVYVFwiLFxuICAgICAgICAgICAgICAgIFJlZiA6IFwiVEVYVFwiLFxuICAgICAgICAgICAgICAgIFEgICA6IFwiSU5UXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAgWycyMDIzLTAxLTAxJywgJ0dvbW1lJyAsIDEwXSxcbiAgICAgICAgICAgICAgICBbJzIwMjMtMDItMjMnLCAnR29tbWUnICwgIDldLFxuICAgICAgICAgICAgICAgIFsnMjAyMy0wNi0xMycsICdHb21tZScgLCAyNF0sXG4gICAgICAgICAgICAgICAgWycyMDIzLTAxLTAxJywgJ0NyYXlvbicsIDIwXSxcbiAgICAgICAgICAgICAgICBbJzIwMjMtMDItMjMnLCAnQ3JheW9uJywgMThdLFxuICAgICAgICAgICAgICAgIFsnMjAyMy0wNi0xMycsICdDcmF5b24nLCA1MF1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgVDE6IHtcbiAgICAgICAgICAgIHNjaGVtYSA6IHtcbiAgICAgICAgICAgICAgICBJRDogXCJJTlRFR0VSIFBSSU1BUlkgS0VZIEFVVE9JTkNSRU1FTlRcIixcbiAgICAgICAgICAgICAgICBUMTogXCJURVhUXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAgW251bGwsICcxJ10sXG4gICAgICAgICAgICAgICAgW251bGwsICcyJ10sXG4gICAgICAgICAgICAgICAgW251bGwsICczJ11cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgVDI6IHtcbiAgICAgICAgICAgIHNjaGVtYSA6IHtcbiAgICAgICAgICAgICAgICBJRDogXCJJTlRcIixcbiAgICAgICAgICAgICAgICBUMjogXCJURVhUXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25zdHJhaW50czogXCJGT1JFSUdOIEtFWShJRCkgUkVGRVJFTkNFUyBUMShJRClcIixcbiAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICBbMSwgICAgJzEnXSxcbiAgICAgICAgICAgICAgICBbMywgICAgJzInXSxcbiAgICAgICAgICAgICAgICBbMywgICAgJzMnXSxcbiAgICAgICAgICAgICAgICBbbnVsbCwgJzQnXVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydCB7ZGIyfTsiLCJpbXBvcnQgTElTUyBmcm9tIFwiaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vZGVuaXMtbWlnZGFsL0xJU1MvbWFpbi9pbmRleC5qc1wiXG5cblxuY29uc3QgY29udGVudCA9IGA8c3BhbiBjbGFzcz1cInJlc2V0XCI+W1Jlc2V0XTwvc3Bhbj48c3BhbiBjbGFzcz1cInByZXZcIj5bUHJldl08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbGF5XCI+W1BsYXkvUGF1c2VdPC9zcGFuPjxzcGFuIGNsYXNzPVwibmV4dFwiPltOZXh0XTwvc3Bhbj5gO1xuXG5jb25zdCBjc3MgPSBgXG5gO1xuXG5jb25zdCBzdHlsZXMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKV0ubWFwKHMgPT4ge1xuICAgIGxldCBzdHlsZSA9IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG4gICAgc3R5bGUucmVwbGFjZVN5bmMocy50ZXh0Q29udGVudCk7XG4gICAgcmV0dXJuIHN0eWxlO1xufSk7XG5cbmNsYXNzIEFuaW1QbGF5ZXIgZXh0ZW5kcyBMSVNTKHtcbiAgICBjb250ZW50LFxuICAgIGNzczogW2NzcywgLi4uc3R5bGVzXSxcbiAgICBhdHRyaWJ1dGVzOiBbXCJzcGVlZFwiXVxufSkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RlcElEID0gMDtcblxuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5wcmV2XCIgKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5wcmV2KCkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5uZXh0XCIgKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5uZXh0KCkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5wbGF5XCIgKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5wbGF5KCkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5yZXNldFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5yZXNldCgpKTtcbiAgICB9XG5cbiAgICBuZXh0U3RlcCgpIHtcbiAgICAgICAgKyt0aGlzLnN0ZXBJRDtcbiAgICAgICAgdGhpcy5ob3N0LmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudChcInN0ZXBcIiwge2RldGFpbDogdGhpcy5zdGVwSUR9KSApO1xuICAgIH1cblxuXG4gICAgY2FuY2VsQXV0b1BsYXkoKSB7XG5cbiAgICAgICAgaWYodGhpcy5pZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaWQpO1xuICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJldigpIHtcbiAgICAgICAgY29uc3QgbmV3U3RlcElEID0gdGhpcy5zdGVwSUQgLSAxO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHdoaWxlKHRoaXMuc3RlcElEICE9PSBuZXdTdGVwSUQpXG4gICAgICAgICAgICB0aGlzLm5leHRTdGVwKCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQXV0b1BsYXkoKTtcbiAgICAgICAgdGhpcy5uZXh0U3RlcCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxBdXRvUGxheSgpO1xuICAgICAgICB0aGlzLnN0ZXBJRCA9IDA7XG4gICAgICAgIHRoaXMuaG9zdC5kaXNwYXRjaEV2ZW50KCBuZXcgQ3VzdG9tRXZlbnQoXCJyZXNldFwiKSApO1xuICAgIH1cbiAgICBwbGF5KCkge1xuXG4gICAgICAgIGlmKCB0aGlzLmNhbmNlbEF1dG9QbGF5KCkgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmlkID0gc2V0SW50ZXJ2YWwoICgpID0+IHRoaXMubmV4dFN0ZXAoKSwgKyh0aGlzLmF0dHJzLnNwZWVkID8/IDUwMCkgKTtcbiAgICB9XG59XG5cbkxJU1MuZGVmaW5lKFwiYW5pbS1wbGF5ZXJcIiwgQW5pbVBsYXllcikiLCJjb25zdCBtZW51ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21lbnUnKTtcblxuY29uc3QgaXNNdWx0aUNNID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaDEnKS5sZW5ndGggPiAxO1xuY29uc3QgdGl0bGVzX3NlbGVjdG9yID0gaXNNdWx0aUNNID8gJ2gxLGgyLGgzJyA6ICdoMixoMyc7XG5jb25zdCBIX29mZnNldCA9IGlzTXVsdGlDTSA/IDEgOiAwO1xuXG5jb25zdCB0aXRyZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRpdGxlc19zZWxlY3Rvcik7XG5cbmNvbnN0IGxpc3RzID0gW2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyldO1xuXG5pZiggaXNNdWx0aUNNIClcbiAgICBsaXN0c1swXS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnSScpOyBcblxuZm9yKGxldCB0aXRyZSBvZiB0aXRyZXMpIHtcblxuICAgIGNvbnN0IGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGluay50ZXh0Q29udGVudCA9IHRpdHJlLnRleHRDb250ZW50O1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgYCMke3RpdHJlLmlkfWApO1xuICAgIFxuICAgIGl0ZW0uYXBwZW5kKGxpbmspO1xuXG5cbiAgICBsZXQgbGlzdCA9IG51bGw7XG4gICAgc3dpdGNoKHRpdHJlLnRhZ05hbWUpIHtcbiAgICAgICAgY2FzZSAnSDEnOlxuICAgICAgICAgICAgbGlzdCA9IGxpc3RzWzBdO1xuICAgICAgICAgICAgbGlzdHNbMV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbCcpO1xuICAgICAgICAgICAgbGlzdHNbMV0uc2V0QXR0cmlidXRlKCd0eXBlJywgJzEnKTsgLy8gP1xuICAgICAgICAgICAgaXRlbS5hcHBlbmQobGlzdHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSDInOlxuICAgICAgICAgICAgbGlzdCA9IGxpc3RzW0hfb2Zmc2V0XTtcbiAgICAgICAgICAgIGxpc3RzW0hfb2Zmc2V0KzFdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb2wnKTtcbiAgICAgICAgICAgIGxpc3RzW0hfb2Zmc2V0KzFdLnNldEF0dHJpYnV0ZSgndHlwZScsICdhJyk7XG4gICAgICAgICAgICBpdGVtLmFwcGVuZChsaXN0c1tIX29mZnNldCsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdIMyc6XG4gICAgICAgICAgICBsaXN0ID0gbGlzdHNbSF9vZmZzZXQrMV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxpc3QuYXBwZW5kKGl0ZW0pO1xufVxuXG5cbm1lbnUuYXBwZW5kKGxpc3RzWzBdKTsiLCJpbXBvcnQgTElTUyBmcm9tIFwiaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vZGVuaXMtbWlnZGFsL0xJU1MvbWFpbi9pbmRleC5qc1wiXG5cbmltcG9ydCB7ZGIyfSBmcm9tIFwiLi9TUUxpdGVcIjtcblxuY29uc3QgQ1NTID1cbmA6aG9zdCB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xufVxuXG46aG9zdCB0YWJsZSB7XG4gICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcblxuICAgICYgY2FwdGlvbiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNnB4O1xuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgfVxuICAgIFxuICAgICYgLmhpZ2hsaWdodCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICM4QjgwMDA7XG4gICAgICAgIHByaW50LWNvbG9yLWFkanVzdDogZXhhY3Q7XG4gICAgfVxuXG4gICAgLyogVE9ETzogbWFrZSBzdHlsZSBhZG9wdGFibGUgdGhyb3VnaCBMSVNTLi4uICovXG4gICAgLmhpZ2hfMSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgICB9XG4gICAgLmhpZ2hfMiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIC5oaWdoXzMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbjtcbiAgICB9XG4gICAgLmhpZ2hfbnVsbCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IG9yYW5nZTtcbiAgICB9XG4gICAgLmhpZGUge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAuY3VyIHtcbiAgICAgICAgYm9yZGVyIDogNHB4IHNvbGlkIHllbGxvdztcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgIH1cbiAgICAubG93bGlnaHQge1xuICAgICAgICBvcGFjaXR5OiAwLjI1O1xuICAgIH1cblxuICAgICYgdGQsICYgdGgge1xuICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICB9XG5cbiAgICAmIHRkIHtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMjJweDtcbiAgICB9XG5cbiAgICAmIHRoIHtcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMjZweDtcbiAgICB9XG4gICAgXG4gICAgJiA+IHRib2R5ID4gdHIgKyB0ciA+IHRkIHtcbiAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkO1xuICAgIH1cbn1gO1xuXG5jbGFzcyBTUUxEeW1UYWJsZSBleHRlbmRzIExJU1Moe1xuICAgIGF0dHJpYnV0ZXM6IFtcInRhYmxlXCIsIFwiaGVhZGVyXCIsIFwiY29sc1wiXSxcbiAgICBjc3M6IENTU1xufSkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGxldCBjb2xzID0gdGhpcy5hdHRycy5jb2xzID8/IFwiKlwiO1xuXG4gICAgICAgIHRoaXMuZXhlYyhgU0VMRUNUICR7Y29sc30gRlJPTSAke3RoaXMuYXR0cnMudGFibGV9O2ApXG4gICAgfVxuXG4gICAgZ2V0IG5iUm93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldFJvdyhyb3dpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzW3Jvd2lkXTtcbiAgICB9XG5cbiAgICBleGVjKHF1ZXJ5KSB7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGIyLmV4ZWNfb25lKHF1ZXJ5KTtcblxuICAgICAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG5cbiAgICAgICAgY29uc3QgY2FwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhcHRpb24nKTtcblxuICAgICAgICBpZiggdGhpcy5hdHRycy5oZWFkZXIgPT09IG51bGwpXG4gICAgICAgICAgICBjYXB0aW9uLnRleHRDb250ZW50ID0gYFRhYmxlICR7dGhpcy5hdHRycy50YWJsZX0gOmA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhcHRpb24udGV4dENvbnRlbnQgPSB0aGlzLmF0dHJzLmhlYWRlcjtcblxuICAgICAgICAvL1RPRE86IGNvbGdyb3VwIChmb3IgaGlnaGxpZ2h0KS5cblxuICAgICAgICBjb25zdCBjb2xncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbGdyb3VwJyk7XG4gICAgICAgIGNvbnN0IHRoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGhlYWQnKTtcbiAgICAgICAgY29uc3QgdHJoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuICAgICAgICB0aGlzLmNvbHMgPSB7fTtcblxuICAgICAgICBjb25zdCBjb2xuYW1lcyA9ICBPYmplY3Qua2V5cyh0aGlzLmRhdGFbMF0pO1xuICAgICAgICBmb3IobGV0IGNvbG5hbWUgb2YgY29sbmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbCcpO1xuICAgICAgICAgICAgLy9jb2wuY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICBjb2xncm91cC5hcHBlbmQoY29sKTtcblxuICAgICAgICAgICAgdGhpcy5jb2xzW2NvbG5hbWVdID0gY29sO1xuXG4gICAgICAgICAgICBjb25zdCB0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgICAgICB0aC50ZXh0Q29udGVudCA9IGNvbG5hbWU7XG4gICAgICAgICAgICB0cmhlYWQuYXBwZW5kKHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVhZC5hcHBlbmQodHJoZWFkKTtcblxuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcblxuICAgICAgICBjb25zdCB0Ym9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG4gICAgICAgIGZvcihsZXQgbGluZSBvZiB0aGlzLmRhdGEpIHtcblxuICAgICAgICAgICAgY29uc3QgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgZm9yKGxldCBjb2xuYW1lIG9mIGNvbG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgIHRkLnRleHRDb250ZW50ID0gbGluZVtjb2xuYW1lXSA/PyBcIk4vQVwiO1xuICAgICAgICAgICAgICAgIHRyLmFwcGVuZCh0ZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Ym9keS5hcHBlbmQodHIpO1xuXG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChbbGluZSx0cl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUuYXBwZW5kKGNhcHRpb24sIGNvbGdyb3VwLCB0aGVhZCwgdGJvZHkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucmVwbGFjZUNoaWxkcmVuKHRhYmxlKTtcbiAgICB9XG5cbiAgICBncm91cEJ5KCBncm91cF9jb2xuYW1lICkge1xuXG4gICAgICAgIGNvbnN0IHRib2R5ID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0Ym9keVwiKTtcblxuICAgICAgICBsZXQgZ3JvdXBzID0ge307XG5cbiAgICAgICAgZm9yKGxldCBsaW5lIG9mIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBsaW5lW2dyb3VwX2NvbG5hbWVdO1xuICAgICAgICAgICAgKGdyb3Vwc1tncm91cF0gPz89IFtdKS5wdXNoKCBsaW5lICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcm93cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGdyb3VwbmFtZSBpbiBncm91cHMpIHtcblxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbZ3JvdXBuYW1lXTtcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGdyb3VwW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuICAgICAgICAgICAgICAgIGZvcihsZXQgY29sIGluIGdyb3VwW2ldKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwudGV4dENvbnRlbnQgPSBlbnRyeVtjb2xdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBjb2wgPT09IGdyb3VwX2NvbG5hbWUgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKFwicm93c3BhblwiLCBncm91cC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKGNlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3dzLnB1c2godHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgcm93cy5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0Ym9keS5yZXBsYWNlQ2hpbGRyZW4oLi4ucm93cyk7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0Q29sKCBmaWx0ZXIgKSB7XG4gICAgICAgIGZvcihsZXQgY29sbmFtZSBpbiB0aGlzLmNvbHMpXG4gICAgICAgICAgICB0aGlzLiNoaWdobGlnaHQodGhpcy5jb2xzW2NvbG5hbWVdLCBmaWx0ZXIoY29sbmFtZSkgKTtcbiAgICB9XG5cbiAgICAjaGlnaGxpZ2h0KHRhcmdldCwgaGlnaGxpZ2h0KSB7IC8vIHRhcmdldDogSFRNTEVsZW1lbnQsIGhpZ2hsaWdodDogYm9vbGVhbnxzdHJpbmd8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4gKSB7XG5cbiAgICAgICAgaWYoIHR5cGVvZiBoaWdobGlnaHQgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdoaWdobGlnaHQnLCBoaWdobGlnaHQpO1xuICAgICAgICBpZiggdHlwZW9mIGhpZ2hsaWdodCA9PT0gXCJzdHJpbmdcIiApXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmNsYXNzTGlzdC5hZGQoaGlnaGxpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGZvcihsZXQgbmFtZSBpbiBoaWdobGlnaHQpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZShuYW1lLCBoaWdobGlnaHRbbmFtZV0pO1xuXG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0Um93KCBmaWx0ZXIgKSB7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0aGlzLiNoaWdobGlnaHQoIHRoaXMucm93c1tpXVsxXSwgZmlsdGVyKHRoaXMucm93c1tpXVswXSwgaSkgKTtcbiAgICB9XG5cbiAgICBoaWdobGlnaHRDZWxscyggZmlsdGVyICkge1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3MubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgY29uc3QgW3Jvd19kYXRhLCByb3dfaHRtbF0gPSB0aGlzLnJvd3NbaV07XG4gICAgICAgICAgICBjb25zdCBjb2xzID0gT2JqZWN0LmtleXMocm93X2RhdGEpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgY29scy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICB0aGlzLiNoaWdobGlnaHQoIHJvd19odG1sLmNoaWxkcmVuW2pdICwgZmlsdGVyKHJvd19kYXRhLCBjb2xzW2pdKSApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5MSVNTLmRlZmluZShcInNxbC1keW10YWJsZVwiLCBTUUxEeW1UYWJsZSkiLCJpbXBvcnQge2RiMn0gZnJvbSBcIi4vU1FMaXRlXCI7XG5cbi8vIExJU1NcblxuaW1wb3J0IExJU1MgZnJvbSBcImh0dHBzOi8vcmF3LmdpdGhhY2suY29tL2RlbmlzLW1pZ2RhbC9MSVNTL21haW4vaW5kZXguanNcIlxuXG5jb25zdCBjb250ZW50ID0gYFxuICAgIDxzbG90IG5hbWU9XCJzZWxlY3RcIj48L3Nsb3Q+XG4gICAgPHNsb3QgbmFtZT1cIm9wdGlvbnNcIj48L3Nsb3Q+XG4gICAgPHNsb3Q+PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJwcmVcIj48L3Nsb3Q+XG4gICAgPGRpdiBjbGFzcz1cImNob2ljZXNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm9wdGlvbnNcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInF1ZXJ5XCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT48ZGl2IGNsYXNzPVwicmVzdWx0XCI+PC9kaXY+PC9jb2RlPjwvcHJlPlxuICAgIDxkaXYgY2xhc3M9XCJzcGFjaW5nXCI+PC9kaXY+XG4gICAgPHNsb3QgbmFtZT1cInBvc3RcIj48L3Nsb3Q+YDtcblxuY29uc3QgY3NzID0gYFxuICAgIDpob3N0IHtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMTlweDtcbiAgICB9XG5cbiAgICAuc2VsZWN0ZWQsIC5oaWdobGlnaHQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBnb2xkO1xuICAgIH1cbiAgICA6aG9zdCAuc3BhY2luZyB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICB9XG4gICAgOmhvc3QgLnF1ZXJ5IHByZS5obGpzIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMDtcblxuICAgICAgICAmID4gY29kZSA+IGRpdiB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIDpob3N0IHByZS5obGpzIHtcblxuICAgICAgICBtYXJnaW46IDJweDtcblxuICAgICAgICAmID4gY29kZSA+IGRpdiB7XG4gICAgICAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAub3B0aW9ucyBwcmUge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDI1cHg7XG5cbiAgICAgICAgJi53aXRoZGVzYyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMjBweDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAub3B0aW9ucyBwcmU6OmFmdGVyIHtcbiAgICAgICAgY29udGVudDogXCI+XCI7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgcmlnaHQ6IDBweDtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgd2lkdGg6IDI1cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IG9yYW5nZTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBcbiAgICB9XG4gICAgLm9wdGlvbnMgcHJlOmhvdmVyIHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgIH1cbiAgICA6aG9zdCB7XG4gICAgICAgIC8qZGlzcGxheTogaW5saW5lLWZsZXg7Ki9cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZ2FwOiA1cHg7XG4gICAgfVxuICAgIHNsb3Q6bm90KFtuYW1lPVwicG9zdFwiXSkge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICBzcGFuLnZhbHVlIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XG4gICAgICAgIHBhZGRpbmctbGVmdDogNXB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XG4gICAgfVxuXG4gICAgLm9wdGlvbiB7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG5cbiAgICAuZXJyb3Ige1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZBMDdBICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLnF1ZXJ5ID4gcHJlIC52YWx1ZSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxM3B4O1xuICAgIH1cblxuICAgIC5xdWVyeSA+IHByZSAudmFsdWU6OmFmdGVyIHtcblxuICAgICAgICByaWdodDogLTE4cHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgY29udGVudDogXCLwn5aJXCI7XG4gICAgfVxuXG4gICAgOmhvc3QgPiBwcmUuaGxqcyB7XG4gICAgICAgIC8qZmxleC1ncm93OiAxOyovXG4gICAgfVxuXG4gICAgOmhvc3QgLmRlc2Mge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMTlweDtcblxuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm9yZGVyLWxlZnQ6IG5vbmU7XG4gICAgICAgIGJvcmRlci10b3A6IG5vbmU7XG4gICAgICAgIHBhZGRpbmctbGVmdDogNXB4O1xuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG5cbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodGdyYXk7XG4gICAgICAgIG9wYWNpdHk6IDAuNjtcbiAgICB9XG5cbiAgICBwcmUge1xuICAgICAgICBwYWRkaW5nOiAwLjVlbTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGNvbG9yOiBibGFjaztcbiAgICB9XG5cbiAgICBjb2RlIHtcbiAgICAgICAgZm9udC1mYW1pbHk6IE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcIkRyb2lkIFNhbnMgTW9ub1wiLCBcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZSwgXCJEcm9pZCBTYW5zIEZhbGxiYWNrXCI7XG4gICAgfVxuXG4gICAgLyogVG9tb3Jyb3cgVGhlbWUgKi9cbiAgICAvKiBodHRwOi8vam1ibG9nLmdpdGh1Yi5jb20vY29sb3ItdGhlbWVzLWZvci1nb29nbGUtY29kZS1oaWdobGlnaHRqcyAqL1xuICAgIC8qIE9yaWdpbmFsIHRoZW1lIC0gaHR0cHM6Ly9naXRodWIuY29tL2Nocmlza2VtcHNvbi90b21vcnJvdy10aGVtZSAqL1xuXG4gICAgLyogVG9tb3Jyb3cgQ29tbWVudCAqL1xuICAgIC5obGpzLWNvbW1lbnQsXG4gICAgLmhsanMtcXVvdGUge1xuICAgICAgICBjb2xvcjogIzhlOTA4YztcbiAgICB9XG5cbiAgICAvKiBUb21vcnJvdyBSZWQgKi9cbiAgICAuaGxqcy12YXJpYWJsZSxcbiAgICAuaGxqcy10ZW1wbGF0ZS12YXJpYWJsZSxcbiAgICAuaGxqcy10YWcsXG4gICAgLmhsanMtbmFtZSxcbiAgICAuaGxqcy1zZWxlY3Rvci1pZCxcbiAgICAuaGxqcy1zZWxlY3Rvci1jbGFzcyxcbiAgICAuaGxqcy1yZWdleHAsXG4gICAgLmhsanMtZGVsZXRpb24ge1xuICAgICAgICBjb2xvcjogI2M4MjgyOTtcbiAgICB9XG5cbiAgICAvKiBUb21vcnJvdyBPcmFuZ2UgKi9cbiAgICAuaGxqcy1udW1iZXIsXG4gICAgLmhsanMtYnVpbHRfaW4sXG4gICAgLmhsanMtYnVpbHRpbi1uYW1lLFxuICAgIC5obGpzLWxpdGVyYWwsXG4gICAgLmhsanMtdHlwZSxcbiAgICAuaGxqcy1wYXJhbXMsXG4gICAgLmhsanMtbWV0YSxcbiAgICAuaGxqcy1saW5rIHtcbiAgICAgICAgY29sb3I6ICNmNTg3MWY7XG4gICAgfVxuXG4gICAgLyogVG9tb3Jyb3cgWWVsbG93ICovXG4gICAgLmhsanMtYXR0cmlidXRlIHtcbiAgICAgICAgY29sb3I6ICNlYWI3MDA7XG4gICAgfVxuXG4gICAgLyogVG9tb3Jyb3cgR3JlZW4gKi9cbiAgICAuaGxqcy1zdHJpbmcsXG4gICAgLmhsanMtc3ltYm9sLFxuICAgIC5obGpzLWJ1bGxldCxcbiAgICAuaGxqcy1hZGRpdGlvbiB7XG4gICAgICAgIGNvbG9yOiAjNzE4YzAwO1xuICAgIH1cblxuICAgIC8qIFRvbW9ycm93IEJsdWUgKi9cbiAgICAuaGxqcy10aXRsZSxcbiAgICAuaGxqcy1zZWN0aW9uIHtcbiAgICAgICAgY29sb3I6ICM0MjcxYWU7XG4gICAgfVxuXG4gICAgLyogVG9tb3Jyb3cgUHVycGxlICovXG4gICAgLmhsanMta2V5d29yZCxcbiAgICAuaGxqcy1zZWxlY3Rvci10YWcge1xuICAgICAgICBjb2xvcjogIzg5NTlhODtcbiAgICB9XG5cbiAgICAuaGxqcyB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBvdmVyZmxvdy14OiBhdXRvO1xuICAgICAgICBjb2xvcjogIzRkNGQ0YztcbiAgICAgICAgcGFkZGluZzogMC41ZW07XG4gICAgfVxuXG4gICAgLmhsanMtZW1waGFzaXMge1xuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgfVxuXG4gICAgLmhsanMtc3Ryb25nIHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuYDtcblxuLypcbmNvbnN0IHN0eWxlcyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpXS5tYXAocyA9PiB7XG4gICAgbGV0IHN0eWxlID0gbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICBzdHlsZS5yZXBsYWNlU3luYyhzLnRleHRDb250ZW50KTtcbiAgICByZXR1cm4gc3R5bGU7XG59KTsqL1xuXG5jbGFzcyBTUUxJbnRlcmFjdGl2ZSBleHRlbmRzIExJU1Moe1xuICAgIGNvbnRlbnQsXG4gICAgY3NzOiBbY3NzXSxcbiAgICBhdHRyaWJ1dGVzOiBbXCJmdWxsLXJlc2V0XCJdXG59KSB7XG5cbiAgICAjcmVzdWx0ICAgPSBcIlwiO1xuICAgICNxdWVyeSAgICA9IG51bGw7XG4gICAgI29wdGlvbnMgID0gbnVsbDtcbiAgICAjaW5wdXQgICAgPSBudWxsO1xuICAgICNzZWxlY3RlZCA9IG51bGw7XG5cbiAgICAjc2VsZWN0UXVlcnkgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy4jcmVzdWx0ICAgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5yZXN1bHRcIik7XG4gICAgICAgIHRoaXMuI3F1ZXJ5ICAgID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIucXVlcnlcIik7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3B0aW9uc1wiKTtcbiBcbiAgICAgICAgbGV0IHNlbGVjdFF1ZXJ5ID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJzbG90W25hbWU9J3NlbGVjdCddXCIpLmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgICAgaWYoc2VsZWN0UXVlcnkubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgdGhpcy4jc2VsZWN0UXVlcnkgID0gc2VsZWN0UXVlcnlbMF0udGV4dENvbnRlbnQ7XG5cbiAgICAgICAgdGhpcy4jb3B0aW9ucy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2KSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBvcHRpb24gPSBldi50YXJnZXQuY2xvc2VzdChcIi5vcHRpb25cIik7XG4gICAgICAgICAgICBpZihvcHRpb24gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYodGhpcy4jc2VsZWN0ZWQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy4jc2VsZWN0ZWQuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIG9wdGlvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgdGhpcy4jc2VsZWN0ZWQgPSBvcHRpb247XG5cbiAgICAgICAgICAgIHRoaXMubGFzdFZhcnMgPSB7fTtcblxuICAgICAgICAgICAgY29uc3Qgb3B0c3ZhbHVlcyA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCcudmFsdWUnKTtcbiAgICAgICAgICAgIGZvciggbGV0IG9wdHN2YWx1ZSBvZiBvcHRzdmFsdWVzKSB7IC8vIG5vdCBvcHRpbWFsIGJ1dCBpdCB3b3Jrc1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VmFyc1tvcHRzdmFsdWUuZGF0YXNldC5uYW1lXSA9IG9wdHN2YWx1ZS50ZXh0Q29udGVudDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuI2lucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoYC52YWx1ZVtkYXRhLW5hbWU9XCIke29wdHN2YWx1ZS5kYXRhc2V0Lm5hbWV9XCJdYCk7XG4gICAgICAgICAgICAgICAgZm9yKGxldCB2YWx1ZSBvZiB2YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRleHRDb250ZW50ID0gb3B0c3ZhbHVlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiNleGVjUXVlcnkoICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwic2xvdDpub3QoW25hbWVdKVwiKS5hc3NpZ25lZEVsZW1lbnRzKClbMF07XG4gICAgICAgIC8vVE9ETzogZmluZCAmIHJlcGxhY2UuLi5cblxuICAgICAgICB0aGlzLiNpbnB1dCA9IHF1ZXJ5LmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICB0aGlzLiNxdWVyeS5hcHBlbmQodGhpcy4jaW5wdXQpO1xuXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJzbG90W25hbWU9J29wdGlvbnMnXVwiKS5hc3NpZ25lZEVsZW1lbnRzKCk7XG5cbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IFsuLi50aGlzLiNpbnB1dC5jaGlsZHJlblswXS5jaGlsZE5vZGVzXTtcblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmKCBub2RlLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgbGV0IHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGV4dC5pbmRleE9mKCckJyk7XG4gICAgICAgICAgICBpZiggc3RhcnQgPT09IC0xKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIHdoaWxlKCBzdGFydCAhPT0gLTEpIHsgLy8gbm90IG9wdGltYWwgYnV0IGl0IHdvcmtzLi4uXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IHRleHQuc2xpY2Uoc3RhcnQrMSkuc2VhcmNoKC9bXFxXXS8pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCBlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCB0ZXh0LCBzdGFydCwgdGV4dC5zbGljZShzdGFydCsxKSApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZCBvZiBTUUwgdmFyaWFibGUgbm90IGZvdW5kICh5b3UgbGlrZWx5IHVzZWQgYSByZXNlcnZlZCBrZXl3b3JkKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbmQgKz0gc3RhcnQgKyAxO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5jbGFzc0xpc3QuYWRkKFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgdmFsdWUuZGF0YXNldC5uYW1lID0gdGV4dC5zbGljZShzdGFydCsxLCBlbmQpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi4gdGV4dC5zbGljZSgwLCBzdGFydCksIHZhbHVlICk7XG5cbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShlbmQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGV4dC5pbmRleE9mKCckJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHQpO1xuXG4gICAgICAgICAgICBub2RlLnJlcGxhY2VXaXRoKC4uLnJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3B0aW9uX3RlbXBsYXRlID0gdGhpcy4jaW5wdXQuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuI2lucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZScpO1xuICAgICAgICBmb3IobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuXG4gICAgICAgICAgICB2YWx1ZS50b2dnbGVBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgICAgICAgICAgaWYoICEgdmFsdWUuZGF0YXNldC5uYW1lLnN0YXJ0c1dpdGgoJ21fJykgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZXYpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBpZihldi5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHZhbHVlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGV2KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLiNzZWxlY3RlZCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc2VsZWN0ZWQuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNpbnB1dC5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3NlbGVjdGVkID0gdGhpcy4jaW5wdXQ7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jaW5wdXRzID0gdGhpcy4jaW5wdXQucXVlcnlTZWxlY3RvckFsbChgLnZhbHVlW2RhdGEtbmFtZT1cIiR7ZXYudGFyZ2V0LmRhdGFzZXQubmFtZX1cIl1gKTtcbiAgICAgICAgICAgICAgICBmb3IoIGxldCBpbnB1dCBvZiBzeW5jaW5wdXRzICkge1xuICAgICAgICAgICAgICAgICAgICBpZihpbnB1dCA9PT0gZXYudGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnRleHRDb250ZW50ID0gZXYudGFyZ2V0LnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuI2V4ZWNRdWVyeSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IG9wdGlvbl90ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBvcHQuY2xhc3NMaXN0LmFkZChcIm9wdGlvblwiKTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gb3B0LnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZScpO1xuICAgICAgICAgICAgZm9yKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lICA9IHZhbHVlLmRhdGFzZXQubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50ZXh0Q29udGVudCA9IG9wdGlvbi5kYXRhc2V0WyBuYW1lIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBvcHRpb24udGV4dENvbnRlbnQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBvcHQuY2xhc3NMaXN0LmFkZCgnd2l0aGRlc2MnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkZXNjLmNsYXNzTGlzdC5hZGQoXCJkZXNjXCIpO1xuICAgICAgICAgICAgICAgIGRlc2MudGV4dENvbnRlbnQgPSBvcHRpb24udGV4dENvbnRlbnQudHJpbSgpICsgXCIgOlwiO1xuXG4gICAgICAgICAgICAgICAgb3B0LmFwcGVuZChkZXNjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4jb3B0aW9ucy5hcHBlbmQoIG9wdCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHRoaXMuI3NlbGVjdFF1ZXJ5ID09PSBudWxsKVxuICAgICAgICAgICAgdGhpcy4jb3B0aW9ucy5maXJzdEVsZW1lbnRDaGlsZC5jbGljaygpO1xuICAgIH1cblxuICAgICNnZXRRdWVyeSgpIHtcblxuICAgICAgICBsZXQgcXVlcnkgPSBcIlwiO1xuICAgICAgICBmb3IobGV0IGVsZW0gb2YgdGhpcy4jaW5wdXQuZmlyc3RFbGVtZW50Q2hpbGQuY2hpbGROb2RlcyApIHtcblxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBpZihjb250ZW50ID09PSBcIlwiICYmIGVsZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYoIHF1ZXJ5W3F1ZXJ5Lmxlbmd0aC0xXSA9PT0gXCIgXCIgKVxuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LnNsaWNlKDAsLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnkgKz0gZWxlbS50ZXh0Q29udGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9XG5cbiAgICAjZXhlY1F1ZXJ5KCkge1xuXG5cbiAgICAgICAgbGV0IHF1ZXJpZXMgPSB0aGlzLiNnZXRRdWVyeSgpLnNwbGl0KCc7XFxuJykuc2xpY2UoMCwtMSkubWFwKCBxID0+IHEgKyBcIjtcIik7XG5cbiAgICAgICAgLy8gYnVpbGQgcXVlcmllcyB0byBleGVjdXRlLi4uXG5cbiAgICAgICAgY29uc3QgZXhlY19xdWVyaWVzID0gW107XG4gICAgICAgIGxldCBzaG93X3RhYmxlID0gdHJ1ZTtcblxuICAgICAgICBsZXQgc2hvd19xdWVyaWVzID0gbnVsbDtcbiAgICAgICAgaWYoIHRoaXMuI3NlbGVjdFF1ZXJ5ICE9PSBudWxsICkge1xuICAgICAgICAgICAgc2hvd19xdWVyaWVzID0gdGhpcy4jc2VsZWN0UXVlcnkuc3BsaXQoJzsnKS5zbGljZSgwLC0xKS5tYXAoIHEgPT4gcS50cmltKCkgKyBcIjtcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaG93ID0gKCkgPT4ge1xuICAgICAgICAgICAgc2hvd190YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoIHNob3dfcXVlcmllcyA9PT0gbnVsbCApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZXhlY19xdWVyaWVzLnB1c2goLi4uc2hvd19xdWVyaWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBxdWVyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJpZXNbaV07XG5cbiAgICAgICAgICAgIGlmKCBxdWVyeS5zdGFydHNXaXRoKFwiU0VMRUNUIFwiKSApIHtcbiAgICAgICAgICAgICAgICBleGVjX3F1ZXJpZXMucHVzaChxdWVyeSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBxdWVyeS5zdGFydHNXaXRoKFwiQ1JFQVRFIFRBQkxFIFwiKSApIHtcblxuICAgICAgICAgICAgICAgIGxldCBxID0gXCJDUkVBVEUgVEFCTEUgXCI7XG4gICAgICAgICAgICAgICAgaWYoIHF1ZXJ5LnN0YXJ0c1dpdGgoXCJDUkVBVEUgVEFCTEUgSUYgRVhJU1RTIFwiKSApXG4gICAgICAgICAgICAgICAgICAgIHEgPSBcIkNSRUFURSBUQUJMRSBJRiBFWElTVFMgXCI7XG5cbiAgICAgICAgICAgICAgICBleGVjX3F1ZXJpZXMucHVzaChxdWVyeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGJfbmFtZSA9IHF1ZXJ5LnNsaWNlKDEzLCBxdWVyeS5pbmRleE9mKFwiIFwiLCBxLmxlbmd0aCkgKTtcbiAgICAgICAgICAgICAgICBleGVjX3F1ZXJpZXMucHVzaChgU0VMRUNUIG5hbWUsIHR5cGUsIFwibm90bnVsbFwiLCBkZmx0X3ZhbHVlLCBwaywgaGlkZGVuXFxuICAgICAgICBGUk9NIHByYWdtYV90YWJsZV94aW5mbygnJHt0Yl9uYW1lfScpO2ApO1xuICAgICAgICAgICAgICAgIHNob3dfdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHNob3dfdGFibGUgKVxuICAgICAgICAgICAgICAgIHNob3coKTtcblxuICAgICAgICAgICAgZXhlY19xdWVyaWVzLnB1c2gocXVlcnkpO1xuXG4gICAgICAgICAgICBzaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0cyA9IGRiMi5leGVjX21hbnkoZXhlY19xdWVyaWVzKTtcbiAgICAgICAgdGhpcy51cGRhdGVSZXN1bHQoZXhlY19xdWVyaWVzLCByZXN1bHRzKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCB0aGlzLmF0dHJzW1wiZnVsbC1yZXNldFwiXSA9PT0gXCJ0cnVlXCIpXG4gICAgICAgICAgICBkYjIuZnVsbFJlc2V0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRiMi5yZXNldCgpO1xuICAgIH1cblxuXG4gICAgI2hsaW5lKGNvbHNpemVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnKyc7XG4gICAgICAgIGZvcihsZXQgY29sc2l6ZSBvZiBjb2xzaXplcylcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiLnBhZEVuZChjb2xzaXplICsgMiwgXCItXCIpICsgJysnO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgI3BhZFJvdyhyb3csIGNvbHNpemVzKSB7XG4gICAgICAgIHJldHVybiByb3cubWFwKCAoXywgaSkgPT4gcm93W2ldLnBhZEVuZChjb2xzaXplc1tpXSArIDEsIFwiIFwiKSApO1xuICAgIH1cbiAgICAjcmF3bGluZShyb3cpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwifFwiO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcm93Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgcm93W2ldICsgXCJ8XCI7XG5cbiAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgICAjbGluZShyb3csIGNvbHNpemVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcInxcIjtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbHNpemVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgcm93W2ldLnBhZEVuZChjb2xzaXplc1tpXSArIDEsIFwiIFwiKSArIFwifFwiO1xuXG4gICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHVwZGF0ZVJlc3VsdChxdWVyaWVzLCBkYXRhcykge1xuXG4gICAgICAgIHRoaXMuI2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ2Vycm9yJyk7XG4gICAgICAgIHRoaXMuI3Jlc3VsdC5jbGFzc0xpc3QucmVtb3ZlKCdlcnJvcicpO1xuICAgICAgICBsZXQgY29udGVudCA9ICcnO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZV90byA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGNvcnJlY3Qgc2VsZWN0XG4gICAgICAgICAgICBpZiggZGF0YXNbaV0gIT09IG51bGwgJiYgdHlwZW9mIGRhdGFzW2ldICE9PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlX3RvIGxhc3Qgb3IgZmlyc3RcbiAgICAgICAgICAgICAgICBmb3IobGV0IGogPSBkYXRhcy5sZW5ndGggLSAxOyBqID4gaTsgLS1qKVxuICAgICAgICAgICAgICAgICAgICBpZiggcXVlcmllc1tqXSA9PT0gcXVlcmllc1tpXSAmJiBkYXRhc1tqXSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YXNbal0gIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlX3RvID0gZGF0YXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCBjb21wYXJlX3RvID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGk7ICsrailcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBxdWVyaWVzW2pdID09PSBxdWVyaWVzW2ldICYmIGRhdGFzW2pdICE9PSBudWxsICYmIHR5cGVvZiBkYXRhc1tqXSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlX3RvID0gZGF0YXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJpZXNbaV07XG4gICAgICAgICAgICBjb25zdCBkYXRhICA9IGRhdGFzW2ldO1xuXG4gICAgICAgICAgICBjb250ZW50ICs9IGBzcWxpdGU+ICR7cXVlcnl9XFxuYDtcblxuICAgICAgICAgICAgaWYoIGRhdGEgPT09IG51bGwgKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHsgLy8gZXhjZXB0aW9uXG5cbiAgICAgICAgICAgICAgICB0aGlzLiNpbnB1dC5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3Jlc3VsdC5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xuXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBkYXRhLmxlbmd0aCA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGBObyByb3cgcmV0dXJuZWQuXFxuYDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtcbiAgICAgICAgICAgICAgICAuLi4gZGF0YS5tYXAoZW50cnkgPT4gT2JqZWN0LnZhbHVlcyhlbnRyeSkubWFwKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB2YWx1ZSA9PT0gbnVsbCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdOL0EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSdgO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfSkgKSAgIFxuICAgICAgICAgICAgXTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IGNvbHNpemVzID0gbmV3IEFycmF5KGhlYWRlcnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjb2xzaXplcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbHNpemVzW2ldID0gaGVhZGVyc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yKGxldCByb3cgb2YgcmVzdWx0cylcbiAgICAgICAgICAgICAgICAgICAgaWYoIHJvd1tpXS5sZW5ndGggPiBjb2xzaXplc1tpXSApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzaXplc1tpXSA9IHJvd1tpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgICAgICBsZXQgcmVzdWx0X3RleHQgPSB0aGlzLiNobGluZShjb2xzaXplcykgKyBcIlxcblwiO1xuICAgICAgICAgICAgcmVzdWx0X3RleHQgKz0gIHRoaXMuI2xpbmUoaGVhZGVycywgY29sc2l6ZXMpO1xuICAgICAgICAgICAgcmVzdWx0X3RleHQgKz0gIHRoaXMuI2hsaW5lKGNvbHNpemVzKSArIFwiXFxuXCI7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgcmVzdWx0cy5sZW5ndGg7ICsraikge1xuXG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IHJlc3VsdHNbal07XG5cbiAgICAgICAgICAgICAgICBpZiggY29tcGFyZV90byA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRfdGV4dCArPSB0aGlzLiNsaW5lKHJvdywgY29sc2l6ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBoaWdobGlnaHQgY2hhbmdlc1xuXG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IFwiSURcIjtcbiAgICAgICAgICAgICAgICBpZiggISAoa2V5IGluIGRhdGFbal0pIClcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJuYW1lXCI7XG5cbiAgICAgICAgICAgICAgICBsZXQgY21wX2xpbmUgPSBjb21wYXJlX3RvLmZpbmQoIGUgPT4gZVtrZXldID09PSBkYXRhW2pdW2tleV0pOyAvLyBoNGNreVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbXBhcmVfdG8gPT09IGRhdGFzW2ldKTtcblxuICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMuI3BhZFJvdyhyb3csIGNvbHNpemVzKTtcblxuICAgICAgICAgICAgICAgIGlmKCBjbXBfbGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvdy5tYXAoIGMgPT4gYDxzdHJvbmc+PGVtPiR7Y308L2VtPjwvc3Ryb25nPmApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMuI3Jhd2xpbmUocm93KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0X3RleHQgKz0gYDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0XCI+JHtsaW5lfTwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xuYW1lID0gaGVhZGVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiggZGF0YVtqXVtjb2xuYW1lXSAhPT0gY21wX2xpbmVbY29sbmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dbaV0gPSBgPHNwYW4gY2xhc3M9aGlnaGxpZ2h0PjxlbT48c3Ryb25nPiR7cm93W2ldfTwvc3Ryb25nPjwvZW0+PC9zcGFuPmA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9IHRoaXMuI3Jhd2xpbmUocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9ICB0aGlzLiNobGluZShjb2xzaXplcyk7XG4gICAgXG4gICAgICAgICAgICBjb250ZW50ICs9IHJlc3VsdF90ZXh0ICsgJ1xcbic7ICAgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNyZXN1bHQuaW5uZXJIVE1MID0gY29udGVudDtcblxuICAgICAgICB0aGlzLiNsYXN0RGF0YXMgPSBkYXRhcztcblxuICAgICAgICB0aGlzLmhvc3QuZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KFwiY2hhbmdlXCIsIHtkZXRhaWw6IHtcbiAgICAgICAgICAgIGRhdGFzXG4gICAgICAgIH19KSApO1xuICAgIH1cblxuICAgICNsYXN0RGF0YXMgPSBudWxsO1xuXG4gICAgZ2V0IGxhc3REYXRhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xhc3REYXRhcztcbiAgICB9XG59XG5cbkxJU1MuZGVmaW5lKFwic3FsLWludGVyYWN0aXZlXCIsIFNRTEludGVyYWN0aXZlKSIsIi8qXG4qKiBMSUNFTlNFIGZvciB0aGUgc3FsaXRlMyBXZWJBc3NlbWJseS9KYXZhU2NyaXB0IEFQSXMuXG4qKlxuKiogVGhpcyBidW5kbGUgKHR5cGljYWxseSByZWxlYXNlZCBhcyBzcWxpdGUzLmpzIG9yIHNxbGl0ZTMubWpzKVxuKiogaXMgYW4gYW1hbGdhbWF0aW9uIG9mIEphdmFTY3JpcHQgc291cmNlIGNvZGUgZnJvbSB0d28gcHJvamVjdHM6XG4qKlxuKiogMSkgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZzogdGhlIEVtc2NyaXB0ZW4gXCJnbHVlIGNvZGVcIiBpcyBjb3ZlcmVkIGJ5XG4qKiAgICB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlIGFuZCBVbml2ZXJzaXR5IG9mIElsbGlub2lzL05DU0FcbioqICAgIE9wZW4gU291cmNlIExpY2Vuc2UsIGFzIGRlc2NyaWJlZCBhdDpcbioqXG4qKiAgICBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvaW50cm9kdWNpbmdfZW1zY3JpcHRlbi9lbXNjcmlwdGVuX2xpY2Vuc2UuaHRtbFxuKipcbioqIDIpIGh0dHBzOi8vc3FsaXRlLm9yZzogYWxsIGNvZGUgYW5kIGRvY3VtZW50YXRpb24gbGFiZWxlZCBhcyBiZWluZ1xuKiogICAgZnJvbSB0aGlzIHNvdXJjZSBhcmUgcmVsZWFzZWQgdW5kZXIgdGhlIHNhbWUgdGVybXMgYXMgdGhlIHNxbGl0ZTNcbioqICAgIEMgbGlicmFyeTpcbioqXG4qKiAyMDIyLTEwLTE2XG4qKlxuKiogVGhlIGF1dGhvciBkaXNjbGFpbXMgY29weXJpZ2h0IHRvIHRoaXMgc291cmNlIGNvZGUuICBJbiBwbGFjZSBvZiBhXG4qKiBsZWdhbCBub3RpY2UsIGhlcmUgaXMgYSBibGVzc2luZzpcbioqXG4qKiAqICAgTWF5IHlvdSBkbyBnb29kIGFuZCBub3QgZXZpbC5cbioqICogICBNYXkgeW91IGZpbmQgZm9yZ2l2ZW5lc3MgZm9yIHlvdXJzZWxmIGFuZCBmb3JnaXZlIG90aGVycy5cbioqICogICBNYXkgeW91IHNoYXJlIGZyZWVseSwgbmV2ZXIgdGFraW5nIG1vcmUgdGhhbiB5b3UgZ2l2ZS5cbiovXG4vKlxuKiogVGhpcyBjb2RlIHdhcyBidWlsdCBmcm9tIHNxbGl0ZTMgdmVyc2lvbi4uLlxuKipcbioqIFNRTElURV9WRVJTSU9OIFwiMy40NS4yXCJcbioqIFNRTElURV9WRVJTSU9OX05VTUJFUiAzMDQ1MDAyXG4qKiBTUUxJVEVfU09VUkNFX0lEIFwiMjAyNC0wMy0xMiAxMTowNjoyMyBkOGNkNmQ0OWI0NmEzOTViMTM5NTUzODdkMDVlOWUxYTJhNDdlNTRmYjk5ZjNjOWI1OTgzNWJiZWZhZDZhZjc3XCJcbioqXG4qKiBVc2luZyB0aGUgRW1zY3JpcHRlbiBTREsgdmVyc2lvbiAzLjEuMzAuXG4qL1xuXG52YXIgc3FsaXRlM0luaXRNb2R1bGUgPSAoKCkgPT4ge1xuICB2YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xuICBcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKGNvbmZpZykge1xuICB2YXIgc3FsaXRlM0luaXRNb2R1bGUgPSBjb25maWcgfHwge307XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBNb2R1bGUgPSB0eXBlb2Ygc3FsaXRlM0luaXRNb2R1bGUgIT0gJ3VuZGVmaW5lZCcgPyBzcWxpdGUzSW5pdE1vZHVsZSA6IHt9O1xuXG5cbnZhciByZWFkeVByb21pc2VSZXNvbHZlLCByZWFkeVByb21pc2VSZWplY3Q7XG5Nb2R1bGVbJ3JlYWR5J10gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgcmVhZHlQcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbn0pO1xuXG5cblxuXG5cblxuY29uc3Qgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9IGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZVxuICAgICAgfHwgT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICAgICAgZGVidWdNb2R1bGU6ICgpPT57fVxuICAgICAgfSk7XG5kZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlO1xuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZSgnZ2xvYmFsVGhpcy5sb2NhdGlvbiA9JyxnbG9iYWxUaGlzLmxvY2F0aW9uKTtcblxuXG5Nb2R1bGVbJ2xvY2F0ZUZpbGUnXSA9IGZ1bmN0aW9uKHBhdGgsIHByZWZpeCkge1xuICAndXNlIHN0cmljdCc7XG4gIGxldCB0aGVGaWxlO1xuICBjb25zdCB1cCA9IHRoaXMudXJsUGFyYW1zO1xuICBpZih1cC5oYXMocGF0aCkpe1xuICAgIHRoZUZpbGUgPSB1cC5nZXQocGF0aCk7XG4gIH1lbHNlIGlmKHRoaXMuc3FsaXRlM0Rpcil7XG4gICAgdGhlRmlsZSA9IHRoaXMuc3FsaXRlM0RpciArIHBhdGg7XG4gIH1lbHNlIGlmKHRoaXMuc2NyaXB0RGlyKXtcbiAgICB0aGVGaWxlID0gdGhpcy5zY3JpcHREaXIgKyBwYXRoO1xuICB9ZWxzZXtcbiAgICB0aGVGaWxlID0gcHJlZml4ICsgcGF0aDtcbiAgfVxuICBzcWxpdGUzSW5pdE1vZHVsZVN0YXRlLmRlYnVnTW9kdWxlKFxuICAgIFwibG9jYXRlRmlsZShcIixhcmd1bWVudHNbMF0sICcsJywgYXJndW1lbnRzWzFdLFwiKVwiLFxuICAgICdzcWxpdGUzSW5pdE1vZHVsZVN0YXRlLnNjcmlwdERpciA9Jyx0aGlzLnNjcmlwdERpcixcbiAgICAndXAuZW50cmllcygpID0nLEFycmF5LmZyb20odXAuZW50cmllcygpKSxcbiAgICBcInJlc3VsdCA9XCIsIHRoZUZpbGVcbiAgKTtcbiAgcmV0dXJuIHRoZUZpbGU7XG59LmJpbmQoc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSk7XG5cblxuY29uc3QgeE5hbWVPZkluc3RhbnRpYXRlV2FzbSA9IGZhbHNlXG4gICAgICA/ICdpbnN0YW50aWF0ZVdhc20nXG4gICAgICA6ICdlbXNjcmlwdGVuLWJ1Zy0xNzk1MSc7XG5Nb2R1bGVbeE5hbWVPZkluc3RhbnRpYXRlV2FzbV0gPSBmdW5jdGlvbiBjYWxsZWUoaW1wb3J0cyxvblN1Y2Nlc3Mpe1xuICBpbXBvcnRzLmVudi5mb28gPSBmdW5jdGlvbigpe307XG4gIGNvbnN0IHVyaSA9IE1vZHVsZS5sb2NhdGVGaWxlKFxuICAgIGNhbGxlZS51cmksIChcbiAgICAgICgndW5kZWZpbmVkJz09PXR5cGVvZiBzY3JpcHREaXJlY3RvcnkpXG4gICAgICAgID8gXCJcIiA6IHNjcmlwdERpcmVjdG9yeSlcbiAgKTtcbiAgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZShcbiAgICBcImluc3RhbnRpYXRlV2FzbSgpIHVyaSA9XCIsIHVyaVxuICApO1xuICBjb25zdCB3ZmV0Y2ggPSAoKT0+ZmV0Y2godXJpLCB7Y3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbid9KTtcbiAgY29uc3QgbG9hZFdhc20gPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ1xuICAgICAgICA/IGFzeW5jICgpPT57XG4gICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHdmZXRjaCgpLCBpbXBvcnRzKVxuICAgICAgICAgICAgLnRoZW4oKGFyZyk9Pm9uU3VjY2VzcyhhcmcuaW5zdGFuY2UsIGFyZy5tb2R1bGUpKTtcbiAgICAgICAgfVxuICAgICAgICA6IGFzeW5jICgpPT57IFxuICAgICAgICAgIHJldHVybiB3ZmV0Y2goKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICAgIC50aGVuKGJ5dGVzID0+IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKSlcbiAgICAgICAgICAgIC50aGVuKChhcmcpPT5vblN1Y2Nlc3MoYXJnLmluc3RhbmNlLCBhcmcubW9kdWxlKSk7XG4gICAgICAgIH07XG4gIGxvYWRXYXNtKCk7XG4gIHJldHVybiB7fTtcbn07XG5cbk1vZHVsZVt4TmFtZU9mSW5zdGFudGlhdGVXYXNtXS51cmkgPSAnc3FsaXRlMy53YXNtJztcblxuXG5cblxuXG5cblxuXG52YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcblxudmFyIGFyZ3VtZW50c18gPSBbXTtcbnZhciB0aGlzUHJvZ3JhbSA9ICcuL3RoaXMucHJvZ3JhbSc7XG52YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gIHRocm93IHRvVGhyb3c7XG59O1xuXG5cblxuXG5cbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnO1xudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09ICdmdW5jdGlvbic7XG5cblxudmFyIEVOVklST05NRU5UX0lTX05PREUgPSB0eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09ICdzdHJpbmcnO1xudmFyIEVOVklST05NRU5UX0lTX1NIRUxMID0gIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG5cbnZhciBzY3JpcHREaXJlY3RvcnkgPSAnJztcbmZ1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCkge1xuICBpZiAoTW9kdWxlWydsb2NhdGVGaWxlJ10pIHtcbiAgICByZXR1cm4gTW9kdWxlWydsb2NhdGVGaWxlJ10ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiAgfVxuICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcbn1cblxuXG52YXIgcmVhZF8sXG4gICAgcmVhZEFzeW5jLFxuICAgIHJlYWRCaW5hcnksXG4gICAgc2V0V2luZG93VGl0bGU7XG5cblxuXG5cbmlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHsgXG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7IFxuICAgIHNjcmlwdERpcmVjdG9yeSA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICB9XG4gIFxuICBcbiAgaWYgKF9zY3JpcHREaXIpIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBfc2NyaXB0RGlyO1xuICB9XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIGlmIChzY3JpcHREaXJlY3RvcnkuaW5kZXhPZignYmxvYjonKSAhPT0gMCkge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCwgc2NyaXB0RGlyZWN0b3J5LnJlcGxhY2UoL1s/I10uKi8sIFwiXCIpLmxhc3RJbmRleE9mKCcvJykrMSk7XG4gIH0gZWxzZSB7XG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG4gIH1cblxuICBcbiAgXG4gIHtcblxuXG5cbiAgcmVhZF8gPSAodXJsKSA9PiB7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICB9XG5cbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgIHJlYWRCaW5hcnkgPSAodXJsKSA9PiB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgoeGhyLnJlc3BvbnNlKSk7XG4gICAgfTtcbiAgfVxuXG4gIHJlYWRBc3luYyA9ICh1cmwsIG9ubG9hZCwgb25lcnJvcikgPT4ge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8ICh4aHIuc3RhdHVzID09IDAgJiYgeGhyLnJlc3BvbnNlKSkgeyBcbiAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uZXJyb3IoKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgfVxuXG5cbiAgfVxuXG4gIHNldFdpbmRvd1RpdGxlID0gKHRpdGxlKSA9PiBkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xufSBlbHNlXG57XG59XG5cbnZhciBvdXQgPSBNb2R1bGVbJ3ByaW50J10gfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbnZhciBlcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ10gfHwgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG5cblxuT2JqZWN0LmFzc2lnbihNb2R1bGUsIG1vZHVsZU92ZXJyaWRlcyk7XG5cblxubW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcblxuXG5cblxuXG5cbmlmIChNb2R1bGVbJ2FyZ3VtZW50cyddKSBhcmd1bWVudHNfID0gTW9kdWxlWydhcmd1bWVudHMnXTtcblxuaWYgKE1vZHVsZVsndGhpc1Byb2dyYW0nXSkgdGhpc1Byb2dyYW0gPSBNb2R1bGVbJ3RoaXNQcm9ncmFtJ107XG5cbmlmIChNb2R1bGVbJ3F1aXQnXSkgcXVpdF8gPSBNb2R1bGVbJ3F1aXQnXTtcblxuXG5cblxuXG5cbnZhciBTVEFDS19BTElHTiA9IDE2O1xudmFyIFBPSU5URVJfU0laRSA9IDQ7XG5cbmZ1bmN0aW9uIGdldE5hdGl2ZVR5cGVTaXplKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaTEnOiBjYXNlICdpOCc6IGNhc2UgJ3U4JzogcmV0dXJuIDE7XG4gICAgY2FzZSAnaTE2JzogY2FzZSAndTE2JzogcmV0dXJuIDI7XG4gICAgY2FzZSAnaTMyJzogY2FzZSAndTMyJzogcmV0dXJuIDQ7XG4gICAgY2FzZSAnaTY0JzogY2FzZSAndTY0JzogcmV0dXJuIDg7XG4gICAgY2FzZSAnZmxvYXQnOiByZXR1cm4gNDtcbiAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gODtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAodHlwZVt0eXBlLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIFBPSU5URVJfU0laRTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlWzBdID09PSAnaScpIHtcbiAgICAgICAgY29uc3QgYml0cyA9IE51bWJlcih0eXBlLnN1YnN0cigxKSk7XG4gICAgICAgIGFzc2VydChiaXRzICUgOCA9PT0gMCwgJ2dldE5hdGl2ZVR5cGVTaXplIGludmFsaWQgYml0cyAnICsgYml0cyArICcsIHR5cGUgJyArIHR5cGUpO1xuICAgICAgICByZXR1cm4gYml0cyAvIDg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHdhc21CaW5hcnk7XG5pZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHdhc21CaW5hcnkgPSBNb2R1bGVbJ3dhc21CaW5hcnknXTtcbnZhciBub0V4aXRSdW50aW1lID0gTW9kdWxlWydub0V4aXRSdW50aW1lJ10gfHwgdHJ1ZTtcblxuaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPSAnb2JqZWN0Jykge1xuICBhYm9ydCgnbm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCcpO1xufVxuXG5cblxudmFyIHdhc21NZW1vcnk7XG5cblxuXG5cblxuXG5cbnZhciBBQk9SVCA9IGZhbHNlO1xuXG5cblxuXG52YXIgRVhJVFNUQVRVUztcblxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCB0ZXh0KSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgXG4gICAgXG4gICAgXG4gICAgYWJvcnQodGV4dCk7XG4gIH1cbn1cblxuXG5cblxuXG5cblxudmFyIFVURjhEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGY4JykgOiB1bmRlZmluZWQ7XG5cblxuZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcoaGVhcE9yQXJyYXksIGlkeCwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiAgdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkO1xuICB2YXIgZW5kUHRyID0gaWR4O1xuICBcbiAgXG4gIFxuICBcbiAgXG4gIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuXG4gIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gIH1cbiAgdmFyIHN0ciA9ICcnO1xuICBcbiAgXG4gIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICB2YXIgdTAgPSBoZWFwT3JBcnJheVtpZHgrK107XG4gICAgaWYgKCEodTAgJiAweDgwKSkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7IGNvbnRpbnVlOyB9XG4gICAgdmFyIHUxID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgaWYgKCh1MCAmIDB4RTApID09IDB4QzApIHsgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCh1MCAmIDMxKSA8PCA2KSB8IHUxKTsgY29udGludWU7IH1cbiAgICB2YXIgdTIgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICBpZiAoKHUwICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgdTAgPSAoKHUwICYgMTUpIDw8IDEyKSB8ICh1MSA8PCA2KSB8IHUyO1xuICAgIH0gZWxzZSB7XG4gICAgICB1MCA9ICgodTAgJiA3KSA8PCAxOCkgfCAodTEgPDwgMTIpIHwgKHUyIDw8IDYpIHwgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcbiAgICB9XG5cbiAgICBpZiAodTAgPCAweDEwMDAwKSB7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaCA9IHUwIC0gMHgxMDAwMDtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiAgcmV0dXJuIHB0ciA/IFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCwgcHRyLCBtYXhCeXRlc1RvUmVhZCkgOiAnJztcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheShzdHIsIGhlYXAsIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSB7XG4gIFxuICBcbiAgaWYgKCEobWF4Qnl0ZXNUb1dyaXRlID4gMCkpXG4gICAgcmV0dXJuIDA7XG5cbiAgdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xuICB2YXIgZW5kSWR4ID0gb3V0SWR4ICsgbWF4Qnl0ZXNUb1dyaXRlIC0gMTsgXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTsgXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB7XG4gICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgdSA9IDB4MTAwMDAgKyAoKHUgJiAweDNGRikgPDwgMTApIHwgKHUxICYgMHgzRkYpO1xuICAgIH1cbiAgICBpZiAodSA8PSAweDdGKSB7XG4gICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IHU7XG4gICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XG4gICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEMwIHwgKHUgPj4gNik7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHhGRkZGKSB7XG4gICAgICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEUwIHwgKHUgPj4gMTIpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvdXRJZHggKyAzID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4RjAgfCAodSA+PiAxOCk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gMTIpICYgNjMpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgfVxuICB9XG4gIFxuICBoZWFwW291dElkeF0gPSAwO1xuICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XG59XG5cblxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgcmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUFU4LG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbn1cblxuXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XG4gIHZhciBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7IFxuICAgIGlmIChjIDw9IDB4N0YpIHtcbiAgICAgIGxlbisrO1xuICAgIH0gZWxzZSBpZiAoYyA8PSAweDdGRikge1xuICAgICAgbGVuICs9IDI7XG4gICAgfSBlbHNlIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikge1xuICAgICAgbGVuICs9IDQ7ICsraTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuICs9IDM7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW47XG59XG5cblxuXG5cbnZhciBIRUFQLFxuXG4gIEhFQVA4LFxuXG4gIEhFQVBVOCxcblxuICBIRUFQMTYsXG5cbiAgSEVBUFUxNixcblxuICBIRUFQMzIsXG5cbiAgSEVBUFUzMixcblxuICBIRUFQRjMyLFxuXG4gIEhFQVA2NCxcblxuICBIRUFQVTY0LFxuXG4gIEhFQVBGNjQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCkge1xuICB2YXIgYiA9IHdhc21NZW1vcnkuYnVmZmVyO1xuICBNb2R1bGVbJ0hFQVA4J10gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUDE2J10gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQMzInXSA9IEhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUFUxNiddID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQVTMyJ10gPSBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBGMzInXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBGNjQnXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVA2NCddID0gSEVBUDY0ID0gbmV3IEJpZ0ludDY0QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUFU2NCddID0gSEVBUFU2NCA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbn1cblxudmFyIFNUQUNLX1NJWkUgPSA1MjQyODg7XG5cbnZhciBJTklUSUFMX01FTU9SWSA9IE1vZHVsZVsnSU5JVElBTF9NRU1PUlknXSB8fCAxNjc3NzIxNjtcblxuXG5cblxuXG5cblxuICBpZiAoTW9kdWxlWyd3YXNtTWVtb3J5J10pIHtcbiAgICB3YXNtTWVtb3J5ID0gTW9kdWxlWyd3YXNtTWVtb3J5J107XG4gIH0gZWxzZVxuICB7XG4gICAgd2FzbU1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICAgICAgJ2luaXRpYWwnOiBJTklUSUFMX01FTU9SWSAvIDY1NTM2LFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgICdtYXhpbXVtJzogMjE0NzQ4MzY0OCAvIDY1NTM2XG4gICAgfSk7XG4gIH1cblxudXBkYXRlTWVtb3J5Vmlld3MoKTtcblxuXG5cbklOSVRJQUxfTUVNT1JZID0gd2FzbU1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aDtcblxuXG5cblxuXG5cblxudmFyIHdhc21UYWJsZTtcblxuXG5cblxuXG5cblxuXG5cblxudmFyIF9fQVRQUkVSVU5fXyAgPSBbXTsgXG52YXIgX19BVElOSVRfXyAgICA9IFtdOyBcbnZhciBfX0FURVhJVF9fICAgID0gW107IFxudmFyIF9fQVRQT1NUUlVOX18gPSBbXTsgXG5cbnZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24ga2VlcFJ1bnRpbWVBbGl2ZSgpIHtcbiAgcmV0dXJuIG5vRXhpdFJ1bnRpbWU7XG59XG5cbmZ1bmN0aW9uIHByZVJ1bigpIHtcblxuICBpZiAoTW9kdWxlWydwcmVSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZVJ1biddID0gW01vZHVsZVsncHJlUnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkge1xuICAgICAgYWRkT25QcmVSdW4oTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xufVxuXG5mdW5jdGlvbiBpbml0UnVudGltZSgpIHtcbiAgcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTtcblxuICBcbmlmICghTW9kdWxlW1wibm9GU0luaXRcIl0gJiYgIUZTLmluaXQuaW5pdGlhbGl6ZWQpXG4gIEZTLmluaXQoKTtcbkZTLmlnbm9yZVBlcm1pc3Npb25zID0gZmFsc2U7XG5cblRUWS5pbml0KCk7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO1xufVxuXG5mdW5jdGlvbiBwb3N0UnVuKCkge1xuXG4gIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwb3N0UnVuJ10gPSBbTW9kdWxlWydwb3N0UnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25FeGl0KGNiKSB7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xuICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBydW5EZXBlbmRlbmNpZXMgPSAwO1xudmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbnZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsOyBcblxuZnVuY3Rpb24gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShpZCkge1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgcnVuRGVwZW5kZW5jaWVzKys7XG5cbiAgaWYgKE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKSB7XG4gICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgcnVuRGVwZW5kZW5jaWVzLS07XG5cbiAgaWYgKE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKSB7XG4gICAgTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcbiAgfVxuXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPT0gMCkge1xuICAgIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7XG4gICAgICBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChkZXBlbmRlbmNpZXNGdWxmaWxsZWQpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGRlcGVuZGVuY2llc0Z1bGZpbGxlZDtcbiAgICAgIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG4gICAgICBjYWxsYmFjaygpOyBcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBhYm9ydCh3aGF0KSB7XG4gIGlmIChNb2R1bGVbJ29uQWJvcnQnXSkge1xuICAgIE1vZHVsZVsnb25BYm9ydCddKHdoYXQpO1xuICB9XG5cbiAgd2hhdCA9ICdBYm9ydGVkKCcgKyB3aGF0ICsgJyknO1xuICBcbiAgXG4gIGVycih3aGF0KTtcblxuICBBQk9SVCA9IHRydWU7XG4gIEVYSVRTVEFUVVMgPSAxO1xuXG4gIHdoYXQgKz0gJy4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby4nO1xuXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBcbiAgXG4gIFxuICBcbiAgXG4gIHZhciBlID0gbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtcblxuICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gIFxuICBcbiAgXG4gIHRocm93IGU7XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cblxuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XG4gIFxuICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcbn1cblxuXG5mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcbn1cblxuXG52YXIgd2FzbUJpbmFyeUZpbGU7XG4gIHdhc21CaW5hcnlGaWxlID0gJ3NxbGl0ZTMud2FzbSc7XG4gIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICAgIHdhc21CaW5hcnlGaWxlID0gbG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7XG4gIH1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5KGZpbGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSk7XG4gICAgfVxuICAgIGlmIChyZWFkQmluYXJ5KSB7XG4gICAgICByZXR1cm4gcmVhZEJpbmFyeShmaWxlKTtcbiAgICB9XG4gICAgdGhyb3cgXCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwiO1xuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKSB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgaWYgKCF3YXNtQmluYXJ5ICYmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSkge1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZVsnb2snXSkge1xuICAgICAgICAgIHRocm93IFwiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIgKyB3YXNtQmluYXJ5RmlsZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZVsnYXJyYXlCdWZmZXInXSgpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKTsgfSk7XG59XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVXYXNtKCkge1xuICBcbiAgdmFyIGluZm8gPSB7XG4gICAgJ2Vudic6IGFzbUxpYnJhcnlBcmcsXG4gICAgJ3dhc2lfc25hcHNob3RfcHJldmlldzEnOiBhc21MaWJyYXJ5QXJnLFxuICB9O1xuICBcbiAgXG4gIFxuICBcbiAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG5cbiAgICBNb2R1bGVbJ2FzbSddID0gZXhwb3J0cztcblxuICAgIHdhc21UYWJsZSA9IE1vZHVsZVsnYXNtJ11bJ19faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUnXTtcblxuICAgIGFkZE9uSW5pdChNb2R1bGVbJ2FzbSddWydfX3dhc21fY2FsbF9jdG9ycyddKTtcblxuICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICB9XG4gIFxuICBhZGRSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG5cbiAgXG4gIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCkge1xuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcikge1xuICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKCkudGhlbihmdW5jdGlvbihiaW5hcnkpIHtcbiAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGluZm8pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSkudGhlbihyZWNlaXZlciwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICBlcnIoJ2ZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICcgKyByZWFzb24pO1xuXG4gICAgICBhYm9ydChyZWFzb24pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYygpIHtcbiAgICBpZiAoIXdhc21CaW5hcnkgJiZcbiAgICAgICAgdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkgJiZcbiAgICAgICAgdHlwZW9mIGZldGNoID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIHJlc3VsdCA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbmZvKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oXG4gICAgICAgICAgcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQsXG4gICAgICAgICAgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXJyKCd3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJyArIHJlYXNvbik7XG4gICAgICAgICAgICBlcnIoJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIFxuICBcbiAgXG4gIFxuICBpZiAoTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZXhwb3J0cyA9IE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcbiAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyKCdNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZSk7XG4gICAgICAgIFxuICAgICAgICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gICAgfVxuICB9XG5cbiAgXG4gIGluc3RhbnRpYXRlQXN5bmMoKS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICByZXR1cm4ge307IFxufVxuXG5cbnZhciB0ZW1wRG91YmxlO1xudmFyIHRlbXBJNjQ7XG5cblxuXG52YXIgQVNNX0NPTlNUUyA9IHtcbiAgXG59O1xuXG5cblxuXG5cbiAgXG4gIGZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICB0aGlzLm5hbWUgPSAnRXhpdFN0YXR1cyc7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSAnUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgnICsgc3RhdHVzICsgJyknO1xuICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICAgICAgd2hpbGUgKGNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIFxuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO1xuICAgICAgfVxuICAgIH1cblxuICBcbiAgICBcbiAgZnVuY3Rpb24gZ2V0VmFsdWUocHRyLCB0eXBlID0gJ2k4Jykge1xuICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9ICcqJztcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpMSc6IHJldHVybiBIRUFQOFsoKHB0cik+PjApXTtcbiAgICAgICAgY2FzZSAnaTgnOiByZXR1cm4gSEVBUDhbKChwdHIpPj4wKV07XG4gICAgICAgIGNhc2UgJ2kxNic6IHJldHVybiBIRUFQMTZbKChwdHIpPj4xKV07XG4gICAgICAgIGNhc2UgJ2kzMic6IHJldHVybiBIRUFQMzJbKChwdHIpPj4yKV07XG4gICAgICAgIGNhc2UgJ2k2NCc6IHJldHVybiBIRUFQNjRbKChwdHIpPj4zKV07XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzogcmV0dXJuIEhFQVBGMzJbKChwdHIpPj4yKV07XG4gICAgICAgIGNhc2UgJ2RvdWJsZSc6IHJldHVybiBIRUFQRjY0WygocHRyKT4+MyldO1xuICAgICAgICBjYXNlICcqJzogcmV0dXJuIEhFQVBVMzJbKChwdHIpPj4yKV07XG4gICAgICAgIGRlZmF1bHQ6IGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAnICsgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgXG4gICAgXG4gIGZ1bmN0aW9uIHNldFZhbHVlKHB0ciwgdmFsdWUsIHR5cGUgPSAnaTgnKSB7XG4gICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gJyonO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2kxJzogSEVBUDhbKChwdHIpPj4wKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2k4JzogSEVBUDhbKChwdHIpPj4wKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2kxNic6IEhFQVAxNlsoKHB0cik+PjEpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnaTMyJzogSEVBUDMyWygocHRyKT4+MildID0gdmFsdWU7IGJyZWFrO1xuICAgICAgICBjYXNlICdpNjQnOiAodGVtcEk2NCA9IFt2YWx1ZT4+PjAsKHRlbXBEb3VibGU9dmFsdWUsKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKChwdHIpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChwdHIpKyg0KSk+PjIpXSA9IHRlbXBJNjRbMV0pOyBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvYXQnOiBIRUFQRjMyWygocHRyKT4+MildID0gdmFsdWU7IGJyZWFrO1xuICAgICAgICBjYXNlICdkb3VibGUnOiBIRUFQRjY0WygocHRyKT4+MyldID0gdmFsdWU7IGJyZWFrO1xuICAgICAgICBjYXNlICcqJzogSEVBUFUzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDogYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICcgKyB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgdmFyIFBBVEggPSB7aXNBYnM6KHBhdGgpID0+IHBhdGguY2hhckF0KDApID09PSAnLycsc3BsaXRQYXRoOihmaWxlbmFtZSkgPT4ge1xuICAgICAgICB2YXIgc3BsaXRQYXRoUmUgPSAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbiAgICAgICAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xuICAgICAgfSxub3JtYWxpemVBcnJheToocGFydHMsIGFsbG93QWJvdmVSb290KSA9PiB7XG4gICAgICAgIFxuICAgICAgICB2YXIgdXAgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgICAgICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGZvciAoOyB1cDsgdXAtLSkge1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxub3JtYWxpemU6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBQQVRILmlzQWJzKHBhdGgpLFxuICAgICAgICAgICAgdHJhaWxpbmdTbGFzaCA9IHBhdGguc3Vic3RyKC0xKSA9PT0gJy8nO1xuICAgICAgICBcbiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplQXJyYXkocGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgICAgICAgcGF0aCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbiAgICAgIH0sZGlybmFtZToocGF0aCkgPT4ge1xuICAgICAgICB2YXIgcmVzdWx0ID0gUEFUSC5zcGxpdFBhdGgocGF0aCksXG4gICAgICAgICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgICAgICAgZGlyID0gcmVzdWx0WzFdO1xuICAgICAgICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgIFxuICAgICAgICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290ICsgZGlyO1xuICAgICAgfSxiYXNlbmFtZToocGF0aCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgaWYgKHBhdGggPT09ICcvJykgcmV0dXJuICcvJztcbiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIHZhciBsYXN0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKSByZXR1cm4gcGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyKGxhc3RTbGFzaCsxKTtcbiAgICAgIH0sam9pbjpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKHBhdGhzLmpvaW4oJy8nKSk7XG4gICAgICB9LGpvaW4yOihsLCByKSA9PiB7XG4gICAgICAgIHJldHVybiBQQVRILm5vcm1hbGl6ZShsICsgJy8nICsgcik7XG4gICAgICB9fTtcbiAgXG4gIGZ1bmN0aW9uIGdldFJhbmRvbURldmljZSgpIHtcbiAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09ICdvYmplY3QnICYmIHR5cGVvZiBjcnlwdG9bJ2dldFJhbmRvbVZhbHVlcyddID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciByYW5kb21CdWZmZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHsgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CdWZmZXIpOyByZXR1cm4gcmFuZG9tQnVmZmVyWzBdOyB9O1xuICAgICAgfSBlbHNlXG4gICAgICBcbiAgICAgIHJldHVybiAoKSA9PiBhYm9ydChcInJhbmRvbURldmljZVwiKTtcbiAgICB9XG4gIFxuICBcbiAgXG4gIHZhciBQQVRIX0ZTID0ge3Jlc29sdmU6ZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IEZTLmN3ZCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7IFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBQQVRILmlzQWJzKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcmVzb2x2ZWRQYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShyZXNvbHZlZFBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG4gICAgICAgIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbiAgICAgIH0scmVsYXRpdmU6KGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGZyb20gPSBQQVRIX0ZTLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICAgICAgICB0byA9IFBBVEhfRlMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuICAgICAgICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgICAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgICAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG4gICAgICB9fTtcbiAgXG4gIFxuICBcbiAgZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksIGRvbnRBZGROdWxsLCBsZW5ndGgpIHtcbiAgICB2YXIgbGVuID0gbGVuZ3RoID4gMCA/IGxlbmd0aCA6IGxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSsxO1xuICAgIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIG51bUJ5dGVzV3JpdHRlbiA9IHN0cmluZ1RvVVRGOEFycmF5KHN0cmluZ3ksIHU4YXJyYXksIDAsIHU4YXJyYXkubGVuZ3RoKTtcbiAgICBpZiAoZG9udEFkZE51bGwpIHU4YXJyYXkubGVuZ3RoID0gbnVtQnl0ZXNXcml0dGVuO1xuICAgIHJldHVybiB1OGFycmF5O1xuICB9XG4gIHZhciBUVFkgPSB7dHR5czpbXSxpbml0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgfSxzaHV0ZG93bjpmdW5jdGlvbigpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgIH0scmVnaXN0ZXI6ZnVuY3Rpb24oZGV2LCBvcHMpIHtcbiAgICAgICAgVFRZLnR0eXNbZGV2XSA9IHsgaW5wdXQ6IFtdLCBvdXRwdXQ6IFtdLCBvcHM6IG9wcyB9O1xuICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIFRUWS5zdHJlYW1fb3BzKTtcbiAgICAgIH0sc3RyZWFtX29wczp7b3BlbjpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgdHR5ID0gVFRZLnR0eXNbc3RyZWFtLm5vZGUucmRldl07XG4gICAgICAgICAgaWYgKCF0dHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLnR0eSA9IHR0eTtcbiAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTtcbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICBcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mc3luYyhzdHJlYW0udHR5KTtcbiAgICAgICAgfSxmc3luYzpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mc3luYyhzdHJlYW0udHR5KTtcbiAgICAgICAgfSxyZWFkOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zICkge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICBieXRlc1JlYWQrKztcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQraV0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChieXRlc1JlYWQpIHtcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICAgIH0sd3JpdGU6ZnVuY3Rpb24oc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLnB1dF9jaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS50dHkub3BzLnB1dF9jaGFyKHN0cmVhbS50dHksIGJ1ZmZlcltvZmZzZXQraV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH19LGRlZmF1bHRfdHR5X29wczp7Z2V0X2NoYXI6ZnVuY3Rpb24odHR5KSB7XG4gICAgICAgICAgaWYgKCF0dHkuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cucHJvbXB0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHdpbmRvdy5wcm9tcHQoJ0lucHV0OiAnKTsgIFxuICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkbGluZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXN1bHQgPSByZWFkbGluZSgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR0eS5pbnB1dCA9IGludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHR5LmlucHV0LnNoaWZ0KCk7XG4gICAgICAgIH0scHV0X2NoYXI6ZnVuY3Rpb24odHR5LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHtcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7IFxuICAgICAgICAgIH1cbiAgICAgICAgfSxmc3luYzpmdW5jdGlvbih0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9fSxkZWZhdWx0X3R0eTFfb3BzOntwdXRfY2hhcjpmdW5jdGlvbih0dHksIHZhbCkge1xuICAgICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSAxMCkge1xuICAgICAgICAgICAgZXJyKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbCAhPSAwKSB0dHkub3V0cHV0LnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sZnN5bmM6ZnVuY3Rpb24odHR5KSB7XG4gICAgICAgICAgaWYgKHR0eS5vdXRwdXQgJiYgdHR5Lm91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfX19O1xuICBcbiAgXG4gIGZ1bmN0aW9uIHplcm9NZW1vcnkoYWRkcmVzcywgc2l6ZSkge1xuICAgICAgSEVBUFU4LmZpbGwoMCwgYWRkcmVzcywgYWRkcmVzcyArIHNpemUpO1xuICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gYWxpZ25NZW1vcnkoc2l6ZSwgYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHNpemUgLyBhbGlnbm1lbnQpICogYWxpZ25tZW50O1xuICAgIH1cbiAgZnVuY3Rpb24gbW1hcEFsbG9jKHNpemUpIHtcbiAgICAgIHNpemUgPSBhbGlnbk1lbW9yeShzaXplLCA2NTUzNik7XG4gICAgICB2YXIgcHRyID0gX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbig2NTUzNiwgc2l6ZSk7XG4gICAgICBpZiAoIXB0cikgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gemVyb01lbW9yeShwdHIsIHNpemUpO1xuICAgIH1cbiAgdmFyIE1FTUZTID0ge29wc190YWJsZTpudWxsLG1vdW50OmZ1bmN0aW9uKG1vdW50KSB7XG4gICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKG51bGwsICcvJywgMTYzODQgfCA1MTEgLCAwKTtcbiAgICAgIH0sY3JlYXRlTm9kZTpmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikge1xuICAgICAgICBpZiAoRlMuaXNCbGtkZXYobW9kZSkgfHwgRlMuaXNGSUZPKG1vZGUpKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTUVNRlMub3BzX3RhYmxlKSB7XG4gICAgICAgICAgTUVNRlMub3BzX3RhYmxlID0ge1xuICAgICAgICAgICAgZGlyOiB7XG4gICAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBNRU1GUy5ub2RlX29wcy5sb29rdXAsXG4gICAgICAgICAgICAgICAgbWtub2Q6IE1FTUZTLm5vZGVfb3BzLm1rbm9kLFxuICAgICAgICAgICAgICAgIHJlbmFtZTogTUVNRlMubm9kZV9vcHMucmVuYW1lLFxuICAgICAgICAgICAgICAgIHVubGluazogTUVNRlMubm9kZV9vcHMudW5saW5rLFxuICAgICAgICAgICAgICAgIHJtZGlyOiBNRU1GUy5ub2RlX29wcy5ybWRpcixcbiAgICAgICAgICAgICAgICByZWFkZGlyOiBNRU1GUy5ub2RlX29wcy5yZWFkZGlyLFxuICAgICAgICAgICAgICAgIHN5bWxpbms6IE1FTUZTLm5vZGVfb3BzLnN5bWxpbmtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2Vla1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbToge1xuICAgICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWssXG4gICAgICAgICAgICAgICAgcmVhZDogTUVNRlMuc3RyZWFtX29wcy5yZWFkLFxuICAgICAgICAgICAgICAgIHdyaXRlOiBNRU1GUy5zdHJlYW1fb3BzLndyaXRlLFxuICAgICAgICAgICAgICAgIGFsbG9jYXRlOiBNRU1GUy5zdHJlYW1fb3BzLmFsbG9jYXRlLFxuICAgICAgICAgICAgICAgIG1tYXA6IE1FTUZTLnN0cmVhbV9vcHMubW1hcCxcbiAgICAgICAgICAgICAgICBtc3luYzogTUVNRlMuc3RyZWFtX29wcy5tc3luY1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluazoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgICAgIHJlYWRsaW5rOiBNRU1GUy5ub2RlX29wcy5yZWFkbGlua1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hyZGV2OiB7XG4gICAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiBGUy5jaHJkZXZfc3RyZWFtX29wc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIuc3RyZWFtO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLnN0cmVhbTtcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7IFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsOyBcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUubGluay5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLnN0cmVhbTtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIFxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50LmNvbnRlbnRzW25hbWVdID0gbm9kZTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gbm9kZS50aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGdldEZpbGVEYXRhQXNUeXBlZEFycmF5OmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5KSByZXR1cm4gbm9kZS5jb250ZW50cy5zdWJhcnJheSgwLCBub2RlLnVzZWRCeXRlcyk7IFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobm9kZS5jb250ZW50cyk7XG4gICAgICB9LGV4cGFuZEZpbGVTdG9yYWdlOmZ1bmN0aW9uKG5vZGUsIG5ld0NhcGFjaXR5KSB7XG4gICAgICAgIHZhciBwcmV2Q2FwYWNpdHkgPSBub2RlLmNvbnRlbnRzID8gbm9kZS5jb250ZW50cy5sZW5ndGggOiAwO1xuICAgICAgICBpZiAocHJldkNhcGFjaXR5ID49IG5ld0NhcGFjaXR5KSByZXR1cm47IFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYID0gMTAyNCAqIDEwMjQ7XG4gICAgICAgIG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgobmV3Q2FwYWNpdHksIChwcmV2Q2FwYWNpdHkgKiAocHJldkNhcGFjaXR5IDwgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYID8gMi4wIDogMS4xMjUpKSA+Pj4gMCk7XG4gICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgIT0gMCkgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChuZXdDYXBhY2l0eSwgMjU2KTsgXG4gICAgICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7XG4gICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShuZXdDYXBhY2l0eSk7IFxuICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPiAwKSBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBub2RlLnVzZWRCeXRlcyksIDApOyBcbiAgICAgIH0scmVzaXplRmlsZVN0b3JhZ2U6ZnVuY3Rpb24obm9kZSwgbmV3U2l6ZSkge1xuICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPT0gbmV3U2l6ZSkgcmV0dXJuO1xuICAgICAgICBpZiAobmV3U2l6ZSA9PSAwKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7IFxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShuZXdTaXplKTsgXG4gICAgICAgICAgaWYgKG9sZENvbnRlbnRzKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBNYXRoLm1pbihuZXdTaXplLCBub2RlLnVzZWRCeXRlcykpKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbmV3U2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSxub2RlX29wczp7Z2V0YXR0cjpmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgICBcbiAgICAgICAgICBhdHRyLmRldiA9IEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkgPyBub2RlLmlkIDogMTtcbiAgICAgICAgICBhdHRyLmlubyA9IG5vZGUuaWQ7XG4gICAgICAgICAgYXR0ci5tb2RlID0gbm9kZS5tb2RlO1xuICAgICAgICAgIGF0dHIubmxpbmsgPSAxO1xuICAgICAgICAgIGF0dHIudWlkID0gMDtcbiAgICAgICAgICBhdHRyLmdpZCA9IDA7XG4gICAgICAgICAgYXR0ci5yZGV2ID0gbm9kZS5yZGV2O1xuICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSA0MDk2O1xuICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IG5vZGUudXNlZEJ5dGVzO1xuICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IG5vZGUubGluay5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHIuYXRpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgYXR0ci5tdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBhdHRyLmN0aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIGF0dHIuYmxrc2l6ZSA9IDQwOTY7XG4gICAgICAgICAgYXR0ci5ibG9ja3MgPSBNYXRoLmNlaWwoYXR0ci5zaXplIC8gYXR0ci5ibGtzaXplKTtcbiAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfSxzZXRhdHRyOmZ1bmN0aW9uKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICBpZiAoYXR0ci5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUubW9kZSA9IGF0dHIubW9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHIudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gYXR0ci50aW1lc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTUVNRlMucmVzaXplRmlsZVN0b3JhZ2Uobm9kZSwgYXR0ci5zaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sbG9va3VwOmZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIHRocm93IEZTLmdlbmVyaWNFcnJvcnNbNDRdO1xuICAgICAgICB9LG1rbm9kOmZ1bmN0aW9uKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7XG4gICAgICAgICAgcmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgICB9LHJlbmFtZTpmdW5jdGlvbihvbGRfbm9kZSwgbmV3X2RpciwgbmV3X25hbWUpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdfbm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3X25vZGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBuZXdfbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBkZWxldGUgb2xkX25vZGUucGFyZW50LmNvbnRlbnRzW29sZF9ub2RlLm5hbWVdO1xuICAgICAgICAgIG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgICAgICAgb2xkX25vZGUubmFtZSA9IG5ld19uYW1lO1xuICAgICAgICAgIG5ld19kaXIuY29udGVudHNbbmV3X25hbWVdID0gb2xkX25vZGU7XG4gICAgICAgICAgbmV3X2Rpci50aW1lc3RhbXAgPSBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wO1xuICAgICAgICAgIG9sZF9ub2RlLnBhcmVudCA9IG5ld19kaXI7XG4gICAgICAgIH0sdW5saW5rOmZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0scm1kaXI6ZnVuY3Rpb24ocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0scmVhZGRpcjpmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBbJy4nLCAnLi4nXTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sc3ltbGluazpmdW5jdGlvbihwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuZXduYW1lLCA1MTEgIHwgNDA5NjAsIDApO1xuICAgICAgICAgIG5vZGUubGluayA9IG9sZHBhdGg7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0scmVhZGxpbms6ZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmICghRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUubGluaztcbiAgICAgICAgfX0sc3RyZWFtX29wczp7cmVhZDpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IHN0cmVhbS5ub2RlLnVzZWRCeXRlcykgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihzdHJlYW0ubm9kZS51c2VkQnl0ZXMgLSBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgICBpZiAoc2l6ZSA+IDggJiYgY29udGVudHMuc3ViYXJyYXkpIHsgXG4gICAgICAgICAgICBidWZmZXIuc2V0KGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIHNpemUpLCBvZmZzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH0sd3JpdGU6ZnVuY3Rpb24oc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xuICAgICAgICAgICAgY2FuT3duID0gZmFsc2U7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBpZiAoIWxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzdHJlYW0ubm9kZTtcbiAgICAgICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIFxuICAgICAgICAgIGlmIChidWZmZXIuc3ViYXJyYXkgJiYgKCFub2RlLmNvbnRlbnRzIHx8IG5vZGUuY29udGVudHMuc3ViYXJyYXkpKSB7IFxuICAgICAgICAgICAgaWYgKGNhbk93bikge1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudXNlZEJ5dGVzID09PSAwICYmIHBvc2l0aW9uID09PSAwKSB7IFxuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uICsgbGVuZ3RoIDw9IG5vZGUudXNlZEJ5dGVzKSB7IFxuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBcbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShub2RlLCBwb3NpdGlvbitsZW5ndGgpO1xuICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5ICYmIGJ1ZmZlci5zdWJhcnJheSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICBub2RlLmNvbnRlbnRzW3Bvc2l0aW9uICsgaV0gPSBidWZmZXJbb2Zmc2V0ICsgaV07IFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IE1hdGgubWF4KG5vZGUudXNlZEJ5dGVzLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfSxsbHNlZWs6ZnVuY3Rpb24oc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG9mZnNldDtcbiAgICAgICAgICBpZiAod2hlbmNlID09PSAxKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgICAgfSBlbHNlIGlmICh3aGVuY2UgPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfSxhbGxvY2F0ZTpmdW5jdGlvbihzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uoc3RyZWFtLm5vZGUsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgc3RyZWFtLm5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgoc3RyZWFtLm5vZGUudXNlZEJ5dGVzLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9LG1tYXA6ZnVuY3Rpb24oc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykge1xuICAgICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwdHI7XG4gICAgICAgICAgdmFyIGFsbG9jYXRlZDtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIShmbGFncyAmIDIpICYmIGNvbnRlbnRzLmJ1ZmZlciA9PT0gSEVBUDguYnVmZmVyKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWxsb2NhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBwdHIgPSBjb250ZW50cy5ieXRlT2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IDAgfHwgcG9zaXRpb24gKyBsZW5ndGggPCBjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzLnN1YmFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbG9jYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBwdHIgPSBtbWFwQWxsb2MobGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICghcHRyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhFQVA4LnNldChjb250ZW50cywgcHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgcHRyOiBwdHIsIGFsbG9jYXRlZDogYWxsb2NhdGVkIH07XG4gICAgICAgIH0sbXN5bmM6ZnVuY3Rpb24oc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpIHtcbiAgICAgICAgICBNRU1GUy5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSwgYnVmZmVyLCAwLCBsZW5ndGgsIG9mZnNldCwgZmFsc2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9fX07XG4gIFxuICBcbiAgZnVuY3Rpb24gYXN5bmNMb2FkKHVybCwgb25sb2FkLCBvbmVycm9yLCBub1J1bkRlcCkge1xuICAgICAgdmFyIGRlcCA9ICFub1J1bkRlcCA/IGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koJ2FsICcgKyB1cmwpIDogJyc7XG4gICAgICByZWFkQXN5bmModXJsLCAoYXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgYXNzZXJ0KGFycmF5QnVmZmVyLCAnTG9hZGluZyBkYXRhIGZpbGUgXCInICsgdXJsICsgJ1wiIGZhaWxlZCAobm8gYXJyYXlCdWZmZXIpLicpO1xuICAgICAgICBvbmxvYWQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgaWYgKGRlcCkgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgfSwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChvbmVycm9yKSB7XG4gICAgICAgICAgb25lcnJvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdMb2FkaW5nIGRhdGEgZmlsZSBcIicgKyB1cmwgKyAnXCIgZmFpbGVkLic7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRlcCkgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xuICAgIH1cbiAgXG4gIHZhciBGUyA9IHtyb290Om51bGwsbW91bnRzOltdLGRldmljZXM6e30sc3RyZWFtczpbXSxuZXh0SW5vZGU6MSxuYW1lVGFibGU6bnVsbCxjdXJyZW50UGF0aDpcIi9cIixpbml0aWFsaXplZDpmYWxzZSxpZ25vcmVQZXJtaXNzaW9uczp0cnVlLEVycm5vRXJyb3I6bnVsbCxnZW5lcmljRXJyb3JzOnt9LGZpbGVzeXN0ZW1zOm51bGwsc3luY0ZTUmVxdWVzdHM6MCxsb29rdXBQYXRoOihwYXRoLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShwYXRoKTtcbiAgXG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIHsgcGF0aDogJycsIG5vZGU6IG51bGwgfTtcbiAgXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBmb2xsb3dfbW91bnQ6IHRydWUsXG4gICAgICAgICAgcmVjdXJzZV9jb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBvcHRzID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cylcbiAgXG4gICAgICAgIGlmIChvcHRzLnJlY3Vyc2VfY291bnQgPiA4KSB7ICBcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMik7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIFxuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApO1xuICBcbiAgICAgICAgXG4gICAgICAgIHZhciBjdXJyZW50ID0gRlMucm9vdDtcbiAgICAgICAgdmFyIGN1cnJlbnRfcGF0aCA9ICcvJztcbiAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNsYXN0ID0gKGkgPT09IHBhcnRzLmxlbmd0aC0xKTtcbiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgY3VycmVudCA9IEZTLmxvb2t1cE5vZGUoY3VycmVudCwgcGFydHNbaV0pO1xuICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEguam9pbjIoY3VycmVudF9wYXRoLCBwYXJ0c1tpXSk7XG4gIFxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQoY3VycmVudCkpIHtcbiAgICAgICAgICAgIGlmICghaXNsYXN0IHx8IChpc2xhc3QgJiYgb3B0cy5mb2xsb3dfbW91bnQpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1vdW50ZWQucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaXNsYXN0IHx8IG9wdHMuZm9sbG93KSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5rID0gRlMucmVhZGxpbmsoY3VycmVudF9wYXRoKTtcbiAgICAgICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSF9GUy5yZXNvbHZlKFBBVEguZGlybmFtZShjdXJyZW50X3BhdGgpLCBsaW5rKTtcbiAgXG4gICAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKGN1cnJlbnRfcGF0aCwgeyByZWN1cnNlX2NvdW50OiBvcHRzLnJlY3Vyc2VfY291bnQgKyAxIH0pO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gbG9va3VwLm5vZGU7XG4gIFxuICAgICAgICAgICAgICBpZiAoY291bnQrKyA+IDQwKSB7ICBcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiB7IHBhdGg6IGN1cnJlbnRfcGF0aCwgbm9kZTogY3VycmVudCB9O1xuICAgICAgfSxnZXRQYXRoOihub2RlKSA9PiB7XG4gICAgICAgIHZhciBwYXRoO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBtb3VudCA9IG5vZGUubW91bnQubW91bnRwb2ludDtcbiAgICAgICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG1vdW50O1xuICAgICAgICAgICAgcmV0dXJuIG1vdW50W21vdW50Lmxlbmd0aC0xXSAhPT0gJy8nID8gbW91bnQgKyAnLycgKyBwYXRoIDogbW91bnQgKyBwYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoID0gcGF0aCA/IG5vZGUubmFtZSArICcvJyArIHBhdGggOiBub2RlLm5hbWU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICB9LGhhc2hOYW1lOihwYXJlbnRpZCwgbmFtZSkgPT4ge1xuICAgICAgICB2YXIgaGFzaCA9IDA7XG4gIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWUuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKHBhcmVudGlkICsgaGFzaCkgPj4+IDApICUgRlMubmFtZVRhYmxlLmxlbmd0aDtcbiAgICAgIH0saGFzaEFkZE5vZGU6KG5vZGUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTtcbiAgICAgICAgbm9kZS5uYW1lX25leHQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGU7XG4gICAgICB9LGhhc2hSZW1vdmVOb2RlOihub2RlKSA9PiB7XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChGUy5uYW1lVGFibGVbaGFzaF0gPT09IG5vZGUpIHtcbiAgICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlLm5hbWVfbmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubmFtZV9uZXh0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQubmFtZV9uZXh0ID0gbm9kZS5uYW1lX25leHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmFtZV9uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxsb29rdXBOb2RlOihwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlMb29rdXAocGFyZW50KTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUocGFyZW50LmlkLCBuYW1lKTtcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IEZTLm5hbWVUYWJsZVtoYXNoXTsgbm9kZTsgbm9kZSA9IG5vZGUubmFtZV9uZXh0KSB7XG4gICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICAgIGlmIChub2RlLnBhcmVudC5pZCA9PT0gcGFyZW50LmlkICYmIG5vZGVOYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBGUy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sY3JlYXRlTm9kZToocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSA9PiB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IEZTLkZTTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpO1xuICBcbiAgICAgICAgRlMuaGFzaEFkZE5vZGUobm9kZSk7XG4gIFxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sZGVzdHJveU5vZGU6KG5vZGUpID0+IHtcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUobm9kZSk7XG4gICAgICB9LGlzUm9vdDoobm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gbm9kZS5wYXJlbnQ7XG4gICAgICB9LGlzTW91bnRwb2ludDoobm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gISFub2RlLm1vdW50ZWQ7XG4gICAgICB9LGlzRmlsZToobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDMyNzY4O1xuICAgICAgfSxpc0RpcjoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDE2Mzg0O1xuICAgICAgfSxpc0xpbms6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2MDtcbiAgICAgIH0saXNDaHJkZXY6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA4MTkyO1xuICAgICAgfSxpc0Jsa2RldjoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDI0NTc2O1xuICAgICAgfSxpc0ZJRk86KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2O1xuICAgICAgfSxpc1NvY2tldDoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA0OTE1MikgPT09IDQ5MTUyO1xuICAgICAgfSxmbGFnTW9kZXM6e1wiclwiOjAsXCJyK1wiOjIsXCJ3XCI6NTc3LFwidytcIjo1NzgsXCJhXCI6MTA4OSxcImErXCI6MTA5MH0sbW9kZVN0cmluZ1RvRmxhZ3M6KHN0cikgPT4ge1xuICAgICAgICB2YXIgZmxhZ3MgPSBGUy5mbGFnTW9kZXNbc3RyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJyArIHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfSxmbGFnc1RvUGVybWlzc2lvblN0cmluZzooZmxhZykgPT4ge1xuICAgICAgICB2YXIgcGVybXMgPSBbJ3InLCAndycsICdydyddW2ZsYWcgJiAzXTtcbiAgICAgICAgaWYgKChmbGFnICYgNTEyKSkge1xuICAgICAgICAgIHBlcm1zICs9ICd3JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVybXM7XG4gICAgICB9LG5vZGVQZXJtaXNzaW9uczoobm9kZSwgcGVybXMpID0+IHtcbiAgICAgICAgaWYgKEZTLmlnbm9yZVBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwZXJtcy5pbmNsdWRlcygncicpICYmICEobm9kZS5tb2RlICYgMjkyKSkge1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcm1zLmluY2x1ZGVzKCd3JykgJiYgIShub2RlLm1vZGUgJiAxNDYpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3gnKSAmJiAhKG5vZGUubW9kZSAmIDczKSkge1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxtYXlMb29rdXA6KGRpcikgPT4ge1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSByZXR1cm4gZXJyQ29kZTtcbiAgICAgICAgaWYgKCFkaXIubm9kZV9vcHMubG9va3VwKSByZXR1cm4gMjtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LG1heUNyZWF0ZTooZGlyLCBuYW1lKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICAgICAgfSxtYXlEZWxldGU6KGRpciwgbmFtZSwgaXNkaXIpID0+IHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmVycm5vO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGVyckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzZGlyKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gNTQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChGUy5pc1Jvb3Qobm9kZSkgfHwgRlMuZ2V0UGF0aChub2RlKSA9PT0gRlMuY3dkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LG1heU9wZW46KG5vZGUsIGZsYWdzKSA9PiB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHJldHVybiA0NDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIGlmIChGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykgIT09ICdyJyB8fCBcbiAgICAgICAgICAgICAgKGZsYWdzICYgNTEyKSkgeyBcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpO1xuICAgICAgfSxNQVhfT1BFTl9GRFM6NDA5NixuZXh0ZmQ6KGZkX3N0YXJ0ID0gMCwgZmRfZW5kID0gRlMuTUFYX09QRU5fRkRTKSA9PiB7XG4gICAgICAgIGZvciAodmFyIGZkID0gZmRfc3RhcnQ7IGZkIDw9IGZkX2VuZDsgZmQrKykge1xuICAgICAgICAgIGlmICghRlMuc3RyZWFtc1tmZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzMpO1xuICAgICAgfSxnZXRTdHJlYW06KGZkKSA9PiBGUy5zdHJlYW1zW2ZkXSxjcmVhdGVTdHJlYW06KHN0cmVhbSwgZmRfc3RhcnQsIGZkX2VuZCkgPT4ge1xuICAgICAgICBpZiAoIUZTLkZTU3RyZWFtKSB7XG4gICAgICAgICAgRlMuRlNTdHJlYW0gPSAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZCA9IHsgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEZTLkZTU3RyZWFtLnByb3RvdHlwZSA9IHt9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTLkZTU3RyZWFtLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ub2RlOyB9LFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHsgdGhpcy5ub2RlID0gdmFsOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZWFkOiB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzV3JpdGU6IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAwOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBcHBlbmQ6IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEwMjQpOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNoYXJlZC5mbGFnczsgfSxcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7IHRoaXMuc2hhcmVkLmZsYWdzID0gdmFsOyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uIDoge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2hhcmVkLnBvc2l0aW9uOyB9LFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHsgdGhpcy5zaGFyZWQucG9zaXRpb24gPSB2YWw7IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdHJlYW0gPSBPYmplY3QuYXNzaWduKG5ldyBGUy5GU1N0cmVhbSgpLCBzdHJlYW0pO1xuICAgICAgICB2YXIgZmQgPSBGUy5uZXh0ZmQoZmRfc3RhcnQsIGZkX2VuZCk7XG4gICAgICAgIHN0cmVhbS5mZCA9IGZkO1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IHN0cmVhbTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sY2xvc2VTdHJlYW06KGZkKSA9PiB7XG4gICAgICAgIEZTLnN0cmVhbXNbZmRdID0gbnVsbDtcbiAgICAgIH0sY2hyZGV2X3N0cmVhbV9vcHM6e29wZW46KHN0cmVhbSkgPT4ge1xuICAgICAgICAgIHZhciBkZXZpY2UgPSBGUy5nZXREZXZpY2Uoc3RyZWFtLm5vZGUucmRldik7XG4gICAgICAgICAgXG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMgPSBkZXZpY2Uuc3RyZWFtX29wcztcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xuICAgICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3BlbihzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxsbHNlZWs6KCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfX0sbWFqb3I6KGRldikgPT4gKChkZXYpID4+IDgpLG1pbm9yOihkZXYpID0+ICgoZGV2KSAmIDB4ZmYpLG1ha2VkZXY6KG1hLCBtaSkgPT4gKChtYSkgPDwgOCB8IChtaSkpLHJlZ2lzdGVyRGV2aWNlOihkZXYsIG9wcykgPT4ge1xuICAgICAgICBGUy5kZXZpY2VzW2Rldl0gPSB7IHN0cmVhbV9vcHM6IG9wcyB9O1xuICAgICAgfSxnZXREZXZpY2U6KGRldikgPT4gRlMuZGV2aWNlc1tkZXZdLGdldE1vdW50czoobW91bnQpID0+IHtcbiAgICAgICAgdmFyIG1vdW50cyA9IFtdO1xuICAgICAgICB2YXIgY2hlY2sgPSBbbW91bnRdO1xuICBcbiAgICAgICAgd2hpbGUgKGNoZWNrLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBtID0gY2hlY2sucG9wKCk7XG4gIFxuICAgICAgICAgIG1vdW50cy5wdXNoKG0pO1xuICBcbiAgICAgICAgICBjaGVjay5wdXNoLmFwcGx5KGNoZWNrLCBtLm1vdW50cyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBtb3VudHM7XG4gICAgICB9LHN5bmNmczoocG9wdWxhdGUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9wdWxhdGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrID0gcG9wdWxhdGU7XG4gICAgICAgICAgcG9wdWxhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMrKztcbiAgXG4gICAgICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHtcbiAgICAgICAgICBlcnIoJ3dhcm5pbmc6ICcgKyBGUy5zeW5jRlNSZXF1ZXN0cyArICcgRlMuc3luY2ZzIG9wZXJhdGlvbnMgaW4gZmxpZ2h0IGF0IG9uY2UsIHByb2JhYmx5IGp1c3QgZG9pbmcgZXh0cmEgd29yaycpO1xuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKEZTLnJvb3QubW91bnQpO1xuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgXG4gICAgICAgIGZ1bmN0aW9uIGRvQ2FsbGJhY2soZXJyQ29kZSkge1xuICAgICAgICAgIEZTLnN5bmNGU1JlcXVlc3RzLS07XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyckNvZGUpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyckNvZGUpIHtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgaWYgKCFkb25lLmVycm9yZWQpIHtcbiAgICAgICAgICAgICAgZG9uZS5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvQ2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgrK2NvbXBsZXRlZCA+PSBtb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb0NhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgXG4gICAgICAgIFxuICAgICAgICBtb3VudHMuZm9yRWFjaCgobW91bnQpID0+IHtcbiAgICAgICAgICBpZiAoIW1vdW50LnR5cGUuc3luY2ZzKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnQudHlwZS5zeW5jZnMobW91bnQsIHBvcHVsYXRlLCBkb25lKTtcbiAgICAgICAgfSk7XG4gICAgICB9LG1vdW50Oih0eXBlLCBvcHRzLCBtb3VudHBvaW50KSA9PiB7XG4gICAgICAgIHZhciByb290ID0gbW91bnRwb2ludCA9PT0gJy8nO1xuICAgICAgICB2YXIgcHNldWRvID0gIW1vdW50cG9pbnQ7XG4gICAgICAgIHZhciBub2RlO1xuICBcbiAgICAgICAgaWYgKHJvb3QgJiYgRlMucm9vdCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm9vdCAmJiAhcHNldWRvKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICBcbiAgICAgICAgICBtb3VudHBvaW50ID0gbG9va3VwLnBhdGg7ICBcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gIFxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG1vdW50ID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgb3B0czogb3B0cyxcbiAgICAgICAgICBtb3VudHBvaW50OiBtb3VudHBvaW50LFxuICAgICAgICAgIG1vdW50czogW11cbiAgICAgICAgfTtcbiAgXG4gICAgICAgIFxuICAgICAgICB2YXIgbW91bnRSb290ID0gdHlwZS5tb3VudChtb3VudCk7XG4gICAgICAgIG1vdW50Um9vdC5tb3VudCA9IG1vdW50O1xuICAgICAgICBtb3VudC5yb290ID0gbW91bnRSb290O1xuICBcbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICBGUy5yb290ID0gbW91bnRSb290O1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBub2RlLm1vdW50ZWQgPSBtb3VudDtcbiAgXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKG5vZGUubW91bnQpIHtcbiAgICAgICAgICAgIG5vZGUubW91bnQubW91bnRzLnB1c2gobW91bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIG1vdW50Um9vdDtcbiAgICAgIH0sdW5tb3VudDoobW91bnRwb2ludCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG4gIFxuICAgICAgICBpZiAoIUZTLmlzTW91bnRwb2ludChsb29rdXAubm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIFxuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50ZWQ7XG4gICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMobW91bnQpO1xuICBcbiAgICAgICAgT2JqZWN0LmtleXMoRlMubmFtZVRhYmxlKS5mb3JFYWNoKChoYXNoKSA9PiB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gIFxuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGN1cnJlbnQubmFtZV9uZXh0O1xuICBcbiAgICAgICAgICAgIGlmIChtb3VudHMuaW5jbHVkZXMoY3VycmVudC5tb3VudCkpIHtcbiAgICAgICAgICAgICAgRlMuZGVzdHJveU5vZGUoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgXG4gICAgICAgIFxuICAgICAgICBub2RlLm1vdW50ZWQgPSBudWxsO1xuICBcbiAgICAgICAgXG4gICAgICAgIHZhciBpZHggPSBub2RlLm1vdW50Lm1vdW50cy5pbmRleE9mKG1vdW50KTtcbiAgICAgICAgbm9kZS5tb3VudC5tb3VudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9LGxvb2t1cDoocGFyZW50LCBuYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubG9va3VwKHBhcmVudCwgbmFtZSk7XG4gICAgICB9LG1rbm9kOihwYXRoLCBtb2RlLCBkZXYpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICBpZiAoIW5hbWUgfHwgbmFtZSA9PT0gJy4nIHx8IG5hbWUgPT09ICcuLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5ta25vZCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLm1rbm9kKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgIH0sY3JlYXRlOihwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIG1vZGUgPSBtb2RlICE9PSB1bmRlZmluZWQgPyBtb2RlIDogNDM4IDtcbiAgICAgICAgbW9kZSAmPSA0MDk1O1xuICAgICAgICBtb2RlIHw9IDMyNzY4O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LG1rZGlyOihwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIG1vZGUgPSBtb2RlICE9PSB1bmRlZmluZWQgPyBtb2RlIDogNTExIDtcbiAgICAgICAgbW9kZSAmPSA1MTEgfCA1MTI7XG4gICAgICAgIG1vZGUgfD0gMTYzODQ7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgIH0sbWtkaXJUcmVlOihwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIHZhciBkaXJzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICB2YXIgZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoIWRpcnNbaV0pIGNvbnRpbnVlO1xuICAgICAgICAgIGQgKz0gJy8nICsgZGlyc1tpXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRlMubWtkaXIoZCwgbW9kZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBpZiAoZS5lcnJubyAhPSAyMCkgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sbWtkZXY6KHBhdGgsIG1vZGUsIGRldikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGRldiA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRldiA9IG1vZGU7XG4gICAgICAgICAgbW9kZSA9IDQzOCA7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSB8PSA4MTkyO1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sc3ltbGluazoob2xkcGF0aCwgbmV3cGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVBBVEhfRlMucmVzb2x2ZShvbGRwYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3bmFtZSA9IFBBVEguYmFzZW5hbWUobmV3cGF0aCk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmV3bmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMuc3ltbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKTtcbiAgICAgIH0scmVuYW1lOihvbGRfcGF0aCwgbmV3X3BhdGgpID0+IHtcbiAgICAgICAgdmFyIG9sZF9kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG9sZF9wYXRoKTtcbiAgICAgICAgdmFyIG5ld19kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG5ld19wYXRoKTtcbiAgICAgICAgdmFyIG9sZF9uYW1lID0gUEFUSC5iYXNlbmFtZShvbGRfcGF0aCk7XG4gICAgICAgIHZhciBuZXdfbmFtZSA9IFBBVEguYmFzZW5hbWUobmV3X3BhdGgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxvb2t1cCwgb2xkX2RpciwgbmV3X2RpcjtcbiAgXG4gICAgICAgIFxuICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG9sZF9wYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgb2xkX2RpciA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld19wYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgbmV3X2RpciA9IGxvb2t1cC5ub2RlO1xuICBcbiAgICAgICAgaWYgKCFvbGRfZGlyIHx8ICFuZXdfZGlyKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIFxuICAgICAgICBpZiAob2xkX2Rpci5tb3VudCAhPT0gbmV3X2Rpci5tb3VudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDc1KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIG9sZF9ub2RlID0gRlMubG9va3VwTm9kZShvbGRfZGlyLCBvbGRfbmFtZSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVsYXRpdmUgPSBQQVRIX0ZTLnJlbGF0aXZlKG9sZF9wYXRoLCBuZXdfZGlybmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmVsYXRpdmUgPSBQQVRIX0ZTLnJlbGF0aXZlKG5ld19wYXRoLCBvbGRfZGlybmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG9sZF9ub2RlID09PSBuZXdfbm9kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGlzZGlyID0gRlMuaXNEaXIob2xkX25vZGUubW9kZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKG9sZF9kaXIsIG9sZF9uYW1lLCBpc2Rpcik7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBlcnJDb2RlID0gbmV3X25vZGUgP1xuICAgICAgICAgIEZTLm1heURlbGV0ZShuZXdfZGlyLCBuZXdfbmFtZSwgaXNkaXIpIDpcbiAgICAgICAgICBGUy5tYXlDcmVhdGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChvbGRfbm9kZSkgfHwgKG5ld19ub2RlICYmIEZTLmlzTW91bnRwb2ludChuZXdfbm9kZSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobmV3X2RpciAhPT0gb2xkX2Rpcikge1xuICAgICAgICAgIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMob2xkX2RpciwgJ3cnKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShvbGRfbm9kZSk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIG9sZF9kaXIubm9kZV9vcHMucmVuYW1lKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIEZTLmhhc2hBZGROb2RlKG9sZF9ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxybWRpcjoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnJtZGlyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnJtZGlyKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxyZWFkZGlyOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMucmVhZGRpcikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5yZWFkZGlyKG5vZGUpO1xuICAgICAgfSx1bmxpbms6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUocGFyZW50LCBuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMudW5saW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsIG5hbWUpO1xuICAgICAgICBGUy5kZXN0cm95Tm9kZShub2RlKTtcbiAgICAgIH0scmVhZGxpbms6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCk7XG4gICAgICAgIHZhciBsaW5rID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBVEhfRlMucmVzb2x2ZShGUy5nZXRQYXRoKGxpbmsucGFyZW50KSwgbGluay5ub2RlX29wcy5yZWFkbGluayhsaW5rKSk7XG4gICAgICB9LHN0YXQ6KHBhdGgsIGRvbnRGb2xsb3cpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLmdldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZV9vcHMuZ2V0YXR0cihub2RlKTtcbiAgICAgIH0sbHN0YXQ6KHBhdGgpID0+IHtcbiAgICAgICAgcmV0dXJuIEZTLnN0YXQocGF0aCwgdHJ1ZSk7XG4gICAgICB9LGNobW9kOihwYXRoLCBtb2RlLCBkb250Rm9sbG93KSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pO1xuICAgICAgfSxsY2htb2Q6KHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSwgdHJ1ZSk7XG4gICAgICB9LGZjaG1vZDooZmQsIG1vZGUpID0+IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2htb2Qoc3RyZWFtLm5vZGUsIG1vZGUpO1xuICAgICAgfSxjaG93bjoocGF0aCwgdWlkLCBnaWQsIGRvbnRGb2xsb3cpID0+IHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICBcbiAgICAgICAgfSk7XG4gICAgICB9LGxjaG93bjoocGF0aCwgdWlkLCBnaWQpID0+IHtcbiAgICAgICAgRlMuY2hvd24ocGF0aCwgdWlkLCBnaWQsIHRydWUpO1xuICAgICAgfSxmY2hvd246KGZkLCB1aWQsIGdpZCkgPT4ge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jaG93bihzdHJlYW0ubm9kZSwgdWlkLCBnaWQpO1xuICAgICAgfSx0cnVuY2F0ZToocGF0aCwgbGVuKSA9PiB7XG4gICAgICAgIGlmIChsZW4gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCAndycpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgc2l6ZTogbGVuLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KTtcbiAgICAgIH0sZnRydW5jYXRlOihmZCwgbGVuKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgRlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsIGxlbik7XG4gICAgICB9LHV0aW1lOihwYXRoLCBhdGltZSwgbXRpbWUpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBNYXRoLm1heChhdGltZSwgbXRpbWUpXG4gICAgICAgIH0pO1xuICAgICAgfSxvcGVuOihwYXRoLCBmbGFncywgbW9kZSkgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyA9IHR5cGVvZiBmbGFncyA9PSAnc3RyaW5nJyA/IEZTLm1vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKSA6IGZsYWdzO1xuICAgICAgICBtb2RlID0gdHlwZW9mIG1vZGUgPT0gJ3VuZGVmaW5lZCcgPyA0MzggIDogbW9kZTtcbiAgICAgICAgaWYgKChmbGFncyAmIDY0KSkge1xuICAgICAgICAgIG1vZGUgPSAobW9kZSAmIDQwOTUpIHwgMzI3Njg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwge1xuICAgICAgICAgICAgICBmb2xsb3c6ICEoZmxhZ3MgJiAxMzEwNzIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBjcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA2NCkpIHtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMTI4KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBmbGFncyAmPSB+NTEyO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoKGZsYWdzICYgNjU1MzYpICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmICghY3JlYXRlZCkge1xuICAgICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5T3Blbihub2RlLCBmbGFncyk7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKChmbGFncyAmIDUxMikgJiYgIWNyZWF0ZWQpIHtcbiAgICAgICAgICBGUy50cnVuY2F0ZShub2RlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZmxhZ3MgJj0gfigxMjggfCA1MTIgfCAxMzEwNzIpO1xuICBcbiAgICAgICAgXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgcGF0aDogRlMuZ2V0UGF0aChub2RlKSwgIFxuICAgICAgICAgIGZsYWdzOiBmbGFncyxcbiAgICAgICAgICBzZWVrYWJsZTogdHJ1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICBzdHJlYW1fb3BzOiBub2RlLnN0cmVhbV9vcHMsXG4gICAgICAgICAgXG4gICAgICAgICAgdW5nb3R0ZW46IFtdLFxuICAgICAgICAgIGVycm9yOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7XG4gICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3BlbihzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ2xvZ1JlYWRGaWxlcyddICYmICEoZmxhZ3MgJiAxKSkge1xuICAgICAgICAgIGlmICghRlMucmVhZEZpbGVzKSBGUy5yZWFkRmlsZXMgPSB7fTtcbiAgICAgICAgICBpZiAoIShwYXRoIGluIEZTLnJlYWRGaWxlcykpIHtcbiAgICAgICAgICAgIEZTLnJlYWRGaWxlc1twYXRoXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LGNsb3NlOihzdHJlYW0pID0+IHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmdldGRlbnRzKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsOyBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2UpIHtcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5mZCA9IG51bGw7XG4gICAgICB9LGlzQ2xvc2VkOihzdHJlYW0pID0+IHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5mZCA9PT0gbnVsbDtcbiAgICAgIH0sbGxzZWVrOihzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc2Vla2FibGUgfHwgIXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlbmNlICE9IDAgJiYgd2hlbmNlICE9IDEgJiYgd2hlbmNlICE9IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvc2l0aW9uID0gc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgICBzdHJlYW0udW5nb3R0ZW4gPSBbXTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIH0scmVhZDooc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMucmVhZCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNSZWFkID0gc3RyZWFtLnN0cmVhbV9vcHMucmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNSZWFkO1xuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgfSx3cml0ZTooc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKSA9PiB7XG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy53cml0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLnNlZWthYmxlICYmIHN0cmVhbS5mbGFncyAmIDEwMjQpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBGUy5sbHNlZWsoc3RyZWFtLCAwLCAyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vla2luZyA9IHR5cGVvZiBwb3NpdGlvbiAhPSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnl0ZXNXcml0dGVuID0gc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKTtcbiAgICAgICAgaWYgKCFzZWVraW5nKSBzdHJlYW0ucG9zaXRpb24gKz0gYnl0ZXNXcml0dGVuO1xuICAgICAgICByZXR1cm4gYnl0ZXNXcml0dGVuO1xuICAgICAgfSxhbGxvY2F0ZTooc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSAmJiAhRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUoc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICB9LG1tYXA6KHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpID0+IHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKChwcm90ICYgMikgIT09IDBcbiAgICAgICAgICAgICYmIChmbGFncyAmIDIpID09PSAwXG4gICAgICAgICAgICAmJiAoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5tbWFwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tbWFwKHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpO1xuICAgICAgfSxtc3luYzooc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpID0+IHtcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5tc3luYykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tc3luYyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncyk7XG4gICAgICB9LG11bm1hcDooc3RyZWFtKSA9PiAwLGlvY3RsOihzdHJlYW0sIGNtZCwgYXJnKSA9PiB7XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1OSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKHN0cmVhbSwgY21kLCBhcmcpO1xuICAgICAgfSxyZWFkRmlsZToocGF0aCwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDA7XG4gICAgICAgIG9wdHMuZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nIHx8ICdiaW5hcnknO1xuICAgICAgICBpZiAob3B0cy5lbmNvZGluZyAhPT0gJ3V0ZjgnICYmIG9wdHMuZW5jb2RpbmcgIT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nIHR5cGUgXCInICsgb3B0cy5lbmNvZGluZyArICdcIicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKHBhdGgsIG9wdHMuZmxhZ3MpO1xuICAgICAgICB2YXIgc3RhdCA9IEZTLnN0YXQocGF0aCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBzdGF0LnNpemU7XG4gICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgICBGUy5yZWFkKHN0cmVhbSwgYnVmLCAwLCBsZW5ndGgsIDApO1xuICAgICAgICBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAgICAgcmV0ID0gVVRGOEFycmF5VG9TdHJpbmcoYnVmLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLmVuY29kaW5nID09PSAnYmluYXJ5Jykge1xuICAgICAgICAgIHJldCA9IGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSx3cml0ZUZpbGU6KHBhdGgsIGRhdGEsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCA1Nzc7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKHBhdGgsIG9wdHMuZmxhZ3MsIG9wdHMubW9kZSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGhCeXRlc1VURjgoZGF0YSkrMSk7XG4gICAgICAgICAgdmFyIGFjdHVhbE51bUJ5dGVzID0gc3RyaW5nVG9VVEY4QXJyYXkoZGF0YSwgYnVmLCAwLCBidWYubGVuZ3RoKTtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGJ1ZiwgMCwgYWN0dWFsTnVtQnl0ZXMsIHVuZGVmaW5lZCwgb3B0cy5jYW5Pd24pO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICB9LGN3ZDooKSA9PiBGUy5jdXJyZW50UGF0aCxjaGRpcjoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGxvb2t1cC5ub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRlMuaXNEaXIobG9va3VwLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMobG9va3VwLm5vZGUsICd4Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY3VycmVudFBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgIH0sY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzOigpID0+IHtcbiAgICAgICAgRlMubWtkaXIoJy90bXAnKTtcbiAgICAgICAgRlMubWtkaXIoJy9ob21lJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZS93ZWJfdXNlcicpO1xuICAgICAgfSxjcmVhdGVEZWZhdWx0RGV2aWNlczooKSA9PiB7XG4gICAgICAgIFxuICAgICAgICBGUy5ta2RpcignL2RldicpO1xuICAgICAgICBcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLCAzKSwge1xuICAgICAgICAgIHJlYWQ6ICgpID0+IDAsXG4gICAgICAgICAgd3JpdGU6IChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgPT4gbGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgRlMubWtkZXYoJy9kZXYvbnVsbCcsIEZTLm1ha2VkZXYoMSwgMykpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7XG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDYsIDApLCBUVFkuZGVmYXVsdF90dHkxX29wcyk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eScsIEZTLm1ha2VkZXYoNSwgMCkpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHkxJywgRlMubWFrZWRldig2LCAwKSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmFuZG9tX2RldmljZSA9IGdldFJhbmRvbURldmljZSgpO1xuICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAncmFuZG9tJywgcmFuZG9tX2RldmljZSk7XG4gICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICd1cmFuZG9tJywgcmFuZG9tX2RldmljZSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvZGV2L3NobS90bXAnKTtcbiAgICAgIH0sY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOigpID0+IHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBGUy5ta2RpcignL3Byb2MnKTtcbiAgICAgICAgdmFyIHByb2Nfc2VsZiA9IEZTLm1rZGlyKCcvcHJvYy9zZWxmJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvcHJvYy9zZWxmL2ZkJyk7XG4gICAgICAgIEZTLm1vdW50KHtcbiAgICAgICAgICBtb3VudDogKCkgPT4ge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVOb2RlKHByb2Nfc2VsZiwgJ2ZkJywgMTYzODQgfCA1MTEgLCA3Myk7XG4gICAgICAgICAgICBub2RlLm5vZGVfb3BzID0ge1xuICAgICAgICAgICAgICBsb29rdXA6IChwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgZmQgPSArbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0cmVhbSkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIG1vdW50OiB7IG1vdW50cG9pbnQ6ICdmYWtlJyB9LFxuICAgICAgICAgICAgICAgICAgbm9kZV9vcHM6IHsgcmVhZGxpbms6ICgpID0+IHN0cmVhbS5wYXRoIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXQucGFyZW50ID0gcmV0OyBcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7fSwgJy9wcm9jL3NlbGYvZmQnKTtcbiAgICAgIH0sY3JlYXRlU3RhbmRhcmRTdHJlYW1zOigpID0+IHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoTW9kdWxlWydzdGRpbiddKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGluJywgTW9kdWxlWydzdGRpbiddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZGluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1vZHVsZVsnc3Rkb3V0J10pIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3Rkb3V0JywgbnVsbCwgTW9kdWxlWydzdGRvdXQnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRlMuc3ltbGluaygnL2Rldi90dHknLCAnL2Rldi9zdGRvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydzdGRlcnInXSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRlcnInLCBudWxsLCBNb2R1bGVbJ3N0ZGVyciddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eTEnLCAnL2Rldi9zdGRlcnInKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGRpbiA9IEZTLm9wZW4oJy9kZXYvc3RkaW4nLCAwKTtcbiAgICAgICAgdmFyIHN0ZG91dCA9IEZTLm9wZW4oJy9kZXYvc3Rkb3V0JywgMSk7XG4gICAgICAgIHZhciBzdGRlcnIgPSBGUy5vcGVuKCcvZGV2L3N0ZGVycicsIDEpO1xuICAgICAgfSxlbnN1cmVFcnJub0Vycm9yOigpID0+IHtcbiAgICAgICAgaWYgKEZTLkVycm5vRXJyb3IpIHJldHVybjtcbiAgICAgICAgRlMuRXJybm9FcnJvciA9ICBmdW5jdGlvbiBFcnJub0Vycm9yKGVycm5vLCBub2RlKSB7XG4gICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICB0aGlzLnNldEVycm5vID0gIGZ1bmN0aW9uKGVycm5vKSB7XG4gICAgICAgICAgICB0aGlzLmVycm5vID0gZXJybm87XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnNldEVycm5vKGVycm5vKTtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnRlMgZXJyb3InO1xuICBcbiAgICAgICAgfTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGUy5FcnJub0Vycm9yO1xuICAgICAgICBcbiAgICAgICAgWzQ0XS5mb3JFYWNoKChjb2RlKSA9PiB7XG4gICAgICAgICAgRlMuZ2VuZXJpY0Vycm9yc1tjb2RlXSA9IG5ldyBGUy5FcnJub0Vycm9yKGNvZGUpO1xuICAgICAgICAgIEZTLmdlbmVyaWNFcnJvcnNbY29kZV0uc3RhY2sgPSAnPGdlbmVyaWMgZXJyb3IsIG5vIHN0YWNrPic7XG4gICAgICAgIH0pO1xuICAgICAgfSxzdGF0aWNJbml0OigpID0+IHtcbiAgICAgICAgRlMuZW5zdXJlRXJybm9FcnJvcigpO1xuICBcbiAgICAgICAgRlMubmFtZVRhYmxlID0gbmV3IEFycmF5KDQwOTYpO1xuICBcbiAgICAgICAgRlMubW91bnQoTUVNRlMsIHt9LCAnLycpO1xuICBcbiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzKCk7XG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREZXZpY2VzKCk7XG4gICAgICAgIEZTLmNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllcygpO1xuICBcbiAgICAgICAgRlMuZmlsZXN5c3RlbXMgPSB7XG4gICAgICAgICAgJ01FTUZTJzogTUVNRlMsXG4gICAgICAgIH07XG4gICAgICB9LGluaXQ6KGlucHV0LCBvdXRwdXQsIGVycm9yKSA9PiB7XG4gICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICBcbiAgICAgICAgRlMuZW5zdXJlRXJybm9FcnJvcigpO1xuICBcbiAgICAgICAgXG4gICAgICAgIE1vZHVsZVsnc3RkaW4nXSA9IGlucHV0IHx8IE1vZHVsZVsnc3RkaW4nXTtcbiAgICAgICAgTW9kdWxlWydzdGRvdXQnXSA9IG91dHB1dCB8fCBNb2R1bGVbJ3N0ZG91dCddO1xuICAgICAgICBNb2R1bGVbJ3N0ZGVyciddID0gZXJyb3IgfHwgTW9kdWxlWydzdGRlcnInXTtcbiAgXG4gICAgICAgIEZTLmNyZWF0ZVN0YW5kYXJkU3RyZWFtcygpO1xuICAgICAgfSxxdWl0OigpID0+IHtcbiAgICAgICAgRlMuaW5pdC5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRlMuc3RyZWFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5zdHJlYW1zW2ldO1xuICAgICAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfSxnZXRNb2RlOihjYW5SZWFkLCBjYW5Xcml0ZSkgPT4ge1xuICAgICAgICB2YXIgbW9kZSA9IDA7XG4gICAgICAgIGlmIChjYW5SZWFkKSBtb2RlIHw9IDI5MiB8IDczO1xuICAgICAgICBpZiAoY2FuV3JpdGUpIG1vZGUgfD0gMTQ2O1xuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH0sZmluZE9iamVjdDoocGF0aCwgZG9udFJlc29sdmVMYXN0TGluaykgPT4ge1xuICAgICAgICB2YXIgcmV0ID0gRlMuYW5hbHl6ZVBhdGgocGF0aCwgZG9udFJlc29sdmVMYXN0TGluayk7XG4gICAgICAgIGlmICghcmV0LmV4aXN0cykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQub2JqZWN0O1xuICAgICAgfSxhbmFseXplUGF0aDoocGF0aCwgZG9udFJlc29sdmVMYXN0TGluaykgPT4ge1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRSZXNvbHZlTGFzdExpbmsgfSk7XG4gICAgICAgICAgcGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLCBleGlzdHM6IGZhbHNlLCBlcnJvcjogMCwgbmFtZTogbnVsbCwgcGF0aDogbnVsbCwgb2JqZWN0OiBudWxsLFxuICAgICAgICAgIHBhcmVudEV4aXN0czogZmFsc2UsIHBhcmVudFBhdGg6IG51bGwsIHBhcmVudE9iamVjdDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICAgIHJldC5wYXJlbnRFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIHJldC5wYXJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgICAgcmV0LnBhcmVudE9iamVjdCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIHJldC5uYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgICAgICByZXQuZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5vYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IGxvb2t1cC5ub2RlLm5hbWU7XG4gICAgICAgICAgcmV0LmlzUm9vdCA9IGxvb2t1cC5wYXRoID09PSAnLyc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXQuZXJyb3IgPSBlLmVycm5vO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxjcmVhdGVQYXRoOihwYXJlbnQsIHBhdGgsIGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5yZXZlcnNlKCk7XG4gICAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzLnBvcCgpO1xuICAgICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBQQVRILmpvaW4yKHBhcmVudCwgcGFydCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEZTLm1rZGlyKGN1cnJlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfSxjcmVhdGVGaWxlOihwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLCBuYW1lKTtcbiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTtcbiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgICAgIH0sY3JlYXRlRGF0YUZpbGU6KHBhcmVudCwgbmFtZSwgZGF0YSwgY2FuUmVhZCwgY2FuV3JpdGUsIGNhbk93bikgPT4ge1xuICAgICAgICB2YXIgcGF0aCA9IG5hbWU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpO1xuICAgICAgICAgIHBhdGggPSBuYW1lID8gUEFUSC5qb2luMihwYXJlbnQsIG5hbWUpIDogcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlKHBhdGgsIG1vZGUpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47ICsraSkgYXJyW2ldID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgZGF0YSA9IGFycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSB8IDE0Nik7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4obm9kZSwgNTc3KTtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGNyZWF0ZURldmljZToocGFyZW50LCBuYW1lLCBpbnB1dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLCBuYW1lKTtcbiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKCEhaW5wdXQsICEhb3V0cHV0KTtcbiAgICAgICAgaWYgKCFGUy5jcmVhdGVEZXZpY2UubWFqb3IpIEZTLmNyZWF0ZURldmljZS5tYWpvciA9IDY0O1xuICAgICAgICB2YXIgZGV2ID0gRlMubWFrZWRldihGUy5jcmVhdGVEZXZpY2UubWFqb3IrKywgMCk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCB7XG4gICAgICAgICAgb3BlbjogKHN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZTogKHN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAob3V0cHV0ICYmIG91dHB1dC5idWZmZXIgJiYgb3V0cHV0LmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgb3V0cHV0KDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlYWQ6IChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcyApID0+IHtcbiAgICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgICBieXRlc1JlYWQrKztcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCtpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlc1JlYWQpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0KGJ1ZmZlcltvZmZzZXQraV0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRlMubWtkZXYocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgIH0sZm9yY2VMb2FkRmlsZToob2JqKSA9PiB7XG4gICAgICAgIGlmIChvYmouaXNEZXZpY2UgfHwgb2JqLmlzRm9sZGVyIHx8IG9iai5saW5rIHx8IG9iai5jb250ZW50cykgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhZF8pIHtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG9iai5jb250ZW50cyA9IGludEFycmF5RnJvbVN0cmluZyhyZWFkXyhvYmoudXJsKSwgdHJ1ZSk7XG4gICAgICAgICAgICBvYmoudXNlZEJ5dGVzID0gb2JqLmNvbnRlbnRzLmxlbmd0aDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgd2l0aG91dCByZWFkKCkgb3IgWE1MSHR0cFJlcXVlc3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0sY3JlYXRlTGF6eUZpbGU6KHBhcmVudCwgbmFtZSwgdXJsLCBjYW5SZWFkLCBjYW5Xcml0ZSkgPT4ge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5KCkge1xuICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNodW5rcyA9IFtdOyBcbiAgICAgICAgfVxuICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuZ2V0ID0gIGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2dldChpZHgpIHtcbiAgICAgICAgICBpZiAoaWR4ID4gdGhpcy5sZW5ndGgtMSB8fCBpZHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSB0aGlzLmNodW5rU2l6ZTtcbiAgICAgICAgICB2YXIgY2h1bmtOdW0gPSAoaWR4IC8gdGhpcy5jaHVua1NpemUpfDA7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKGNodW5rTnVtKVtjaHVua09mZnNldF07XG4gICAgICAgIH07XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5zZXREYXRhR2V0dGVyID0gZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfc2V0RGF0YUdldHRlcihnZXR0ZXIpIHtcbiAgICAgICAgICB0aGlzLmdldHRlciA9IGdldHRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmNhY2hlTGVuZ3RoID0gZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfY2FjaGVMZW5ndGgoKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgaWYgKCEoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBsb2FkIFwiICsgdXJsICsgXCIuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgICB2YXIgZGF0YWxlbmd0aCA9IE51bWJlcih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LWxlbmd0aFwiKSk7XG4gICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSkgJiYgaGVhZGVyID09PSBcImJ5dGVzXCI7XG4gICAgICAgICAgdmFyIHVzZXNHemlwID0gKGhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikpICYmIGhlYWRlciA9PT0gXCJnemlwXCI7XG4gIFxuICAgICAgICAgIHZhciBjaHVua1NpemUgPSAxMDI0KjEwMjQ7IFxuICBcbiAgICAgICAgICBpZiAoIWhhc0J5dGVTZXJ2aW5nKSBjaHVua1NpemUgPSBkYXRhbGVuZ3RoO1xuICBcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgZG9YSFIgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gdG8pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmFuZ2UgKFwiICsgZnJvbSArIFwiLCBcIiArIHRvICsgXCIpIG9yIG5vIGJ5dGVzIHJlcXVlc3RlZCFcIik7XG4gICAgICAgICAgICBpZiAodG8gPiBkYXRhbGVuZ3RoLTEpIHRocm93IG5ldyBFcnJvcihcIm9ubHkgXCIgKyBkYXRhbGVuZ3RoICsgXCIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIVwiKTtcbiAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChkYXRhbGVuZ3RoICE9PSBjaHVua1NpemUpIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgXCJieXRlcz1cIiArIGZyb20gKyBcIi1cIiArIHRvKTtcbiAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgaWYgKHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICBpZiAoISh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwIHx8IHhoci5zdGF0dXMgPT09IDMwNCkpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyBcIi4gU3RhdHVzOiBcIiArIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgoeGhyLnJlc3BvbnNlIHx8IFtdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW50QXJyYXlGcm9tU3RyaW5nKHhoci5yZXNwb25zZVRleHQgfHwgJycsIHRydWUpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IHRoaXM7XG4gICAgICAgICAgbGF6eUFycmF5LnNldERhdGFHZXR0ZXIoKGNodW5rTnVtKSA9PiB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBjaHVua051bSAqIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSAoY2h1bmtOdW0rMSkgKiBjaHVua1NpemUgLSAxOyBcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgZGF0YWxlbmd0aC0xKTsgXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID0gZG9YSFIoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2RvWEhSIGZhaWxlZCEnKTtcbiAgICAgICAgICAgIHJldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXTtcbiAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgaWYgKHVzZXNHemlwIHx8ICFkYXRhbGVuZ3RoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGggPSAxOyBcbiAgICAgICAgICAgIGRhdGFsZW5ndGggPSB0aGlzLmdldHRlcigwKS5sZW5ndGg7XG4gICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgICAgb3V0KFwiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkXCIpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdGhpcy5fbGVuZ3RoID0gZGF0YWxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgICAgICAgdGhpcy5sZW5ndGhLbm93biA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoIUVOVklST05NRU5UX0lTX1dPUktFUikgdGhyb3cgJ0Nhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2MnO1xuICAgICAgICAgIHZhciBsYXp5QXJyYXkgPSBuZXcgTGF6eVVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5QXJyYXksIHtcbiAgICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgICBnZXQ6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNodW5rU2l6ZToge1xuICAgICAgICAgICAgICBnZXQ6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgdXJsOiB1cmwgfTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVGaWxlKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAocHJvcGVydGllcy5jb250ZW50cykge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBwcm9wZXJ0aWVzLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMudXJsKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgbm9kZS51cmwgPSBwcm9wZXJ0aWVzLnVybDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSwge1xuICAgICAgICAgIHVzZWRCeXRlczoge1xuICAgICAgICAgICAgZ2V0OiAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aDsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RyZWFtX29wcyA9IHt9O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuc3RyZWFtX29wcyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgdmFyIGZuID0gbm9kZS5zdHJlYW1fb3BzW2tleV07XG4gICAgICAgICAgc3RyZWFtX29wc1trZXldID0gZnVuY3Rpb24gZm9yY2VMb2FkTGF6eUZpbGUoKSB7XG4gICAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlQ2h1bmtzKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gY29udGVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbihjb250ZW50cy5sZW5ndGggLSBwb3NpdGlvbiwgbGVuZ3RoKTtcbiAgICAgICAgICBpZiAoY29udGVudHMuc2xpY2UpIHsgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgeyBcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHMuZ2V0KHBvc2l0aW9uICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdHJlYW1fb3BzLnJlYWQgPSAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtzKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBzdHJlYW1fb3BzLm1tYXAgPSAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykgPT4ge1xuICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgdmFyIHB0ciA9IG1tYXBBbGxvYyhsZW5ndGgpO1xuICAgICAgICAgIGlmICghcHRyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdyaXRlQ2h1bmtzKHN0cmVhbSwgSEVBUDgsIHB0ciwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHsgcHRyOiBwdHIsIGFsbG9jYXRlZDogdHJ1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBzdHJlYW1fb3BzO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sY3JlYXRlUHJlbG9hZGVkRmlsZToocGFyZW50LCBuYW1lLCB1cmwsIGNhblJlYWQsIGNhbldyaXRlLCBvbmxvYWQsIG9uZXJyb3IsIGRvbnRDcmVhdGVGaWxlLCBjYW5Pd24sIHByZUZpbmlzaCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBmdWxsbmFtZSA9IG5hbWUgPyBQQVRIX0ZTLnJlc29sdmUoUEFUSC5qb2luMihwYXJlbnQsIG5hbWUpKSA6IHBhcmVudDtcbiAgICAgICAgdmFyIGRlcCA9IGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koJ2NwICcgKyBmdWxsbmFtZSk7IFxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpIHtcbiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goYnl0ZUFycmF5KSB7XG4gICAgICAgICAgICBpZiAocHJlRmluaXNoKSBwcmVGaW5pc2goKTtcbiAgICAgICAgICAgIGlmICghZG9udENyZWF0ZUZpbGUpIHtcbiAgICAgICAgICAgICAgRlMuY3JlYXRlRGF0YUZpbGUocGFyZW50LCBuYW1lLCBieXRlQXJyYXksIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ubG9hZCkgb25sb2FkKCk7XG4gICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChCcm93c2VyLmhhbmRsZWRCeVByZWxvYWRQbHVnaW4oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob25lcnJvcikgb25lcnJvcigpO1xuICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaChieXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhc3luY0xvYWQodXJsLCAoYnl0ZUFycmF5KSA9PiBwcm9jZXNzRGF0YShieXRlQXJyYXkpLCBvbmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzRGF0YSh1cmwpO1xuICAgICAgICB9XG4gICAgICB9LGluZGV4ZWREQjooKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5kZXhlZERCIHx8IHdpbmRvdy5tb3pJbmRleGVkREIgfHwgd2luZG93LndlYmtpdEluZGV4ZWREQiB8fCB3aW5kb3cubXNJbmRleGVkREI7XG4gICAgICB9LERCX05BTUU6KCkgPT4ge1xuICAgICAgICByZXR1cm4gJ0VNX0ZTXycgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB9LERCX1ZFUlNJT046MjAsREJfU1RPUkVfTkFNRTpcIkZJTEVfREFUQVwiLHNhdmVGaWxlc1RvREI6KHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xuICAgICAgICAgIG91dCgnY3JlYXRpbmcgZGInKTtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgdmFyIGZpbGVzID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgICAgICAgdmFyIG9rID0gMCwgZmFpbCA9IDAsIHRvdGFsID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpOyBlbHNlIG9uZXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgdmFyIHB1dFJlcXVlc3QgPSBmaWxlcy5wdXQoRlMuYW5hbHl6ZVBhdGgocGF0aCkub2JqZWN0LmNvbnRlbnRzLCBwYXRoKTtcbiAgICAgICAgICAgIHB1dFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4geyBvaysrOyBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKSB9O1xuICAgICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4geyBmYWlsKys7IGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgfSxsb2FkRmlsZXNGcm9tREI6KHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gb25lcnJvcjsgXG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBvbmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgICAgICB2YXIgb2sgPSAwLCBmYWlsID0gMCwgdG90YWwgPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAgICAgaWYgKGZhaWwgPT0gMCkgb25sb2FkKCk7IGVsc2Ugb25lcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IGZpbGVzLmdldChwYXRoKTtcbiAgICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoRlMuYW5hbHl6ZVBhdGgocGF0aCkuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFBBVEguZGlybmFtZShwYXRoKSwgUEFUSC5iYXNlbmFtZShwYXRoKSwgZ2V0UmVxdWVzdC5yZXN1bHQsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICBvaysrO1xuICAgICAgICAgICAgICBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7IGZhaWwrKzsgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCkgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICB9fTtcbiAgdmFyIFNZU0NBTExTID0ge0RFRkFVTFRfUE9MTE1BU0s6NSxjYWxjdWxhdGVBdDpmdW5jdGlvbihkaXJmZCwgcGF0aCwgYWxsb3dFbXB0eSkge1xuICAgICAgICBpZiAoUEFUSC5pc0FicyhwYXRoKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgZGlyO1xuICAgICAgICBpZiAoZGlyZmQgPT09IC0xMDApIHtcbiAgICAgICAgICBkaXIgPSBGUy5jd2QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGlyc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGRpcmZkKTtcbiAgICAgICAgICBkaXIgPSBkaXJzdHJlYW0ucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIGlmICghYWxsb3dFbXB0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpOztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSC5qb2luMihkaXIsIHBhdGgpO1xuICAgICAgfSxkb1N0YXQ6ZnVuY3Rpb24oZnVuYywgcGF0aCwgYnVmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHN0YXQgPSBmdW5jKHBhdGgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS5ub2RlICYmIFBBVEgubm9ybWFsaXplKHBhdGgpICE9PSBQQVRILm5vcm1hbGl6ZShGUy5nZXRQYXRoKGUubm9kZSkpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAtNTQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyWygoYnVmKT4+MildID0gc3RhdC5kZXY7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKyg4KSk+PjIpXSA9IHN0YXQuaW5vO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMTIpKT4+MildID0gc3RhdC5tb2RlO1xuICAgICAgICBIRUFQVTMyWygoKGJ1ZikrKDE2KSk+PjIpXSA9IHN0YXQubmxpbms7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygyMCkpPj4yKV0gPSBzdGF0LnVpZDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDI0KSk+PjIpXSA9IHN0YXQuZ2lkO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMjgpKT4+MildID0gc3RhdC5yZGV2O1xuICAgICAgICAodGVtcEk2NCA9IFtzdGF0LnNpemU+Pj4wLCh0ZW1wRG91YmxlPXN0YXQuc2l6ZSwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKChidWYpKyg0MCkpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChidWYpKyg0NCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDQ4KSk+PjIpXSA9IDQwOTY7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKyg1MikpPj4yKV0gPSBzdGF0LmJsb2NrcztcbiAgICAgICAgdmFyIGF0aW1lID0gc3RhdC5hdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBtdGltZSA9IHN0YXQubXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgY3RpbWUgPSBzdGF0LmN0aW1lLmdldFRpbWUoKTtcbiAgICAgICAgKHRlbXBJNjQgPSBbTWF0aC5mbG9vcihhdGltZSAvIDEwMDApPj4+MCwodGVtcERvdWJsZT1NYXRoLmZsb29yKGF0aW1lIC8gMTAwMCksKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgoYnVmKSsoNTYpKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoNjApKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIEhFQVBVMzJbKCgoYnVmKSsoNjQpKT4+MildID0gKGF0aW1lICUgMTAwMCkgKiAxMDAwO1xuICAgICAgICAodGVtcEk2NCA9IFtNYXRoLmZsb29yKG10aW1lIC8gMTAwMCk+Pj4wLCh0ZW1wRG91YmxlPU1hdGguZmxvb3IobXRpbWUgLyAxMDAwKSwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKChidWYpKyg3MikpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChidWYpKyg3NikpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUFUzMlsoKChidWYpKyg4MCkpPj4yKV0gPSAobXRpbWUgJSAxMDAwKSAqIDEwMDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW01hdGguZmxvb3IoY3RpbWUgLyAxMDAwKT4+PjAsKHRlbXBEb3VibGU9TWF0aC5mbG9vcihjdGltZSAvIDEwMDApLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGJ1ZikrKDg4KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDkyKSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQVTMyWygoKGJ1ZikrKDk2KSk+PjIpXSA9IChjdGltZSAlIDEwMDApICogMTAwMDtcbiAgICAgICAgKHRlbXBJNjQgPSBbc3RhdC5pbm8+Pj4wLCh0ZW1wRG91YmxlPXN0YXQuaW5vLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGJ1ZikrKDEwNCkpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChidWYpKygxMDgpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxkb01zeW5jOmZ1bmN0aW9uKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KSB7XG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gSEVBUFU4LnNsaWNlKGFkZHIsIGFkZHIgKyBsZW4pO1xuICAgICAgICBGUy5tc3luYyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW4sIGZsYWdzKTtcbiAgICAgIH0sdmFyYXJnczp1bmRlZmluZWQsZ2V0OmZ1bmN0aW9uKCkge1xuICAgICAgICBTWVNDQUxMUy52YXJhcmdzICs9IDQ7XG4gICAgICAgIHZhciByZXQgPSBIRUFQMzJbKCgoU1lTQ0FMTFMudmFyYXJncyktKDQpKT4+MildO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxnZXRTdHI6ZnVuY3Rpb24ocHRyKSB7XG4gICAgICAgIHZhciByZXQgPSBVVEY4VG9TdHJpbmcocHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sZ2V0U3RyZWFtRnJvbUZEOmZ1bmN0aW9uKGZkKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9fTtcbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9jaG1vZChwYXRoLCBtb2RlKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIEZTLmNobW9kKHBhdGgsIG1vZGUpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZhY2Nlc3NhdChkaXJmZCwgcGF0aCwgYW1vZGUsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICBpZiAoYW1vZGUgJiB+Nykge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgIH1cbiAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gLTQ0O1xuICAgICAgfVxuICAgICAgdmFyIHBlcm1zID0gJyc7XG4gICAgICBpZiAoYW1vZGUgJiA0KSBwZXJtcyArPSAncic7XG4gICAgICBpZiAoYW1vZGUgJiAyKSBwZXJtcyArPSAndyc7XG4gICAgICBpZiAoYW1vZGUgJiAxKSBwZXJtcyArPSAneCc7XG4gICAgICBpZiAocGVybXMgICYmIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBwZXJtcykpIHtcbiAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZjaG1vZChmZCwgbW9kZSkge1xuICB0cnkge1xuICBcbiAgICAgIEZTLmZjaG1vZChmZCwgbW9kZSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNob3duMzIoZmQsIG93bmVyLCBncm91cCkge1xuICB0cnkge1xuICBcbiAgICAgIEZTLmZjaG93bihmZCwgb3duZXIsIGdyb3VwKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0RXJyTm8odmFsdWUpIHtcbiAgICAgIEhFQVAzMlsoKF9fX2Vycm5vX2xvY2F0aW9uKCkpPj4yKV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZjbnRsNjQoZmQsIGNtZCwgdmFyYXJncykge1xuICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgIHZhciBhcmcgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICBpZiAoYXJnIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1N0cmVhbTtcbiAgICAgICAgICBuZXdTdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oc3RyZWFtLCBhcmcpO1xuICAgICAgICAgIHJldHVybiBuZXdTdHJlYW0uZmQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIDA7ICBcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBzdHJlYW0uZmxhZ3M7XG4gICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgIHZhciBhcmcgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICBzdHJlYW0uZmxhZ3MgfD0gYXJnO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgIHtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgYXJnID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgSEVBUDE2WygoKGFyZykrKG9mZnNldCkpPj4xKV0gPSAyO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIDA7IFxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIC0yODsgXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBcbiAgICAgICAgICBzZXRFcnJObygyOCk7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9mc3RhdDY0KGZkLCBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQoRlMuc3RhdCwgc3RyZWFtLnBhdGgsIGJ1Zik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICB2YXIgTUFYX0lOVDUzID0gOTAwNzE5OTI1NDc0MDk5MjtcbiAgXG4gIHZhciBNSU5fSU5UNTMgPSAtOTAwNzE5OTI1NDc0MDk5MjtcbiAgZnVuY3Rpb24gYmlnaW50VG9JNTNDaGVja2VkKG51bSkge1xuICAgICAgcmV0dXJuIChudW0gPCBNSU5fSU5UNTMgfHwgbnVtID4gTUFYX0lOVDUzKSA/IE5hTiA6IE51bWJlcihudW0pO1xuICAgIH1cbiAgXG4gIFxuICBcbiAgXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZnRydW5jYXRlNjQoZmQsICBsZW5ndGgpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBsZW5ndGggPSBiaWdpbnRUb0k1M0NoZWNrZWQobGVuZ3RoKTsgaWYgKGlzTmFOKGxlbmd0aCkpIHJldHVybiAtNjE7XG4gICAgICBGUy5mdHJ1bmNhdGUoZmQsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0Y3dkKGJ1Ziwgc2l6ZSkge1xuICB0cnkge1xuICBcbiAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gLTI4O1xuICAgICAgdmFyIGN3ZCA9IEZTLmN3ZCgpO1xuICAgICAgdmFyIGN3ZExlbmd0aEluQnl0ZXMgPSBsZW5ndGhCeXRlc1VURjgoY3dkKSArIDE7XG4gICAgICBpZiAoc2l6ZSA8IGN3ZExlbmd0aEluQnl0ZXMpIHJldHVybiAtNjg7XG4gICAgICBzdHJpbmdUb1VURjgoY3dkLCBidWYsIHNpemUpO1xuICAgICAgcmV0dXJuIGN3ZExlbmd0aEluQnl0ZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2lvY3RsKGZkLCBvcCwgdmFyYXJncykge1xuICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSAyMTUwOTpcbiAgICAgICAgY2FzZSAyMTUwNToge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTEwOlxuICAgICAgICBjYXNlIDIxNTExOlxuICAgICAgICBjYXNlIDIxNTEyOlxuICAgICAgICBjYXNlIDIxNTA2OlxuICAgICAgICBjYXNlIDIxNTA3OlxuICAgICAgICBjYXNlIDIxNTA4OiB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHJldHVybiAwOyBcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTE5OiB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHZhciBhcmdwID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgSEVBUDMyWygoYXJncCk+PjIpXSA9IDA7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUyMDoge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gLTI4OyBcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTMxOiB7XG4gICAgICAgICAgdmFyIGFyZ3AgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICByZXR1cm4gRlMuaW9jdGwoc3RyZWFtLCBvcCwgYXJncCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUyMzoge1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTI0OiB7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAtMjg7IFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9sc3RhdDY0KHBhdGgsIGJ1Zikge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KEZTLmxzdGF0LCBwYXRoLCBidWYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9ta2RpcmF0KGRpcmZkLCBwYXRoLCBtb2RlKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICBcbiAgICAgIFxuICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGgtMV0gPT09ICcvJykgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGVuZ3RoLTEpO1xuICAgICAgRlMubWtkaXIocGF0aCwgbW9kZSwgMCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbmV3ZnN0YXRhdChkaXJmZCwgcGF0aCwgYnVmLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICB2YXIgbm9mb2xsb3cgPSBmbGFncyAmIDI1NjtcbiAgICAgIHZhciBhbGxvd0VtcHR5ID0gZmxhZ3MgJiA0MDk2O1xuICAgICAgZmxhZ3MgPSBmbGFncyAmICh+NjQwMCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgsIGFsbG93RW1wdHkpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChub2ZvbGxvdyA/IEZTLmxzdGF0IDogRlMuc3RhdCwgcGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfb3BlbmF0KGRpcmZkLCBwYXRoLCBmbGFncywgdmFyYXJncykge1xuICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIHZhciBtb2RlID0gdmFyYXJncyA/IFNZU0NBTExTLmdldCgpIDogMDtcbiAgICAgIHJldHVybiBGUy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlKS5mZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcmVhZGxpbmthdChkaXJmZCwgcGF0aCwgYnVmLCBidWZzaXplKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICBpZiAoYnVmc2l6ZSA8PSAwKSByZXR1cm4gLTI4O1xuICAgICAgdmFyIHJldCA9IEZTLnJlYWRsaW5rKHBhdGgpO1xuICBcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihidWZzaXplLCBsZW5ndGhCeXRlc1VURjgocmV0KSk7XG4gICAgICB2YXIgZW5kQ2hhciA9IEhFQVA4W2J1ZitsZW5dO1xuICAgICAgc3RyaW5nVG9VVEY4KHJldCwgYnVmLCBidWZzaXplKzEpO1xuICAgICAgXG4gICAgICBcbiAgICAgIEhFQVA4W2J1ZitsZW5dID0gZW5kQ2hhcjtcbiAgICAgIHJldHVybiBsZW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3JtZGlyKHBhdGgpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfc3RhdDY0KHBhdGgsIGJ1Zikge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3VubGlua2F0KGRpcmZkLCBwYXRoLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgaWYgKGZsYWdzID09PSAwKSB7XG4gICAgICAgIEZTLnVubGluayhwYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgPT09IDUxMikge1xuICAgICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFib3J0KCdJbnZhbGlkIGZsYWdzIHBhc3NlZCB0byB1bmxpbmthdCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSTUzRnJvbUk2NChwdHIpIHtcbiAgICAgIHJldHVybiBIRUFQVTMyW3B0cj4+Ml0gKyBIRUFQMzJbcHRyKzQ+PjJdICogNDI5NDk2NzI5NjtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3V0aW1lbnNhdChkaXJmZCwgcGF0aCwgdGltZXMsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCwgdHJ1ZSk7XG4gICAgICBpZiAoIXRpbWVzKSB7XG4gICAgICAgIHZhciBhdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBtdGltZSA9IGF0aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlY29uZHMgPSByZWFkSTUzRnJvbUk2NCh0aW1lcyk7XG4gICAgICAgIHZhciBuYW5vc2Vjb25kcyA9IEhFQVAzMlsoKCh0aW1lcykrKDgpKT4+MildO1xuICAgICAgICBhdGltZSA9IChzZWNvbmRzKjEwMDApICsgKG5hbm9zZWNvbmRzLygxMDAwKjEwMDApKTtcbiAgICAgICAgdGltZXMgKz0gMTY7XG4gICAgICAgIHNlY29uZHMgPSByZWFkSTUzRnJvbUk2NCh0aW1lcyk7XG4gICAgICAgIG5hbm9zZWNvbmRzID0gSEVBUDMyWygoKHRpbWVzKSsoOCkpPj4yKV07XG4gICAgICAgIG10aW1lID0gKHNlY29uZHMqMTAwMCkgKyAobmFub3NlY29uZHMvKDEwMDAqMTAwMCkpO1xuICAgICAgfVxuICAgICAgRlMudXRpbWUocGF0aCwgYXRpbWUsIG10aW1lKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgdmFyIG5vd0lzTW9ub3RvbmljID0gdHJ1ZTs7XG4gIGZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYygpIHtcbiAgICAgIHJldHVybiBub3dJc01vbm90b25pYztcbiAgICB9XG5cbiAgXG4gIGZ1bmN0aW9uIF9faXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiB5ZWFyJTQgPT09IDAgJiYgKHllYXIlMTAwICE9PSAwIHx8IHllYXIlNDAwID09PSAwKTtcbiAgICB9XG4gIFxuICB2YXIgX19NT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA9IFswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdO1xuICBcbiAgdmFyIF9fTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUgPSBbMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtcbiAgZnVuY3Rpb24gX195ZGF5X2Zyb21fZGF0ZShkYXRlKSB7XG4gICAgICB2YXIgaXNMZWFwWWVhciA9IF9faXNMZWFwWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgdmFyIG1vbnRoRGF5c0N1bXVsYXRpdmUgPSAoaXNMZWFwWWVhciA/IF9fTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkUgOiBfX01PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFKTtcbiAgICAgIHZhciB5ZGF5ID0gbW9udGhEYXlzQ3VtdWxhdGl2ZVtkYXRlLmdldE1vbnRoKCldICsgZGF0ZS5nZXREYXRlKCkgLSAxOyBcbiAgXG4gICAgICByZXR1cm4geWRheTtcbiAgICB9XG4gIGZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHJlYWRJNTNGcm9tSTY0KHRpbWUpKjEwMDApO1xuICAgICAgSEVBUDMyWygodG1QdHIpPj4yKV0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKyg4KSk+PjIpXSA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTYpKT4+MildID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjApKT4+MildID0gZGF0ZS5nZXRGdWxsWWVhcigpLTE5MDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyNCkpPj4yKV0gPSBkYXRlLmdldERheSgpO1xuICBcbiAgICAgIHZhciB5ZGF5ID0gX195ZGF5X2Zyb21fZGF0ZShkYXRlKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDM2KSk+PjIpXSA9IC0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjApO1xuICBcbiAgICAgIFxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDYsIDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBkc3QgPSAoc3VtbWVyT2Zmc2V0ICE9IHdpbnRlck9mZnNldCAmJiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT0gTWF0aC5taW4od2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMzIpKT4+MildID0gZHN0O1xuICAgIH1cblxuICBcbiAgXG4gIGZ1bmN0aW9uIF9fbW1hcF9qcyhsZW4sIHByb3QsIGZsYWdzLCBmZCwgb2ZmLCBhbGxvY2F0ZWQsIGFkZHIpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHZhciByZXMgPSBGUy5tbWFwKHN0cmVhbSwgbGVuLCBvZmYsIHByb3QsIGZsYWdzKTtcbiAgICAgIHZhciBwdHIgPSByZXMucHRyO1xuICAgICAgSEVBUDMyWygoYWxsb2NhdGVkKT4+MildID0gcmVzLmFsbG9jYXRlZDtcbiAgICAgIEhFQVBVMzJbKChhZGRyKT4+MildID0gcHRyO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBcbiAgXG4gIGZ1bmN0aW9uIF9fbXVubWFwX2pzKGFkZHIsIGxlbiwgcHJvdCwgZmxhZ3MsIGZkLCBvZmZzZXQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIGlmIChwcm90ICYgMikge1xuICAgICAgICBTWVNDQUxMUy5kb01zeW5jKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIEZTLm11bm1hcChzdHJlYW0pO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvY2F0ZVVURjgoc3RyKSB7XG4gICAgICB2YXIgc2l6ZSA9IGxlbmd0aEJ5dGVzVVRGOChzdHIpICsgMTtcbiAgICAgIHZhciByZXQgPSBfbWFsbG9jKHNpemUpO1xuICAgICAgaWYgKHJldCkgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBmdW5jdGlvbiBfX3R6c2V0X2pzKHRpbWV6b25lLCBkYXlsaWdodCwgdHpuYW1lKSB7XG4gICAgICBcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDYsIDEpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcbiAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgSEVBUFUzMlsoKHRpbWV6b25lKT4+MildID0gc3RkVGltZXpvbmVPZmZzZXQgKiA2MDtcbiAgXG4gICAgICBIRUFQMzJbKChkYXlsaWdodCk+PjIpXSA9IE51bWJlcih3aW50ZXJPZmZzZXQgIT0gc3VtbWVyT2Zmc2V0KTtcbiAgXG4gICAgICBmdW5jdGlvbiBleHRyYWN0Wm9uZShkYXRlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRhdGUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBcIkdNVFwiO1xuICAgICAgfTtcbiAgICAgIHZhciB3aW50ZXJOYW1lID0gZXh0cmFjdFpvbmUod2ludGVyKTtcbiAgICAgIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyKTtcbiAgICAgIHZhciB3aW50ZXJOYW1lUHRyID0gYWxsb2NhdGVVVEY4KHdpbnRlck5hbWUpO1xuICAgICAgdmFyIHN1bW1lck5hbWVQdHIgPSBhbGxvY2F0ZVVURjgoc3VtbWVyTmFtZSk7XG4gICAgICBpZiAoc3VtbWVyT2Zmc2V0IDwgd2ludGVyT2Zmc2V0KSB7XG4gICAgICAgIFxuICAgICAgICBIRUFQVTMyWygodHpuYW1lKT4+MildID0gd2ludGVyTmFtZVB0cjtcbiAgICAgICAgSEVBUFUzMlsoKCh0em5hbWUpKyg0KSk+PjIpXSA9IHN1bW1lck5hbWVQdHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIRUFQVTMyWygodHpuYW1lKT4+MildID0gc3VtbWVyTmFtZVB0cjtcbiAgICAgICAgSEVBUFUzMlsoKCh0em5hbWUpKyg0KSk+PjIpXSA9IHdpbnRlck5hbWVQdHI7XG4gICAgICB9XG4gICAgfVxuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2RhdGVfbm93KCkge1xuICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgfVxuXG4gIHZhciBfZW1zY3JpcHRlbl9nZXRfbm93O19lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgO1xuXG4gIGZ1bmN0aW9uIGdldEhlYXBNYXgoKSB7XG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIHJldHVybiAyMTQ3NDgzNjQ4O1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIoc2l6ZSkge1xuICAgICAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIFxuICAgICAgICB3YXNtTWVtb3J5Lmdyb3coKHNpemUgLSBiLmJ5dGVMZW5ndGggKyA2NTUzNSkgPj4+IDE2KTsgXG4gICAgICAgIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gICAgICAgIHJldHVybiAxIDtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICB9XG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpIHtcbiAgICAgIHZhciBvbGRTaXplID0gSEVBUFU4Lmxlbmd0aDtcbiAgICAgIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuICAgICAgXG4gICAgICBcbiAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgXG4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIG1heEhlYXBTaXplID0gZ2V0SGVhcE1heCgpO1xuICAgICAgaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIFxuICAgICAgbGV0IGFsaWduVXAgPSAoeCwgbXVsdGlwbGUpID0+IHggKyAobXVsdGlwbGUgLSB4ICUgbXVsdGlwbGUpICUgbXVsdGlwbGU7XG4gIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgZm9yICh2YXIgY3V0RG93biA9IDE7IGN1dERvd24gPD0gNDsgY3V0RG93biAqPSAyKSB7XG4gICAgICAgIHZhciBvdmVyR3Jvd25IZWFwU2l6ZSA9IG9sZFNpemUgKiAoMSArIDAuMiAvIGN1dERvd24pOyBcbiAgICAgICAgXG4gICAgICAgIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUsIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYgKTtcbiAgXG4gICAgICAgIHZhciBuZXdTaXplID0gTWF0aC5taW4obWF4SGVhcFNpemUsIGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSwgb3Zlckdyb3duSGVhcFNpemUpLCA2NTUzNikpO1xuICBcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihuZXdTaXplKTtcbiAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gIFxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIHZhciBFTlYgPSB7fTtcbiAgXG4gIGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVOYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXNQcm9ncmFtIHx8ICcuL3RoaXMucHJvZ3JhbSc7XG4gICAgfVxuICBmdW5jdGlvbiBnZXRFbnZTdHJpbmdzKCkge1xuICAgICAgaWYgKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3MpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgbGFuZyA9ICgodHlwZW9mIG5hdmlnYXRvciA9PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0pIHx8ICdDJykucmVwbGFjZSgnLScsICdfJykgKyAnLlVURi04JztcbiAgICAgICAgdmFyIGVudiA9IHtcbiAgICAgICAgICAnVVNFUic6ICd3ZWJfdXNlcicsXG4gICAgICAgICAgJ0xPR05BTUUnOiAnd2ViX3VzZXInLFxuICAgICAgICAgICdQQVRIJzogJy8nLFxuICAgICAgICAgICdQV0QnOiAnLycsXG4gICAgICAgICAgJ0hPTUUnOiAnL2hvbWUvd2ViX3VzZXInLFxuICAgICAgICAgICdMQU5HJzogbGFuZyxcbiAgICAgICAgICAnXyc6IGdldEV4ZWN1dGFibGVOYW1lKClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHggaW4gRU5WKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKEVOVlt4XSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgZW52W3hdO1xuICAgICAgICAgIGVsc2UgZW52W3hdID0gRU5WW3hdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIHggaW4gZW52KSB7XG4gICAgICAgICAgc3RyaW5ncy5wdXNoKHggKyAnPScgKyBlbnZbeF0pO1xuICAgICAgICB9XG4gICAgICAgIGdldEVudlN0cmluZ3Muc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzO1xuICAgIH1cbiAgXG4gIFxuICBmdW5jdGlvbiB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyLCBidWZmZXIsIGRvbnRBZGROdWxsKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBIRUFQOFsoKGJ1ZmZlcisrKT4+MCldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghZG9udEFkZE51bGwpIEhFQVA4WygoYnVmZmVyKT4+MCldID0gMDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBfZW52aXJvbl9nZXQoX19lbnZpcm9uLCBlbnZpcm9uX2J1Zikge1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLCBpKSB7XG4gICAgICAgIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gICAgICAgIEhFQVBVMzJbKCgoX19lbnZpcm9uKSsoaSo0KSk+PjIpXSA9IHB0cjtcbiAgICAgICAgd3JpdGVBc2NpaVRvTWVtb3J5KHN0cmluZywgcHRyKTtcbiAgICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gIFxuICBmdW5jdGlvbiBfZW52aXJvbl9zaXplc19nZXQocGVudmlyb25fY291bnQsIHBlbnZpcm9uX2J1Zl9zaXplKSB7XG4gICAgICB2YXIgc3RyaW5ncyA9IGdldEVudlN0cmluZ3MoKTtcbiAgICAgIEhFQVBVMzJbKChwZW52aXJvbl9jb3VudCk+PjIpXSA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBidWZTaXplICs9IHN0cmluZy5sZW5ndGggKyAxO1xuICAgICAgfSk7XG4gICAgICBIRUFQVTMyWygocGVudmlyb25fYnVmX3NpemUpPj4yKV0gPSBidWZTaXplO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gIGZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZmRfZmRzdGF0X2dldChmZCwgcGJ1Zikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgXG4gICAgICBcbiAgICAgIHZhciB0eXBlID0gc3RyZWFtLnR0eSA/IDIgOlxuICAgICAgICAgICAgICAgICBGUy5pc0RpcihzdHJlYW0ubW9kZSkgPyAzIDpcbiAgICAgICAgICAgICAgICAgRlMuaXNMaW5rKHN0cmVhbS5tb2RlKSA/IDcgOlxuICAgICAgICAgICAgICAgICA0O1xuICAgICAgSEVBUDhbKChwYnVmKT4+MCldID0gdHlwZTtcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICBcbiAgZnVuY3Rpb24gZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgICB2YXIgcHRyID0gSEVBUFUzMlsoKGlvdik+PjIpXTtcbiAgICAgICAgdmFyIGxlbiA9IEhFQVBVMzJbKCgoaW92KSsoNCkpPj4yKV07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICB2YXIgY3VyciA9IEZTLnJlYWQoc3RyZWFtLCBIRUFQOCxwdHIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGN1cnIgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIHJldCArPSBjdXJyO1xuICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWs7IFxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gY3VycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBfZmRfcmVhZChmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHZhciBudW0gPSBkb1JlYWR2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgICAgSEVBUFUzMlsoKHBudW0pPj4yKV0gPSBudW07XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgXG4gIFxuICBcbiAgXG4gIGZ1bmN0aW9uIF9mZF9zZWVrKGZkLCAgb2Zmc2V0LCB3aGVuY2UsIG5ld09mZnNldCkge1xuICB0cnkge1xuICBcbiAgICAgIG9mZnNldCA9IGJpZ2ludFRvSTUzQ2hlY2tlZChvZmZzZXQpOyBpZiAoaXNOYU4ob2Zmc2V0KSkgcmV0dXJuIDYxO1xuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBGUy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7XG4gICAgICAodGVtcEk2NCA9IFtzdHJlYW0ucG9zaXRpb24+Pj4wLCh0ZW1wRG91YmxlPXN0cmVhbS5wb3NpdGlvbiwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKG5ld09mZnNldCk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKG5ld09mZnNldCkrKDQpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICBpZiAoc3RyZWFtLmdldGRlbnRzICYmIG9mZnNldCA9PT0gMCAmJiB3aGVuY2UgPT09IDApIHN0cmVhbS5nZXRkZW50cyA9IG51bGw7IFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9mZF9zeW5jKGZkKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMgJiYgc3RyZWFtLnN0cmVhbV9vcHMuZnN5bmMpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLmZzeW5jKHN0cmVhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDsgXG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbiAgfVxuXG4gIFxuICBmdW5jdGlvbiBkb1dyaXRldihzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICAgICAgICB2YXIgcHRyID0gSEVBUFUzMlsoKGlvdik+PjIpXTtcbiAgICAgICAgdmFyIGxlbiA9IEhFQVBVMzJbKCgoaW92KSsoNCkpPj4yKV07XG4gICAgICAgIGlvdiArPSA4O1xuICAgICAgICB2YXIgY3VyciA9IEZTLndyaXRlKHN0cmVhbSwgSEVBUDgscHRyLCBsZW4sIG9mZnNldCk7XG4gICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICByZXQgKz0gY3VycjtcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGN1cnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgdmFyIG51bSA9IGRvV3JpdGV2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgICAgSEVBUFUzMlsoKHBudW0pPj4yKV0gPSBudW07XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgdmFyIEZTTm9kZSA9ICBmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpIHtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcGFyZW50ID0gdGhpczsgIFxuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLm1vdW50ID0gcGFyZW50Lm1vdW50O1xuICAgIHRoaXMubW91bnRlZCA9IG51bGw7XG4gICAgdGhpcy5pZCA9IEZTLm5leHRJbm9kZSsrO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLm5vZGVfb3BzID0ge307XG4gICAgdGhpcy5zdHJlYW1fb3BzID0ge307XG4gICAgdGhpcy5yZGV2ID0gcmRldjtcbiAgfTtcbiAgdmFyIHJlYWRNb2RlID0gMjkyIHwgNzM7XG4gIHZhciB3cml0ZU1vZGUgPSAxNDY7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTTm9kZS5wcm90b3R5cGUsIHtcbiAgIHJlYWQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHJlYWRNb2RlKSA9PT0gcmVhZE1vZGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICB2YWwgPyB0aGlzLm1vZGUgfD0gcmVhZE1vZGUgOiB0aGlzLm1vZGUgJj0gfnJlYWRNb2RlO1xuICAgIH1cbiAgIH0sXG4gICB3cml0ZToge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiAodGhpcy5tb2RlICYgd3JpdGVNb2RlKSA9PT0gd3JpdGVNb2RlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgdmFsID8gdGhpcy5tb2RlIHw9IHdyaXRlTW9kZSA6IHRoaXMubW9kZSAmPSB+d3JpdGVNb2RlO1xuICAgIH1cbiAgIH0sXG4gICBpc0ZvbGRlcjoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBGUy5pc0Rpcih0aGlzLm1vZGUpO1xuICAgIH1cbiAgIH0sXG4gICBpc0RldmljZToge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBGUy5pc0NocmRldih0aGlzLm1vZGUpO1xuICAgIH1cbiAgIH1cbiAgfSk7XG4gIEZTLkZTTm9kZSA9IEZTTm9kZTtcbiAgRlMuc3RhdGljSW5pdCgpOztcbnZhciBBU1NFUlRJT05TID0gZmFsc2U7XG5cbnZhciBhc21MaWJyYXJ5QXJnID0ge1xuICBcIl9fc3lzY2FsbF9jaG1vZFwiOiBfX19zeXNjYWxsX2NobW9kLFxuICBcIl9fc3lzY2FsbF9mYWNjZXNzYXRcIjogX19fc3lzY2FsbF9mYWNjZXNzYXQsXG4gIFwiX19zeXNjYWxsX2ZjaG1vZFwiOiBfX19zeXNjYWxsX2ZjaG1vZCxcbiAgXCJfX3N5c2NhbGxfZmNob3duMzJcIjogX19fc3lzY2FsbF9mY2hvd24zMixcbiAgXCJfX3N5c2NhbGxfZmNudGw2NFwiOiBfX19zeXNjYWxsX2ZjbnRsNjQsXG4gIFwiX19zeXNjYWxsX2ZzdGF0NjRcIjogX19fc3lzY2FsbF9mc3RhdDY0LFxuICBcIl9fc3lzY2FsbF9mdHJ1bmNhdGU2NFwiOiBfX19zeXNjYWxsX2Z0cnVuY2F0ZTY0LFxuICBcIl9fc3lzY2FsbF9nZXRjd2RcIjogX19fc3lzY2FsbF9nZXRjd2QsXG4gIFwiX19zeXNjYWxsX2lvY3RsXCI6IF9fX3N5c2NhbGxfaW9jdGwsXG4gIFwiX19zeXNjYWxsX2xzdGF0NjRcIjogX19fc3lzY2FsbF9sc3RhdDY0LFxuICBcIl9fc3lzY2FsbF9ta2RpcmF0XCI6IF9fX3N5c2NhbGxfbWtkaXJhdCxcbiAgXCJfX3N5c2NhbGxfbmV3ZnN0YXRhdFwiOiBfX19zeXNjYWxsX25ld2ZzdGF0YXQsXG4gIFwiX19zeXNjYWxsX29wZW5hdFwiOiBfX19zeXNjYWxsX29wZW5hdCxcbiAgXCJfX3N5c2NhbGxfcmVhZGxpbmthdFwiOiBfX19zeXNjYWxsX3JlYWRsaW5rYXQsXG4gIFwiX19zeXNjYWxsX3JtZGlyXCI6IF9fX3N5c2NhbGxfcm1kaXIsXG4gIFwiX19zeXNjYWxsX3N0YXQ2NFwiOiBfX19zeXNjYWxsX3N0YXQ2NCxcbiAgXCJfX3N5c2NhbGxfdW5saW5rYXRcIjogX19fc3lzY2FsbF91bmxpbmthdCxcbiAgXCJfX3N5c2NhbGxfdXRpbWVuc2F0XCI6IF9fX3N5c2NhbGxfdXRpbWVuc2F0LFxuICBcIl9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljXCI6IF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyxcbiAgXCJfbG9jYWx0aW1lX2pzXCI6IF9fbG9jYWx0aW1lX2pzLFxuICBcIl9tbWFwX2pzXCI6IF9fbW1hcF9qcyxcbiAgXCJfbXVubWFwX2pzXCI6IF9fbXVubWFwX2pzLFxuICBcIl90enNldF9qc1wiOiBfX3R6c2V0X2pzLFxuICBcImVtc2NyaXB0ZW5fZGF0ZV9ub3dcIjogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gIFwiZW1zY3JpcHRlbl9nZXRfbm93XCI6IF9lbXNjcmlwdGVuX2dldF9ub3csXG4gIFwiZW1zY3JpcHRlbl9yZXNpemVfaGVhcFwiOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgXCJlbnZpcm9uX2dldFwiOiBfZW52aXJvbl9nZXQsXG4gIFwiZW52aXJvbl9zaXplc19nZXRcIjogX2Vudmlyb25fc2l6ZXNfZ2V0LFxuICBcImZkX2Nsb3NlXCI6IF9mZF9jbG9zZSxcbiAgXCJmZF9mZHN0YXRfZ2V0XCI6IF9mZF9mZHN0YXRfZ2V0LFxuICBcImZkX3JlYWRcIjogX2ZkX3JlYWQsXG4gIFwiZmRfc2Vla1wiOiBfZmRfc2VlayxcbiAgXCJmZF9zeW5jXCI6IF9mZF9zeW5jLFxuICBcImZkX3dyaXRlXCI6IF9mZF93cml0ZSxcbiAgXCJtZW1vcnlcIjogd2FzbU1lbW9yeVxufTtcbnZhciBhc20gPSBjcmVhdGVXYXNtKCk7XG5cbnZhciBfX193YXNtX2NhbGxfY3RvcnMgPSBNb2R1bGVbXCJfX193YXNtX2NhbGxfY3RvcnNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfX193YXNtX2NhbGxfY3RvcnMgPSBNb2R1bGVbXCJfX193YXNtX2NhbGxfY3RvcnNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJfX3dhc21fY2FsbF9jdG9yc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0YXR1czY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RhdHVzNjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdGF0dXM2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0YXR1czY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdGF0dXM2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0YXR1cyA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0YXR1c1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0YXR1cyA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0YXR1c1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RhdHVzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZGJfc3RhdHVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfc3RhdHVzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZGJfc3RhdHVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfc3RhdHVzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kYl9zdGF0dXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19tc2l6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX21zaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfbXNpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19tc2l6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfbXNpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192ZnNfZmluZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Zmc19maW5kXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmZzX2ZpbmQgPSBNb2R1bGVbXCJfc3FsaXRlM192ZnNfZmluZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmZzX2ZpbmRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19pbml0aWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfaW5pdGlhbGl6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2luaXRpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19pbml0aWFsaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19pbml0aWFsaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfbWFsbG9jID0gTW9kdWxlW1wiX3NxbGl0ZTNfbWFsbG9jXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfbWFsbG9jID0gTW9kdWxlW1wiX3NxbGl0ZTNfbWFsbG9jXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19tYWxsb2NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19mcmVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZnJlZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2ZyZWUgPSBNb2R1bGVbXCJfc3FsaXRlM19mcmVlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19mcmVlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmZzX3JlZ2lzdGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmZzX3JlZ2lzdGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmZzX3JlZ2lzdGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmZzX3JlZ2lzdGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192ZnNfcmVnaXN0ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192ZnNfdW5yZWdpc3RlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Zmc191bnJlZ2lzdGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM192ZnNfdW5yZWdpc3RlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmZzX3VucmVnaXN0ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19tYWxsb2M2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX21hbGxvYzY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfbWFsbG9jNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19tYWxsb2M2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfbWFsbG9jNjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZWFsbG9jID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVhbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3JlYWxsb2MgPSBNb2R1bGVbXCJfc3FsaXRlM19yZWFsbG9jXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZWFsbG9jXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVhbGxvYzY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVhbGxvYzY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVhbGxvYzY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVhbGxvYzY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZWFsbG9jNjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfdGV4dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV90ZXh0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV90ZXh0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmFuZG9tbmVzcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3JhbmRvbW5lc3NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yYW5kb21uZXNzID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmFuZG9tbmVzc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmFuZG9tbmVzc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0cmljbXAgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJpY21wXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RyaWNtcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cmljbXBcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0cmljbXBcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdHJuaWNtcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cm5pY21wXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RybmljbXAgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJuaWNtcFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RybmljbXBcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM191cmlfcGFyYW1ldGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX3BhcmFtZXRlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfcGFyYW1ldGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM191cmlfcGFyYW1ldGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX19fZXJybm9fbG9jYXRpb24gPSBNb2R1bGVbXCJfX19lcnJub19sb2NhdGlvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9fX2Vycm5vX2xvY2F0aW9uID0gTW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJfX2Vycm5vX2xvY2F0aW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdXJpX2Jvb2xlYW4gPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfYm9vbGVhblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3VyaV9ib29sZWFuID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX2Jvb2xlYW5cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3VyaV9ib29sZWFuXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc2VyaWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2VyaWFsaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc2VyaWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2VyaWFsaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zZXJpYWxpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmVwYXJlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJlcGFyZV92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXBhcmVfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmVwYXJlX3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmVwYXJlX3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RlcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0ZXBcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdGVwID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RlcFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RlcFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9pbnQ2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9pbnQ2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX2ludDY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXNldFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzZXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc2V0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXhlYyA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4ZWNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19leGVjID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXhlY1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXhlY1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5faW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9pbnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl9pbnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19maW5hbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2ZpbmFsaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZmluYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19maW5hbGl6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZmluYWxpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19maWxlX2NvbnRyb2wgPSBNb2R1bGVbXCJfc3FsaXRlM19maWxlX2NvbnRyb2xcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19maWxlX2NvbnRyb2wgPSBNb2R1bGVbXCJfc3FsaXRlM19maWxlX2NvbnRyb2xcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2ZpbGVfY29udHJvbFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl9uYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX25hbWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9uYW1lXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fbmFtZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX3RleHRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl90ZXh0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fdGV4dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl90eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX3R5cGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fdHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl90eXBlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fdHlwZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2Vycm1zZyA9IE1vZHVsZVtcIl9zcWxpdGUzX2Vycm1zZ1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2Vycm1zZyA9IE1vZHVsZVtcIl9zcWxpdGUzX2Vycm1zZ1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXJybXNnXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZGVzZXJpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19kZXNlcmlhbGl6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2Rlc2VyaWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGVzZXJpYWxpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2Rlc2VyaWFsaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MgPSBNb2R1bGVbXCJfc3FsaXRlM19jbGVhcl9iaW5kaW5nc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NsZWFyX2JpbmRpbmdzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2Jsb2JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfYmxvYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfYmxvYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2J5dGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfYnl0ZXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9ieXRlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2J5dGVzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9ieXRlc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2RvdWJsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2RvdWJsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfZG91YmxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfaW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfaW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfaW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfaW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9pbnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2ludDY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9pbnQ2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfaW50NjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9zdWJ0eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfc3VidHlwZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX3N1YnR5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9zdWJ0eXBlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9zdWJ0eXBlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfcG9pbnRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3BvaW50ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfcG9pbnRlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfcG9pbnRlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX3R5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV90eXBlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfdHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3R5cGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX3R5cGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX25vY2hhbmdlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9ub2NoYW5nZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfbm9jaGFuZ2VcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9mcm9tYmluZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2Zyb21iaW5kXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9mcm9tYmluZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfZnJvbWJpbmRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9kdXAgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9kdXBcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9kdXAgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9kdXBcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2R1cFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9mcmVlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfZnJlZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2ZyZWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2ZyZWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9ibG9iXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfYmxvYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2Jsb2JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZ1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZG91YmxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfZG91YmxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfZXJyb3JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfaW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2ludFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfaW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfaW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2ludDY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2ludDY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfaW50NjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfbnVsbCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9udWxsXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X251bGwgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfbnVsbFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X251bGxcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfcG9pbnRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9wb2ludGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfcG9pbnRlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X3BvaW50ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfc3VidHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfc3VidHlwZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X3N1YnR5cGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF90ZXh0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfdGV4dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X3RleHRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3VzZXJfZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3VzZXJfZGF0YVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3VzZXJfZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3VzZXJfZGF0YVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdXNlcl9kYXRhXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfbm9jaGFuZ2VcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX25vY2hhbmdlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9ub2NoYW5nZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2luX2ZpcnN0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9pbl9maXJzdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfaW5fZmlyc3RcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfaW5fZmlyc3RcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX2luX25leHQgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2luX25leHRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX2luX25leHQgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2luX25leHRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfaW5fbmV4dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2dldF9hdXhkYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfZ2V0X2F1eGRhdGFcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19nZXRfYXV4ZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX2dldF9hdXhkYXRhXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19nZXRfYXV4ZGF0YVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3NldF9hdXhkYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2V0X2F1eGRhdGFcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zZXRfYXV4ZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3NldF9hdXhkYXRhXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zZXRfYXV4ZGF0YVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9jb3VudFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9jb3VudFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX2NvdW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZGF0YV9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2RhdGFfY291bnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kYXRhX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGF0YV9jb3VudFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZGF0YV9jb3VudFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2Jsb2JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9ibG9iXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fYmxvYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl9ieXRlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9ieXRlc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9ieXRlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9ieXRlc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX2J5dGVzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9kb3VibGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2RvdWJsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX2RvdWJsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl92YWx1ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl92YWx1ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl92YWx1ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl92YWx1ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX3ZhbHVlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9ibG9iXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9ibG9iXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX2Jsb2JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfZG91YmxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2RvdWJsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9kb3VibGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfaW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2ludFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9pbnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9pbnQ2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2ludDY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX2ludDY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9udWxsID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9udWxsXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9udWxsID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9udWxsXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX251bGxcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX3BvaW50ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3BvaW50ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX3BvaW50ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3BvaW50ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfcG9pbnRlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfdGV4dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfdGV4dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF90ZXh0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXggPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXhcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZGJfaGFuZGxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfaGFuZGxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZGJfaGFuZGxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfaGFuZGxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kYl9oYW5kbGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdG10X3JlYWRvbmx5ID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RtdF9yZWFkb25seVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfcmVhZG9ubHkgPSBNb2R1bGVbXCJfc3FsaXRlM19zdG10X3JlYWRvbmx5XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdG10X3JlYWRvbmx5XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RtdF9pc2V4cGxhaW4gPSBNb2R1bGVbXCJfc3FsaXRlM19zdG10X2lzZXhwbGFpblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfaXNleHBsYWluID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RtdF9pc2V4cGxhaW5cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0bXRfaXNleHBsYWluXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RtdF9zdGF0dXMgPSBNb2R1bGVbXCJfc3FsaXRlM19zdG10X3N0YXR1c1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0bXRfc3RhdHVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RtdF9zdGF0dXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0bXRfc3RhdHVzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3FsID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3FsXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3FsID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3FsXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zcWxcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19leHBhbmRlZF9zcWwgPSBNb2R1bGVbXCJfc3FsaXRlM19leHBhbmRlZF9zcWxcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19leHBhbmRlZF9zcWwgPSBNb2R1bGVbXCJfc3FsaXRlM19leHBhbmRlZF9zcWxcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2V4cGFuZGVkX3NxbFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9vbGQgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfb2xkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9vbGRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXVwZGF0ZV9vbGRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmV1cGRhdGVfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfY291bnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfY291bnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJldXBkYXRlX2RlcHRoXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9uZXcgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfbmV3XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX25ldyA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9uZXdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXVwZGF0ZV9uZXdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3NldF9hdXRob3JpemVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zZXRfYXV0aG9yaXplciA9IE1vZHVsZVtcIl9zcWxpdGUzX3NldF9hdXRob3JpemVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zZXRfYXV0aG9yaXplclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0cmdsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJnbG9iXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RyZ2xvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cmdsb2JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0cmdsb2JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdHJsaWtlID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RybGlrZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0cmxpa2UgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJsaWtlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdHJsaWtlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19hdXRvX2V4dGVuc2lvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfYXV0b19leHRlbnNpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2F1dG9fZXh0ZW5zaW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmVwYXJlX3YzID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJlcGFyZV92M1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXBhcmVfdjMgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmVwYXJlX3YzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmVwYXJlX3YzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfbW9kdWxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX21vZHVsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY3JlYXRlX21vZHVsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kcm9wX21vZHVsZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19kcm9wX21vZHVsZXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kcm9wX21vZHVsZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19kcm9wX21vZHVsZXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2Ryb3BfbW9kdWxlc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2RlY2xhcmVfdnRhYiA9IE1vZHVsZVtcIl9zcWxpdGUzX2RlY2xhcmVfdnRhYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2RlY2xhcmVfdnRhYiA9IE1vZHVsZVtcIl9zcWxpdGUzX2RlY2xhcmVfdnRhYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZGVjbGFyZV92dGFiXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfb25fY29uZmxpY3RcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9vbl9jb25mbGljdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX2NvbGxhdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX2NvbGxhdGlvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfaW4gPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2luXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9pbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfaW5cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfaW5cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX3Joc192YWx1ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX3Joc192YWx1ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9yaHNfdmFsdWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX2Rpc3RpbmN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9kaXN0aW5jdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfZGlzdGluY3QgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2Rpc3RpbmN0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX2Rpc3RpbmN0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfa2V5d29yZF9uYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfa2V5d29yZF9uYW1lXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfa2V5d29yZF9uYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfa2V5d29yZF9uYW1lXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19rZXl3b3JkX25hbWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19rZXl3b3JkX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfa2V5d29yZF9jb3VudFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2tleXdvcmRfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19rZXl3b3JkX2NvdW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19rZXl3b3JkX2NvdW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfa2V5d29yZF9jaGVjayA9IE1vZHVsZVtcIl9zcWxpdGUzX2tleXdvcmRfY2hlY2tcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19rZXl3b3JkX2NoZWNrID0gTW9kdWxlW1wiX3NxbGl0ZTNfa2V5d29yZF9jaGVja1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfa2V5d29yZF9jaGVja1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbXBsZXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tcGxldGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb21wbGV0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbXBsZXRlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb21wbGV0ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2xpYnZlcnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19saWJ2ZXJzaW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfbGlidmVyc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2xpYnZlcnNpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2xpYnZlcnNpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlciA9IE1vZHVsZVtcIl9zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zaHV0ZG93biA9IE1vZHVsZVtcIl9zcWxpdGUzX3NodXRkb3duXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc2h1dGRvd24gPSBNb2R1bGVbXCJfc3FsaXRlM19zaHV0ZG93blwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc2h1dGRvd25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCA9IE1vZHVsZVtcIl9zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXCJfc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NoYW5nZXM2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NoYW5nZXM2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NoYW5nZXM2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NoYW5nZXM2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY2hhbmdlczY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY2hhbmdlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2NoYW5nZXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jaGFuZ2VzID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2hhbmdlc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY2hhbmdlc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdG90YWxfY2hhbmdlczY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdG90YWxfY2hhbmdlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3RvdGFsX2NoYW5nZXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM190b3RhbF9jaGFuZ2VzID0gTW9kdWxlW1wiX3NxbGl0ZTNfdG90YWxfY2hhbmdlc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdG90YWxfY2hhbmdlc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3R4bl9zdGF0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3R4bl9zdGF0ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3R4bl9zdGF0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3R4bl9zdGF0ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdHhuX3N0YXRlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY2xvc2VfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jbG9zZV92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2Nsb3NlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2xvc2VfdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2Nsb3NlX3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYnVzeV9oYW5kbGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfYnVzeV9oYW5kbGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYnVzeV9oYW5kbGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfYnVzeV9oYW5kbGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19idXN5X2hhbmRsZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcm9ncmVzc19oYW5kbGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYnVzeV90aW1lb3V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYnVzeV90aW1lb3V0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYnVzeV90aW1lb3V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYnVzeV90aW1lb3V0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19idXN5X3RpbWVvdXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19vdmVybG9hZF9mdW5jdGlvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3RyYWNlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdHJhY2VfdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM190cmFjZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX3RyYWNlX3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM190cmFjZV92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbW1pdF9ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tbWl0X2hvb2tcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb21taXRfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbW1pdF9ob29rXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb21taXRfaG9va1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3VwZGF0ZV9ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXBkYXRlX2hvb2tcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM191cGRhdGVfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX3VwZGF0ZV9ob29rXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM191cGRhdGVfaG9va1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3JvbGxiYWNrX2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM19yb2xsYmFja19ob29rXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX3JvbGxiYWNrX2hvb2tcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3JvbGxiYWNrX2hvb2tcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmV1cGRhdGVfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfaG9va1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJldXBkYXRlX2hvb2tcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19lcnJvcl9vZmZzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJvcl9vZmZzZXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19lcnJvcl9vZmZzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJvcl9vZmZzZXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2Vycm9yX29mZnNldFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2VycmNvZGUgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJjb2RlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXJyY29kZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2VycmNvZGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2VycmNvZGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUgPSBNb2R1bGVbXCJfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19leHRlbmRlZF9lcnJjb2RlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXJyc3RyID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJyc3RyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXJyc3RyID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJyc3RyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19lcnJzdHJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19saW1pdCA9IE1vZHVsZVtcIl9zcWxpdGUzX2xpbWl0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfbGltaXQgPSBNb2R1bGVbXCJfc3FsaXRlM19saW1pdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfbGltaXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19vcGVuID0gTW9kdWxlW1wiX3NxbGl0ZTNfb3BlblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX29wZW4gPSBNb2R1bGVbXCJfc3FsaXRlM19vcGVuXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19vcGVuXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfb3Blbl92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX29wZW5fdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19vcGVuX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfb3Blbl92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfb3Blbl92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sbGF0aW9uX25lZWRlZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2dldF9hdXRvY29tbWl0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19nZXRfYXV0b2NvbW1pdCA9IE1vZHVsZVtcIl9zcWxpdGUzX2dldF9hdXRvY29tbWl0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19nZXRfYXV0b2NvbW1pdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM191cmlfa2V5ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX2tleVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3VyaV9rZXkgPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfa2V5XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM191cmlfa2V5XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdXJpX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX2ludDY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdXJpX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX2ludDY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM191cmlfaW50NjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kYl9uYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfbmFtZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2RiX25hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9uYW1lXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kYl9uYW1lXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZGJfZmlsZW5hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9maWxlbmFtZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2RiX2ZpbGVuYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfZmlsZW5hbWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2RiX2ZpbGVuYW1lXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21waWxlb3B0aW9uX2dldFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fZGlmZiA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9kaWZmXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2RpZmYgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fZGlmZlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2RpZmZcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fYXR0YWNoID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2F0dGFjaFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fYXR0YWNoXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fYXR0YWNoXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jcmVhdGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2NyZWF0ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9kZWxldGUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fZGVsZXRlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9kZWxldGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9kZWxldGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fZW5hYmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9lbmFibGUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fZW5hYmxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fZW5hYmxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25faW5kaXJlY3RcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHkgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25faXNlbXB0eVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2lzZW1wdHlcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZyA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZ1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9uZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X25leHQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9uZXh0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9uZXh0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfb3AgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9vcFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X29wID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfb3BcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X29wXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfcGsgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9wa1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3BrID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfcGtcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X3BrXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfb2xkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9vbGRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9uZXcgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9uZXdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9uZXcgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9uZXdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X25ld1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3RcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9jb25mbGljdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0c1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cyA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0c1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9pbnZlcnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX25ldyA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZWdyb3VwX25ld1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZWdyb3VwX2FkZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9jb25jYXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fY29uZmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NvbmZpZ1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY29uZmlnXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fY29uZmlnXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc291cmNlaWQgPSBNb2R1bGVbXCJfc3FsaXRlM19zb3VyY2VpZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3NvdXJjZWlkID0gTW9kdWxlW1wiX3NxbGl0ZTNfc291cmNlaWRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3NvdXJjZWlkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcHRyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcHRyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3BzdGFja19wdHJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfYWxsb2MgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19hbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfYWxsb2NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3BzdGFja19xdW90YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19xdW90YVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGFcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX2Vycm9yID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9lcnJvclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2Vycm9yXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX2Vycm9yXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cnVjdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9zdHJ1Y3RcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cnVjdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X3N0cnVjdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZW51bV9qc29uID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2VudW1fanNvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZW51bV9qc29uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2VudW1fanNvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdmZzX3VubGluayA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdmZzX3VubGlua1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdmZzX3VubGluayA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdmZzX3VubGlua1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV92ZnNfdW5saW5rXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl92ZnMgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX3Zmc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfdmZzID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl92ZnNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfdmZzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl9yZXNldCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfcmVzZXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX3Jlc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9yZXNldFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl9yZXNldFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfZXhwb3J0X2NodW5rZWQgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2V4cG9ydF9jaHVua2VkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfZXhwb3J0X2NodW5rZWRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfZXhwb3J0X2NodW5rZWRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjayA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2tcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFja1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFja1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdnRhYl9jb25maWdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Z0YWJfY29uZmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZ1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZ1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfaXBcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19zID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl9jb25maWdfc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fY29uZmlnX2kgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2NvbmZpZ19pXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9jb25maWdfaSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fY29uZmlnX2lcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fY29uZmlnX2lcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2NvbmZpZ19paSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fY29uZmlnX2lpXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9jb25maWdfaWkgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2NvbmZpZ19paVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9jb25maWdfaWlcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2NvbmZpZ19qID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9jb25maWdfalwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fY29uZmlnX2ogPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2NvbmZpZ19qXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2NvbmZpZ19qXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9pbml0X3dhc21mcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21faW5pdF93YXNtZnNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2luaXRfd2FzbWZzID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9pbml0X3dhc21mc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9pbml0X3dhc21mc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnRwdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50cHRyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnRwdHJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9pbnRwdHJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X3ZvaWRwdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0clwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X3ZvaWRwdHJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWF4ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9tYXggPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWF4XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWF4XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfdGltZXMyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X3RpbWVzMiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWlubWF4ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5tYXggPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWlubWF4XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWlubWF4XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3dcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3cgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3dcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9zdGFja19vdmVyZmxvd1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9zdHJfaGVsbG8gPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfc3RyX2hlbGxvXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9zdHJfaGVsbG9cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9zdHJfaGVsbG9cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fU1FMVGVzdGVyX3N0cmdsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX21hbGxvYyA9IE1vZHVsZVtcIl9tYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfbWFsbG9jID0gTW9kdWxlW1wiX21hbGxvY1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcIm1hbGxvY1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfZnJlZSA9IE1vZHVsZVtcIl9mcmVlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9yZWFsbG9jID0gTW9kdWxlW1wiX3JlYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfcmVhbGxvYyA9IE1vZHVsZVtcIl9yZWFsbG9jXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wicmVhbGxvY1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24gPSBNb2R1bGVbXCJfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBzdGFja1NhdmUgPSBNb2R1bGVbXCJzdGFja1NhdmVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChzdGFja1NhdmUgPSBNb2R1bGVbXCJzdGFja1NhdmVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzdGFja1NhdmVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBzdGFja1Jlc3RvcmUgPSBNb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChzdGFja1Jlc3RvcmUgPSBNb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzdGFja1Jlc3RvcmVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBzdGFja0FsbG9jID0gTW9kdWxlW1wic3RhY2tBbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHN0YWNrQWxsb2MgPSBNb2R1bGVbXCJzdGFja0FsbG9jXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3RhY2tBbGxvY1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxuXG5cblxuXG5cbk1vZHVsZVtcIndhc21NZW1vcnlcIl0gPSB3YXNtTWVtb3J5O1xuXG5cbnZhciBjYWxsZWRSdW47XG5cbmRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uIHJ1bkNhbGxlcigpIHtcbiAgXG4gIGlmICghY2FsbGVkUnVuKSBydW4oKTtcbiAgaWYgKCFjYWxsZWRSdW4pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjsgXG59O1xuXG5cbmZ1bmN0aW9uIHJ1bihhcmdzKSB7XG4gIGFyZ3MgPSBhcmdzIHx8IGFyZ3VtZW50c187XG5cbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcmVSdW4oKTtcblxuICBcbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmdW5jdGlvbiBkb1J1bigpIHtcbiAgICBcbiAgICBcbiAgICBpZiAoY2FsbGVkUnVuKSByZXR1cm47XG4gICAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgICBNb2R1bGVbJ2NhbGxlZFJ1biddID0gdHJ1ZTtcblxuICAgIGlmIChBQk9SVCkgcmV0dXJuO1xuXG4gICAgaW5pdFJ1bnRpbWUoKTtcblxuICAgIHJlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtcbiAgICBpZiAoTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKSBNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10oKTtcblxuICAgIHBvc3RSdW4oKTtcbiAgfVxuXG4gIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7XG4gICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCcnKTtcbiAgICAgIH0sIDEpO1xuICAgICAgZG9SdW4oKTtcbiAgICB9LCAxKTtcbiAgfSBlbHNlXG4gIHtcbiAgICBkb1J1bigpO1xuICB9XG59XG5cbmlmIChNb2R1bGVbJ3ByZUluaXQnXSkge1xuICBpZiAodHlwZW9mIE1vZHVsZVsncHJlSW5pdCddID09ICdmdW5jdGlvbicpIE1vZHVsZVsncHJlSW5pdCddID0gW01vZHVsZVsncHJlSW5pdCddXTtcbiAgd2hpbGUgKE1vZHVsZVsncHJlSW5pdCddLmxlbmd0aCA+IDApIHtcbiAgICBNb2R1bGVbJ3ByZUluaXQnXS5wb3AoKSgpO1xuICB9XG59XG5cbnJ1bigpO1xuXG5cblxuXG5cbmlmKCFNb2R1bGUucG9zdFJ1bikgTW9kdWxlLnBvc3RSdW4gPSBbXTtcbk1vZHVsZS5wb3N0UnVuLnB1c2goZnVuY3Rpb24oTW9kdWxlKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBcblxuXG5cblxuXG5cblxuXG5cblxuJ3VzZSBzdHJpY3QnO1xuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwID0gZnVuY3Rpb24gc3FsaXRlM0FwaUJvb3RzdHJhcChcbiAgYXBpQ29uZmlnID0gKGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fCBzcWxpdGUzQXBpQm9vdHN0cmFwLmRlZmF1bHRDb25maWcpXG4pe1xuICBpZihzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTMpeyBcbiAgICBjb25zb2xlLndhcm4oXCJzcWxpdGUzQXBpQm9vdHN0cmFwKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlwiLFxuICAgICAgICAgICAgICAgICBcIkNvbmZpZyBhbmQgZXh0ZXJuYWwgaW5pdGlhbGl6ZXJzIGFyZSBpZ25vcmVkIG9uIGNhbGxzIGFmdGVyIHRoZSBmaXJzdC5cIik7XG4gICAgcmV0dXJuIHNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMztcbiAgfVxuICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgIGV4cG9ydHM6IHVuZGVmaW5lZCxcbiAgICBtZW1vcnk6IHVuZGVmaW5lZCxcbiAgICBiaWdJbnRFbmFibGVkOiAoKCk9PntcbiAgICAgIGlmKCd1bmRlZmluZWQnIT09dHlwZW9mIE1vZHVsZSl7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gISFNb2R1bGUuSEVBUFU2NDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIWdsb2JhbFRoaXMuQmlnSW50NjRBcnJheTtcbiAgICB9KSgpLFxuICAgIGRlYnVnOiBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSksXG4gICAgd2FybjogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSksXG4gICAgZXJyb3I6IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxcbiAgICBsb2c6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gICAgd2FzbWZzT3Bmc0RpcjogJy9vcGZzJyxcbiAgICBcbiAgICB1c2VTdGRBbGxvYzogZmFsc2VcbiAgfSwgYXBpQ29uZmlnIHx8IHt9KTtcblxuICBPYmplY3QuYXNzaWduKGNvbmZpZywge1xuICAgIGFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jID8gJ21hbGxvYycgOiAnc3FsaXRlM19tYWxsb2MnLFxuICAgIGRlYWxsb2NFeHBvcnROYW1lOiBjb25maWcudXNlU3RkQWxsb2MgPyAnZnJlZScgOiAnc3FsaXRlM19mcmVlJyxcbiAgICByZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jID8gJ3JlYWxsb2MnIDogJ3NxbGl0ZTNfcmVhbGxvYydcbiAgfSwgY29uZmlnKTtcblxuICBbXG4gICAgXG4gICAgXG4gICAgJ2V4cG9ydHMnLCAnbWVtb3J5JywgJ3dhc21mc09wZnNEaXInXG4gIF0uZm9yRWFjaCgoayk9PntcbiAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2YgY29uZmlnW2tdKXtcbiAgICAgIGNvbmZpZ1trXSA9IGNvbmZpZ1trXSgpO1xuICAgIH1cbiAgfSk7XG4gIFxuICBjb25zdCBjYXBpID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgXG4gIGNvbnN0IHdhc20gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIFxuICBjb25zdCBfX3JjU3RyID0gKHJjKT0+e1xuICAgIHJldHVybiAoY2FwaS5zcWxpdGUzX2pzX3JjX3N0ciAmJiBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyKHJjKSlcbiAgICAgICAgICAgfHwgKFwiVW5rbm93biByZXN1bHQgY29kZSAjXCIrcmMpO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2lzSW50ID0gKG4pPT4nbnVtYmVyJz09PXR5cGVvZiBuICYmIG49PT0obiB8IDApO1xuXG4gIFxuICBjbGFzcyBTUUxpdGUzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICBsZXQgcmM7XG4gICAgICBpZihhcmdzLmxlbmd0aCl7XG4gICAgICAgIGlmKF9faXNJbnQoYXJnc1swXSkpe1xuICAgICAgICAgIHJjID0gYXJnc1swXTtcbiAgICAgICAgICBpZigxPT09YXJncy5sZW5ndGgpe1xuICAgICAgICAgICAgc3VwZXIoX19yY1N0cihhcmdzWzBdKSk7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zdCByY1N0ciA9IF9fcmNTdHIocmMpO1xuICAgICAgICAgICAgaWYoJ29iamVjdCc9PT10eXBlb2YgYXJnc1sxXSl7XG4gICAgICAgICAgICAgIHN1cGVyKHJjU3RyLGFyZ3NbMV0pO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGFyZ3NbMF0gPSByY1N0cisnOic7XG4gICAgICAgICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGlmKDI9PT1hcmdzLmxlbmd0aCAmJiAnb2JqZWN0Jz09PXR5cGVvZiBhcmdzWzFdKXtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc3VwZXIoYXJncy5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRDb2RlID0gcmMgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gICAgICB0aGlzLm5hbWUgPSAnU1FMaXRlM0Vycm9yJztcbiAgICB9XG4gIH07XG5cbiAgXG4gIFNRTGl0ZTNFcnJvci50b3NzID0gKC4uLmFyZ3MpPT57XG4gICAgdGhyb3cgbmV3IFNRTGl0ZTNFcnJvciguLi5hcmdzKTtcbiAgfTtcbiAgY29uc3QgdG9zczMgPSBTUUxpdGUzRXJyb3IudG9zcztcblxuICBpZihjb25maWcud2FzbWZzT3Bmc0RpciAmJiAhL15cXC9bXi9dKyQvLnRlc3QoY29uZmlnLndhc21mc09wZnNEaXIpKXtcbiAgICB0b3NzMyhcImNvbmZpZy53YXNtZnNPcGZzRGlyIG11c3QgYmUgZmFsc3kgb3IgaW4gdGhlIGZvcm0gJy9kaXItbmFtZScuXCIpO1xuICB9XG5cbiAgXG4gIGNvbnN0IGlzSW50MzIgPSAobik9PntcbiAgICByZXR1cm4gKCdiaWdpbnQnIT09dHlwZW9mIG4gKVxuICAgICAgJiYgISEobj09PShufDApICYmIG48PTIxNDc0ODM2NDcgJiYgbj49LTIxNDc0ODM2NDgpO1xuICB9O1xuICBcbiAgY29uc3QgYmlnSW50Rml0czY0ID0gZnVuY3Rpb24gZihiKXtcbiAgICBpZighZi5fbWF4KXtcbiAgICAgIGYuX21heCA9IEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKTtcbiAgICAgIGYuX21pbiA9IH5mLl9tYXg7XG4gICAgfVxuICAgIHJldHVybiBiID49IGYuX21pbiAmJiBiIDw9IGYuX21heDtcbiAgfTtcblxuICBcbiAgY29uc3QgYmlnSW50Rml0czMyID0gKGIpPT4oYiA+PSAoLTB4N2ZmZmZmZmZuIC0gMW4pICYmIGIgPD0gMHg3ZmZmZmZmZm4pO1xuXG4gIFxuICBjb25zdCBiaWdJbnRGaXRzRG91YmxlID0gZnVuY3Rpb24gZihiKXtcbiAgICBpZighZi5fbWluKXtcbiAgICAgIGYuX21pbiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgZi5fbWF4ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIHJldHVybiBiID49IGYuX21pbiAmJiBiIDw9IGYuX21heDtcbiAgfTtcblxuICBcbiAgY29uc3QgaXNUeXBlZEFycmF5ID0gKHYpPT57XG4gICAgcmV0dXJuICh2ICYmIHYuY29uc3RydWN0b3IgJiYgaXNJbnQzMih2LmNvbnN0cnVjdG9yLkJZVEVTX1BFUl9FTEVNRU5UKSkgPyB2IDogZmFsc2U7XG4gIH07XG5cblxuICBcbiAgY29uc3QgX19TQUIgPSAoJ3VuZGVmaW5lZCc9PT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZnVuY3Rpb24oKXt9IDogU2hhcmVkQXJyYXlCdWZmZXI7XG4gIFxuICBjb25zdCBpc1NoYXJlZFR5cGVkQXJyYXkgPSAoYVR5cGVkQXJyYXkpPT4oYVR5cGVkQXJyYXkuYnVmZmVyIGluc3RhbmNlb2YgX19TQUIpO1xuXG4gIFxuICBjb25zdCB0eXBlZEFycmF5UGFydCA9IChhVHlwZWRBcnJheSwgYmVnaW4sIGVuZCk9PntcbiAgICByZXR1cm4gaXNTaGFyZWRUeXBlZEFycmF5KGFUeXBlZEFycmF5KVxuICAgICAgPyBhVHlwZWRBcnJheS5zbGljZShiZWdpbiwgZW5kKVxuICAgICAgOiBhVHlwZWRBcnJheS5zdWJhcnJheShiZWdpbiwgZW5kKTtcbiAgfTtcblxuICBcbiAgY29uc3QgaXNCaW5kYWJsZVR5cGVkQXJyYXkgPSAodik9PntcbiAgICByZXR1cm4gdiAmJiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgfHwgdiBpbnN0YW5jZW9mIEludDhBcnJheVxuICAgICAgICAgICAgICAgICB8fCB2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9O1xuXG4gIFxuICBjb25zdCBpc1NRTGFibGVUeXBlZEFycmF5ID0gKHYpPT57XG4gICAgcmV0dXJuIHYgJiYgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgICAgICAgIHx8IHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgfHwgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfTtcblxuICBcbiAgY29uc3QgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5ID0gKHYpPT57XG4gICAgcmV0dXJuIGlzQmluZGFibGVUeXBlZEFycmF5KHYpXG4gICAgICB8fCB0b3NzMyhcIlZhbHVlIGlzIG5vdCBvZiBhIHN1cHBvcnRlZCBUeXBlZEFycmF5IHR5cGUuXCIpO1xuICB9O1xuXG4gIGNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuXG4gIFxuICBjb25zdCB0eXBlZEFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbih0eXBlZEFycmF5LCBiZWdpbiwgZW5kKXtcbiAgICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHR5cGVkQXJyYXlQYXJ0KHR5cGVkQXJyYXksIGJlZ2luLGVuZCkpO1xuICB9O1xuXG4gIFxuICBjb25zdCBmbGV4aWJsZVN0cmluZyA9IGZ1bmN0aW9uKHYpe1xuICAgIGlmKGlzU1FMYWJsZVR5cGVkQXJyYXkodikpe1xuICAgICAgcmV0dXJuIHR5cGVkQXJyYXlUb1N0cmluZyhcbiAgICAgICAgKHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgPyBuZXcgVWludDhBcnJheSh2KSA6IHZcbiAgICAgICk7XG4gICAgfVxuICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIHYuam9pbihcIlwiKTtcbiAgICBlbHNlIGlmKHdhc20uaXNQdHIodikpIHYgPSB3YXNtLmNzdHJUb0pzKHYpO1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIFxuICBjbGFzcyBXYXNtQWxsb2NFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgIGlmKDI9PT1hcmdzLmxlbmd0aCAmJiAnb2JqZWN0Jz09PXR5cGVvZiBhcmdzWzFdKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICB9ZWxzZSBpZihhcmdzLmxlbmd0aCl7XG4gICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBzdXBlcihcIkFsbG9jYXRpb24gZmFpbGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0Q29kZSA9IGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgdGhpcy5uYW1lID0gJ1dhc21BbGxvY0Vycm9yJztcbiAgICB9XG4gIH07XG4gIFxuICBXYXNtQWxsb2NFcnJvci50b3NzID0gKC4uLmFyZ3MpPT57XG4gICAgdGhyb3cgbmV3IFdhc21BbGxvY0Vycm9yKC4uLmFyZ3MpO1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oY2FwaSwge1xuICAgIFxuICAgIHNxbGl0ZTNfYmluZF9ibG9iOiB1bmRlZmluZWQsXG5cbiAgICBcbiAgICBzcWxpdGUzX2JpbmRfdGV4dDogdW5kZWZpbmVkLFxuXG4gICAgXG4gICAgc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjI6IChcbiAgICAgIHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLCBwQXBwLFxuICAgICAgeEZ1bmMsIHhTdGVwLCB4RmluYWwsIHhEZXN0cm95XG4gICAgKT0+e30sXG4gICAgXG4gICAgc3FsaXRlM19jcmVhdGVfZnVuY3Rpb246IChcbiAgICAgIHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLCBwQXBwLFxuICAgICAgeEZ1bmMsIHhTdGVwLCB4RmluYWxcbiAgICApPT57fSxcbiAgICBcbiAgICBzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb246IChcbiAgICAgIHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLCBwQXBwLFxuICAgICAgeFN0ZXAsIHhGaW5hbCwgeFZhbHVlLCB4SW52ZXJzZSwgeERlc3Ryb3lcbiAgICApPT57fSxcbiAgICBcbiAgICBzcWxpdGUzX3ByZXBhcmVfdjM6IChkYlB0ciwgc3FsLCBzcWxCeXRlTGVuLCBwcmVwRmxhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgc3RtdFB0clB0ciwgc3RyUHRyUHRyKT0+e30sXG5cbiAgICBcbiAgICBzcWxpdGUzX3ByZXBhcmVfdjI6IChkYlB0ciwgc3FsLCBzcWxCeXRlTGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHN0bXRQdHJQdHIsc3RyUHRyUHRyKT0+e30sXG5cbiAgICBcbiAgICBzcWxpdGUzX2V4ZWM6IChwRGIsIHNxbCwgY2FsbGJhY2ssIHBWb2lkLCBwRXJyTXNnKT0+e30sXG5cbiAgICBcbiAgICBzcWxpdGUzX3JhbmRvbW5lc3M6IChuLCBvdXRQdHIpPT57fSxcbiAgfSk7XG5cbiAgXG4gIGNvbnN0IHV0aWwgPSB7XG4gICAgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5LCBmbGV4aWJsZVN0cmluZyxcbiAgICBiaWdJbnRGaXRzMzIsIGJpZ0ludEZpdHM2NCwgYmlnSW50Rml0c0RvdWJsZSxcbiAgICBpc0JpbmRhYmxlVHlwZWRBcnJheSxcbiAgICBpc0ludDMyLCBpc1NRTGFibGVUeXBlZEFycmF5LCBpc1R5cGVkQXJyYXksXG4gICAgdHlwZWRBcnJheVRvU3RyaW5nLFxuICAgIGlzVUlUaHJlYWQ6ICgpPT4oZ2xvYmFsVGhpcy53aW5kb3c9PT1nbG9iYWxUaGlzICYmICEhZ2xvYmFsVGhpcy5kb2N1bWVudCksXG4gICAgXG4gICAgaXNTaGFyZWRUeXBlZEFycmF5LFxuICAgIHRvc3M6IGZ1bmN0aW9uKC4uLmFyZ3Mpe3Rocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSl9LFxuICAgIHRvc3MzLFxuICAgIHR5cGVkQXJyYXlQYXJ0LFxuICAgIFxuICAgIGFmZmlybURiSGVhZGVyOiBmdW5jdGlvbihieXRlcyl7XG4gICAgICBpZihieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IFwiU1FMaXRlIGZvcm1hdCAzXCI7XG4gICAgICBpZiggaGVhZGVyLmxlbmd0aCA+IGJ5dGVzLmJ5dGVMZW5ndGggKXtcbiAgICAgICAgdG9zczMoXCJJbnB1dCBkb2VzIG5vdCBjb250YWluIGFuIFNRTGl0ZTMgZGF0YWJhc2UgaGVhZGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoZWFkZXIubGVuZ3RoOyArK2kpe1xuICAgICAgICBpZiggaGVhZGVyLmNoYXJDb2RlQXQoaSkgIT09IGJ5dGVzW2ldICl7XG4gICAgICAgICAgdG9zczMoXCJJbnB1dCBkb2VzIG5vdCBjb250YWluIGFuIFNRTGl0ZTMgZGF0YWJhc2UgaGVhZGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgYWZmaXJtSXNEYjogZnVuY3Rpb24oYnl0ZXMpe1xuICAgICAgaWYoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgIGlmKG48NTEyIHx8IG4lNTEyIT09MCkge1xuICAgICAgICB0b3NzMyhcIkJ5dGUgYXJyYXkgc2l6ZVwiLG4sXCJpcyBpbnZhbGlkIGZvciBhbiBTUUxpdGUzIGRiLlwiKTtcbiAgICAgIH1cbiAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoYnl0ZXMpO1xuICAgIH1cbiAgfTtcblxuICBPYmplY3QuYXNzaWduKHdhc20sIHtcbiAgICBcbiAgICBwdHJTaXplb2Y6IGNvbmZpZy53YXNtUHRyU2l6ZW9mIHx8IDQsXG4gICAgXG4gICAgcHRySVI6IGNvbmZpZy53YXNtUHRySVIgfHwgXCJpMzJcIixcbiAgICBcbiAgICBiaWdJbnRFbmFibGVkOiAhIWNvbmZpZy5iaWdJbnRFbmFibGVkLFxuICAgIFxuICAgIGV4cG9ydHM6IGNvbmZpZy5leHBvcnRzXG4gICAgICB8fCB0b3NzMyhcIk1pc3NpbmcgQVBJIGNvbmZpZy5leHBvcnRzIChXQVNNIG1vZHVsZSBleHBvcnRzKS5cIiksXG5cbiAgICBcbiAgICBtZW1vcnk6IGNvbmZpZy5tZW1vcnkgfHwgY29uZmlnLmV4cG9ydHNbJ21lbW9yeSddXG4gICAgICB8fCB0b3NzMyhcIkFQSSBjb25maWcgb2JqZWN0IHJlcXVpcmVzIGEgV2ViQXNzZW1ibHkuTWVtb3J5IG9iamVjdFwiLFxuICAgICAgICAgICAgICBcImluIGVpdGhlciBjb25maWcuZXhwb3J0cy5tZW1vcnkgKGV4cG9ydGVkKVwiLFxuICAgICAgICAgICAgICBcIm9yIGNvbmZpZy5tZW1vcnkgKGltcG9ydGVkKS5cIiksXG5cbiAgICBcbiAgICBhbGxvYzogdW5kZWZpbmVkLFxuXG4gICAgXG4gICAgcmVhbGxvYzogdW5kZWZpbmVkLFxuXG4gICAgXG4gICAgZGVhbGxvYzogdW5kZWZpbmVkXG5cbiAgICBcbiAgfSk7XG5cbiAgXG4gIHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSA9IGZ1bmN0aW9uKHNyY1R5cGVkQXJyYXkpe1xuICAgIGlmKHNyY1R5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7XG4gICAgICBzcmNUeXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc3JjVHlwZWRBcnJheSk7XG4gICAgfVxuICAgIGFmZmlybUJpbmRhYmxlVHlwZWRBcnJheShzcmNUeXBlZEFycmF5KTtcbiAgICBjb25zdCBwUmV0ID0gd2FzbS5hbGxvYyhzcmNUeXBlZEFycmF5LmJ5dGVMZW5ndGggfHwgMSk7XG4gICAgd2FzbS5oZWFwRm9yU2l6ZShzcmNUeXBlZEFycmF5LmNvbnN0cnVjdG9yKS5zZXQoXG4gICAgICBzcmNUeXBlZEFycmF5LmJ5dGVMZW5ndGggPyBzcmNUeXBlZEFycmF5IDogWzBdLCBwUmV0XG4gICAgKTtcbiAgICByZXR1cm4gcFJldDtcbiAgfTtcblxuICB7XG4gICAgXG4gICAgY29uc3Qga2V5QWxsb2MgPSBjb25maWcuYWxsb2NFeHBvcnROYW1lLFxuICAgICAgICAgIGtleURlYWxsb2MgPSBjb25maWcuZGVhbGxvY0V4cG9ydE5hbWUsXG4gICAgICAgICAga2V5UmVhbGxvYyA9IGNvbmZpZy5yZWFsbG9jRXhwb3J0TmFtZTtcbiAgICBmb3IoY29uc3Qga2V5IG9mIFtrZXlBbGxvYywga2V5RGVhbGxvYywga2V5UmVhbGxvY10pe1xuICAgICAgY29uc3QgZiA9IHdhc20uZXhwb3J0c1trZXldO1xuICAgICAgaWYoIShmIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB0b3NzMyhcIk1pc3NpbmcgcmVxdWlyZWQgZXhwb3J0c1tcIixrZXksXCJdIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB3YXNtLmFsbG9jID0gZnVuY3Rpb24gZihuKXtcbiAgICAgIHJldHVybiBmLmltcGwobikgfHwgV2FzbUFsbG9jRXJyb3IudG9zcyhcIkZhaWxlZCB0byBhbGxvY2F0ZVwiLG4sXCIgYnl0ZXMuXCIpO1xuICAgIH07XG4gICAgd2FzbS5hbGxvYy5pbXBsID0gd2FzbS5leHBvcnRzW2tleUFsbG9jXTtcbiAgICB3YXNtLnJlYWxsb2MgPSBmdW5jdGlvbiBmKG0sbil7XG4gICAgICBjb25zdCBtMiA9IGYuaW1wbChtLG4pO1xuICAgICAgcmV0dXJuIG4gPyAobTIgfHwgV2FzbUFsbG9jRXJyb3IudG9zcyhcIkZhaWxlZCB0byByZWFsbG9jYXRlXCIsbixcIiBieXRlcy5cIikpIDogMDtcbiAgICB9O1xuICAgIHdhc20ucmVhbGxvYy5pbXBsID0gd2FzbS5leHBvcnRzW2tleVJlYWxsb2NdO1xuICAgIHdhc20uZGVhbGxvYyA9IHdhc20uZXhwb3J0c1trZXlEZWFsbG9jXTtcbiAgfVxuXG4gIFxuICB3YXNtLmNvbXBpbGVPcHRpb25Vc2VkID0gZnVuY3Rpb24gZihvcHROYW1lKXtcbiAgICBpZighYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICBpZihmLl9yZXN1bHQpIHJldHVybiBmLl9yZXN1bHQ7XG4gICAgICBlbHNlIGlmKCFmLl9vcHQpe1xuICAgICAgICBmLl9yeCA9IC9eKFtePV0rKT0oLispLztcbiAgICAgICAgZi5fcnhJbnQgPSAvXi0/XFxkKyQvO1xuICAgICAgICBmLl9vcHQgPSBmdW5jdGlvbihvcHQsIHJ2KXtcbiAgICAgICAgICBjb25zdCBtID0gZi5fcnguZXhlYyhvcHQpO1xuICAgICAgICAgIHJ2WzBdID0gKG0gPyBtWzFdIDogb3B0KTtcbiAgICAgICAgICBydlsxXSA9IG0gPyAoZi5fcnhJbnQudGVzdChtWzJdKSA/ICttWzJdIDogbVsyXSkgOiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmMgPSB7fSwgb3YgPSBbMCwwXTtcbiAgICAgIGxldCBpID0gMCwgaztcbiAgICAgIHdoaWxlKChrID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0KGkrKykpKXtcbiAgICAgICAgZi5fb3B0KGssb3YpO1xuICAgICAgICByY1tvdlswXV0gPSBvdlsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmLl9yZXN1bHQgPSByYztcbiAgICB9ZWxzZSBpZihBcnJheS5pc0FycmF5KG9wdE5hbWUpKXtcbiAgICAgIGNvbnN0IHJjID0ge307XG4gICAgICBvcHROYW1lLmZvckVhY2goKHYpPT57XG4gICAgICAgIHJjW3ZdID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCh2KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH1lbHNlIGlmKCdvYmplY3QnID09PSB0eXBlb2Ygb3B0TmFtZSl7XG4gICAgICBPYmplY3Qua2V5cyhvcHROYW1lKS5mb3JFYWNoKChrKT0+IHtcbiAgICAgICAgb3B0TmFtZVtrXSA9IGNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQoayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvcHROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgJ3N0cmluZyc9PT10eXBlb2Ygb3B0TmFtZVxuICAgICkgPyAhIWNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQob3B0TmFtZSkgOiBmYWxzZTtcbiAgfTtcblxuICBcbiAgd2FzbS5wc3RhY2sgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgIFxuICAgIHJlc3RvcmU6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmUsXG4gICAgXG4gICAgYWxsb2M6IGZ1bmN0aW9uKG4pe1xuICAgICAgaWYoJ3N0cmluZyc9PT10eXBlb2YgbiAmJiAhKG4gPSB3YXNtLnNpemVvZklSKG4pKSl7XG4gICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXCJJbnZhbGlkIHZhbHVlIGZvciBwc3RhY2suYWxsb2MoXCIsYXJndW1lbnRzWzBdLFwiKVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyhuKVxuICAgICAgICB8fCBXYXNtQWxsb2NFcnJvci50b3NzKFwiQ291bGQgbm90IGFsbG9jYXRlXCIsbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJ5dGVzIGZyb20gdGhlIHBzdGFjay5cIik7XG4gICAgfSxcbiAgICBcbiAgICBhbGxvY0NodW5rczogZnVuY3Rpb24obixzeil7XG4gICAgICBpZignc3RyaW5nJz09PXR5cGVvZiBzeiAmJiAhKHN6ID0gd2FzbS5zaXplb2ZJUihzeikpKXtcbiAgICAgICAgV2FzbUFsbG9jRXJyb3IudG9zcyhcIkludmFsaWQgc2l6ZSB2YWx1ZSBmb3IgYWxsb2NDaHVua3MoXCIsYXJndW1lbnRzWzFdLFwiKVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lbSA9IHdhc20ucHN0YWNrLmFsbG9jKG4gKiBzeik7XG4gICAgICBjb25zdCByYyA9IFtdO1xuICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgZm9yKDsgaSA8IG47ICsraSwgb2Zmc2V0ICs9IHN6KSByYy5wdXNoKG1lbSArIG9mZnNldCk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcbiAgICBcbiAgICBhbGxvY1B0cjogKG49MSxzYWZlUHRyU2l6ZT10cnVlKT0+e1xuICAgICAgcmV0dXJuIDE9PT1uXG4gICAgICAgID8gd2FzbS5wc3RhY2suYWxsb2Moc2FmZVB0clNpemUgPyA4IDogd2FzbS5wdHJTaXplb2YpXG4gICAgICAgIDogd2FzbS5wc3RhY2suYWxsb2NDaHVua3Mobiwgc2FmZVB0clNpemUgPyA4IDogd2FzbS5wdHJTaXplb2YpO1xuICAgIH0sXG5cbiAgICBcbiAgICBjYWxsOiBmdW5jdGlvbihmKXtcbiAgICAgIGNvbnN0IHN0YWNrUG9zID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICAgIHRyeXsgcmV0dXJuIGYoc3FsaXRlMykgfSBmaW5hbGx5e1xuICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrUG9zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdhc20ucHN0YWNrLCB7XG4gICAgXG4gICAgcG9pbnRlcjoge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSwgaXRlcmFibGU6IHRydWUsIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3B0clxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgcXVvdGE6IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGl0ZXJhYmxlOiB0cnVlLCB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19xdW90YVxuICAgIH0sXG4gICAgXG4gICAgcmVtYWluaW5nOiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLCBpdGVyYWJsZTogdHJ1ZSwgd3JpdGVhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nXG4gICAgfVxuICB9KTtcblxuICBjYXBpLnNxbGl0ZTNfcmFuZG9tbmVzcyA9ICguLi5hcmdzKT0+e1xuICAgIGlmKDE9PT1hcmdzLmxlbmd0aCAmJiB1dGlsLmlzVHlwZWRBcnJheShhcmdzWzBdKVxuICAgICAgJiYgMT09PWFyZ3NbMF0uQllURVNfUEVSX0VMRU1FTlQpe1xuICAgICAgY29uc3QgdGEgPSBhcmdzWzBdO1xuICAgICAgaWYoMD09PXRhLmJ5dGVMZW5ndGgpe1xuICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19yYW5kb21uZXNzKDAsMCk7XG4gICAgICAgIHJldHVybiB0YTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBuID0gdGEuYnl0ZUxlbmd0aCwgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QgciA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX3JhbmRvbW5lc3M7XG4gICAgICAgIGNvbnN0IGhlYXAgPSB3YXNtLmhlYXA4dSgpO1xuICAgICAgICBjb25zdCBuQWxsb2MgPSBuIDwgNTEyID8gbiA6IDUxMjtcbiAgICAgICAgY29uc3QgcHRyID0gd2FzbS5wc3RhY2suYWxsb2MobkFsbG9jKTtcbiAgICAgICAgZG97XG4gICAgICAgICAgY29uc3QgaiA9IChuPm5BbGxvYyA/IG5BbGxvYyA6IG4pO1xuICAgICAgICAgIHIoaiwgcHRyKTtcbiAgICAgICAgICB0YS5zZXQodHlwZWRBcnJheVBhcnQoaGVhcCwgcHRyLCBwdHIraiksIG9mZnNldCk7XG4gICAgICAgICAgbiAtPSBqO1xuICAgICAgICAgIG9mZnNldCArPSBqO1xuICAgICAgICB9IHdoaWxlKG4gPiAwKTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkhpZ2hseSB1bmV4cGVjdGVkIChhbmQgaWdub3JlZCEpIFwiK1xuICAgICAgICAgICAgICAgICAgICAgIFwiZXhjZXB0aW9uIGluIHNxbGl0ZTNfcmFuZG9tbmVzcygpOlwiLGUpO1xuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhO1xuICAgIH1cbiAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19yYW5kb21uZXNzKC4uLmFyZ3MpO1xuICB9O1xuXG4gIFxuICBsZXQgX193YXNtZnNPcGZzRGlyID0gdW5kZWZpbmVkO1xuICBcbiAgY2FwaS5zcWxpdGUzX3dhc21mc19vcGZzX2RpciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodW5kZWZpbmVkICE9PSBfX3dhc21mc09wZnNEaXIpIHJldHVybiBfX3dhc21mc09wZnNEaXI7XG4gICAgXG4gICAgY29uc3QgcGRpciA9IGNvbmZpZy53YXNtZnNPcGZzRGlyO1xuICAgIGlmKCFwZGlyXG4gICAgICAgfHwgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZVxuICAgICAgIHx8ICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGVcbiAgICAgICB8fCAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSl7XG4gICAgICByZXR1cm4gX193YXNtZnNPcGZzRGlyID0gXCJcIjtcbiAgICB9XG4gICAgdHJ5e1xuICAgICAgaWYocGRpciAmJiAwPT09d2FzbS54Q2FsbFdyYXBwZWQoXG4gICAgICAgICdzcWxpdGUzX3dhc21faW5pdF93YXNtZnMnLCAnaTMyJywgWydzdHJpbmcnXSwgcGRpclxuICAgICAgKSl7XG4gICAgICAgIHJldHVybiBfX3dhc21mc09wZnNEaXIgPSBwZGlyO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBfX3dhc21mc09wZnNEaXIgPSBcIlwiO1xuICAgICAgfVxuICAgIH1jYXRjaChlKXtcbiAgICAgIFxuICAgICAgcmV0dXJuIF9fd2FzbWZzT3Bmc0RpciA9IFwiXCI7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfd2FzbWZzX2ZpbGVuYW1lX2lzX3BlcnNpc3RlbnQgPSBmdW5jdGlvbihuYW1lKXtcbiAgICBjb25zdCBwID0gY2FwaS5zcWxpdGUzX3dhc21mc19vcGZzX2RpcigpO1xuICAgIHJldHVybiAocCAmJiBuYW1lKSA/IG5hbWUuc3RhcnRzV2l0aChwKycvJykgOiBmYWxzZTtcbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX2RiX3VzZXNfdmZzID0gZnVuY3Rpb24ocERiLHZmc05hbWUsZGJOYW1lPTApe1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IHBLID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKHZmc05hbWUpO1xuICAgICAgaWYoIXBLKSByZXR1cm4gZmFsc2U7XG4gICAgICBlbHNlIGlmKCFwRGIpe1xuICAgICAgICByZXR1cm4gcEs9PT1jYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoMCkgPyBwSyA6IGZhbHNlO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBwSz09PWNhcGkuc3FsaXRlM19qc19kYl92ZnMocERiLGRiTmFtZSkgPyBwSyA6IGZhbHNlO1xuICAgICAgfVxuICAgIH1jYXRjaChlKXtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX3Zmc19saXN0ID0gZnVuY3Rpb24oKXtcbiAgICBjb25zdCByYyA9IFtdO1xuICAgIGxldCBwVmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKDApO1xuICAgIHdoaWxlKHBWZnMpe1xuICAgICAgY29uc3Qgb1ZmcyA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBWZnMpO1xuICAgICAgcmMucHVzaCh3YXNtLmNzdHJUb0pzKG9WZnMuJHpOYW1lKSk7XG4gICAgICBwVmZzID0gb1Zmcy4kcE5leHQ7XG4gICAgICBvVmZzLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJjO1xuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfZGJfZXhwb3J0ID0gZnVuY3Rpb24ocERiLCBzY2hlbWE9MCl7XG4gICAgcERiID0gd2FzbS54V3JhcC50ZXN0Q29udmVydEFyZygnc3FsaXRlMyonLCBwRGIpO1xuICAgIGlmKCFwRGIpIHRvc3MzKCdJbnZhbGlkIHNxbGl0ZTMqIGFyZ3VtZW50LicpO1xuICAgIGlmKCF3YXNtLmJpZ0ludEVuYWJsZWQpIHRvc3MzKCdCaWdJbnQ2NCBzdXBwb3J0IGlzIG5vdCBlbmFibGVkLicpO1xuICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICBsZXQgcE91dDtcbiAgICB0cnl7XG4gICAgICBjb25zdCBwU2l6ZSA9IHdhc20uc2NvcGVkQWxsb2MoOCArIHdhc20ucHRyU2l6ZW9mKTtcbiAgICAgIGNvbnN0IHBwT3V0ID0gcFNpemUgKyA4O1xuICAgICAgXG4gICAgICBjb25zdCB6U2NoZW1hID0gc2NoZW1hXG4gICAgICAgICAgICA/ICh3YXNtLmlzUHRyKHNjaGVtYSkgPyBzY2hlbWEgOiB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZygnJytzY2hlbWEpKVxuICAgICAgICAgICAgOiAwO1xuICAgICAgbGV0IHJjID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemUoXG4gICAgICAgIHBEYiwgelNjaGVtYSwgcHBPdXQsIHBTaXplLCAwXG4gICAgICApO1xuICAgICAgaWYocmMpe1xuICAgICAgICB0b3NzMyhcIkRhdGFiYXNlIHNlcmlhbGl6YXRpb24gZmFpbGVkIHdpdGggY29kZVwiLFxuICAgICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYykpO1xuICAgICAgfVxuICAgICAgcE91dCA9IHdhc20ucGVla1B0cihwcE91dCk7XG4gICAgICBjb25zdCBuT3V0ID0gd2FzbS5wZWVrKHBTaXplLCAnaTY0Jyk7XG4gICAgICByYyA9IG5PdXRcbiAgICAgICAgPyB3YXNtLmhlYXA4dSgpLnNsaWNlKHBPdXQsIHBPdXQgKyBOdW1iZXIobk91dCkpXG4gICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9ZmluYWxseXtcbiAgICAgIGlmKHBPdXQpIHdhc20uZXhwb3J0cy5zcWxpdGUzX2ZyZWUocE91dCk7XG4gICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc19kYl92ZnMgPVxuICAgIChkYlBvaW50ZXIsIGRiTmFtZT0wKT0+d2FzbS5zcWxpdGUzX3dhc21fZGJfdmZzKGRiUG9pbnRlciwgZGJOYW1lKTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX2FnZ3JlZ2F0ZV9jb250ZXh0ID0gKHBDdHgsIG4pPT57XG4gICAgcmV0dXJuIGNhcGkuc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dChwQ3R4LCBuKVxuICAgICAgfHwgKG4gPyBXYXNtQWxsb2NFcnJvci50b3NzKFwiQ2Fubm90IGFsbG9jYXRlXCIsbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJ5dGVzIGZvciBzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0KClcIilcbiAgICAgICAgICA6IDApO1xuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfcG9zaXhfY3JlYXRlX2ZpbGUgPSBmdW5jdGlvbihmaWxlbmFtZSwgZGF0YSwgZGF0YUxlbil7XG4gICAgbGV0IHBEYXRhO1xuICAgIGlmKGRhdGEgJiYgd2FzbS5pc1B0cihkYXRhKSl7XG4gICAgICBwRGF0YSA9IGRhdGE7XG4gICAgfWVsc2UgaWYoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtcbiAgICAgIHBEYXRhID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KGRhdGEpO1xuICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aDwzIHx8ICF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbjwwKXtcbiAgICAgICAgZGF0YUxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFwiSW52YWxpZCAybmQgYXJndW1lbnQgZm9yIHNxbGl0ZTNfanNfcG9zaXhfY3JlYXRlX2ZpbGUoKS5cIik7XG4gICAgfVxuICAgIHRyeXtcbiAgICAgIGlmKCF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbjwwKXtcbiAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXCJJbnZhbGlkIDNyZCBhcmd1bWVudCBmb3Igc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSgpLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJjID0gd2FzbS5zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUoZmlsZW5hbWUsIHBEYXRhLCBkYXRhTGVuKTtcbiAgICAgIGlmKHJjKSBTUUxpdGUzRXJyb3IudG9zcyhcIkNyZWF0aW9uIG9mIGZpbGUgZmFpbGVkIHdpdGggc3FsaXRlMyByZXN1bHQgY29kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpKTtcbiAgICB9ZmluYWxseXtcbiAgICAgICB3YXNtLmRlYWxsb2MocERhdGEpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSA9IGZ1bmN0aW9uKHZmcywgZmlsZW5hbWUsIGRhdGEsIGRhdGFMZW4pe1xuICAgIGNvbmZpZy53YXJuKFwic3FsaXRlM19qc192ZnNfY3JlYXRlX2ZpbGUoKSBpcyBkZXByZWNhdGVkIGFuZFwiLFxuICAgICAgICAgICAgICAgIFwic2hvdWxkIGJlIGF2b2lkZWQgYmVjYXVzZSBpdCBjYW4gbGVhZCB0byBDLWxldmVsIGNyYXNoZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJTZWUgaXRzIGRvY3VtZW50YXRpb24gZm9yIGFsdGVybmF0aXZlIG9wdGlvbnMuXCIpO1xuICAgIGxldCBwRGF0YTtcbiAgICBpZihkYXRhKXtcbiAgICAgIGlmKHdhc20uaXNQdHIoZGF0YSkpe1xuICAgICAgICBwRGF0YSA9IGRhdGE7XG4gICAgICB9ZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICB9XG4gICAgICBpZihkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSl7XG4gICAgICAgIHBEYXRhID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KGRhdGEpO1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoPDQgfHwgIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fCBkYXRhTGVuPDApe1xuICAgICAgICAgIGRhdGFMZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBTUUxpdGUzRXJyb3IudG9zcyhcIkludmFsaWQgM3JkIGFyZ3VtZW50IHR5cGUgZm9yIHNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkuXCIpO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgIHBEYXRhID0gMDtcbiAgICB9XG4gICAgaWYoIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fCBkYXRhTGVuPDApe1xuICAgICAgd2FzbS5kZWFsbG9jKHBEYXRhKTtcbiAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFwiSW52YWxpZCA0dGggYXJndW1lbnQgZm9yIHNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkuXCIpO1xuICAgIH1cbiAgICB0cnl7XG4gICAgICBjb25zdCByYyA9IHdhc20uc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZSh2ZnMsIGZpbGVuYW1lLCBwRGF0YSwgZGF0YUxlbik7XG4gICAgICBpZihyYykgU1FMaXRlM0Vycm9yLnRvc3MoXCJDcmVhdGlvbiBvZiBmaWxlIGZhaWxlZCB3aXRoIHNxbGl0ZTMgcmVzdWx0IGNvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyKHJjKSk7XG4gICAgfWZpbmFsbHl7XG4gICAgICAgd2FzbS5kZWFsbG9jKHBEYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc19zcWxfdG9fc3RyaW5nID0gKHNxbCk9PntcbiAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIHNxbCl7XG4gICAgICByZXR1cm4gc3FsO1xuICAgIH1cbiAgICBjb25zdCB4ID0gZmxleGlibGVTdHJpbmcodik7XG4gICAgcmV0dXJuIHg9PT12ID8gdW5kZWZpbmVkIDogeDtcbiAgfVxuXG4gIGlmKCB1dGlsLmlzVUlUaHJlYWQoKSApe1xuICAgIFxuXG4gICAgXG4gICAgY29uc3QgX19rdnZmc0luZm8gPSBmdW5jdGlvbih3aGljaCl7XG4gICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByYy5wcmVmaXggPSAna3Z2ZnMtJyt3aGljaDtcbiAgICAgIHJjLnN0b3JlcyA9IFtdO1xuICAgICAgaWYoJ3Nlc3Npb24nPT09d2hpY2ggfHwgXCJcIj09PXdoaWNoKSByYy5zdG9yZXMucHVzaChnbG9iYWxUaGlzLnNlc3Npb25TdG9yYWdlKTtcbiAgICAgIGlmKCdsb2NhbCc9PT13aGljaCB8fCBcIlwiPT09d2hpY2gpIHJjLnN0b3Jlcy5wdXNoKGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9O1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2pzX2t2dmZzX2NsZWFyID0gZnVuY3Rpb24od2hpY2g9XCJcIil7XG4gICAgICBsZXQgcmMgPSAwO1xuICAgICAgY29uc3Qga3ZpbmZvID0gX19rdnZmc0luZm8od2hpY2gpO1xuICAgICAga3ZpbmZvLnN0b3Jlcy5mb3JFYWNoKChzKT0+e1xuICAgICAgICBjb25zdCB0b1JtID0gW10gO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yKCBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kgKXtcbiAgICAgICAgICBjb25zdCBrID0gcy5rZXkoaSk7XG4gICAgICAgICAgaWYoay5zdGFydHNXaXRoKGt2aW5mby5wcmVmaXgpKSB0b1JtLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SbS5mb3JFYWNoKChrayk9PnMucmVtb3ZlSXRlbShraykpO1xuICAgICAgICByYyArPSB0b1JtLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH07XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfc2l6ZSA9IGZ1bmN0aW9uKHdoaWNoPVwiXCIpe1xuICAgICAgbGV0IHN6ID0gMDtcbiAgICAgIGNvbnN0IGt2aW5mbyA9IF9fa3Z2ZnNJbmZvKHdoaWNoKTtcbiAgICAgIGt2aW5mby5zdG9yZXMuZm9yRWFjaCgocyk9PntcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgIGNvbnN0IGsgPSBzLmtleShpKTtcbiAgICAgICAgICBpZihrLnN0YXJ0c1dpdGgoa3ZpbmZvLnByZWZpeCkpe1xuICAgICAgICAgICAgc3ogKz0gay5sZW5ndGg7XG4gICAgICAgICAgICBzeiArPSBzLmdldEl0ZW0oaykubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3ogKiAyIDtcbiAgICB9O1xuXG4gIH1cblxuICBcbiAgY2FwaS5zcWxpdGUzX2RiX2NvbmZpZyA9IGZ1bmN0aW9uKHBEYiwgb3AsIC4uLmFyZ3Mpe1xuICAgIGlmKCF0aGlzLnMpe1xuICAgICAgdGhpcy5zID0gd2FzbS54V3JhcCgnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19zJywnaW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdpbnQnLCAnc3RyaW5nOnN0YXRpYyddXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICB0aGlzLnBpaSA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpJywgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdpbnQnLCAnKicsJ2ludCcsICdpbnQnXSk7XG4gICAgICB0aGlzLmlwID0gd2FzbS54V3JhcCgnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCcsJ2ludCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbJ3NxbGl0ZTMqJywgJ2ludCcsICdpbnQnLCcqJ10pO1xuICAgIH1cbiAgICBzd2l0Y2gob3Ape1xuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9GS0VZOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9UUklHR0VSOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9GVFMzX1RPS0VOSVpFUjpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfTE9BRF9FWFRFTlNJT046XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTk9fQ0tQVF9PTl9DTE9TRTpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfUVBTRzpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19UUklHR0VSX0VRUDpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19SRVNFVF9EQVRBQkFTRTpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19ERUZFTlNJVkU6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfV1JJVEFCTEVfU0NIRU1BOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9BTFRFUl9UQUJMRTpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19EUVNfRE1MOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0RRU19EREw6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1ZJRVc6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTEVHQUNZX0ZJTEVfRk9STUFUOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1RSVVNURURfU0NIRU1BOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1NUTVRfU0NBTlNUQVRVUzpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19SRVZFUlNFX1NDQU5PUkRFUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5pcChwRGIsIG9wLCBhcmdzWzBdLCBhcmdzWzFdIHx8IDApO1xuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xPT0tBU0lERTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5waWkocERiLCBvcCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTUFJTkRCTkFNRTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zKHBEYiwgb3AsIGFyZ3NbMF0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9NSVNVU0U7XG4gICAgfVxuICB9LmJpbmQoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgXG4gIGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyA9IGZ1bmN0aW9uKHBWYWwsdGhyb3dJZkNhbm5vdENvbnZlcnQ9dHJ1ZSl7XG4gICAgbGV0IGFyZztcbiAgICBjb25zdCB2YWxUeXBlID0gY2FwaS5zcWxpdGUzX3ZhbHVlX3R5cGUocFZhbCk7XG4gICAgc3dpdGNoKHZhbFR5cGUpe1xuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0lOVEVHRVI6XG4gICAgICAgICAgaWYod2FzbS5iaWdJbnRFbmFibGVkKXtcbiAgICAgICAgICAgIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV9pbnQ2NChwVmFsKTtcbiAgICAgICAgICAgIGlmKHV0aWwuYmlnSW50Rml0c0RvdWJsZShhcmcpKSBhcmcgPSBOdW1iZXIoYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfZG91YmxlKHBWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0ZMT0FUOlxuICAgICAgICAgIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV9kb3VibGUocFZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfVEVYVDpcbiAgICAgICAgICBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfdGV4dChwVmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9CTE9COntcbiAgICAgICAgICBjb25zdCBuID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2J5dGVzKHBWYWwpO1xuICAgICAgICAgIGNvbnN0IHBCbG9iID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2Jsb2IocFZhbCk7XG4gICAgICAgICAgaWYobiAmJiAhcEJsb2IpIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IudG9zcyhcbiAgICAgICAgICAgIFwiQ2Fubm90IGFsbG9jYXRlIG1lbW9yeSBmb3IgYmxvYiBhcmd1bWVudCBvZlwiLG4sXCJieXRlKHMpXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGFyZyA9IG4gPyB3YXNtLmhlYXA4dSgpLnNsaWNlKHBCbG9iLCBwQmxvYiArIE51bWJlcihuKSkgOiBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfTlVMTDpcbiAgICAgICAgICBhcmcgPSBudWxsOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZih0aHJvd0lmQ2Fubm90Q29udmVydCl7XG4gICAgICAgICAgICB0b3NzMyhjYXBpLlNRTElURV9NSVNNQVRDSCxcbiAgICAgICAgICAgICAgICAgIFwiVW5oYW5kbGVkIHNxbGl0ZTNfdmFsdWVfdHlwZSgpOlwiLHZhbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanMgPSBmdW5jdGlvbihhcmdjLHBBcmd2LHRocm93SWZDYW5ub3RDb252ZXJ0PXRydWUpe1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHRndCA9IFtdO1xuICAgIGZvcihpID0gMDsgaSA8IGFyZ2M7ICsraSl7XG4gICAgICBcbiAgICAgIHRndC5wdXNoKGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyhcbiAgICAgICAgd2FzbS5wZWVrUHRyKHBBcmd2ICsgKHdhc20ucHRyU2l6ZW9mICogaSkpLFxuICAgICAgICB0aHJvd0lmQ2Fubm90Q29udmVydFxuICAgICAgKSk7XG4gICAgfVxuICAgIHJldHVybiB0Z3Q7XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMgPSBmdW5jdGlvbihwQ3R4LGUpe1xuICAgIGlmKGUgaW5zdGFuY2VvZiBXYXNtQWxsb2NFcnJvcil7XG4gICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtKHBDdHgpO1xuICAgIH1lbHNle1xuICAgICAgO1xuICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcihwQ3R4LCAnJytlLCAtMSk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzID0gZnVuY3Rpb24ocEN0eCx2YWwpe1xuICAgIGlmKHZhbCBpbnN0YW5jZW9mIEVycm9yKXtcbiAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgdmFsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5e1xuICAgICAgc3dpdGNoKHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfaW50KHBDdHgsIHZhbCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgICAgICBpZih1dGlsLmJpZ0ludEZpdHMzMih2YWwpKXtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQocEN0eCwgTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfWVsc2UgaWYodXRpbC5iaWdJbnRGaXRzRG91YmxlKHZhbCkpe1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2RvdWJsZShwQ3R4LCBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9ZWxzZSBpZih3YXNtLmJpZ0ludEVuYWJsZWQpe1xuICAgICAgICAgICAgICBpZih1dGlsLmJpZ0ludEZpdHM2NCh2YWwpKSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludDY0KHBDdHgsIHZhbCk7XG4gICAgICAgICAgICAgIGVsc2UgdG9zczMoXCJCaWdJbnQgdmFsdWVcIix2YWwudG9TdHJpbmcoKSxcImlzIHRvbyBCaWdJbnQgZm9yIGludDY0LlwiKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0b3NzMyhcIkJpZ0ludCB2YWx1ZVwiLHZhbC50b1N0cmluZygpLFwiaXMgdG9vIEJpZ0ludC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdudW1iZXInOiB7XG4gICAgICAgICAgICBsZXQgZjtcbiAgICAgICAgICAgIGlmKHV0aWwuaXNJbnQzMih2YWwpKXtcbiAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfaW50O1xuICAgICAgICAgICAgfWVsc2UgaWYod2FzbS5iaWdJbnRFbmFibGVkXG4gICAgICAgICAgICAgICAgICAgICAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbClcbiAgICAgICAgICAgICAgICAgICAgICYmIHV0aWwuYmlnSW50Rml0czY0KEJpZ0ludCh2YWwpKSl7XG4gICAgICAgICAgICAgIGYgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludDY0O1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGYgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2RvdWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYocEN0eCwgdmFsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICBjb25zdCBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyh2YWwsdHJ1ZSk7XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X3RleHQocEN0eCwgcCwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYobnVsbD09PXZhbCkge1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X251bGwocEN0eCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfWVsc2UgaWYodXRpbC5pc0JpbmRhYmxlVHlwZWRBcnJheSh2YWwpKXtcbiAgICAgICAgICAgICAgY29uc3QgcEJsb2IgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkodmFsKTtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9ibG9iKFxuICAgICAgICAgICAgICAgIHBDdHgsIHBCbG9iLCB2YWwuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdG9zczMoXCJEb24ndCBub3QgaG93IHRvIGhhbmRsZSB0aGlzIFVERiByZXN1bHQgdmFsdWU6XCIsKHR5cGVvZiB2YWwpLCB2YWwpO1xuICAgICAgfVxuICAgIH1jYXRjaChlKXtcbiAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgZSk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfY29sdW1uX2pzID0gZnVuY3Rpb24ocFN0bXQsIGlDb2wsIHRocm93SWZDYW5ub3RDb252ZXJ0PXRydWUpe1xuICAgIGNvbnN0IHYgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX3ZhbHVlKHBTdG10LCBpQ29sKTtcbiAgICByZXR1cm4gKDA9PT12KSA/IHVuZGVmaW5lZCA6IGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyh2LCB0aHJvd0lmQ2Fubm90Q29udmVydCk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fbmV3T2xkVmFsdWUgPSBmdW5jdGlvbihwT2JqLCBpQ29sLCBpbXBsKXtcbiAgICBpbXBsID0gY2FwaVtpbXBsXTtcbiAgICBpZighdGhpcy5wdHIpIHRoaXMucHRyID0gd2FzbS5hbGxvY1B0cigpO1xuICAgIGVsc2Ugd2FzbS5wb2tlUHRyKHRoaXMucHRyLCAwKTtcbiAgICBjb25zdCByYyA9IGltcGwocE9iaiwgaUNvbCwgdGhpcy5wdHIpO1xuICAgIGlmKHJjKSByZXR1cm4gU1FMaXRlM0Vycm9yLnRvc3MocmMsYXJndW1lbnRzWzJdK1wiKCkgZmFpbGVkIHdpdGggY29kZSBcIityYyk7XG4gICAgY29uc3QgcHYgPSB3YXNtLnBlZWtQdHIodGhpcy5wdHIpO1xuICAgIHJldHVybiBwdiA/IGNhcGkuc3FsaXRlM192YWx1ZV90b19qcyggcHYsIHRydWUgKSA6IHVuZGVmaW5lZDtcbiAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfcHJldXBkYXRlX25ld19qcyA9XG4gICAgKHBEYiwgaUNvbCk9Pl9fbmV3T2xkVmFsdWUocERiLCBpQ29sLCAnc3FsaXRlM19wcmV1cGRhdGVfbmV3Jyk7XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfb2xkX2pzID1cbiAgICAocERiLCBpQ29sKT0+X19uZXdPbGRWYWx1ZShwRGIsIGlDb2wsICdzcWxpdGUzX3ByZXVwZGF0ZV9vbGQnKTtcblxuICBcbiAgY2FwaS5zcWxpdGUzY2hhbmdlc2V0X25ld19qcyA9XG4gICAgKHBDaGFuZ2VzZXRJdGVyLCBpQ29sKSA9PiBfX25ld09sZFZhbHVlKHBDaGFuZ2VzZXRJdGVyLCBpQ29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9uZXcnKTtcblxuICBcbiAgY2FwaS5zcWxpdGUzY2hhbmdlc2V0X29sZF9qcyA9XG4gICAgKHBDaGFuZ2VzZXRJdGVyLCBpQ29sKT0+X19uZXdPbGRWYWx1ZShwQ2hhbmdlc2V0SXRlciwgaUNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X29sZCcpO1xuXG4gIFxuICBjb25zdCBzcWxpdGUzID0ge1xuICAgIFdhc21BbGxvY0Vycm9yOiBXYXNtQWxsb2NFcnJvcixcbiAgICBTUUxpdGUzRXJyb3I6IFNRTGl0ZTNFcnJvcixcbiAgICBjYXBpLFxuICAgIHV0aWwsXG4gICAgd2FzbSxcbiAgICBjb25maWcsXG4gICAgXG4gICAgdmVyc2lvbjogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIFxuICAgIGNsaWVudDogdW5kZWZpbmVkLFxuXG4gICAgXG4gICAgYXN5bmNQb3N0SW5pdDogYXN5bmMgZnVuY3Rpb24gZmYoKXtcbiAgICAgIGlmKGZmLmlzUmVhZHkgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gZmYuaXNSZWFkeTtcbiAgICAgIGxldCBsaWEgPSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVyc0FzeW5jO1xuICAgICAgZGVsZXRlIHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzQXN5bmM7XG4gICAgICBjb25zdCBwb3N0SW5pdCA9IGFzeW5jICgpPT57XG4gICAgICAgIGlmKCFzcWxpdGUzLl9faXNVbmRlclRlc3Qpe1xuICAgICAgICAgIFxuICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzLnV0aWw7XG4gICAgICAgICAgXG4gICAgICAgICAgZGVsZXRlIHNxbGl0ZTMuU3RydWN0QmluZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcWxpdGUzO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNhdGNoZXIgPSAoZSk9PntcbiAgICAgICAgY29uZmlnLmVycm9yKFwiYW4gYXN5bmMgc3FsaXRlMyBpbml0aWFsaXplciBmYWlsZWQ6XCIsZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9O1xuICAgICAgaWYoIWxpYSB8fCAhbGlhLmxlbmd0aCl7XG4gICAgICAgIHJldHVybiBmZi5pc1JlYWR5ID0gcG9zdEluaXQoKS5jYXRjaChjYXRjaGVyKTtcbiAgICAgIH1cbiAgICAgIGxpYSA9IGxpYS5tYXAoKGYpPT57XG4gICAgICAgIHJldHVybiAoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSA/IGFzeW5jIHg9PmYoc3FsaXRlMykgOiBmO1xuICAgICAgfSk7XG4gICAgICBsaWEucHVzaChwb3N0SW5pdCk7XG4gICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZShzcWxpdGUzKTtcbiAgICAgIHdoaWxlKGxpYS5sZW5ndGgpIHAgPSBwLnRoZW4obGlhLnNoaWZ0KCkpO1xuICAgICAgcmV0dXJuIGZmLmlzUmVhZHkgPSBwLmNhdGNoKGNhdGNoZXIpO1xuICAgIH0sXG4gICAgXG4gICAgc2NyaXB0SW5mbzogdW5kZWZpbmVkXG4gIH07XG4gIHRyeXtcbiAgICBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5mb3JFYWNoKChmKT0+e1xuICAgICAgZihzcWxpdGUzKTtcbiAgICB9KTtcbiAgfWNhdGNoKGUpe1xuICAgIFxuICAgIGNvbnNvbGUuZXJyb3IoXCJzcWxpdGUzIGJvb3RzdHJhcCBpbml0aWFsaXplciB0aHJldzpcIixlKTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycztcbiAgc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gc3FsaXRlMztcbiAgcmV0dXJuIHNxbGl0ZTM7XG59O1xuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzID0gW107XG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYyA9IFtdO1xuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuZGVmYXVsdENvbmZpZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzID0gdW5kZWZpbmVkO1xuXG5cblxuXG5nbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAndXNlIHN0cmljdCc7XG4gIGlmKHVuZGVmaW5lZD09PXRhcmdldC5iaWdJbnRFbmFibGVkKXtcbiAgICB0YXJnZXQuYmlnSW50RW5hYmxlZCA9ICEhZ2xvYmFsVGhpc1snQmlnSW50NjRBcnJheSddO1xuICB9XG5cbiAgXG4gIGNvbnN0IHRvc3MgPSAoLi4uYXJncyk9Pnt0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpfTtcblxuICBpZighdGFyZ2V0LmV4cG9ydHMpe1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdleHBvcnRzJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiAoKT0+KHRhcmdldC5pbnN0YW5jZSAmJiB0YXJnZXQuaW5zdGFuY2UuZXhwb3J0cylcbiAgICB9KTtcbiAgfVxuXG4gIFxuICBcblxuICBcbiAgY29uc3QgcHRySVIgPSB0YXJnZXQucG9pbnRlcklSIHx8ICdpMzInO1xuICBjb25zdCBwdHJTaXplb2YgPSB0YXJnZXQucHRyU2l6ZW9mID1cbiAgICAgICAgKCdpMzInPT09cHRySVIgPyA0XG4gICAgICAgICA6ICgnaTY0Jz09PXB0cklSXG4gICAgICAgICAgICA/IDggOiB0b3NzKFwiVW5oYW5kbGVkIHB0clNpemVvZjpcIixwdHJJUikpKTtcbiAgXG4gIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgXG4gIGNhY2hlLmhlYXBTaXplID0gMDtcbiAgXG4gIGNhY2hlLm1lbW9yeSA9IG51bGw7XG4gIFxuICBjYWNoZS5mcmVlRnVuY0luZGV4ZXMgPSBbXTtcbiAgXG4gIGNhY2hlLnNjb3BlZEFsbG9jID0gW107XG5cbiAgY2FjaGUudXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY2FjaGUudXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04Jyk7XG5cbiAgXG4gIHRhcmdldC5zaXplb2ZJUiA9IChuKT0+e1xuICAgIHN3aXRjaChuKXtcbiAgICAgICAgY2FzZSAnaTgnOiByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAnaTE2JzogcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgJ2kzMic6IGNhc2UgJ2YzMic6IGNhc2UgJ2Zsb2F0JzogcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgJ2k2NCc6IGNhc2UgJ2Y2NCc6IGNhc2UgJ2RvdWJsZSc6IHJldHVybiA4O1xuICAgICAgICBjYXNlICcqJzogcmV0dXJuIHB0clNpemVvZjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gKCcnK24pLmVuZHNXaXRoKCcqJykgPyBwdHJTaXplb2YgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjb25zdCBoZWFwV3JhcHBlcnMgPSBmdW5jdGlvbigpe1xuICAgIGlmKCFjYWNoZS5tZW1vcnkpe1xuICAgICAgY2FjaGUubWVtb3J5ID0gKHRhcmdldC5tZW1vcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5NZW1vcnkpXG4gICAgICAgID8gdGFyZ2V0Lm1lbW9yeSA6IHRhcmdldC5leHBvcnRzLm1lbW9yeTtcbiAgICB9ZWxzZSBpZihjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKXtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgYiA9IGNhY2hlLm1lbW9yeS5idWZmZXI7XG4gICAgY2FjaGUuSEVBUDggPSBuZXcgSW50OEFycmF5KGIpOyBjYWNoZS5IRUFQOFUgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBjYWNoZS5IRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTsgY2FjaGUuSEVBUDE2VSA9IG5ldyBVaW50MTZBcnJheShiKTtcbiAgICBjYWNoZS5IRUFQMzIgPSBuZXcgSW50MzJBcnJheShiKTsgY2FjaGUuSEVBUDMyVSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICBpZih0YXJnZXQuYmlnSW50RW5hYmxlZCl7XG4gICAgICBjYWNoZS5IRUFQNjQgPSBuZXcgQmlnSW50NjRBcnJheShiKTsgY2FjaGUuSEVBUDY0VSA9IG5ldyBCaWdVaW50NjRBcnJheShiKTtcbiAgICB9XG4gICAgY2FjaGUuSEVBUDMyRiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7IGNhY2hlLkhFQVA2NEYgPSBuZXcgRmxvYXQ2NEFycmF5KGIpO1xuICAgIGNhY2hlLmhlYXBTaXplID0gYi5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmhlYXA4ID0gKCk9PmhlYXBXcmFwcGVycygpLkhFQVA4O1xuXG4gIFxuICB0YXJnZXQuaGVhcDh1ID0gKCk9PmhlYXBXcmFwcGVycygpLkhFQVA4VTtcblxuICBcbiAgdGFyZ2V0LmhlYXAxNiA9ICgpPT5oZWFwV3JhcHBlcnMoKS5IRUFQMTY7XG5cbiAgXG4gIHRhcmdldC5oZWFwMTZ1ID0gKCk9PmhlYXBXcmFwcGVycygpLkhFQVAxNlU7XG5cbiAgXG4gIHRhcmdldC5oZWFwMzIgPSAoKT0+aGVhcFdyYXBwZXJzKCkuSEVBUDMyO1xuXG4gIFxuICB0YXJnZXQuaGVhcDMydSA9ICgpPT5oZWFwV3JhcHBlcnMoKS5IRUFQMzJVO1xuXG4gIFxuICB0YXJnZXQuaGVhcEZvclNpemUgPSBmdW5jdGlvbihuLHVuc2lnbmVkID0gdHJ1ZSl7XG4gICAgbGV0IGN0b3I7XG4gICAgY29uc3QgYyA9IChjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICA/IGNhY2hlIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgc3dpdGNoKG4pe1xuICAgICAgICBjYXNlIEludDhBcnJheTogcmV0dXJuIGMuSEVBUDg7IGNhc2UgVWludDhBcnJheTogcmV0dXJuIGMuSEVBUDhVO1xuICAgICAgICBjYXNlIEludDE2QXJyYXk6IHJldHVybiBjLkhFQVAxNjsgY2FzZSBVaW50MTZBcnJheTogcmV0dXJuIGMuSEVBUDE2VTtcbiAgICAgICAgY2FzZSBJbnQzMkFycmF5OiByZXR1cm4gYy5IRUFQMzI7IGNhc2UgVWludDMyQXJyYXk6IHJldHVybiBjLkhFQVAzMlU7XG4gICAgICAgIGNhc2UgODogIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDhVIDogYy5IRUFQODtcbiAgICAgICAgY2FzZSAxNjogcmV0dXJuIHVuc2lnbmVkID8gYy5IRUFQMTZVIDogYy5IRUFQMTY7XG4gICAgICAgIGNhc2UgMzI6IHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDMyVSA6IGMuSEVBUDMyO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIGlmKGMuSEVBUDY0KSByZXR1cm4gdW5zaWduZWQgPyBjLkhFQVA2NFUgOiBjLkhFQVA2NDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZih0YXJnZXQuYmlnSW50RW5hYmxlZCl7XG4gICAgICAgICAgICBpZihuPT09Z2xvYmFsVGhpc1snQmlnVWludDY0QXJyYXknXSkgcmV0dXJuIGMuSEVBUDY0VTtcbiAgICAgICAgICAgIGVsc2UgaWYobj09PWdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSkgcmV0dXJuIGMuSEVBUDY0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgIH1cbiAgICB0b3NzKFwiSW52YWxpZCBoZWFwRm9yU2l6ZSgpIHNpemU6IGV4cGVjdGluZyA4LCAxNiwgMzIsXCIsXG4gICAgICAgICBcIm9yIChpZiBCaWdJbnQgaXMgZW5hYmxlZCkgNjQuXCIpO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuZnVuY3Rpb25UYWJsZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRhcmdldC5leHBvcnRzLl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGU7XG4gICAgXG4gIH07XG5cbiAgXG4gIHRhcmdldC5mdW5jdGlvbkVudHJ5ID0gZnVuY3Rpb24oZnB0cil7XG4gICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgIHJldHVybiBmcHRyIDwgZnQubGVuZ3RoID8gZnQuZ2V0KGZwdHIpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuanNGdW5jVG9XYXNtID0gZnVuY3Rpb24gZihmdW5jLCBzaWcpe1xuICAgIFxuICAgIGlmKCFmLl8pe1xuICAgICAgZi5fID0ge1xuICAgICAgICBcbiAgICAgICAgc2lnVHlwZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgICAgICAgaTogJ2kzMicsIHA6ICdpMzInLCBQOiAnaTMyJywgczogJ2kzMicsXG4gICAgICAgICAgajogJ2k2NCcsIGY6ICdmMzInLCBkOiAnZjY0J1xuICAgICAgICB9KSxcbiAgICAgICAgXG4gICAgICAgIHR5cGVDb2RlczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICAgICAgICBmNjQ6IDB4N2MsIGYzMjogMHg3ZCwgaTY0OiAweDdlLCBpMzI6IDB4N2ZcbiAgICAgICAgfSksXG4gICAgICAgIFxuICAgICAgICB1bGViMTI4RW5jb2RlOiBmdW5jdGlvbih0Z3QsIG1ldGhvZCwgbil7XG4gICAgICAgICAgaWYobjwxMjgpIHRndFttZXRob2RdKG4pO1xuICAgICAgICAgIGVsc2UgdGd0W21ldGhvZF0oIChuICUgMTI4KSB8IDEyOCwgbj4+Nyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICByeEpTaWc6IC9eKFxcdylcXCgoXFx3KilcXCkkLyxcbiAgICAgICAgXG4gICAgICAgIHNpZ1BhcmFtczogZnVuY3Rpb24oc2lnKXtcbiAgICAgICAgICBjb25zdCBtID0gZi5fLnJ4SlNpZy5leGVjKHNpZyk7XG4gICAgICAgICAgcmV0dXJuIG0gPyBtWzJdIDogc2lnLnN1YnN0cigxKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGxldHRlclR5cGU6ICh4KT0+Zi5fLnNpZ1R5cGVzW3hdIHx8IHRvc3MoXCJJbnZhbGlkIHNpZ25hdHVyZSBsZXR0ZXI6XCIseCksXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHB1c2hTaWdUeXBlOiAoZGVzdCwgbGV0dGVyKT0+ZGVzdC5wdXNoKGYuXy50eXBlQ29kZXNbZi5fLmxldHRlclR5cGUobGV0dGVyKV0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZignc3RyaW5nJz09PXR5cGVvZiBmdW5jKXtcbiAgICAgIGNvbnN0IHggPSBzaWc7XG4gICAgICBzaWcgPSBmdW5jO1xuICAgICAgZnVuYyA9IHg7XG4gICAgfVxuICAgIGNvbnN0IHNpZ1BhcmFtcyA9IGYuXy5zaWdQYXJhbXMoc2lnKTtcbiAgICBjb25zdCB3YXNtQ29kZSA9IFsweDAxLCAweDYwXTtcbiAgICBmLl8udWxlYjEyOEVuY29kZSh3YXNtQ29kZSwgJ3B1c2gnLCBzaWdQYXJhbXMubGVuZ3RoKTtcbiAgICBmb3IoY29uc3QgeCBvZiBzaWdQYXJhbXMpIGYuXy5wdXNoU2lnVHlwZSh3YXNtQ29kZSwgeCk7XG4gICAgaWYoJ3YnPT09c2lnWzBdKSB3YXNtQ29kZS5wdXNoKDApO1xuICAgIGVsc2V7XG4gICAgICB3YXNtQ29kZS5wdXNoKDEpO1xuICAgICAgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCBzaWdbMF0pO1xuICAgIH1cbiAgICBmLl8udWxlYjEyOEVuY29kZSh3YXNtQ29kZSwgJ3Vuc2hpZnQnLCB3YXNtQ29kZS5sZW5ndGgpO1xuICAgIHdhc21Db2RlLnVuc2hpZnQoXG4gICAgICAweDAwLCAweDYxLCAweDczLCAweDZkLCBcbiAgICAgIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIFxuICAgICAgMHgwMSBcbiAgICApO1xuICAgIHdhc21Db2RlLnB1c2goXG4gICAgICAgMHgwMiwgMHgwNyxcbiAgICAgIFxuICAgICAgMHgwMSwgMHgwMSwgMHg2NSwgMHgwMSwgMHg2NiwgMHgwMCwgMHgwMCxcbiAgICAgICAweDA3LCAweDA1LFxuICAgICAgXG4gICAgICAweDAxLCAweDAxLCAweDY2LCAweDAwLCAweDAwXG4gICAgKTtcbiAgICByZXR1cm4gKG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShcbiAgICAgIG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkod2FzbUNvZGUpKSwge1xuICAgICAgICBlOiB7IGY6IGZ1bmMgfVxuICAgICAgfSkpLmV4cG9ydHNbJ2YnXTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZywgc2NvcGVkKXtcbiAgICBpZihzY29wZWQgJiYgIWNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCl7XG4gICAgICB0b3NzKFwiTm8gc2NvcGVkQWxsb2NQdXNoKCkgc2NvcGUgaXMgYWN0aXZlLlwiKTtcbiAgICB9XG4gICAgaWYoJ3N0cmluZyc9PT10eXBlb2YgZnVuYyl7XG4gICAgICBjb25zdCB4ID0gc2lnO1xuICAgICAgc2lnID0gZnVuYztcbiAgICAgIGZ1bmMgPSB4O1xuICAgIH1cbiAgICBpZignc3RyaW5nJyE9PXR5cGVvZiBzaWcgfHwgIShmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICAgIHRvc3MoXCJJbnZhbGlkIGFyZ3VtZW50czogZXhwZWN0aW5nIChmdW5jdGlvbixzaWduYXR1cmUpIFwiK1xuICAgICAgICAgICBcIm9yIChzaWduYXR1cmUsZnVuY3Rpb24pLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgIGNvbnN0IG9sZExlbiA9IGZ0Lmxlbmd0aDtcbiAgICBsZXQgcHRyO1xuICAgIHdoaWxlKGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5sZW5ndGgpe1xuICAgICAgcHRyID0gY2FjaGUuZnJlZUZ1bmNJbmRleGVzLnBvcCgpO1xuICAgICAgaWYoZnQuZ2V0KHB0cikpeyBcbiAgICAgICAgcHRyID0gbnVsbDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKCFwdHIpe1xuICAgICAgcHRyID0gb2xkTGVuO1xuICAgICAgZnQuZ3JvdygxKTtcbiAgICB9XG4gICAgdHJ5e1xuICAgICAgXG4gICAgICBmdC5zZXQocHRyLCBmdW5jKTtcbiAgICAgIGlmKHNjb3BlZCl7XG4gICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aC0xXS5wdXNoKHB0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHRyO1xuICAgIH1jYXRjaChlKXtcbiAgICAgIGlmKCEoZSBpbnN0YW5jZW9mIFR5cGVFcnJvcikpe1xuICAgICAgICBpZihwdHI9PT1vbGRMZW4pIGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5wdXNoKG9sZExlbik7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmcHRyID0gdGFyZ2V0LmpzRnVuY1RvV2FzbShmdW5jLCBzaWcpO1xuICAgICAgZnQuc2V0KHB0ciwgZnB0cik7XG4gICAgICBpZihzY29wZWQpe1xuICAgICAgICBjYWNoZS5zY29wZWRBbGxvY1tjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgtMV0ucHVzaChwdHIpO1xuICAgICAgfVxuICAgIH1jYXRjaChlKXtcbiAgICAgIGlmKHB0cj09PW9sZExlbikgY2FjaGUuZnJlZUZ1bmNJbmRleGVzLnB1c2gob2xkTGVuKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiBwdHI7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5pbnN0YWxsRnVuY3Rpb24gPSAoZnVuYywgc2lnKT0+X19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCBmYWxzZSk7XG5cbiAgXG4gIHRhcmdldC5zY29wZWRJbnN0YWxsRnVuY3Rpb24gPSAoZnVuYywgc2lnKT0+X19pbnN0YWxsRnVuY3Rpb24oZnVuYywgc2lnLCB0cnVlKTtcblxuICBcbiAgdGFyZ2V0LnVuaW5zdGFsbEZ1bmN0aW9uID0gZnVuY3Rpb24ocHRyKXtcbiAgICBpZighcHRyICYmIDAhPT1wdHIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZmkgPSBjYWNoZS5mcmVlRnVuY0luZGV4ZXM7XG4gICAgY29uc3QgZnQgPSB0YXJnZXQuZnVuY3Rpb25UYWJsZSgpO1xuICAgIGZpLnB1c2gocHRyKTtcbiAgICBjb25zdCByYyA9IGZ0LmdldChwdHIpO1xuICAgIGZ0LnNldChwdHIsIG51bGwpO1xuICAgIHJldHVybiByYztcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnBlZWsgPSBmdW5jdGlvbiBmKHB0ciwgdHlwZT0naTgnKXtcbiAgICBpZih0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSBwdHJJUjtcbiAgICBjb25zdCBjID0gKGNhY2hlLm1lbW9yeSAmJiBjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgID8gY2FjaGUgOiBoZWFwV3JhcHBlcnMoKTtcbiAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheShwdHIpID8gW10gOiB1bmRlZmluZWQ7XG4gICAgbGV0IHJjO1xuICAgIGRve1xuICAgICAgaWYobGlzdCkgcHRyID0gYXJndW1lbnRzWzBdLnNoaWZ0KCk7XG4gICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgIGNhc2UgJ2k4JzogcmMgPSBjLkhFQVA4W3B0cj4+MF07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2kxNic6IHJjID0gYy5IRUFQMTZbcHRyPj4xXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaTMyJzogcmMgPSBjLkhFQVAzMltwdHI+PjJdOyBicmVhaztcbiAgICAgICAgICBjYXNlICdmbG9hdCc6IGNhc2UgJ2YzMic6IHJjID0gYy5IRUFQMzJGW3B0cj4+Ml07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6IGNhc2UgJ2Y2NCc6IHJjID0gTnVtYmVyKGMuSEVBUDY0RltwdHI+PjNdKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgIGlmKHRhcmdldC5iaWdJbnRFbmFibGVkKXtcbiAgICAgICAgICAgICAgcmMgPSBCaWdJbnQoYy5IRUFQNjRbcHRyPj4zXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdHlwZSBmb3IgcGVlaygpOicsdHlwZSk7XG4gICAgICB9XG4gICAgICBpZihsaXN0KSBsaXN0LnB1c2gocmMpO1xuICAgIH13aGlsZShsaXN0ICYmIGFyZ3VtZW50c1swXS5sZW5ndGgpO1xuICAgIHJldHVybiBsaXN0IHx8IHJjO1xuICB9O1xuXG4gIFxuICB0YXJnZXQucG9rZSA9IGZ1bmN0aW9uKHB0ciwgdmFsdWUsIHR5cGU9J2k4Jyl7XG4gICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9IHB0cklSO1xuICAgIGNvbnN0IGMgPSAoY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgPyBjYWNoZSA6IGhlYXBXcmFwcGVycygpO1xuICAgIGZvcihjb25zdCBwIG9mIChBcnJheS5pc0FycmF5KHB0cikgPyBwdHIgOiBbcHRyXSkpe1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnaTEnOlxuICAgICAgICAgIGNhc2UgJ2k4JzogYy5IRUFQOFtwPj4wXSA9IHZhbHVlOyBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdpMTYnOiBjLkhFQVAxNltwPj4xXSA9IHZhbHVlOyBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdpMzInOiBjLkhFQVAzMltwPj4yXSA9IHZhbHVlOyBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdmbG9hdCc6IGNhc2UgJ2YzMic6IGMuSEVBUDMyRltwPj4yXSA9IHZhbHVlOyBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdkb3VibGUnOiBjYXNlICdmNjQnOiBjLkhFQVA2NEZbcD4+M10gPSB2YWx1ZTsgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnaTY0JzpcbiAgICAgICAgICAgIGlmKGMuSEVBUDY0KXtcbiAgICAgICAgICAgICAgYy5IRUFQNjRbcD4+M10gPSBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0b3NzKCdJbnZhbGlkIHR5cGUgZm9yIHBva2UoKTogJyArIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnBlZWtQdHIgPSAoLi4ucHRyKT0+dGFyZ2V0LnBlZWsoICgxPT09cHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciksIHB0cklSICk7XG5cbiAgXG4gIHRhcmdldC5wb2tlUHRyID0gKHB0ciwgdmFsdWU9MCk9PnRhcmdldC5wb2tlKHB0ciwgdmFsdWUsIHB0cklSKTtcblxuICBcbiAgdGFyZ2V0LnBlZWs4ID0gKC4uLnB0cik9PnRhcmdldC5wZWVrKCAoMT09PXB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIpLCAnaTgnICk7XG4gIFxuICB0YXJnZXQucG9rZTggPSAocHRyLCB2YWx1ZSk9PnRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpOCcpO1xuICBcbiAgdGFyZ2V0LnBlZWsxNiA9ICguLi5wdHIpPT50YXJnZXQucGVlayggKDE9PT1wdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyKSwgJ2kxNicgKTtcbiAgXG4gIHRhcmdldC5wb2tlMTYgPSAocHRyLCB2YWx1ZSk9PnRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpMTYnKTtcbiAgXG4gIHRhcmdldC5wZWVrMzIgPSAoLi4ucHRyKT0+dGFyZ2V0LnBlZWsoICgxPT09cHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciksICdpMzInICk7XG4gIFxuICB0YXJnZXQucG9rZTMyID0gKHB0ciwgdmFsdWUpPT50YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTMyJyk7XG4gIFxuICB0YXJnZXQucGVlazY0ID0gKC4uLnB0cik9PnRhcmdldC5wZWVrKCAoMT09PXB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIpLCAnaTY0JyApO1xuICBcbiAgdGFyZ2V0LnBva2U2NCA9IChwdHIsIHZhbHVlKT0+dGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2k2NCcpO1xuICBcbiAgdGFyZ2V0LnBlZWszMmYgPSAoLi4ucHRyKT0+dGFyZ2V0LnBlZWsoICgxPT09cHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciksICdmMzInICk7XG4gIFxuICB0YXJnZXQucG9rZTMyZiA9IChwdHIsIHZhbHVlKT0+dGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2YzMicpO1xuICBcbiAgdGFyZ2V0LnBlZWs2NGYgPSAoLi4ucHRyKT0+dGFyZ2V0LnBlZWsoICgxPT09cHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciksICdmNjQnICk7XG4gIFxuICB0YXJnZXQucG9rZTY0ZiA9IChwdHIsIHZhbHVlKT0+dGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2Y2NCcpO1xuXG4gIFxuICB0YXJnZXQuZ2V0TWVtVmFsdWUgPSB0YXJnZXQucGVlaztcbiAgXG4gIHRhcmdldC5nZXRQdHJWYWx1ZSA9IHRhcmdldC5wZWVrUHRyO1xuICBcbiAgdGFyZ2V0LnNldE1lbVZhbHVlID0gdGFyZ2V0LnBva2U7XG4gIFxuICB0YXJnZXQuc2V0UHRyVmFsdWUgPSB0YXJnZXQucG9rZVB0cjtcblxuICBcbiAgdGFyZ2V0LmlzUHRyMzIgPSAocHRyKT0+KCdudW1iZXInPT09dHlwZW9mIHB0ciAmJiAocHRyPT09KHB0cnwwKSkgJiYgcHRyPj0wKTtcblxuICBcbiAgdGFyZ2V0LmlzUHRyID0gdGFyZ2V0LmlzUHRyMzI7XG5cbiAgXG4gIHRhcmdldC5jc3RybGVuID0gZnVuY3Rpb24ocHRyKXtcbiAgICBpZighcHRyIHx8ICF0YXJnZXQuaXNQdHIocHRyKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaCA9IGhlYXBXcmFwcGVycygpLkhFQVA4VTtcbiAgICBsZXQgcG9zID0gcHRyO1xuICAgIGZvciggOyBoW3Bvc10gIT09IDA7ICsrcG9zICl7fVxuICAgIHJldHVybiBwb3MgLSBwdHI7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fU0FCID0gKCd1bmRlZmluZWQnPT09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKVxuICAgICAgICA/IGZ1bmN0aW9uKCl7fSA6IFNoYXJlZEFycmF5QnVmZmVyO1xuICBjb25zdCBfX3V0ZjhEZWNvZGUgPSBmdW5jdGlvbihhcnJheUJ1ZmZlciwgYmVnaW4sIGVuZCl7XG4gICAgcmV0dXJuIGNhY2hlLnV0ZjhEZWNvZGVyLmRlY29kZShcbiAgICAgIChhcnJheUJ1ZmZlci5idWZmZXIgaW5zdGFuY2VvZiBfX1NBQilcbiAgICAgICAgPyBhcnJheUJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKVxuICAgICAgICA6IGFycmF5QnVmZmVyLnN1YmFycmF5KGJlZ2luLCBlbmQpXG4gICAgKTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmNzdHJUb0pzID0gZnVuY3Rpb24ocHRyKXtcbiAgICBjb25zdCBuID0gdGFyZ2V0LmNzdHJsZW4ocHRyKTtcbiAgICByZXR1cm4gbiA/IF9fdXRmOERlY29kZShoZWFwV3JhcHBlcnMoKS5IRUFQOFUsIHB0ciwgcHRyK24pIDogKG51bGw9PT1uID8gbiA6IFwiXCIpO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuanN0cmxlbiA9IGZ1bmN0aW9uKHN0cil7XG4gICAgXG4gICAgaWYoJ3N0cmluZychPT10eXBlb2Ygc3RyKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBuID0gc3RyLmxlbmd0aDtcbiAgICBsZXQgbGVuID0gMDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbjsgKytpKXtcbiAgICAgIGxldCB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZih1Pj0weGQ4MDAgJiYgdTw9MHhkZmZmKXtcbiAgICAgICAgdSA9IDB4MTAwMDAgKyAoKHUgJiAweDNGRikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNGRik7XG4gICAgICB9XG4gICAgICBpZih1PD0weDdmKSArK2xlbjtcbiAgICAgIGVsc2UgaWYodTw9MHg3ZmYpIGxlbiArPSAyO1xuICAgICAgZWxzZSBpZih1PD0weGZmZmYpIGxlbiArPSAzO1xuICAgICAgZWxzZSBsZW4gKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIGxlbjtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmpzdHJjcHkgPSBmdW5jdGlvbihqc3RyLCB0Z3QsIG9mZnNldCA9IDAsIG1heEJ5dGVzID0gLTEsIGFkZE51bCA9IHRydWUpe1xuICAgIFxuICAgIGlmKCF0Z3QgfHwgKCEodGd0IGluc3RhbmNlb2YgSW50OEFycmF5KSAmJiAhKHRndCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSl7XG4gICAgICB0b3NzKFwianN0cmNweSgpIHRhcmdldCBtdXN0IGJlIGFuIEludDhBcnJheSBvciBVaW50OEFycmF5LlwiKTtcbiAgICB9XG4gICAgaWYobWF4Qnl0ZXM8MCkgbWF4Qnl0ZXMgPSB0Z3QubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGlmKCEobWF4Qnl0ZXM+MCkgfHwgIShvZmZzZXQ+PTApKSByZXR1cm4gMDtcbiAgICBsZXQgaSA9IDAsIG1heCA9IGpzdHIubGVuZ3RoO1xuICAgIGNvbnN0IGJlZ2luID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBtYXhCeXRlcyAtIChhZGROdWwgPyAxIDogMCk7XG4gICAgZm9yKDsgaSA8IG1heCAmJiBvZmZzZXQgPCBlbmQ7ICsraSl7XG4gICAgICBsZXQgdSA9IGpzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmKHU+PTB4ZDgwMCAmJiB1PD0weGRmZmYpe1xuICAgICAgICB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAoanN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNGRik7XG4gICAgICB9XG4gICAgICBpZih1PD0weDdmKXtcbiAgICAgICAgaWYob2Zmc2V0ID49IGVuZCkgYnJlYWs7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSB1O1xuICAgICAgfWVsc2UgaWYodTw9MHg3ZmYpe1xuICAgICAgICBpZihvZmZzZXQgKyAxID49IGVuZCkgYnJlYWs7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweEMwIHwgKHUgPj4gNik7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgIH1lbHNlIGlmKHU8PTB4ZmZmZil7XG4gICAgICAgIGlmKG9mZnNldCArIDIgPj0gZW5kKSBicmVhaztcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ZTAgfCAodSA+PiAxMik7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgMHgzZik7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBpZihvZmZzZXQgKyAzID49IGVuZCkgYnJlYWs7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweGYwIHwgKHUgPj4gMTgpO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiAweDNmKTtcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiAweDNmKTtcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAodSAmIDB4M2YpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihhZGROdWwpIHRndFtvZmZzZXQrK10gPSAwO1xuICAgIHJldHVybiBvZmZzZXQgLSBiZWdpbjtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmNzdHJuY3B5ID0gZnVuY3Rpb24odGd0UHRyLCBzcmNQdHIsIG4pe1xuICAgIGlmKCF0Z3RQdHIgfHwgIXNyY1B0cikgdG9zcyhcImNzdHJuY3B5KCkgZG9lcyBub3QgYWNjZXB0IE5VTEwgc3RyaW5ncy5cIik7XG4gICAgaWYobjwwKSBuID0gdGFyZ2V0LmNzdHJsZW4oc3RyUHRyKSsxO1xuICAgIGVsc2UgaWYoIShuPjApKSByZXR1cm4gMDtcbiAgICBjb25zdCBoZWFwID0gdGFyZ2V0LmhlYXA4dSgpO1xuICAgIGxldCBpID0gMCwgY2g7XG4gICAgZm9yKDsgaSA8IG4gJiYgKGNoID0gaGVhcFtzcmNQdHIraV0pOyArK2kpe1xuICAgICAgaGVhcFt0Z3RQdHIraV0gPSBjaDtcbiAgICB9XG4gICAgaWYoaTxuKSBoZWFwW3RndFB0ciArIGkrK10gPSAwO1xuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuanN0clRvVWludEFycmF5ID0gKHN0ciwgYWRkTnVsPWZhbHNlKT0+e1xuICAgIHJldHVybiBjYWNoZS51dGY4RW5jb2Rlci5lbmNvZGUoYWRkTnVsID8gKHN0citcIlxcMFwiKSA6IHN0cik7XG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gIH07XG5cbiAgY29uc3QgX19hZmZpcm1BbGxvYyA9IChvYmosZnVuY05hbWUpPT57XG4gICAgaWYoIShvYmouYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAhKG9iai5kZWFsbG9jIGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICAgIHRvc3MoXCJPYmplY3QgaXMgbWlzc2luZyBhbGxvYygpIGFuZC9vciBkZWFsbG9jKCkgZnVuY3Rpb24ocylcIixcbiAgICAgICAgICAgXCJyZXF1aXJlZCBieVwiLGZ1bmNOYW1lK1wiKCkuXCIpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBfX2FsbG9jQ1N0ciA9IGZ1bmN0aW9uKGpzdHIsIHJldHVybldpdGhMZW5ndGgsIGFsbG9jYXRvciwgZnVuY05hbWUpe1xuICAgIF9fYWZmaXJtQWxsb2ModGFyZ2V0LCBmdW5jTmFtZSk7XG4gICAgaWYoJ3N0cmluZychPT10eXBlb2YganN0cikgcmV0dXJuIG51bGw7XG4gICAgaWYoMCl7XG4gICAgICBjb25zdCBuID0gdGFyZ2V0LmpzdHJsZW4oanN0ciksXG4gICAgICAgICAgICBwdHIgPSBhbGxvY2F0b3IobisxKTtcbiAgICAgIHRhcmdldC5qc3RyY3B5KGpzdHIsIHRhcmdldC5oZWFwOHUoKSwgcHRyLCBuKzEsIHRydWUpO1xuICAgICAgcmV0dXJuIHJldHVybldpdGhMZW5ndGggPyBbcHRyLCBuXSA6IHB0cjtcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnN0IHUgPSBjYWNoZS51dGY4RW5jb2Rlci5lbmNvZGUoanN0ciksXG4gICAgICAgICAgICBwdHIgPSBhbGxvY2F0b3IodS5sZW5ndGgrMSksXG4gICAgICAgICAgICBoZWFwID0gaGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuICAgICAgaGVhcC5zZXQodSwgcHRyKTtcbiAgICAgIGhlYXBbcHRyICsgdS5sZW5ndGhdID0gMDtcbiAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgdS5sZW5ndGhdIDogcHRyO1xuICAgIH1cbiAgfTtcblxuICBcbiAgdGFyZ2V0LmFsbG9jQ1N0cmluZyA9XG4gICAgKGpzdHIsIHJldHVybldpdGhMZW5ndGg9ZmFsc2UpPT5fX2FsbG9jQ1N0cihqc3RyLCByZXR1cm5XaXRoTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFsbG9jLCAnYWxsb2NDU3RyaW5nKCknKTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEFsbG9jUHVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsICdzY29wZWRBbGxvY1B1c2gnKTtcbiAgICBjb25zdCBhID0gW107XG4gICAgY2FjaGUuc2NvcGVkQWxsb2MucHVzaChhKTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEFsbG9jUG9wID0gZnVuY3Rpb24oc3RhdGUpe1xuICAgIF9fYWZmaXJtQWxsb2ModGFyZ2V0LCAnc2NvcGVkQWxsb2NQb3AnKTtcbiAgICBjb25zdCBuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgID8gY2FjaGUuc2NvcGVkQWxsb2MuaW5kZXhPZihzdGF0ZSlcbiAgICAgICAgICA6IGNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aC0xO1xuICAgIGlmKG48MCkgdG9zcyhcIkludmFsaWQgc3RhdGUgb2JqZWN0IGZvciBzY29wZWRBbGxvY1BvcCgpLlwiKTtcbiAgICBpZigwPT09YXJndW1lbnRzLmxlbmd0aCkgc3RhdGUgPSBjYWNoZS5zY29wZWRBbGxvY1tuXTtcbiAgICBjYWNoZS5zY29wZWRBbGxvYy5zcGxpY2UobiwxKTtcbiAgICBmb3IobGV0IHA7IChwID0gc3RhdGUucG9wKCkpOyApe1xuICAgICAgaWYodGFyZ2V0LmZ1bmN0aW9uRW50cnkocCkpe1xuICAgICAgICBcbiAgICAgICAgdGFyZ2V0LnVuaW5zdGFsbEZ1bmN0aW9uKHApO1xuICAgICAgfVxuICAgICAgZWxzZSB0YXJnZXQuZGVhbGxvYyhwKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIHRhcmdldC5zY29wZWRBbGxvYyA9IGZ1bmN0aW9uKG4pe1xuICAgIGlmKCFjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgpe1xuICAgICAgdG9zcyhcIk5vIHNjb3BlZEFsbG9jUHVzaCgpIHNjb3BlIGlzIGFjdGl2ZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IHAgPSB0YXJnZXQuYWxsb2Mobik7XG4gICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoLTFdLnB1c2gocCk7XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldC5zY29wZWRBbGxvYywgJ2xldmVsJywge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogKCk9PmNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCxcbiAgICBzZXQ6ICgpPT50b3NzKFwiVGhlICdhY3RpdmUnIHByb3BlcnR5IGlzIHJlYWQtb25seS5cIilcbiAgfSk7XG5cbiAgXG4gIHRhcmdldC5zY29wZWRBbGxvY0NTdHJpbmcgPVxuICAgIChqc3RyLCByZXR1cm5XaXRoTGVuZ3RoPWZhbHNlKT0+X19hbGxvY0NTdHIoanN0ciwgcmV0dXJuV2l0aExlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zY29wZWRBbGxvYywgJ3Njb3BlZEFsbG9jQ1N0cmluZygpJyk7XG5cbiAgXG4gIGNvbnN0IF9fYWxsb2NNYWluQXJndiA9IGZ1bmN0aW9uKGlzU2NvcGVkLCBsaXN0KXtcbiAgICBjb25zdCBwTGlzdCA9IHRhcmdldFtcbiAgICAgIGlzU2NvcGVkID8gJ3Njb3BlZEFsbG9jJyA6ICdhbGxvYydcbiAgICBdKChsaXN0Lmxlbmd0aCArIDEpICogdGFyZ2V0LnB0clNpemVvZik7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxpc3QuZm9yRWFjaCgoZSk9PntcbiAgICAgIHRhcmdldC5wb2tlUHRyKHBMaXN0ICsgKHRhcmdldC5wdHJTaXplb2YgKiBpKyspLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2NvcGVkID8gJ3Njb3BlZEFsbG9jQ1N0cmluZycgOiAnYWxsb2NDU3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgIF0oXCJcIitlKSk7XG4gICAgfSk7XG4gICAgdGFyZ2V0LnBva2VQdHIocExpc3QgKyAodGFyZ2V0LnB0clNpemVvZiAqIGkpLCAwKTtcbiAgICByZXR1cm4gcExpc3Q7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5zY29wZWRBbGxvY01haW5Bcmd2ID0gKGxpc3QpPT5fX2FsbG9jTWFpbkFyZ3YodHJ1ZSwgbGlzdCk7XG5cbiAgXG4gIHRhcmdldC5hbGxvY01haW5Bcmd2ID0gKGxpc3QpPT5fX2FsbG9jTWFpbkFyZ3YoZmFsc2UsIGxpc3QpO1xuXG4gIFxuICB0YXJnZXQuY0FyZ3ZUb0pzID0gKGFyZ2MsIHBBcmd2KT0+e1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXJnYzsgKytpKXtcbiAgICAgIGNvbnN0IGFyZyA9IHRhcmdldC5wZWVrUHRyKHBBcmd2ICsgKHRhcmdldC5wdHJTaXplb2YgKiBpKSk7XG4gICAgICBsaXN0LnB1c2goIGFyZyA/IHRhcmdldC5jc3RyVG9KcyhhcmcpIDogbnVsbCApO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEFsbG9jQ2FsbCA9IGZ1bmN0aW9uKGZ1bmMpe1xuICAgIHRhcmdldC5zY29wZWRBbGxvY1B1c2goKTtcbiAgICB0cnl7IHJldHVybiBmdW5jKCkgfSBmaW5hbGx5eyB0YXJnZXQuc2NvcGVkQWxsb2NQb3AoKSB9XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fYWxsb2NQdHIgPSBmdW5jdGlvbihob3dNYW55LCBzYWZlUHRyU2l6ZSwgbWV0aG9kKXtcbiAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgbWV0aG9kKTtcbiAgICBjb25zdCBwSXIgPSBzYWZlUHRyU2l6ZSA/ICdpNjQnIDogcHRySVI7XG4gICAgbGV0IG0gPSB0YXJnZXRbbWV0aG9kXShob3dNYW55ICogKHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZikpO1xuICAgIHRhcmdldC5wb2tlKG0sIDAsIHBJcilcbiAgICBpZigxPT09aG93TWFueSl7XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgY29uc3QgYSA9IFttXTtcbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgaG93TWFueTsgKytpKXtcbiAgICAgIG0gKz0gKHNhZmVQdHJTaXplID8gOCA6IHB0clNpemVvZik7XG4gICAgICBhW2ldID0gbTtcbiAgICAgIHRhcmdldC5wb2tlKG0sIDAsIHBJcik7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuYWxsb2NQdHIgPVxuICAgIChob3dNYW55PTEsIHNhZmVQdHJTaXplPXRydWUpPT5fX2FsbG9jUHRyKGhvd01hbnksIHNhZmVQdHJTaXplLCAnYWxsb2MnKTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEFsbG9jUHRyID1cbiAgICAoaG93TWFueT0xLCBzYWZlUHRyU2l6ZT10cnVlKT0+X19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ3Njb3BlZEFsbG9jJyk7XG5cbiAgXG4gIHRhcmdldC54R2V0ID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHRhcmdldC5leHBvcnRzW25hbWVdIHx8IHRvc3MoXCJDYW5ub3QgZmluZCBleHBvcnRlZCBzeW1ib2w6XCIsbmFtZSk7XG4gIH07XG5cbiAgY29uc3QgX19hcmdjTWlzbWF0Y2ggPVxuICAgICAgICAoZixuKT0+dG9zcyhmK1wiKCkgcmVxdWlyZXNcIixuLFwiYXJndW1lbnQocykuXCIpO1xuXG4gIFxuICB0YXJnZXQueENhbGwgPSBmdW5jdGlvbihmbmFtZSwgLi4uYXJncyl7XG4gICAgY29uc3QgZiA9IHRhcmdldC54R2V0KGZuYW1lKTtcbiAgICBpZighKGYgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHRvc3MoXCJFeHBvcnRlZCBzeW1ib2xcIixmbmFtZSxcImlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICBpZihmLmxlbmd0aCE9PWFyZ3MubGVuZ3RoKSBfX2FyZ2NNaXNtYXRjaChmbmFtZSxmLmxlbmd0aClcbiAgICA7XG4gICAgcmV0dXJuICgyPT09YXJndW1lbnRzLmxlbmd0aCAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpXG4gICAgICA/IGYuYXBwbHkobnVsbCwgYXJndW1lbnRzWzFdKVxuICAgICAgOiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIFxuICBjYWNoZS54V3JhcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNhY2hlLnhXcmFwLmNvbnZlcnQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBcbiAgY2FjaGUueFdyYXAuY29udmVydC5hcmcgPSBuZXcgTWFwO1xuICBcbiAgY2FjaGUueFdyYXAuY29udmVydC5yZXN1bHQgPSBuZXcgTWFwO1xuICBjb25zdCB4QXJnID0gY2FjaGUueFdyYXAuY29udmVydC5hcmcsIHhSZXN1bHQgPSBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdDtcblxuICBpZih0YXJnZXQuYmlnSW50RW5hYmxlZCl7XG4gICAgeEFyZy5zZXQoJ2k2NCcsIChpKT0+QmlnSW50KGkpKTtcbiAgfVxuICBjb25zdCBfX3hBcmdQdHIgPSAnaTMyJyA9PT0gcHRySVJcbiAgICAgICAgPyAoKGkpPT4oaSB8IDApKSA6ICgoaSk9PihCaWdJbnQoaSkgfCBCaWdJbnQoMCkpKTtcbiAgeEFyZy5zZXQoJ2kzMicsIF9feEFyZ1B0ciApXG4gICAgLnNldCgnaTE2JywgKGkpPT4oKGkgfCAwKSAmIDB4RkZGRikpXG4gICAgLnNldCgnaTgnLCAoaSk9PigoaSB8IDApICYgMHhGRikpXG4gICAgLnNldCgnZjMyJywgKGkpPT5OdW1iZXIoaSkudmFsdWVPZigpKVxuICAgIC5zZXQoJ2Zsb2F0JywgeEFyZy5nZXQoJ2YzMicpKVxuICAgIC5zZXQoJ2Y2NCcsIHhBcmcuZ2V0KCdmMzInKSlcbiAgICAuc2V0KCdkb3VibGUnLCB4QXJnLmdldCgnZjY0JykpXG4gICAgLnNldCgnaW50JywgeEFyZy5nZXQoJ2kzMicpKVxuICAgIC5zZXQoJ251bGwnLCAoaSk9PmkpXG4gICAgLnNldChudWxsLCB4QXJnLmdldCgnbnVsbCcpKVxuICAgIC5zZXQoJyoqJywgX194QXJnUHRyKVxuICAgIC5zZXQoJyonLCBfX3hBcmdQdHIpO1xuICB4UmVzdWx0LnNldCgnKicsIF9feEFyZ1B0cilcbiAgICAuc2V0KCdwb2ludGVyJywgX194QXJnUHRyKVxuICAgIC5zZXQoJ251bWJlcicsICh2KT0+TnVtYmVyKHYpKVxuICAgIC5zZXQoJ3ZvaWQnLCAodik9PnVuZGVmaW5lZClcbiAgICAuc2V0KCdudWxsJywgKHYpPT52KVxuICAgIC5zZXQobnVsbCwgeFJlc3VsdC5nZXQoJ251bGwnKSk7XG5cbiAgeyBcbiAgICBjb25zdCBjb3B5VG9SZXN1bHQgPSBbJ2k4JywgJ2kxNicsICdpMzInLCAnaW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2YzMicsICdmbG9hdCcsICdmNjQnLCAnZG91YmxlJ107XG4gICAgaWYodGFyZ2V0LmJpZ0ludEVuYWJsZWQpIGNvcHlUb1Jlc3VsdC5wdXNoKCdpNjQnKTtcbiAgICBjb25zdCBhZGFwdFB0ciA9IHhBcmcuZ2V0KHB0cklSKTtcbiAgICBmb3IoY29uc3QgdCBvZiBjb3B5VG9SZXN1bHQpe1xuICAgICAgeEFyZy5zZXQodCsnKicsIGFkYXB0UHRyKTtcbiAgICAgIHhSZXN1bHQuc2V0KHQrJyonLCBhZGFwdFB0cik7XG4gICAgICB4UmVzdWx0LnNldCh0LCAoeEFyZy5nZXQodCkgfHwgdG9zcyhcIk1pc3NpbmcgYXJnIGNvbnZlcnRlcjpcIix0KSkpO1xuICAgIH1cbiAgfVxuXG4gIFxuICBjb25zdCBfX3hBcmdTdHJpbmcgPSBmdW5jdGlvbih2KXtcbiAgICBpZignc3RyaW5nJz09PXR5cGVvZiB2KSByZXR1cm4gdGFyZ2V0LnNjb3BlZEFsbG9jQ1N0cmluZyh2KTtcbiAgICByZXR1cm4gdiA/IF9feEFyZ1B0cih2KSA6IG51bGw7XG4gIH07XG4gIHhBcmcuc2V0KCdzdHJpbmcnLCBfX3hBcmdTdHJpbmcpXG4gICAgLnNldCgndXRmOCcsIF9feEFyZ1N0cmluZylcbiAgICAuc2V0KCdwb2ludGVyJywgX194QXJnU3RyaW5nKTtcbiAgXG5cbiAgeFJlc3VsdC5zZXQoJ3N0cmluZycsIChpKT0+dGFyZ2V0LmNzdHJUb0pzKGkpKVxuICAgIC5zZXQoJ3V0ZjgnLCB4UmVzdWx0LmdldCgnc3RyaW5nJykpXG4gICAgLnNldCgnc3RyaW5nOmRlYWxsb2MnLCAoaSk9PntcbiAgICAgIHRyeSB7IHJldHVybiBpID8gdGFyZ2V0LmNzdHJUb0pzKGkpIDogbnVsbCB9XG4gICAgICBmaW5hbGx5eyB0YXJnZXQuZGVhbGxvYyhpKSB9XG4gICAgfSlcbiAgICAuc2V0KCd1dGY4OmRlYWxsb2MnLCB4UmVzdWx0LmdldCgnc3RyaW5nOmRlYWxsb2MnKSlcbiAgICAuc2V0KCdqc29uJywgKGkpPT5KU09OLnBhcnNlKHRhcmdldC5jc3RyVG9KcyhpKSkpXG4gICAgLnNldCgnanNvbjpkZWFsbG9jJywgKGkpPT57XG4gICAgICB0cnl7IHJldHVybiBpID8gSlNPTi5wYXJzZSh0YXJnZXQuY3N0clRvSnMoaSkpIDogbnVsbCB9XG4gICAgICBmaW5hbGx5eyB0YXJnZXQuZGVhbGxvYyhpKSB9XG4gICAgfSk7XG5cbiAgXG4gIGNvbnN0IEFic3RyYWN0QXJnQWRhcHRlciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHQpe1xuICAgICAgdGhpcy5uYW1lID0gb3B0Lm5hbWUgfHwgJ3VubmFtZWQgYWRhcHRlcic7XG4gICAgfVxuICAgIFxuICAgIGNvbnZlcnRBcmcodixhcmd2LGFyZ0luZGV4KXtcbiAgICAgIHRvc3MoXCJBYnN0cmFjdEFyZ0FkYXB0ZXIgbXVzdCBiZSBzdWJjbGFzc2VkLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIHhBcmcuRnVuY1B0ckFkYXB0ZXIgPSBjbGFzcyBGdW5jUHRyQWRhcHRlciBleHRlbmRzIEFic3RyYWN0QXJnQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICBzdXBlcihvcHQpO1xuICAgICAgaWYoeEFyZy5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2Upe1xuICAgICAgICBjb25zb2xlLndhcm4oJ3hBcmcuRnVuY1B0ckFkYXB0ZXIgaXMgYW4gaW50ZXJuYWwtb25seSBBUEknLFxuICAgICAgICAgICAgICAgICAgICAgJ2FuZCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaW52b2tlZCBmcm9tJyxcbiAgICAgICAgICAgICAgICAgICAgICdjbGllbnQtbGV2ZWwgY29kZS4gSW52b2tlZCB3aXRoOicsb3B0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IG9wdC5uYW1lIHx8IFwidW5uYW1lZFwiO1xuICAgICAgdGhpcy5zaWduYXR1cmUgPSBvcHQuc2lnbmF0dXJlO1xuICAgICAgaWYob3B0LmNvbnRleHRLZXkgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgIHRoaXMuY29udGV4dEtleSA9IG9wdC5jb250ZXh0S2V5O1xuICAgICAgICBpZighb3B0LmJpbmRTY29wZSkgb3B0LmJpbmRTY29wZSA9ICdjb250ZXh0JztcbiAgICAgIH1cbiAgICAgIHRoaXMuYmluZFNjb3BlID0gb3B0LmJpbmRTY29wZVxuICAgICAgICB8fCB0b3NzKFwiRnVuY1B0ckFkYXB0ZXIgb3B0aW9ucyByZXF1aXJlcyBhIGJpbmRTY29wZSAoZXhwbGljaXQgb3IgaW1wbGllZCkuXCIpO1xuICAgICAgaWYoRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5pbmRleE9mKG9wdC5iaW5kU2NvcGUpPDApe1xuICAgICAgICB0b3NzKFwiSW52YWxpZCBvcHRpb25zLmJpbmRTY29wZSAoXCIrb3B0LmJpbmRNb2QrXCIpIGZvciBGdW5jUHRyQWRhcHRlci4gXCIrXG4gICAgICAgICAgICAgXCJFeHBlY3Rpbmcgb25lIG9mOiAoXCIrRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3Blcy5qb2luKCcsICcpKycpJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzVHJhbnNpZW50ID0gJ3RyYW5zaWVudCc9PT10aGlzLmJpbmRTY29wZTtcbiAgICAgIHRoaXMuaXNDb250ZXh0ID0gJ2NvbnRleHQnPT09dGhpcy5iaW5kU2NvcGU7XG4gICAgICB0aGlzLmlzUGVybWFuZW50ID0gJ3Blcm1hbmVudCc9PT10aGlzLmJpbmRTY29wZTtcbiAgICAgIHRoaXMuc2luZ2xldG9uID0gKCdzaW5nbGV0b24nPT09dGhpcy5iaW5kU2NvcGUpID8gW10gOiB1bmRlZmluZWQ7XG4gICAgICBcbiAgICAgIHRoaXMuY2FsbFByb3h5ID0gKG9wdC5jYWxsUHJveHkgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgPyBvcHQuY2FsbFByb3h5IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIFxuXG4gICAgXG4gICAgY29udGV4dEtleShhcmd2LGFyZ0luZGV4KXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFxuICAgIGNvbnRleHRNYXAoa2V5KXtcbiAgICAgIGNvbnN0IGNtID0gKHRoaXMuX19jbWFwIHx8ICh0aGlzLl9fY21hcCA9IG5ldyBNYXApKTtcbiAgICAgIGxldCByYyA9IGNtLmdldChrZXkpO1xuICAgICAgaWYodW5kZWZpbmVkPT09cmMpIGNtLnNldChrZXksIChyYyA9IFtdKSk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfVxuXG4gICAgXG4gICAgY29udmVydEFyZyh2LGFyZ3YsYXJnSW5kZXgpe1xuICAgICAgXG4gICAgICBsZXQgcGFpciA9IHRoaXMuc2luZ2xldG9uO1xuICAgICAgaWYoIXBhaXIgJiYgdGhpcy5pc0NvbnRleHQpe1xuICAgICAgICBwYWlyID0gdGhpcy5jb250ZXh0TWFwKHRoaXMuY29udGV4dEtleShhcmd2LGFyZ0luZGV4KSk7XG4gICAgICAgIFxuICAgICAgfVxuICAgICAgaWYocGFpciAmJiBwYWlyWzBdPT09dikgcmV0dXJuIHBhaXJbMV07XG4gICAgICBpZih2IGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuY2FsbFByb3h5KSB2ID0gdGhpcy5jYWxsUHJveHkodik7XG4gICAgICAgIGNvbnN0IGZwID0gX19pbnN0YWxsRnVuY3Rpb24odiwgdGhpcy5zaWduYXR1cmUsIHRoaXMuaXNUcmFuc2llbnQpO1xuICAgICAgICBpZihGdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsKXtcbiAgICAgICAgICBGdW5jUHRyQWRhcHRlci5kZWJ1Z091dChcIkZ1bmNQdHJBZGFwdGVyIGluc3RhbGxlZFwiLCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dEtleShhcmd2LGFyZ0luZGV4KSwgJ0AnK2ZwLCB2KTtcbiAgICAgICAgfVxuICAgICAgICBpZihwYWlyKXtcbiAgICAgICAgICBcbiAgICAgICAgICBpZihwYWlyWzFdKXtcbiAgICAgICAgICAgIGlmKEZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwpe1xuICAgICAgICAgICAgICBGdW5jUHRyQWRhcHRlci5kZWJ1Z091dChcIkZ1bmNQdHJBZGFwdGVyIHVuaW5zdGFsbGluZ1wiLCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndixhcmdJbmRleCksICdAJytwYWlyWzFdLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aC0xXS5wdXNoKHBhaXJbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYWlyWzBdID0gdjtcbiAgICAgICAgICBwYWlyWzFdID0gZnA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZwO1xuICAgICAgfWVsc2UgaWYodGFyZ2V0LmlzUHRyKHYpIHx8IG51bGw9PT12IHx8IHVuZGVmaW5lZD09PXYpe1xuICAgICAgICBcbiAgICAgICAgaWYocGFpciAmJiBwYWlyWzFdICYmIHBhaXJbMV0hPT12KXtcbiAgICAgICAgICBcbiAgICAgICAgICBpZihGdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsKXtcbiAgICAgICAgICAgIEZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0KFwiRnVuY1B0ckFkYXB0ZXIgdW5pbnN0YWxsaW5nXCIsIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndixhcmdJbmRleCksICdAJytwYWlyWzFdLCB2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5eyBjYWNoZS5zY29wZWRBbGxvY1tjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgtMV0ucHVzaChwYWlyWzFdKSB9XG4gICAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgICAgIHBhaXJbMF0gPSBwYWlyWzFdID0gKHYgfCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdiB8fCAwO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIEZ1bmNQdHJBZGFwdGVyIGFyZ3VtZW50IHR5cGUuIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0aW5nIGEgZnVuY3Rpb24gcG9pbnRlciBvciBhIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm5hbWUgPyB0aGlzLm5hbWUrJyAnIDogJycpK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbWF0Y2hpbmcgc2lnbmF0dXJlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlK1wiLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXG4gIHhBcmcuRnVuY1B0ckFkYXB0ZXIud2Fybk9uVXNlID0gZmFsc2U7XG5cbiAgXG4gIHhBcmcuRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCA9IGZhbHNlO1xuXG4gIFxuICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0ID0gY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpO1xuXG4gIHhBcmcuRnVuY1B0ckFkYXB0ZXIuYmluZFNjb3BlcyA9IFtcbiAgICAndHJhbnNpZW50JywgJ2NvbnRleHQnLCAnc2luZ2xldG9uJywgJ3Blcm1hbmVudCdcbiAgXTtcblxuICBjb25zdCBfX3hBcmdBZGFwdGVyQ2hlY2sgPVxuICAgICAgICAodCk9PnhBcmcuZ2V0KHQpIHx8IHRvc3MoXCJBcmd1bWVudCBhZGFwdGVyIG5vdCBmb3VuZDpcIix0KTtcblxuICBjb25zdCBfX3hSZXN1bHRBZGFwdGVyQ2hlY2sgPVxuICAgICAgICAodCk9PnhSZXN1bHQuZ2V0KHQpIHx8IHRvc3MoXCJSZXN1bHQgYWRhcHRlciBub3QgZm91bmQ6XCIsdCk7XG5cbiAgY2FjaGUueFdyYXAuY29udmVydEFyZyA9ICh0LC4uLmFyZ3MpPT5fX3hBcmdBZGFwdGVyQ2hlY2sodCkoLi4uYXJncyk7XG4gIGNhY2hlLnhXcmFwLmNvbnZlcnRBcmdOb0NoZWNrID0gKHQsLi4uYXJncyk9PnhBcmcuZ2V0KHQpKC4uLmFyZ3MpO1xuXG4gIGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHQgPVxuICAgICh0LHYpPT4obnVsbD09PXQgPyB2IDogKHQgPyBfX3hSZXN1bHRBZGFwdGVyQ2hlY2sodCkodikgOiB1bmRlZmluZWQpKTtcbiAgY2FjaGUueFdyYXAuY29udmVydFJlc3VsdE5vQ2hlY2sgPVxuICAgICh0LHYpPT4obnVsbD09PXQgPyB2IDogKHQgPyB4UmVzdWx0LmdldCh0KSh2KSA6IHVuZGVmaW5lZCkpO1xuXG4gIFxuICB0YXJnZXQueFdyYXAgPSBmdW5jdGlvbihmQXJnLCByZXN1bHRUeXBlLCAuLi5hcmdUeXBlcyl7XG4gICAgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pKXtcbiAgICAgIGFyZ1R5cGVzID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICBpZih0YXJnZXQuaXNQdHIoZkFyZykpe1xuICAgICAgZkFyZyA9IHRhcmdldC5mdW5jdGlvbkVudHJ5KGZBcmcpXG4gICAgICAgIHx8IHRvc3MoXCJGdW5jdGlvbiBwb2ludGVyIG5vdCBmb3VuZCBpbiBXQVNNIGZ1bmN0aW9uIHRhYmxlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZklzRnVuYyA9IChmQXJnIGluc3RhbmNlb2YgRnVuY3Rpb24pO1xuICAgIGNvbnN0IHhmID0gZklzRnVuYyA/IGZBcmcgOiB0YXJnZXQueEdldChmQXJnKTtcbiAgICBpZihmSXNGdW5jKSBmQXJnID0geGYubmFtZSB8fCAndW5uYW1lZCBmdW5jdGlvbic7XG4gICAgaWYoYXJnVHlwZXMubGVuZ3RoIT09eGYubGVuZ3RoKSBfX2FyZ2NNaXNtYXRjaChmQXJnLCB4Zi5sZW5ndGgpO1xuICAgIGlmKChudWxsPT09cmVzdWx0VHlwZSkgJiYgMD09PXhmLmxlbmd0aCl7XG4gICAgICBcbiAgICAgIHJldHVybiB4ZjtcbiAgICB9XG4gICAgO1xuICAgIGlmKHVuZGVmaW5lZCE9PXJlc3VsdFR5cGUgJiYgbnVsbCE9PXJlc3VsdFR5cGUpIF9feFJlc3VsdEFkYXB0ZXJDaGVjayhyZXN1bHRUeXBlKTtcbiAgICBmb3IoY29uc3QgdCBvZiBhcmdUeXBlcyl7XG4gICAgICBpZih0IGluc3RhbmNlb2YgQWJzdHJhY3RBcmdBZGFwdGVyKSB4QXJnLnNldCh0LCAoLi4uYXJncyk9PnQuY29udmVydEFyZyguLi5hcmdzKSk7XG4gICAgICBlbHNlIF9feEFyZ0FkYXB0ZXJDaGVjayh0KTtcbiAgICB9XG4gICAgY29uc3QgY3h3ID0gY2FjaGUueFdyYXA7XG4gICAgaWYoMD09PXhmLmxlbmd0aCl7XG4gICAgICBcbiAgICAgIHJldHVybiAoLi4uYXJncyk9PihhcmdzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgID8gX19hcmdjTWlzbWF0Y2goZkFyZywgeGYubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgIDogY3h3LmNvbnZlcnRSZXN1bHQocmVzdWx0VHlwZSwgeGYuY2FsbChudWxsKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICBpZihhcmdzLmxlbmd0aCE9PXhmLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZkFyZywgeGYubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHNjb3BlID0gdGFyZ2V0LnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgdHJ5e1xuICAgICAgICBcbiAgICAgICAgZm9yKGNvbnN0IGkgaW4gYXJncykgYXJnc1tpXSA9IGN4dy5jb252ZXJ0QXJnTm9DaGVjayhcbiAgICAgICAgICBhcmdUeXBlc1tpXSwgYXJnc1tpXSwgYXJncywgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gY3h3LmNvbnZlcnRSZXN1bHROb0NoZWNrKHJlc3VsdFR5cGUsIHhmLmFwcGx5KG51bGwsYXJncykpO1xuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIHRhcmdldC5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBcbiAgY29uc3QgX194QWRhcHRlciA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ2MsIHR5cGVOYW1lLCBhZGFwdGVyLCBtb2RlTmFtZSwgeGN2UGFydCl7XG4gICAgaWYoJ3N0cmluZyc9PT10eXBlb2YgdHlwZU5hbWUpe1xuICAgICAgaWYoMT09PWFyZ2MpIHJldHVybiB4Y3ZQYXJ0LmdldCh0eXBlTmFtZSk7XG4gICAgICBlbHNlIGlmKDI9PT1hcmdjKXtcbiAgICAgICAgaWYoIWFkYXB0ZXIpe1xuICAgICAgICAgIGRlbGV0ZSB4Y3ZQYXJ0LmdldCh0eXBlTmFtZSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICAgIH1lbHNlIGlmKCEoYWRhcHRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgICAgICAgdG9zcyhtb2RlTmFtZSxcInJlcXVpcmVzIGEgZnVuY3Rpb24gYXJndW1lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHhjdlBhcnQuc2V0KHR5cGVOYW1lLCBhZGFwdGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgfVxuICAgIHRvc3MoXCJJbnZhbGlkIGFyZ3VtZW50cyB0b1wiLG1vZGVOYW1lKTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnhXcmFwLnJlc3VsdEFkYXB0ZXIgPSBmdW5jdGlvbiBmKHR5cGVOYW1lLCBhZGFwdGVyKXtcbiAgICByZXR1cm4gX194QWRhcHRlcihmLCBhcmd1bWVudHMubGVuZ3RoLCB0eXBlTmFtZSwgYWRhcHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAncmVzdWx0QWRhcHRlcigpJywgeFJlc3VsdCk7XG4gIH07XG5cbiAgXG4gIHRhcmdldC54V3JhcC5hcmdBZGFwdGVyID0gZnVuY3Rpb24gZih0eXBlTmFtZSwgYWRhcHRlcil7XG4gICAgcmV0dXJuIF9feEFkYXB0ZXIoZiwgYXJndW1lbnRzLmxlbmd0aCwgdHlwZU5hbWUsIGFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgJ2FyZ0FkYXB0ZXIoKScsIHhBcmcpO1xuICB9O1xuXG4gIHRhcmdldC54V3JhcC5GdW5jUHRyQWRhcHRlciA9IHhBcmcuRnVuY1B0ckFkYXB0ZXI7XG5cbiAgXG4gIHRhcmdldC54Q2FsbFdyYXBwZWQgPSBmdW5jdGlvbihmQXJnLCByZXN1bHRUeXBlLCBhcmdUeXBlcywgLi4uYXJncyl7XG4gICAgaWYoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbM10pKSBhcmdzID0gYXJndW1lbnRzWzNdO1xuICAgIHJldHVybiB0YXJnZXQueFdyYXAoZkFyZywgcmVzdWx0VHlwZSwgYXJnVHlwZXN8fFtdKS5hcHBseShudWxsLCBhcmdzfHxbXSk7XG4gIH07XG5cbiAgXG4gIHRhcmdldC54V3JhcC50ZXN0Q29udmVydEFyZyA9IGNhY2hlLnhXcmFwLmNvbnZlcnRBcmc7XG5cbiAgXG4gIHRhcmdldC54V3JhcC50ZXN0Q29udmVydFJlc3VsdCA9IGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHQ7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuZ2xvYmFsVGhpcy5XaFdhc21VdGlsSW5zdGFsbGVyLnlhd2wgPSBmdW5jdGlvbihjb25maWcpe1xuICBjb25zdCB3ZmV0Y2ggPSAoKT0+ZmV0Y2goY29uZmlnLnVyaSwge2NyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nfSk7XG4gIGNvbnN0IHd1aSA9IHRoaXM7XG4gIGNvbnN0IGZpbmFsVGhlbiA9IGZ1bmN0aW9uKGFyZyl7XG4gICAgXG4gICAgaWYoY29uZmlnLndhc21VdGlsVGFyZ2V0KXtcbiAgICAgIGNvbnN0IHRvc3MgPSAoLi4uYXJncyk9Pnt0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpfTtcbiAgICAgIGNvbnN0IHRndCA9IGNvbmZpZy53YXNtVXRpbFRhcmdldDtcbiAgICAgIHRndC5tb2R1bGUgPSBhcmcubW9kdWxlO1xuICAgICAgdGd0Lmluc3RhbmNlID0gYXJnLmluc3RhbmNlO1xuICAgICAgXG4gICAgICBpZighdGd0Lmluc3RhbmNlLmV4cG9ydHMubWVtb3J5KXtcbiAgICAgICAgXG4gICAgICAgIHRndC5tZW1vcnkgPSAoY29uZmlnLmltcG9ydHMgJiYgY29uZmlnLmltcG9ydHMuZW52XG4gICAgICAgICAgICAgICAgICAgICAgJiYgY29uZmlnLmltcG9ydHMuZW52Lm1lbW9yeSlcbiAgICAgICAgICB8fCB0b3NzKFwiTWlzc2luZyAnbWVtb3J5JyBvYmplY3QhXCIpO1xuICAgICAgfVxuICAgICAgaWYoIXRndC5hbGxvYyAmJiBhcmcuaW5zdGFuY2UuZXhwb3J0cy5tYWxsb2Mpe1xuICAgICAgICBjb25zdCBleHBvcnRzID0gYXJnLmluc3RhbmNlLmV4cG9ydHM7XG4gICAgICAgIHRndC5hbGxvYyA9IGZ1bmN0aW9uKG4pe1xuICAgICAgICAgIHJldHVybiBleHBvcnRzLm1hbGxvYyhuKSB8fCB0b3NzKFwiQWxsb2NhdGlvbiBvZlwiLG4sXCJieXRlcyBmYWlsZWQuXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0Z3QuZGVhbGxvYyA9IGZ1bmN0aW9uKG0pe2V4cG9ydHMuZnJlZShtKX07XG4gICAgICB9XG4gICAgICB3dWkodGd0KTtcbiAgICB9XG4gICAgaWYoY29uZmlnLm9ubG9hZCkgY29uZmlnLm9ubG9hZChhcmcsY29uZmlnKTtcbiAgICByZXR1cm4gYXJnIDtcbiAgfTtcbiAgY29uc3QgbG9hZFdhc20gPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ1xuICAgICAgICA/IGZ1bmN0aW9uIGxvYWRXYXNtU3RyZWFtaW5nKCl7XG4gICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHdmZXRjaCgpLCBjb25maWcuaW1wb3J0c3x8e30pXG4gICAgICAgICAgICAudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gbG9hZFdhc21PbGRTY2hvb2woKXsgXG4gICAgICAgICAgcmV0dXJuIHdmZXRjaCgpXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgICAgLnRoZW4oYnl0ZXMgPT4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGNvbmZpZy5pbXBvcnRzfHx7fSkpXG4gICAgICAgICAgICAudGhlbihmaW5hbFRoZW4pO1xuICAgICAgICB9O1xuICByZXR1cm4gbG9hZFdhc207XG59LmJpbmQoZ2xvYmFsVGhpcy5XaFdhc21VdGlsSW5zdGFsbGVyKTtcblxuXG5cbid1c2Ugc3RyaWN0Jztcbmdsb2JhbFRoaXMuSmFjY3dhYnl0ID0gZnVuY3Rpb24gU3RydWN0QmluZGVyRmFjdG9yeShjb25maWcpe1xuXG5cbiAgXG4gIGNvbnN0IHRvc3MgPSAoLi4uYXJncyk9Pnt0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpfTtcblxuICBcbiAgaWYoIShjb25maWcuaGVhcCBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSlcbiAgICAgJiYgIShjb25maWcuaGVhcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgdG9zcyhcImNvbmZpZy5oZWFwIG11c3QgYmUgV2ViQXNzZW1ibHkuTWVtb3J5IGluc3RhbmNlIG9yIGEgZnVuY3Rpb24uXCIpO1xuICB9XG4gIFsnYWxsb2MnLCdkZWFsbG9jJ10uZm9yRWFjaChmdW5jdGlvbihrKXtcbiAgICAoY29uZmlnW2tdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICB0b3NzKFwiQ29uZmlnIG9wdGlvbiAnXCIraytcIicgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgfSk7XG4gIGNvbnN0IFNCRiA9IFN0cnVjdEJpbmRlckZhY3Rvcnk7XG4gIGNvbnN0IGhlYXAgPSAoY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgPyBjb25maWcuaGVhcCA6ICgoKT0+bmV3IFVpbnQ4QXJyYXkoY29uZmlnLmhlYXAuYnVmZmVyKSksXG4gICAgICAgIGFsbG9jID0gY29uZmlnLmFsbG9jLFxuICAgICAgICBkZWFsbG9jID0gY29uZmlnLmRlYWxsb2MsXG4gICAgICAgIGxvZyA9IGNvbmZpZy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgICAgICAgbWVtYmVyUHJlZml4ID0gKGNvbmZpZy5tZW1iZXJQcmVmaXggfHwgXCJcIiksXG4gICAgICAgIG1lbWJlclN1ZmZpeCA9IChjb25maWcubWVtYmVyU3VmZml4IHx8IFwiXCIpLFxuICAgICAgICBiaWdJbnRFbmFibGVkID0gKHVuZGVmaW5lZD09PWNvbmZpZy5iaWdJbnRFbmFibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyAhIWdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSA6ICEhY29uZmlnLmJpZ0ludEVuYWJsZWQpLFxuICAgICAgICBCaWdJbnQgPSBnbG9iYWxUaGlzWydCaWdJbnQnXSxcbiAgICAgICAgQmlnSW50NjRBcnJheSA9IGdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXSxcbiAgICAgICAgXG4gICAgICAgIHB0clNpemVvZiA9IGNvbmZpZy5wdHJTaXplb2YgfHwgNCxcbiAgICAgICAgcHRySVIgPSBjb25maWcucHRySVIgfHwgJ2kzMidcbiAgO1xuXG4gIGlmKCFTQkYuZGVidWdGbGFncyl7XG4gICAgU0JGLl9fbWFrZURlYnVnRmxhZ3MgPSBmdW5jdGlvbihkZXJpdmVGcm9tPW51bGwpe1xuICAgICAgXG4gICAgICBpZihkZXJpdmVGcm9tICYmIGRlcml2ZUZyb20uX19mbGFncykgZGVyaXZlRnJvbSA9IGRlcml2ZUZyb20uX19mbGFncztcbiAgICAgIGNvbnN0IGYgPSBmdW5jdGlvbiBmKGZsYWdzKXtcbiAgICAgICAgaWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgIHJldHVybiBmLl9fZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZmxhZ3M8MCl7XG4gICAgICAgICAgZGVsZXRlIGYuX19mbGFncy5nZXR0ZXI7IGRlbGV0ZSBmLl9fZmxhZ3Muc2V0dGVyO1xuICAgICAgICAgIGRlbGV0ZSBmLl9fZmxhZ3MuYWxsb2M7IGRlbGV0ZSBmLl9fZmxhZ3MuZGVhbGxvYztcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgZi5fX2ZsYWdzLmdldHRlciAgPSAwIT09KDB4MDEgJiBmbGFncyk7XG4gICAgICAgICAgZi5fX2ZsYWdzLnNldHRlciAgPSAwIT09KDB4MDIgJiBmbGFncyk7XG4gICAgICAgICAgZi5fX2ZsYWdzLmFsbG9jICAgPSAwIT09KDB4MDQgJiBmbGFncyk7XG4gICAgICAgICAgZi5fX2ZsYWdzLmRlYWxsb2MgPSAwIT09KDB4MDggJiBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYuX2ZsYWdzO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCdfX2ZsYWdzJywge1xuICAgICAgICBpdGVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IE9iamVjdC5jcmVhdGUoZGVyaXZlRnJvbSlcbiAgICAgIH0pO1xuICAgICAgaWYoIWRlcml2ZUZyb20pIGYoMCk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuICAgIFNCRi5kZWJ1Z0ZsYWdzID0gU0JGLl9fbWFrZURlYnVnRmxhZ3MoKTtcbiAgfVxuXG4gIGNvbnN0IGlzTGl0dGxlRW5kaWFuID0gKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcbiAgICBuZXcgRGF0YVZpZXcoYnVmZmVyKS5zZXRJbnQxNigwLCAyNTYsIHRydWUgKTtcbiAgICBcbiAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyKVswXSA9PT0gMjU2O1xuICB9KSgpO1xuICBcblxuICBcbiAgY29uc3QgaXNGdW5jU2lnID0gKHMpPT4nKCc9PT1zWzFdO1xuICBcbiAgY29uc3QgaXNQdHJTaWcgPSAocyk9PidwJz09PXMgfHwgJ1AnPT09cztcbiAgY29uc3QgaXNBdXRvUHRyU2lnID0gKHMpPT4nUCc9PT1zIDtcbiAgY29uc3Qgc2lnTGV0dGVyID0gKHMpPT5pc0Z1bmNTaWcocykgPyAncCcgOiBzWzBdO1xuICBcbiAgY29uc3Qgc2lnSVIgPSBmdW5jdGlvbihzKXtcbiAgICBzd2l0Y2goc2lnTGV0dGVyKHMpKXtcbiAgICAgICAgY2FzZSAnYyc6IGNhc2UgJ0MnOiByZXR1cm4gJ2k4JztcbiAgICAgICAgY2FzZSAnaSc6IHJldHVybiAnaTMyJztcbiAgICAgICAgY2FzZSAncCc6IGNhc2UgJ1AnOiBjYXNlICdzJzogcmV0dXJuIHB0cklSO1xuICAgICAgICBjYXNlICdqJzogcmV0dXJuICdpNjQnO1xuICAgICAgICBjYXNlICdmJzogcmV0dXJuICdmbG9hdCc7XG4gICAgICAgIGNhc2UgJ2QnOiByZXR1cm4gJ2RvdWJsZSc7XG4gICAgfVxuICAgIHRvc3MoXCJVbmhhbmRsZWQgc2lnbmF0dXJlIElSOlwiLHMpO1xuICB9O1xuXG4gIGNvbnN0IGFmZmlybUJpZ0ludEFycmF5ID0gQmlnSW50NjRBcnJheVxuICAgICAgICA/ICgpPT50cnVlIDogKCk9PnRvc3MoJ0JpZ0ludDY0QXJyYXkgaXMgbm90IGF2YWlsYWJsZS4nKTtcbiAgXG4gIGNvbnN0IHNpZ0RWR2V0dGVyID0gZnVuY3Rpb24ocyl7XG4gICAgc3dpdGNoKHNpZ0xldHRlcihzKSkge1xuICAgICAgICBjYXNlICdwJzogY2FzZSAnUCc6IGNhc2UgJ3MnOiB7XG4gICAgICAgICAgc3dpdGNoKHB0clNpemVvZil7XG4gICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuICdnZXRJbnQzMic7XG4gICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ2dldEJpZ0ludDY0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaSc6IHJldHVybiAnZ2V0SW50MzInO1xuICAgICAgICBjYXNlICdjJzogcmV0dXJuICdnZXRJbnQ4JztcbiAgICAgICAgY2FzZSAnQyc6IHJldHVybiAnZ2V0VWludDgnO1xuICAgICAgICBjYXNlICdqJzogcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ2dldEJpZ0ludDY0JztcbiAgICAgICAgY2FzZSAnZic6IHJldHVybiAnZ2V0RmxvYXQzMic7XG4gICAgICAgIGNhc2UgJ2QnOiByZXR1cm4gJ2dldEZsb2F0NjQnO1xuICAgIH1cbiAgICB0b3NzKFwiVW5oYW5kbGVkIERhdGFWaWV3IGdldHRlciBmb3Igc2lnbmF0dXJlOlwiLHMpO1xuICB9O1xuICBcbiAgY29uc3Qgc2lnRFZTZXR0ZXIgPSBmdW5jdGlvbihzKXtcbiAgICBzd2l0Y2goc2lnTGV0dGVyKHMpKXtcbiAgICAgICAgY2FzZSAncCc6IGNhc2UgJ1AnOiBjYXNlICdzJzoge1xuICAgICAgICAgIHN3aXRjaChwdHJTaXplb2Ype1xuICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiAnc2V0SW50MzInO1xuICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdzZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2knOiByZXR1cm4gJ3NldEludDMyJztcbiAgICAgICAgY2FzZSAnYyc6IHJldHVybiAnc2V0SW50OCc7XG4gICAgICAgIGNhc2UgJ0MnOiByZXR1cm4gJ3NldFVpbnQ4JztcbiAgICAgICAgY2FzZSAnaic6IHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdzZXRCaWdJbnQ2NCc7XG4gICAgICAgIGNhc2UgJ2YnOiByZXR1cm4gJ3NldEZsb2F0MzInO1xuICAgICAgICBjYXNlICdkJzogcmV0dXJuICdzZXRGbG9hdDY0JztcbiAgICB9XG4gICAgdG9zcyhcIlVuaGFuZGxlZCBEYXRhVmlldyBzZXR0ZXIgZm9yIHNpZ25hdHVyZTpcIixzKTtcbiAgfTtcbiAgXG4gIGNvbnN0IHNpZ0RWU2V0V3JhcHBlciA9IGZ1bmN0aW9uKHMpe1xuICAgIHN3aXRjaChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgY2FzZSAnaSc6IGNhc2UgJ2YnOiBjYXNlICdjJzogY2FzZSAnQyc6IGNhc2UgJ2QnOiByZXR1cm4gTnVtYmVyO1xuICAgICAgICBjYXNlICdqJzogcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgQmlnSW50O1xuICAgICAgICBjYXNlICdwJzogY2FzZSAnUCc6IGNhc2UgJ3MnOlxuICAgICAgICAgIHN3aXRjaChwdHJTaXplb2Ype1xuICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBOdW1iZXI7XG4gICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgQmlnSW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdG9zcyhcIlVuaGFuZGxlZCBEYXRhVmlldyBzZXQgd3JhcHBlciBmb3Igc2lnbmF0dXJlOlwiLHMpO1xuICB9O1xuXG4gIFxuICBjb25zdCBzUHJvcE5hbWUgPSAocyxrKT0+cysnOjonK2s7XG5cbiAgY29uc3QgX19wcm9wVGhyb3dPblNldCA9IGZ1bmN0aW9uKHN0cnVjdE5hbWUscHJvcE5hbWUpe1xuICAgIHJldHVybiAoKT0+dG9zcyhzUHJvcE5hbWUoc3RydWN0TmFtZSxwcm9wTmFtZSksXCJpcyByZWFkLW9ubHkuXCIpO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2luc3RhbmNlUG9pbnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgXG4gIGNvbnN0IHhQdHJQcm9wTmFtZSA9ICcocG9pbnRlci1pcy1leHRlcm5hbCknO1xuXG4gIFxuICBjb25zdCBfX2ZyZWVTdHJ1Y3QgPSBmdW5jdGlvbihjdG9yLCBvYmosIG0pe1xuICAgIGlmKCFtKSBtID0gX19pbnN0YW5jZVBvaW50ZXJNYXAuZ2V0KG9iaik7XG4gICAgaWYobSkge1xuICAgICAgX19pbnN0YW5jZVBvaW50ZXJNYXAuZGVsZXRlKG9iaik7XG4gICAgICBpZihBcnJheS5pc0FycmF5KG9iai5vbmRpc3Bvc2UpKXtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIHdoaWxlKCh4ID0gb2JqLm9uZGlzcG9zZS5zaGlmdCgpKSl7XG4gICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaWYoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB4LmNhbGwob2JqKTtcbiAgICAgICAgICAgIGVsc2UgaWYoeCBpbnN0YW5jZW9mIFN0cnVjdFR5cGUpIHguZGlzcG9zZSgpO1xuICAgICAgICAgICAgZWxzZSBpZignbnVtYmVyJyA9PT0gdHlwZW9mIHgpIGRlYWxsb2MoeCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIm9uZGlzcG9zZSgpIGZvclwiLGN0b3Iuc3RydWN0TmFtZSwnQCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgbSwndGhyZXcuIE5PVCBwcm9wYWdhdGluZyBpdC4nLGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYob2JqLm9uZGlzcG9zZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgdHJ5e29iai5vbmRpc3Bvc2UoKX1cbiAgICAgICAgY2F0Y2goZSl7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS53YXJuKFwib25kaXNwb3NlKCkgZm9yXCIsY3Rvci5zdHJ1Y3ROYW1lLCdAJyxcbiAgICAgICAgICAgICAgICAgICAgICAgbSwndGhyZXcuIE5PVCBwcm9wYWdhdGluZyBpdC4nLGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgb2JqLm9uZGlzcG9zZTtcbiAgICAgIGlmKGN0b3IuZGVidWdGbGFncy5fX2ZsYWdzLmRlYWxsb2Mpe1xuICAgICAgICBsb2coXCJkZWJ1Zy5kZWFsbG9jOlwiLChvYmpbeFB0clByb3BOYW1lXT9cIkVYVEVSTkFMXCI6XCJcIiksXG4gICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXCJpbnN0YW5jZTpcIixcbiAgICAgICAgICAgIGN0b3Iuc3RydWN0SW5mby5zaXplb2YsXCJieXRlcyBAXCIrbSk7XG4gICAgICB9XG4gICAgICBpZighb2JqW3hQdHJQcm9wTmFtZV0pIGRlYWxsb2MobSk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjb25zdCByb3AgPSAodik9PntyZXR1cm4ge2NvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYWJsZTogZmFsc2UsIHZhbHVlOiB2fX07XG5cbiAgXG4gIGNvbnN0IF9fYWxsb2NTdHJ1Y3QgPSBmdW5jdGlvbihjdG9yLCBvYmosIG0pe1xuICAgIGxldCBmaWxsID0gIW07XG4gICAgaWYobSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgeFB0clByb3BOYW1lLCByb3AobSkpO1xuICAgIGVsc2V7XG4gICAgICBtID0gYWxsb2MoY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZik7XG4gICAgICBpZighbSkgdG9zcyhcIkFsbG9jYXRpb24gb2ZcIixjdG9yLnN0cnVjdE5hbWUsXCJzdHJ1Y3R1cmUgZmFpbGVkLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmKGN0b3IuZGVidWdGbGFncy5fX2ZsYWdzLmFsbG9jKXtcbiAgICAgICAgbG9nKFwiZGVidWcuYWxsb2M6XCIsKGZpbGw/XCJcIjpcIkVYVEVSTkFMXCIpLFxuICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFwiaW5zdGFuY2U6XCIsXG4gICAgICAgICAgICBjdG9yLnN0cnVjdEluZm8uc2l6ZW9mLFwiYnl0ZXMgQFwiK20pO1xuICAgICAgfVxuICAgICAgaWYoZmlsbCkgaGVhcCgpLmZpbGwoMCwgbSwgbSArIGN0b3Iuc3RydWN0SW5mby5zaXplb2YpO1xuICAgICAgX19pbnN0YW5jZVBvaW50ZXJNYXAuc2V0KG9iaiwgbSk7XG4gICAgfWNhdGNoKGUpe1xuICAgICAgX19mcmVlU3RydWN0KGN0b3IsIG9iaiwgbSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IF9fbWVtb3J5RHVtcCA9IGZ1bmN0aW9uKCl7XG4gICAgY29uc3QgcCA9IHRoaXMucG9pbnRlcjtcbiAgICByZXR1cm4gcFxuICAgICAgPyBuZXcgVWludDhBcnJheShoZWFwKCkuc2xpY2UocCwgcCt0aGlzLnN0cnVjdEluZm8uc2l6ZW9mKSlcbiAgICAgIDogbnVsbDtcbiAgfTtcblxuICBjb25zdCBfX21lbWJlcktleSA9IChrKT0+bWVtYmVyUHJlZml4ICsgayArIG1lbWJlclN1ZmZpeDtcbiAgY29uc3QgX19tZW1iZXJLZXlQcm9wID0gcm9wKF9fbWVtYmVyS2V5KTtcblxuICBcbiAgY29uc3QgX19sb29rdXBNZW1iZXIgPSBmdW5jdGlvbihzdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZD10cnVlKXtcbiAgICBsZXQgbSA9IHN0cnVjdEluZm8ubWVtYmVyc1ttZW1iZXJOYW1lXTtcbiAgICBpZighbSAmJiAobWVtYmVyUHJlZml4IHx8IG1lbWJlclN1ZmZpeCkpe1xuICAgICAgXG4gICAgICBmb3IoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHN0cnVjdEluZm8ubWVtYmVycykpe1xuICAgICAgICBpZih2LmtleT09PW1lbWJlck5hbWUpeyBtID0gdjsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICAgIGlmKCFtICYmIHRvc3NJZk5vdEZvdW5kKXtcbiAgICAgICAgdG9zcyhzUHJvcE5hbWUoc3RydWN0SW5mby5uYW1lLG1lbWJlck5hbWUpLCdpcyBub3QgYSBtYXBwZWQgc3RydWN0IG1lbWJlci4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fbWVtYmVyU2lnbmF0dXJlID0gZnVuY3Rpb24gZihvYmosbWVtYmVyTmFtZSxlbXNjcmlwdGVuRm9ybWF0PWZhbHNlKXtcbiAgICBpZighZi5fKSBmLl8gPSAoeCk9PngucmVwbGFjZSgvW152aXBQc2pyZGNDXS9nLFwiXCIpLnJlcGxhY2UoL1twUHNjQ10vZywnaScpO1xuICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGVtc2NyaXB0ZW5Gb3JtYXQgPyBmLl8obS5zaWduYXR1cmUpIDogbS5zaWduYXR1cmU7XG4gIH07XG5cbiAgY29uc3QgX19wdHJQcm9wRGVzY3JpcHRvciA9IHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIF9faW5zdGFuY2VQb2ludGVyTWFwLmdldCh0aGlzKX0sXG4gICAgc2V0OiAoKT0+dG9zcyhcIkNhbm5vdCBhc3NpZ24gdGhlICdwb2ludGVyJyBwcm9wZXJ0eSBvZiBhIHN0cnVjdC5cIilcbiAgICBcbiAgICBcbiAgICBcbiAgfTtcblxuICBcbiAgY29uc3QgX19zdHJ1Y3RNZW1iZXJLZXlzID0gcm9wKGZ1bmN0aW9uKCl7XG4gICAgY29uc3QgYSA9IFtdO1xuICAgIGZvcihjb25zdCBrIG9mIE9iamVjdC5rZXlzKHRoaXMuc3RydWN0SW5mby5tZW1iZXJzKSl7XG4gICAgICBhLnB1c2godGhpcy5tZW1iZXJLZXkoaykpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSk7XG5cbiAgY29uc3QgX191dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgY29uc3QgX191dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBcbiAgY29uc3QgX19TQUIgPSAoJ3VuZGVmaW5lZCc9PT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZnVuY3Rpb24oKXt9IDogU2hhcmVkQXJyYXlCdWZmZXI7XG4gIGNvbnN0IF9fdXRmOERlY29kZSA9IGZ1bmN0aW9uKGFycmF5QnVmZmVyLCBiZWdpbiwgZW5kKXtcbiAgICByZXR1cm4gX191dGY4RGVjb2Rlci5kZWNvZGUoXG4gICAgICAoYXJyYXlCdWZmZXIuYnVmZmVyIGluc3RhbmNlb2YgX19TQUIpXG4gICAgICAgID8gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgOiBhcnJheUJ1ZmZlci5zdWJhcnJheShiZWdpbiwgZW5kKVxuICAgICk7XG4gIH07XG4gIFxuICBjb25zdCBfX21lbWJlcklzU3RyaW5nID0gZnVuY3Rpb24ob2JqLG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kPWZhbHNlKXtcbiAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kKTtcbiAgICByZXR1cm4gKG0gJiYgMT09PW0uc2lnbmF0dXJlLmxlbmd0aCAmJiAncyc9PT1tLnNpZ25hdHVyZVswXSkgPyBtIDogZmFsc2U7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fYWZmaXJtQ1N0cmluZ1NpZ25hdHVyZSA9IGZ1bmN0aW9uKG1lbWJlcil7XG4gICAgaWYoJ3MnPT09bWVtYmVyLnNpZ25hdHVyZSkgcmV0dXJuO1xuICAgIHRvc3MoXCJJbnZhbGlkIG1lbWJlciB0eXBlIHNpZ25hdHVyZSBmb3IgQy1zdHJpbmcgdmFsdWU6XCIsXG4gICAgICAgICBKU09OLnN0cmluZ2lmeShtZW1iZXIpKTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19tZW1iZXJUb0pzU3RyaW5nID0gZnVuY3Rpb24gZihvYmosbWVtYmVyTmFtZSl7XG4gICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0cnVlKTtcbiAgICBfX2FmZmlybUNTdHJpbmdTaWduYXR1cmUobSk7XG4gICAgY29uc3QgYWRkciA9IG9ialttLmtleV07XG4gICAgXG4gICAgaWYoIWFkZHIpIHJldHVybiBudWxsO1xuICAgIGxldCBwb3MgPSBhZGRyO1xuICAgIGNvbnN0IG1lbSA9IGhlYXAoKTtcbiAgICBmb3IoIDsgbWVtW3Bvc10hPT0wOyArK3BvcyApIHtcbiAgICAgIFxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIChhZGRyPT09cG9zKSA/IFwiXCIgOiBfX3V0ZjhEZWNvZGUobWVtLCBhZGRyLCBwb3MpO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2FkZE9uRGlzcG9zZSA9IGZ1bmN0aW9uKG9iaiwgLi4udil7XG4gICAgaWYob2JqLm9uZGlzcG9zZSl7XG4gICAgICBpZighQXJyYXkuaXNBcnJheShvYmoub25kaXNwb3NlKSl7XG4gICAgICAgIG9iai5vbmRpc3Bvc2UgPSBbb2JqLm9uZGlzcG9zZV07XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBvYmoub25kaXNwb3NlID0gW107XG4gICAgfVxuICAgIG9iai5vbmRpc3Bvc2UucHVzaCguLi52KTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19hbGxvY0NTdHJpbmcgPSBmdW5jdGlvbihzdHIpe1xuICAgIGNvbnN0IHUgPSBfX3V0ZjhFbmNvZGVyLmVuY29kZShzdHIpO1xuICAgIGNvbnN0IG1lbSA9IGFsbG9jKHUubGVuZ3RoKzEpO1xuICAgIGlmKCFtZW0pIHRvc3MoXCJBbGxvY2F0aW9uIGVycm9yIHdoaWxlIGR1cGxpY2F0aW5nIHN0cmluZzpcIixzdHIpO1xuICAgIGNvbnN0IGggPSBoZWFwKCk7XG4gICAgXG4gICAgXG4gICAgaC5zZXQodSwgbWVtKTtcbiAgICBoW21lbSArIHUubGVuZ3RoXSA9IDA7XG4gICAgXG4gICAgcmV0dXJuIG1lbTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19zZXRNZW1iZXJDU3RyaW5nID0gZnVuY3Rpb24ob2JqLCBtZW1iZXJOYW1lLCBzdHIpe1xuICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdHJ1ZSk7XG4gICAgX19hZmZpcm1DU3RyaW5nU2lnbmF0dXJlKG0pO1xuICAgIFxuICAgIGNvbnN0IG1lbSA9IF9fYWxsb2NDU3RyaW5nKHN0cik7XG4gICAgb2JqW20ua2V5XSA9IG1lbTtcbiAgICBfX2FkZE9uRGlzcG9zZShvYmosIG1lbSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBcbiAgY29uc3QgU3RydWN0VHlwZSA9IGZ1bmN0aW9uIGN0b3Ioc3RydWN0TmFtZSwgc3RydWN0SW5mbyl7XG4gICAgaWYoYXJndW1lbnRzWzJdIT09cm9wKXtcbiAgICAgIHRvc3MoXCJEbyBub3QgY2FsbCB0aGUgU3RydWN0VHlwZSBjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICBcImZyb20gY2xpZW50LWxldmVsIGNvZGUuXCIpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHtcbiAgICAgIFxuICAgICAgc3RydWN0TmFtZTogcm9wKHN0cnVjdE5hbWUpLFxuICAgICAgc3RydWN0SW5mbzogcm9wKHN0cnVjdEluZm8pXG4gICAgfSk7XG4gIH07XG5cbiAgXG4gIFN0cnVjdFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgZGlzcG9zZTogcm9wKGZ1bmN0aW9uKCl7X19mcmVlU3RydWN0KHRoaXMuY29uc3RydWN0b3IsIHRoaXMpfSksXG4gICAgbG9va3VwTWVtYmVyOiByb3AoZnVuY3Rpb24obWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQ9dHJ1ZSl7XG4gICAgICByZXR1cm4gX19sb29rdXBNZW1iZXIodGhpcy5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgfSksXG4gICAgbWVtYmVyVG9Kc1N0cmluZzogcm9wKGZ1bmN0aW9uKG1lbWJlck5hbWUpe1xuICAgICAgcmV0dXJuIF9fbWVtYmVyVG9Kc1N0cmluZyh0aGlzLCBtZW1iZXJOYW1lKTtcbiAgICB9KSxcbiAgICBtZW1iZXJJc1N0cmluZzogcm9wKGZ1bmN0aW9uKG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kPXRydWUpe1xuICAgICAgcmV0dXJuIF9fbWVtYmVySXNTdHJpbmcodGhpcywgbWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQpO1xuICAgIH0pLFxuICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgIG1lbWJlcktleXM6IF9fc3RydWN0TWVtYmVyS2V5cyxcbiAgICBtZW1iZXJTaWduYXR1cmU6IHJvcChmdW5jdGlvbihtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0PWZhbHNlKXtcbiAgICAgIHJldHVybiBfX21lbWJlclNpZ25hdHVyZSh0aGlzLCBtZW1iZXJOYW1lLCBlbXNjcmlwdGVuRm9ybWF0KTtcbiAgICB9KSxcbiAgICBtZW1vcnlEdW1wOiByb3AoX19tZW1vcnlEdW1wKSxcbiAgICBwb2ludGVyOiBfX3B0clByb3BEZXNjcmlwdG9yLFxuICAgIHNldE1lbWJlckNTdHJpbmc6IHJvcChmdW5jdGlvbihtZW1iZXJOYW1lLCBzdHIpe1xuICAgICAgcmV0dXJuIF9fc2V0TWVtYmVyQ1N0cmluZyh0aGlzLCBtZW1iZXJOYW1lLCBzdHIpO1xuICAgIH0pXG4gIH0pO1xuICBcbiAgT2JqZWN0LmFzc2lnbihTdHJ1Y3RUeXBlLnByb3RvdHlwZSx7XG4gICAgYWRkT25EaXNwb3NlOiBmdW5jdGlvbiguLi52KXtcbiAgICAgIF9fYWRkT25EaXNwb3NlKHRoaXMsLi4udik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIFxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RUeXBlLCB7XG4gICAgYWxsb2NDU3RyaW5nOiByb3AoX19hbGxvY0NTdHJpbmcpLFxuICAgIGlzQTogcm9wKCh2KT0+diBpbnN0YW5jZW9mIFN0cnVjdFR5cGUpLFxuICAgIGhhc0V4dGVybmFsUG9pbnRlcjogcm9wKCh2KT0+KHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSAmJiAhIXZbeFB0clByb3BOYW1lXSksXG4gICAgbWVtYmVyS2V5OiBfX21lbWJlcktleVByb3BcbiAgfSk7XG5cbiAgY29uc3QgaXNOdW1lcmljVmFsdWUgPSAodik9Pk51bWJlci5pc0Zpbml0ZSh2KSB8fCAodiBpbnN0YW5jZW9mIChCaWdJbnQgfHwgTnVtYmVyKSk7XG5cbiAgXG4gIGNvbnN0IG1ha2VNZW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gZihjdG9yLG5hbWUsIGRlc2NyKXtcbiAgICBpZighZi5fKXtcbiAgICAgIFxuICAgICAgZi5fID0ge2dldHRlcnM6IHt9LCBzZXR0ZXJzOiB7fSwgc3c6e319O1xuICAgICAgY29uc3QgYSA9IFsnaScsJ2MnLCdDJywncCcsJ1AnLCdzJywnZicsJ2QnLCd2KCknXTtcbiAgICAgIGlmKGJpZ0ludEVuYWJsZWQpIGEucHVzaCgnaicpO1xuICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uKHYpe1xuICAgICAgICBcbiAgICAgICAgZi5fLmdldHRlcnNbdl0gPSBzaWdEVkdldHRlcih2KSA7XG4gICAgICAgIGYuXy5zZXR0ZXJzW3ZdID0gc2lnRFZTZXR0ZXIodikgO1xuICAgICAgICBmLl8uc3dbdl0gPSBzaWdEVlNldFdyYXBwZXIodikgIDtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcnhTaWcxID0gL15baXBQc2pmZGNDXSQvLFxuICAgICAgICAgICAgcnhTaWcyID0gL15bdmlwUHNqZmRjQ11cXChbaXBQc2pmZGNDXSpcXCkkLztcbiAgICAgIGYuc2lnQ2hlY2sgPSBmdW5jdGlvbihvYmosIG5hbWUsIGtleSxzaWcpe1xuICAgICAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKXtcbiAgICAgICAgICB0b3NzKG9iai5zdHJ1Y3ROYW1lLCdhbHJlYWR5IGhhcyBhIHByb3BlcnR5IG5hbWVkJyxrZXkrJy4nKTtcbiAgICAgICAgfVxuICAgICAgICByeFNpZzEudGVzdChzaWcpIHx8IHJ4U2lnMi50ZXN0KHNpZylcbiAgICAgICAgICB8fCB0b3NzKFwiTWFsZm9ybWVkIHNpZ25hdHVyZSBmb3JcIixcbiAgICAgICAgICAgICAgICAgIHNQcm9wTmFtZShvYmouc3RydWN0TmFtZSxuYW1lKStcIjpcIixzaWcpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gY3Rvci5tZW1iZXJLZXkobmFtZSk7XG4gICAgZi5zaWdDaGVjayhjdG9yLnByb3RvdHlwZSwgbmFtZSwga2V5LCBkZXNjci5zaWduYXR1cmUpO1xuICAgIGRlc2NyLmtleSA9IGtleTtcbiAgICBkZXNjci5uYW1lID0gbmFtZTtcbiAgICBjb25zdCBzaWdHbHlwaCA9IHNpZ0xldHRlcihkZXNjci5zaWduYXR1cmUpO1xuICAgIGNvbnN0IHhQcm9wTmFtZSA9IHNQcm9wTmFtZShjdG9yLnByb3RvdHlwZS5zdHJ1Y3ROYW1lLGtleSk7XG4gICAgY29uc3QgZGJnID0gY3Rvci5wcm90b3R5cGUuZGVidWdGbGFncy5fX2ZsYWdzO1xuICAgIFxuICAgIGNvbnN0IHByb3AgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHByb3AuY29uZmlndXJhYmxlID0gZmFsc2U7XG4gICAgcHJvcC5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgcHJvcC5nZXQgPSBmdW5jdGlvbigpe1xuICAgICAgaWYoZGJnLmdldHRlcil7XG4gICAgICAgIGxvZyhcImRlYnVnLmdldHRlcjpcIixmLl8uZ2V0dGVyc1tzaWdHbHlwaF0sXCJmb3JcIiwgc2lnSVIoc2lnR2x5cGgpLFxuICAgICAgICAgICAgeFByb3BOYW1lLCdAJywgdGhpcy5wb2ludGVyLCcrJyxkZXNjci5vZmZzZXQsJ3N6JyxkZXNjci5zaXplb2YpO1xuICAgICAgfVxuICAgICAgbGV0IHJjID0gKFxuICAgICAgICBuZXcgRGF0YVZpZXcoaGVhcCgpLmJ1ZmZlciwgdGhpcy5wb2ludGVyICsgZGVzY3Iub2Zmc2V0LCBkZXNjci5zaXplb2YpXG4gICAgICApW2YuXy5nZXR0ZXJzW3NpZ0dseXBoXV0oMCwgaXNMaXR0bGVFbmRpYW4pO1xuICAgICAgaWYoZGJnLmdldHRlcikgbG9nKFwiZGVidWcuZ2V0dGVyOlwiLHhQcm9wTmFtZSxcInJlc3VsdCA9XCIscmMpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH07XG4gICAgaWYoZGVzY3IucmVhZE9ubHkpe1xuICAgICAgcHJvcC5zZXQgPSBfX3Byb3BUaHJvd09uU2V0KGN0b3IucHJvdG90eXBlLnN0cnVjdE5hbWUsa2V5KTtcbiAgICB9ZWxzZXtcbiAgICAgIHByb3Auc2V0ID0gZnVuY3Rpb24odil7XG4gICAgICAgIGlmKGRiZy5zZXR0ZXIpe1xuICAgICAgICAgIGxvZyhcImRlYnVnLnNldHRlcjpcIixmLl8uc2V0dGVyc1tzaWdHbHlwaF0sXCJmb3JcIiwgc2lnSVIoc2lnR2x5cGgpLFxuICAgICAgICAgICAgICB4UHJvcE5hbWUsJ0AnLCB0aGlzLnBvaW50ZXIsJysnLGRlc2NyLm9mZnNldCwnc3onLGRlc2NyLnNpemVvZiwgdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXRoaXMucG9pbnRlcil7XG4gICAgICAgICAgdG9zcyhcIkNhbm5vdCBzZXQgc3RydWN0IHByb3BlcnR5IG9uIGRpc3Bvc2VkIGluc3RhbmNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZihudWxsPT09dikgdiA9IDA7XG4gICAgICAgIGVsc2Ugd2hpbGUoIWlzTnVtZXJpY1ZhbHVlKHYpKXtcbiAgICAgICAgICBpZihpc0F1dG9QdHJTaWcoZGVzY3Iuc2lnbmF0dXJlKSAmJiAodiBpbnN0YW5jZW9mIFN0cnVjdFR5cGUpKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdiA9IHYucG9pbnRlciB8fCAwO1xuICAgICAgICAgICAgaWYoZGJnLnNldHRlcikgbG9nKFwiZGVidWcuc2V0dGVyOlwiLHhQcm9wTmFtZSxcInJlc29sdmVkIHRvXCIsdik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9zcyhcIkludmFsaWQgdmFsdWUgZm9yIHBvaW50ZXItdHlwZVwiLHhQcm9wTmFtZSsnLicpO1xuICAgICAgICB9XG4gICAgICAgIChcbiAgICAgICAgICBuZXcgRGF0YVZpZXcoaGVhcCgpLmJ1ZmZlciwgdGhpcy5wb2ludGVyICsgZGVzY3Iub2Zmc2V0LCBkZXNjci5zaXplb2YpXG4gICAgICAgIClbZi5fLnNldHRlcnNbc2lnR2x5cGhdXSgwLCBmLl8uc3dbc2lnR2x5cGhdKHYpLCBpc0xpdHRsZUVuZGlhbik7XG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsIGtleSwgcHJvcCk7XG4gIH07XG4gIFxuICBcbiAgY29uc3QgU3RydWN0QmluZGVyID0gZnVuY3Rpb24gU3RydWN0QmluZGVyKHN0cnVjdE5hbWUsIHN0cnVjdEluZm8pe1xuICAgIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgIHN0cnVjdEluZm8gPSBzdHJ1Y3ROYW1lO1xuICAgICAgc3RydWN0TmFtZSA9IHN0cnVjdEluZm8ubmFtZTtcbiAgICB9ZWxzZSBpZighc3RydWN0SW5mby5uYW1lKXtcbiAgICAgIHN0cnVjdEluZm8ubmFtZSA9IHN0cnVjdE5hbWU7XG4gICAgfVxuICAgIGlmKCFzdHJ1Y3ROYW1lKSB0b3NzKFwiU3RydWN0IG5hbWUgaXMgcmVxdWlyZWQuXCIpO1xuICAgIGxldCBsYXN0TWVtYmVyID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMoc3RydWN0SW5mby5tZW1iZXJzKS5mb3JFYWNoKChrKT0+e1xuICAgICAgXG4gICAgICBjb25zdCBtID0gc3RydWN0SW5mby5tZW1iZXJzW2tdO1xuICAgICAgaWYoIW0uc2l6ZW9mKSB0b3NzKHN0cnVjdE5hbWUsXCJtZW1iZXJcIixrLFwiaXMgbWlzc2luZyBzaXplb2YuXCIpO1xuICAgICAgZWxzZSBpZihtLnNpemVvZj09PTEpe1xuICAgICAgICAobS5zaWduYXR1cmUgPT09ICdjJyB8fCBtLnNpZ25hdHVyZSA9PT0gJ0MnKSB8fFxuICAgICAgICAgIHRvc3MoXCJVbmV4cGVjdGVkIHNpemVvZj09MSBtZW1iZXJcIixcbiAgICAgICAgICAgICAgIHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsayksXG4gICAgICAgICAgICAgICBcIndpdGggc2lnbmF0dXJlXCIsbS5zaWduYXR1cmUpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYoMCE9PShtLnNpemVvZiU0KSl7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBzdHJ1Y3QgbWVtYmVyIGRlc2NyaXB0aW9uID1cIixtLFwiZnJvbVwiLHN0cnVjdEluZm8pO1xuICAgICAgICAgIHRvc3Moc3RydWN0TmFtZSxcIm1lbWJlclwiLGssXCJzaXplb2YgaXMgbm90IGFsaWduZWQuIHNpemVvZj1cIittLnNpemVvZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoMCE9PShtLm9mZnNldCU0KSl7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBzdHJ1Y3QgbWVtYmVyIGRlc2NyaXB0aW9uID1cIixtLFwiZnJvbVwiLHN0cnVjdEluZm8pO1xuICAgICAgICAgIHRvc3Moc3RydWN0TmFtZSxcIm1lbWJlclwiLGssXCJvZmZzZXQgaXMgbm90IGFsaWduZWQuIG9mZnNldD1cIittLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCFsYXN0TWVtYmVyIHx8IGxhc3RNZW1iZXIub2Zmc2V0IDwgbS5vZmZzZXQpIGxhc3RNZW1iZXIgPSBtO1xuICAgIH0pO1xuICAgIGlmKCFsYXN0TWVtYmVyKSB0b3NzKFwiTm8gbWVtYmVyIHByb3BlcnR5IGRlc2NyaXB0aW9ucyBmb3VuZC5cIik7XG4gICAgZWxzZSBpZihzdHJ1Y3RJbmZvLnNpemVvZiA8IGxhc3RNZW1iZXIub2Zmc2V0K2xhc3RNZW1iZXIuc2l6ZW9mKXtcbiAgICAgIHRvc3MoXCJJbnZhbGlkIHN0cnVjdCBjb25maWc6XCIsc3RydWN0TmFtZSxcbiAgICAgICAgICAgXCJtYXggbWVtYmVyIG9mZnNldCAoXCIrbGFzdE1lbWJlci5vZmZzZXQrXCIpIFwiLFxuICAgICAgICAgICBcImV4dGVuZHMgcGFzdCBlbmQgb2Ygc3RydWN0IChzaXplb2Y9XCIrc3RydWN0SW5mby5zaXplb2YrXCIpLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVidWdGbGFncyA9IHJvcChTQkYuX19tYWtlRGVidWdGbGFncyhTdHJ1Y3RCaW5kZXIuZGVidWdGbGFncykpO1xuICAgIFxuICAgIGNvbnN0IFN0cnVjdEN0b3IgPSBmdW5jdGlvbiBTdHJ1Y3RDdG9yKGV4dGVybmFsTWVtb3J5KXtcbiAgICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIFN0cnVjdEN0b3IpKXtcbiAgICAgICAgdG9zcyhcIlRoZVwiLHN0cnVjdE5hbWUsXCJjb25zdHJ1Y3RvciBtYXkgb25seSBiZSBjYWxsZWQgdmlhICduZXcnLlwiKTtcbiAgICAgIH1lbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICBpZihleHRlcm5hbE1lbW9yeSE9PShleHRlcm5hbE1lbW9yeXwwKSB8fCBleHRlcm5hbE1lbW9yeTw9MCl7XG4gICAgICAgICAgdG9zcyhcIkludmFsaWQgcG9pbnRlciB2YWx1ZSBmb3JcIixzdHJ1Y3ROYW1lLFwiY29uc3RydWN0b3IuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fYWxsb2NTdHJ1Y3QoU3RydWN0Q3RvciwgdGhpcywgZXh0ZXJuYWxNZW1vcnkpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIF9fYWxsb2NTdHJ1Y3QoU3RydWN0Q3RvciwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RDdG9yLHtcbiAgICAgIGRlYnVnRmxhZ3M6IGRlYnVnRmxhZ3MsXG4gICAgICBpc0E6IHJvcCgodik9PnYgaW5zdGFuY2VvZiBTdHJ1Y3RDdG9yKSxcbiAgICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wLFxuICAgICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgICAgbWV0aG9kSW5mb0ZvcktleTogcm9wKGZ1bmN0aW9uKG1LZXkpe1xuICAgICAgfSksXG4gICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbyksXG4gICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSlcbiAgICB9KTtcbiAgICBTdHJ1Y3RDdG9yLnByb3RvdHlwZSA9IG5ldyBTdHJ1Y3RUeXBlKHN0cnVjdE5hbWUsIHN0cnVjdEluZm8sIHJvcCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3RydWN0Q3Rvci5wcm90b3R5cGUse1xuICAgICAgZGVidWdGbGFnczogZGVidWdGbGFncyxcbiAgICAgIGNvbnN0cnVjdG9yOiByb3AoU3RydWN0Q3RvcilcbiAgICAgIFxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKHN0cnVjdEluZm8ubWVtYmVycykuZm9yRWFjaChcbiAgICAgIChuYW1lKT0+bWFrZU1lbWJlcldyYXBwZXIoU3RydWN0Q3RvciwgbmFtZSwgc3RydWN0SW5mby5tZW1iZXJzW25hbWVdKVxuICAgICk7XG4gICAgcmV0dXJuIFN0cnVjdEN0b3I7XG4gIH07XG4gIFN0cnVjdEJpbmRlci5TdHJ1Y3RUeXBlID0gU3RydWN0VHlwZTtcbiAgU3RydWN0QmluZGVyLmNvbmZpZyA9IGNvbmZpZztcbiAgU3RydWN0QmluZGVyLmFsbG9jQ1N0cmluZyA9IF9fYWxsb2NDU3RyaW5nO1xuICBpZighU3RydWN0QmluZGVyLmRlYnVnRmxhZ3Mpe1xuICAgIFN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzID0gU0JGLl9fbWFrZURlYnVnRmxhZ3MoU0JGLmRlYnVnRmxhZ3MpO1xuICB9XG4gIHJldHVybiBTdHJ1Y3RCaW5kZXI7XG59O1xuXG5cblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uKHNxbGl0ZTMpe1xuICAndXNlIHN0cmljdCc7XG4gIGNvbnN0IHRvc3MgPSAoLi4uYXJncyk9Pnt0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpfTtcbiAgY29uc3QgdG9zczMgPSBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzO1xuICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpLCB3YXNtID0gc3FsaXRlMy53YXNtLCB1dGlsID0gc3FsaXRlMy51dGlsO1xuICBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIod2FzbSk7XG4gIGRlbGV0ZSBnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXI7XG5cbiAgaWYoMCl7XG4gICAgXG4gICAgXG4gICAgY29uc3QgZGVhbGxvYyA9IHdhc20uZXhwb3J0c1tzcWxpdGUzLmNvbmZpZy5kZWFsbG9jRXhwb3J0TmFtZV07XG4gICAgY29uc3QgbkZ1bmMgPSB3YXNtLmZ1bmN0aW9uVGFibGUoKS5sZW5ndGg7XG4gICAgbGV0IGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgbkZ1bmM7ICsraSl7XG4gICAgICBjb25zdCBlID0gd2FzbS5mdW5jdGlvbkVudHJ5KGkpO1xuICAgICAgaWYoZGVhbGxvYyA9PT0gZSl7XG4gICAgICAgIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihkZWFsbG9jICE9PSB3YXNtLmZ1bmN0aW9uRW50cnkoY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKSl7XG4gICAgICB0b3NzKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBmaW5kIGZ1bmN0aW9uIHBvaW50ZXIgZm9yIFNRTElURV9XQVNNX0RFQUxMT0MuXCIpO1xuICAgIH1cbiAgfVxuXG4gIFxuICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzID0gW1xuICAgIFxuICAgIFtcInNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHRcIixcInZvaWQqXCIsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcImludFwiXSxcbiAgICBcbiAgICBcbiAgICBbXCJzcWxpdGUzX2JpbmRfZG91YmxlXCIsXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCIsIFwiZjY0XCJdLFxuICAgIFtcInNxbGl0ZTNfYmluZF9pbnRcIixcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19iaW5kX251bGxcIix1bmRlZmluZWQsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50XCIsIFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4XCIsXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfYmluZF9wb2ludGVyXCIsIFwiaW50XCIsXG4gICAgIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiLCBcIipcIiwgXCJzdHJpbmc6c3RhdGljXCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX2J1c3lfaGFuZGxlclwiLFwiaW50XCIsIFtcbiAgICAgIFwic3FsaXRlMypcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgc2lnbmF0dXJlOiAnaShwaSknLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndixhcmdJbmRleCk9PmFyZ3ZbMF1cbiAgICAgIH0pLFxuICAgICAgXCIqXCJcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX2J1c3lfdGltZW91dFwiLFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJpbnRcIl0sXG4gICAgXG4gICAgXG4gICAgW1wic3FsaXRlM19jaGFuZ2VzXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19jbGVhcl9iaW5kaW5nc1wiLFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcIipcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX2Jsb2JcIixcIipcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX2J5dGVzXCIsXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX2NvdW50XCIsIFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl9kb3VibGVcIixcImY2NFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5faW50XCIsXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX25hbWVcIixcInN0cmluZ1wiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fdGV4dFwiLFwic3RyaW5nXCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl90eXBlXCIsXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX3ZhbHVlXCIsXCJzcWxpdGUzX3ZhbHVlKlwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb21taXRfaG9va1wiLCBcInZvaWQqXCIsIFtcbiAgICAgIFwic3FsaXRlMypcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogJ3NxbGl0ZTNfY29tbWl0X2hvb2snLFxuICAgICAgICBzaWduYXR1cmU6ICdpKHApJyxcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YpPT5hcmd2WzBdXG4gICAgICB9KSxcbiAgICAgICcqJ1xuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXRcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWRcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM19jb21wbGV0ZVwiLCBcImludFwiLCBcInN0cmluZzpmbGV4aWJsZVwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlXCIsIFwic3FsaXRlMypcIiwgXCJzcWxpdGUzX2NvbnRleHQqXCJdLFxuXG4gICAgXG4gICAgXG4gICAgW1wic3FsaXRlM19kYXRhX2NvdW50XCIsIFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX2RiX2ZpbGVuYW1lXCIsIFwic3RyaW5nXCIsIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM19kYl9oYW5kbGVcIiwgXCJzcWxpdGUzKlwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19kYl9uYW1lXCIsIFwic3RyaW5nXCIsIFwic3FsaXRlMypcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19kYl9zdGF0dXNcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcImludFwiLCBcIipcIiwgXCIqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfZXJyY29kZVwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfZXJybXNnXCIsIFwic3RyaW5nXCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19lcnJvcl9vZmZzZXRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX2VycnN0clwiLCBcInN0cmluZ1wiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2V4ZWNcIiwgXCJpbnRcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLCBcInN0cmluZzpmbGV4aWJsZVwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBzaWduYXR1cmU6ICdpKHBpcHApJyxcbiAgICAgICAgYmluZFNjb3BlOiAndHJhbnNpZW50JyxcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgbGV0IGFOYW1lcztcbiAgICAgICAgICByZXR1cm4gKHBWb2lkLCBuQ29scywgcENvbFZhbHMsIHBDb2xOYW1lcyk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFWYWxzID0gd2FzbS5jQXJndlRvSnMobkNvbHMsIHBDb2xWYWxzKTtcbiAgICAgICAgICAgICAgaWYoIWFOYW1lcykgYU5hbWVzID0gd2FzbS5jQXJndlRvSnMobkNvbHMsIHBDb2xOYW1lcyk7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhVmFscywgYU5hbWVzKSB8IDA7XG4gICAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBcIipcIiwgXCIqKlwiXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19leHBhbmRlZF9zcWxcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZVwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19maWxlX2NvbnRyb2xcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcImludFwiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19maW5hbGl6ZVwiLCBcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19mcmVlXCIsIHVuZGVmaW5lZCxcIipcIl0sXG4gICAgW1wic3FsaXRlM19nZXRfYXV0b2NvbW1pdFwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfZ2V0X2F1eGRhdGFcIiwgXCIqXCIsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2luaXRpYWxpemVcIiwgdW5kZWZpbmVkXSxcbiAgICBcbiAgICBbXCJzcWxpdGUzX2tleXdvcmRfY291bnRcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19rZXl3b3JkX25hbWVcIiwgXCJpbnRcIiwgW1wiaW50XCIsIFwiKipcIiwgXCIqXCJdXSxcbiAgICBbXCJzcWxpdGUzX2tleXdvcmRfY2hlY2tcIiwgXCJpbnRcIiwgW1wic3RyaW5nXCIsIFwiaW50XCJdXSxcbiAgICBbXCJzcWxpdGUzX2xpYnZlcnNpb25cIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM19saWJ2ZXJzaW9uX251bWJlclwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2xpbWl0XCIsIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsIFwiaW50XCIsIFwiaW50XCJdXSxcbiAgICBbXCJzcWxpdGUzX21hbGxvY1wiLCBcIipcIixcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX29wZW5cIiwgXCJpbnRcIiwgXCJzdHJpbmdcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfb3Blbl92MlwiLCBcImludFwiLCBcInN0cmluZ1wiLCBcIipcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIl0sXG4gICAgXG4gICAgXG4gICAgW1wic3FsaXRlM19wcm9ncmVzc19oYW5kbGVyXCIsIHVuZGVmaW5lZCwgW1xuICAgICAgXCJzcWxpdGUzKlwiLCBcImludFwiLCBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6ICd4UHJvZ3Jlc3NIYW5kbGVyJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnaShwKScsXG4gICAgICAgIGJpbmRTY29wZTogJ2NvbnRleHQnLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndixhcmdJbmRleCk9PmFyZ3ZbMF1cbiAgICAgIH0pLCBcIipcIlxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfcmVhbGxvY1wiLCBcIipcIixcIipcIixcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc2V0XCIsIFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9ibG9iXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiKlwiLCBcImludFwiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfZG91YmxlXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiZjY0XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwic3RyaW5nXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGVcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW1cIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2ludFwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9udWxsXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X3BvaW50ZXJcIiwgdW5kZWZpbmVkLFxuICAgICBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCIqXCIsIFwic3RyaW5nOnN0YXRpY1wiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfc3VidHlwZVwiLCB1bmRlZmluZWQsIFwic3FsaXRlM192YWx1ZSpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfdGV4dFwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcInN0cmluZ1wiLCBcImludFwiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfemVyb2Jsb2JcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19yb2xsYmFja19ob29rXCIsIFwidm9pZCpcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiAnc3FsaXRlM19yb2xsYmFja19ob29rJyxcbiAgICAgICAgc2lnbmF0dXJlOiAndihwKScsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2KT0+YXJndlswXVxuICAgICAgfSksXG4gICAgICAnKidcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX3NldF9hdXRob3JpemVyXCIsIFwiaW50XCIsIFtcbiAgICAgIFwic3FsaXRlMypcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogXCJzcWxpdGUzX3NldF9hdXRob3JpemVyOjp4QXV0aFwiLFxuICAgICAgICBzaWduYXR1cmU6IFwiaShwaVwiK1wic3NzcylcIixcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KT0+YXJndlswXSxcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgcmV0dXJuIChwViwgaUNvZGUsIHMwLCBzMSwgczIsIHMzKT0+e1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBzMCA9IHMwICYmIHdhc20uY3N0clRvSnMoczApOyBzMSA9IHMxICYmIHdhc20uY3N0clRvSnMoczEpO1xuICAgICAgICAgICAgICBzMiA9IHMyICYmIHdhc20uY3N0clRvSnMoczIpOyBzMyA9IHMzICYmIHdhc20uY3N0clRvSnMoczMpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socFYsIGlDb2RlLCBzMCwgczEsIHMyLCBzMykgfHwgMDtcbiAgICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgXCIqXCJcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX3NldF9hdXhkYXRhXCIsIHVuZGVmaW5lZCwgW1xuICAgICAgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiaW50XCIsIFwiKlwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiAneERlc3Ryb3lBdXhEYXRhJyxcbiAgICAgICAgc2lnbmF0dXJlOiAndigqKScsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCk9PmFyZ3ZbMF1cbiAgICAgIH0pXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19zaHV0ZG93blwiLCB1bmRlZmluZWRdLFxuICAgIFtcInNxbGl0ZTNfc291cmNlaWRcIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM19zcWxcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfc3RhdHVzXCIsIFwiaW50XCIsIFwiaW50XCIsIFwiKlwiLCBcIipcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19zdGVwXCIsIFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX3N0bXRfaXNleHBsYWluXCIsIFwiaW50XCIsIFtcInNxbGl0ZTNfc3RtdCpcIl1dLFxuICAgIFtcInNxbGl0ZTNfc3RtdF9yZWFkb25seVwiLCBcImludFwiLCBbXCJzcWxpdGUzX3N0bXQqXCJdXSxcbiAgICBbXCJzcWxpdGUzX3N0bXRfc3RhdHVzXCIsIFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3N0cmdsb2JcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIixcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX3N0cmljbXBcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM19zdHJsaWtlXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsIFwic3RyaW5nXCIsXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19zdHJuaWNtcFwiLCBcImludFwiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YVwiLCBcImludFwiLFxuICAgICBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwic3RyaW5nXCIsIFwic3RyaW5nXCIsXG4gICAgIFwiKipcIiwgXCIqKlwiLCBcIipcIiwgXCIqXCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX3RvdGFsX2NoYW5nZXNcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX3RyYWNlX3YyXCIsIFwiaW50XCIsIFtcbiAgICAgIFwic3FsaXRlMypcIiwgXCJpbnRcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogJ3NxbGl0ZTNfdHJhY2VfdjI6OmNhbGxiYWNrJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnaShpcHBwKScsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2LGFyZ0luZGV4KT0+YXJndlswXVxuICAgICAgfSksXG4gICAgICBcIipcIlxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfdHhuX3N0YXRlXCIsIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsXCJzdHJpbmdcIl1dLFxuICAgIFxuICAgIFtcInNxbGl0ZTNfdXJpX2Jvb2xlYW5cIiwgXCJpbnRcIiwgXCJzcWxpdGUzX2ZpbGVuYW1lXCIsIFwic3RyaW5nXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfdXJpX2tleVwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTNfZmlsZW5hbWVcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM191cmlfcGFyYW1ldGVyXCIsIFwic3RyaW5nXCIsIFwic3FsaXRlM19maWxlbmFtZVwiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX3VzZXJfZGF0YVwiLFwidm9pZCpcIiwgXCJzcWxpdGUzX2NvbnRleHQqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfYmxvYlwiLCBcIipcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2J5dGVzXCIsXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2RvdWJsZVwiLFwiZjY0XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9kdXBcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfZnJlZVwiLCB1bmRlZmluZWQsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9mcm9tYmluZFwiLCBcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfaW50XCIsXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX25vY2hhbmdlXCIsIFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX3BvaW50ZXJcIiwgXCIqXCIsIFwic3FsaXRlM192YWx1ZSpcIiwgXCJzdHJpbmc6c3RhdGljXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfc3VidHlwZVwiLCBcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfdGV4dFwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfdHlwZVwiLCBcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmZzX2ZpbmRcIiwgXCIqXCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfdmZzX3JlZ2lzdGVyXCIsIFwiaW50XCIsIFwic3FsaXRlM192ZnMqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfdmZzX3VucmVnaXN0ZXJcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZmcypcIl1cbiAgXTtcblxuICBpZihmYWxzZSAmJiB3YXNtLmNvbXBpbGVPcHRpb25Vc2VkKCdTUUxJVEVfRU5BQkxFX05PUk1BTElaRScpKXtcbiAgICBcbiAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLnB1c2goW1wic3FsaXRlM19ub3JtYWxpemVkX3NxbFwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTNfc3RtdCpcIl0pO1xuICB9XG5cbiAgaWYod2FzbS5leHBvcnRzLnNxbGl0ZTNfYWN0aXZhdGVfc2VlIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMucHVzaChcbiAgICAgIFtcInNxbGl0ZTNfa2V5XCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIl0sXG4gICAgICBbXCJzcWxpdGUzX2tleV92MlwiLFwiaW50XCIsXCJzcWxpdGUzKlwiLFwic3RyaW5nXCIsXCIqXCIsXCJpbnRcIl0sXG4gICAgICBbXCJzcWxpdGUzX3Jla2V5XCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIl0sXG4gICAgICBbXCJzcWxpdGUzX3Jla2V5X3YyXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCIqXCIsIFwiaW50XCJdLFxuICAgICAgW1wic3FsaXRlM19hY3RpdmF0ZV9zZWVcIiwgdW5kZWZpbmVkLCBcInN0cmluZ1wiXVxuICAgICk7XG4gIH1cbiAgXG4gIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQgPSBbXG4gICAgW1wic3FsaXRlM19iaW5kX2ludDY0XCIsXCJpbnRcIiwgW1wic3FsaXRlM19zdG10KlwiLCBcImludFwiLCBcImk2NFwiXV0sXG4gICAgW1wic3FsaXRlM19jaGFuZ2VzNjRcIixcImk2NFwiLCBbXCJzcWxpdGUzKlwiXV0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5faW50NjRcIixcImk2NFwiLCBbXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdXSxcbiAgICBbXCJzcWxpdGUzX2NyZWF0ZV9tb2R1bGVcIiwgXCJpbnRcIixcbiAgICAgW1wic3FsaXRlMypcIixcInN0cmluZ1wiLFwic3FsaXRlM19tb2R1bGUqXCIsXCIqXCJdXSxcbiAgICBbXCJzcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjJcIiwgXCJpbnRcIixcbiAgICAgW1wic3FsaXRlMypcIixcInN0cmluZ1wiLFwic3FsaXRlM19tb2R1bGUqXCIsXCIqXCIsXCIqXCJdXSxcbiAgICBbXCJzcWxpdGUzX2RlY2xhcmVfdnRhYlwiLCBcImludFwiLCBbXCJzcWxpdGUzKlwiLCBcInN0cmluZzpmbGV4aWJsZVwiXV0sXG4gICAgW1wic3FsaXRlM19kZXNlcmlhbGl6ZVwiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiKlwiLCBcImk2NFwiLCBcImk2NFwiLCBcImludFwiXVxuICAgICxcbiAgICBbXCJzcWxpdGUzX2Ryb3BfbW9kdWxlc1wiLCBcImludFwiLCBbXCJzcWxpdGUzKlwiLCBcIioqXCJdXSxcbiAgICBbXCJzcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkXCIsIFwiaTY0XCIsIFtcInNxbGl0ZTMqXCJdXSxcbiAgICBbXCJzcWxpdGUzX21hbGxvYzY0XCIsIFwiKlwiLFwiaTY0XCJdLFxuICAgIFtcInNxbGl0ZTNfbXNpemVcIiwgXCJpNjRcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb25cIiwgXCJpbnRcIiwgW1wic3FsaXRlMypcIixcInN0cmluZ1wiLFwiaW50XCJdXSxcbiAgICBbXCJzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ByZXVwZGF0ZV9jb3VudFwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfcHJldXBkYXRlX2RlcHRoXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19wcmV1cGRhdGVfaG9va1wiLCBcIipcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiAnc3FsaXRlM19wcmV1cGRhdGVfaG9vaycsXG4gICAgICAgIHNpZ25hdHVyZTogXCJ2KHBwaXBwamopXCIsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2KT0+YXJndlswXSxcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgcmV0dXJuIChwLGRiLG9wLHpEYix6VGJsLGlLZXkxLGlLZXkyKT0+e1xuICAgICAgICAgICAgY2FsbGJhY2socCwgZGIsIG9wLCB3YXNtLmNzdHJUb0pzKHpEYiksIHdhc20uY3N0clRvSnMoelRibCksXG4gICAgICAgICAgICAgICAgICAgICBpS2V5MSwgaUtleTIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgXCIqXCJcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX3ByZXVwZGF0ZV9uZXdcIiwgXCJpbnRcIiwgW1wic3FsaXRlMypcIiwgXCJpbnRcIiwgXCIqKlwiXV0sXG4gICAgW1wic3FsaXRlM19wcmV1cGRhdGVfb2xkXCIsIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsIFwiaW50XCIsIFwiKipcIl1dLFxuICAgIFtcInNxbGl0ZTNfcmVhbGxvYzY0XCIsIFwiKlwiLFwiKlwiLCBcImk2NFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9pbnQ2NFwiLCB1bmRlZmluZWQsIFwiKlwiLCBcImk2NFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0XCIsIFwiaW50XCIsIFwiKlwiLCBcImk2NFwiXSxcbiAgICBbXCJzcWxpdGUzX3NlcmlhbGl6ZVwiLFwiKlwiLCBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZFwiLCB1bmRlZmluZWQsIFtcInNxbGl0ZTMqXCIsIFwiaTY0XCJdXSxcbiAgICBbXCJzcWxpdGUzX3N0YXR1czY0XCIsIFwiaW50XCIsIFwiaW50XCIsIFwiKlwiLCBcIipcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM190b3RhbF9jaGFuZ2VzNjRcIiwgXCJpNjRcIiwgW1wic3FsaXRlMypcIl1dLFxuICAgIFtcInNxbGl0ZTNfdXBkYXRlX2hvb2tcIiwgXCIqXCIsIFtcbiAgICAgIFwic3FsaXRlMypcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogJ3NxbGl0ZTNfdXBkYXRlX2hvb2snLFxuICAgICAgICBzaWduYXR1cmU6IFwidihpaXBwailcIixcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YpPT5hcmd2WzBdLFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICByZXR1cm4gKHAsb3AsejAsejEscm93aWQpPT57XG4gICAgICAgICAgICBjYWxsYmFjayhwLCBvcCwgd2FzbS5jc3RyVG9Kcyh6MCksIHdhc20uY3N0clRvSnMoejEpLCByb3dpZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBcIipcIlxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfdXJpX2ludDY0XCIsIFwiaTY0XCIsIFtcInNxbGl0ZTNfZmlsZW5hbWVcIiwgXCJzdHJpbmdcIiwgXCJpNjRcIl1dLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfaW50NjRcIixcImk2NFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdnRhYl9jb2xsYXRpb25cIixcInN0cmluZ1wiLFwic3FsaXRlM19pbmRleF9pbmZvKlwiLFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfdnRhYl9kaXN0aW5jdFwiLFwiaW50XCIsIFwic3FsaXRlM19pbmRleF9pbmZvKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Z0YWJfaW5cIixcImludFwiLCBcInNxbGl0ZTNfaW5kZXhfaW5mbypcIiwgXCJpbnRcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM192dGFiX2luX2ZpcnN0XCIsIFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIiwgXCIqKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Z0YWJfaW5fbmV4dFwiLCBcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCIsIFwiKipcIl0sXG4gICAgXG4gICAgW1wic3FsaXRlM192dGFiX25vY2hhbmdlXCIsXCJpbnRcIiwgXCJzcWxpdGUzX2NvbnRleHQqXCJdLFxuICAgIFtcInNxbGl0ZTNfdnRhYl9vbl9jb25mbGljdFwiLFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM192dGFiX3Joc192YWx1ZVwiLFwiaW50XCIsIFwic3FsaXRlM19pbmRleF9pbmZvKlwiLCBcImludFwiLCBcIioqXCJdXG4gIF07XG5cbiAgXG4gIGlmKHdhc20uYmlnSW50RW5hYmxlZCAmJiAhIXdhc20uZXhwb3J0cy5zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkKXtcbiAgICBcbiAgICBcbiAgICBjb25zdCBfX2lwc1Byb3h5ID0ge1xuICAgICAgc2lnbmF0dXJlOiAnaShwcyknLFxuICAgICAgY2FsbFByb3h5OihjYWxsYmFjayk9PntcbiAgICAgICAgcmV0dXJuIChwLHMpPT57XG4gICAgICAgICAgdHJ5e3JldHVybiBjYWxsYmFjayhwLCB3YXNtLmNzdHJUb0pzKHMpKSB8IDB9XG4gICAgICAgICAgY2F0Y2goZSl7cmV0dXJuIGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUn1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0LnB1c2goLi4uW1xuICAgICAgWydzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkJywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2Vncm91cConLCAnaW50JywgJ3ZvaWQqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlM19jaGFuZ2Vncm91cConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlJywgdW5kZWZpbmVkLCBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlZ3JvdXBfbmV3JywgJ2ludCcsIFsnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZWdyb3VwKicsICdpbnQqJywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlM19jaGFuZ2Vncm91cConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hPdXRwdXQnLCBzaWduYXR1cmU6ICdpKHBwaSknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9hcHBseScsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzKicsICdpbnQnLCAndm9pZConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hGaWx0ZXInLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLCAuLi5fX2lwc1Byb3h5XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsIHNpZ25hdHVyZTogJ2kocGlwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneEZpbHRlcicsIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsIC4uLl9faXBzUHJveHlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneENvbmZsaWN0Jywgc2lnbmF0dXJlOiAnaShwaXApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjInLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlMyonLCAnaW50JywgJ3ZvaWQqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJywgYmluZFNjb3BlOiAndHJhbnNpZW50JywgLi4uX19pcHNQcm94eVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4Q29uZmxpY3QnLCBzaWduYXR1cmU6ICdpKHBpcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLCAnKionLCAnaW50KicsICdpbnQnXG5cbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlMyonLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneEZpbHRlcicsIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsIC4uLl9faXBzUHJveHlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneENvbmZsaWN0Jywgc2lnbmF0dXJlOiAnaShwaXApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJywgJyoqJywgJ2ludConLCAnaW50J1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0JywgJ2ludCcsIFsnaW50Jywndm9pZConLCAnaW50JywgJ3ZvaWQqJywgJ2ludConLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0nLCAnaW50JywgW1xuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dEEnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dEInLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hPdXRwdXQnLCBzaWduYXR1cmU6ICdpKHBwaSknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZScsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0cycsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludConXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0JywgJ2ludCcsIFsnaW50JywgJ3ZvaWQqJywgJ2ludConLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0nLCAnaW50JywgW1xuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneE91dHB1dCcsIHNpZ25hdHVyZTogJ2kocHBpKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X25ldycsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9uZXh0JywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnaW50JywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X29wJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJyoqJywgJ2ludConLCAnaW50KicsJ2ludConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9waycsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJyoqJywgJ2ludConXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQnLCAnaW50JywgWycqKicsICdpbnQnLCAnKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJyoqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MicsICdpbnQnLCBbJyoqJywgJ2ludCcsICcqJywgJ2ludCddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJyoqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLCAnaW50J1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2F0dGFjaCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnc3RyaW5nJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludConLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlM19zZXNzaW9uKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneE91dHB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jb25maWcnLCAnaW50JywgWydpbnQnLCAndm9pZConXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZScsICdpbnQnLCBbJ3NxbGl0ZTMqJywgJ3N0cmluZycsICcqKiddXSxcbiAgICAgIFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9kaWZmJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdzdHJpbmcnLCAnc3RyaW5nJywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9lbmFibGUnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25faXNlbXB0eScsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkJywgJ2k2NCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZycsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50JywgJ3ZvaWQqJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnKicsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybScsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzX3Nlc3Npb24qJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4T3V0cHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcicsIHVuZGVmaW5lZCwgW1xuICAgICAgICAnc3FsaXRlM19zZXNzaW9uKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneEZpbHRlcicsIC4uLl9faXBzUHJveHksXG4gICAgICAgICAgY29udGV4dEtleTogKGFyZ3YsYXJnSW5kZXgpPT5hcmd2WzBdXG4gICAgICAgIH0pLFxuICAgICAgICAnKidcbiAgICAgIF1dXG4gICAgXSk7XG4gIH1cblxuICBcbiAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy53YXNtID0gW1xuICAgIFtcInNxbGl0ZTNfd2FzbV9kYl9yZXNldFwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfd2FzbV9kYl92ZnNcIiwgXCJzcWxpdGUzX3ZmcypcIiwgXCJzcWxpdGUzKlwiLFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGVcIiwgXCJpbnRcIixcbiAgICAgXCJzcWxpdGUzX3ZmcypcIixcInN0cmluZ1wiLFwiKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGVcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIixcIipcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM193YXNtX3Zmc191bmxpbmtcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZmcypcIixcInN0cmluZ1wiXVxuICBdO1xuXG4gIFxuICBzcWxpdGUzLlN0cnVjdEJpbmRlciA9IGdsb2JhbFRoaXMuSmFjY3dhYnl0KHtcbiAgICBoZWFwOiAwID8gd2FzbS5tZW1vcnkgOiB3YXNtLmhlYXA4dSxcbiAgICBhbGxvYzogd2FzbS5hbGxvYyxcbiAgICBkZWFsbG9jOiB3YXNtLmRlYWxsb2MsXG4gICAgYmlnSW50RW5hYmxlZDogd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgIG1lbWJlclByZWZpeDogICckJ1xuICB9KTtcbiAgZGVsZXRlIGdsb2JhbFRoaXMuSmFjY3dhYnl0O1xuXG4gIHtcblxuICAgIFxuICAgIGNvbnN0IF9feFN0cmluZyA9IHdhc20ueFdyYXAuYXJnQWRhcHRlcignc3RyaW5nJyk7XG4gICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKFxuICAgICAgJ3N0cmluZzpmbGV4aWJsZScsICh2KT0+X194U3RyaW5nKHV0aWwuZmxleGlibGVTdHJpbmcodikpXG4gICAgKTtcblxuICAgIFxuICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcihcbiAgICAgICdzdHJpbmc6c3RhdGljJyxcbiAgICAgIGZ1bmN0aW9uKHYpe1xuICAgICAgICBpZih3YXNtLmlzUHRyKHYpKSByZXR1cm4gdjtcbiAgICAgICAgdiA9ICcnK3Y7XG4gICAgICAgIGxldCByYyA9IHRoaXNbdl07XG4gICAgICAgIHJldHVybiByYyB8fCAodGhpc1t2XSA9IHdhc20uYWxsb2NDU3RyaW5nKHYpKTtcbiAgICAgIH0uYmluZChPYmplY3QuY3JlYXRlKG51bGwpKVxuICAgICk7XG5cbiAgICBcbiAgICBjb25zdCBfX3hBcmdQdHIgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJyonKTtcbiAgICBjb25zdCBuaWxUeXBlID0gZnVuY3Rpb24oKXt9O1xuICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcignc3FsaXRlM19maWxlbmFtZScsIF9feEFyZ1B0cilcbiAgICAoJ3NxbGl0ZTNfY29udGV4dConLCBfX3hBcmdQdHIpXG4gICAgKCdzcWxpdGUzX3ZhbHVlKicsIF9feEFyZ1B0cilcbiAgICAoJ3ZvaWQqJywgX194QXJnUHRyKVxuICAgICgnc3FsaXRlM19jaGFuZ2Vncm91cConLCBfX3hBcmdQdHIpXG4gICAgKCdzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsIF9feEFyZ1B0cilcbiAgICBcbiAgICAoJ3NxbGl0ZTNfc2Vzc2lvbionLCBfX3hBcmdQdHIpXG4gICAgKCdzcWxpdGUzX3N0bXQqJywgKHYpPT5cbiAgICAgIF9feEFyZ1B0cigodiBpbnN0YW5jZW9mIChzcWxpdGUzPy5vbzE/LlN0bXQgfHwgbmlsVHlwZSkpXG4gICAgICAgICAgID8gdi5wb2ludGVyIDogdikpXG4gICAgKCdzcWxpdGUzKicsICh2KT0+XG4gICAgICBfX3hBcmdQdHIoKHYgaW5zdGFuY2VvZiAoc3FsaXRlMz8ub28xPy5EQiB8fCBuaWxUeXBlKSlcbiAgICAgICAgICAgPyB2LnBvaW50ZXIgOiB2KSlcbiAgICAoJ3NxbGl0ZTNfaW5kZXhfaW5mbyonLCAodik9PlxuICAgICAgX194QXJnUHRyKCh2IGluc3RhbmNlb2YgKGNhcGkuc3FsaXRlM19pbmRleF9pbmZvIHx8IG5pbFR5cGUpKVxuICAgICAgICAgICA/IHYucG9pbnRlciA6IHYpKVxuICAgICgnc3FsaXRlM19tb2R1bGUqJywgKHYpPT5cbiAgICAgIF9feEFyZ1B0cigodiBpbnN0YW5jZW9mIChjYXBpLnNxbGl0ZTNfbW9kdWxlIHx8IG5pbFR5cGUpKVxuICAgICAgICAgICA/IHYucG9pbnRlciA6IHYpKVxuICAgIFxuICAgICgnc3FsaXRlM192ZnMqJywgKHYpPT57XG4gICAgICBpZignc3RyaW5nJz09PXR5cGVvZiB2KXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodilcbiAgICAgICAgICB8fCBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKFxuICAgICAgICAgICAgY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICBcIlVua25vd24gc3FsaXRlM192ZnMgbmFtZTpcIiwgdlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX194QXJnUHRyKCh2IGluc3RhbmNlb2YgKGNhcGkuc3FsaXRlM192ZnMgfHwgbmlsVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgID8gdi5wb2ludGVyIDogdik7XG4gICAgfSk7XG5cbiAgICBjb25zdCBfX3hSY1B0ciA9IHdhc20ueFdyYXAucmVzdWx0QWRhcHRlcignKicpO1xuICAgIHdhc20ueFdyYXAucmVzdWx0QWRhcHRlcignc3FsaXRlMyonLCBfX3hSY1B0cilcbiAgICAoJ3NxbGl0ZTNfY29udGV4dConLCBfX3hSY1B0cilcbiAgICAoJ3NxbGl0ZTNfc3RtdConLCBfX3hSY1B0cilcbiAgICAoJ3NxbGl0ZTNfdmFsdWUqJywgX194UmNQdHIpXG4gICAgKCdzcWxpdGUzX3ZmcyonLCBfX3hSY1B0cilcbiAgICAoJ3ZvaWQqJywgX194UmNQdHIpO1xuXG4gICAgXG4gICAgaWYoMCA9PT0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfc3RlcC5sZW5ndGgpe1xuICAgICAgXG4gICAgICB3YXNtLnhXcmFwLmRvQXJnY0NoZWNrID0gZmFsc2U7XG4gICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFxuICAgICAgICBcIkRpc2FibGluZyBzcWxpdGUzLndhc20ueFdyYXAuZG9BcmdjQ2hlY2sgZHVlIHRvIGVudmlyb25tZW50YWwgcXVpcmtzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmb3IoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzKXtcbiAgICAgIGNhcGlbZVswXV0gPSB3YXNtLnhXcmFwLmFwcGx5KG51bGwsIGUpO1xuICAgIH1cbiAgICBmb3IoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLndhc20pe1xuICAgICAgd2FzbVtlWzBdXSA9IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSk7XG4gICAgfVxuXG4gICAgXG4gICAgY29uc3QgZkk2NERpc2FibGVkID0gZnVuY3Rpb24oZm5hbWUpe1xuICAgICAgcmV0dXJuICgpPT50b3NzKGZuYW1lK1wiKCkgaXMgdW5hdmFpbGFibGUgZHVlIHRvIGxhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIm9mIEJpZ0ludCBzdXBwb3J0IGluIHRoaXMgYnVpbGQuXCIpO1xuICAgIH07XG4gICAgZm9yKGNvbnN0IGUgb2Ygd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5pbnQ2NCl7XG4gICAgICBjYXBpW2VbMF1dID0gd2FzbS5iaWdJbnRFbmFibGVkXG4gICAgICAgID8gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKVxuICAgICAgICA6IGZJNjREaXNhYmxlZChlWzBdKTtcbiAgICB9XG5cbiAgICBcbiAgICBkZWxldGUgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcztcblxuICAgIGlmKHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fZGJfZXJyb3Ipe1xuICAgICAgY29uc3QgX19kYl9lcnIgPSB3YXNtLnhXcmFwKFxuICAgICAgICAnc3FsaXRlM193YXNtX2RiX2Vycm9yJywgJ2ludCcsICdzcWxpdGUzKicsICdpbnQnLCAnc3RyaW5nJ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBmdW5jdGlvbihwRGIsIHJlc3VsdENvZGUsIG1lc3NhZ2Upe1xuICAgICAgICBpZihyZXN1bHRDb2RlIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcil7XG4gICAgICAgICAgcmVzdWx0Q29kZSA9IGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgICAgIG1lc3NhZ2UgPSAwIDtcbiAgICAgICAgfWVsc2UgaWYocmVzdWx0Q29kZSBpbnN0YW5jZW9mIEVycm9yKXtcbiAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnJytyZXN1bHRDb2RlO1xuICAgICAgICAgIHJlc3VsdENvZGUgPSAocmVzdWx0Q29kZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcERiID8gX19kYl9lcnIocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKSA6IHJlc3VsdENvZGU7XG4gICAgICB9O1xuICAgIH1lbHNle1xuICAgICAgdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBmdW5jdGlvbihwRGIsZXJyQ29kZSxtc2cpe1xuICAgICAgICBjb25zb2xlLndhcm4oXCJzcWxpdGUzX3dhc21fZGJfZXJyb3IoKSBpcyBub3QgZXhwb3J0ZWQuXCIsYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGVyckNvZGU7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBjb25zdCBjSnNvbiA9IHdhc20ueENhbGwoJ3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24nKTtcbiAgICBpZighY0pzb24pe1xuICAgICAgdG9zcyhcIk1haW50ZW5hbmNlIHJlcXVpcmVkOiBpbmNyZWFzZSBzcWxpdGUzX3dhc21fZW51bV9qc29uKCknc1wiLFxuICAgICAgICAgICBcInN0YXRpYyBidWZmZXIgc2l6ZSFcIik7XG4gICAgfVxuICAgIFxuICAgIHdhc20uY3R5cGUgPSBKU09OLnBhcnNlKHdhc20uY3N0clRvSnMoY0pzb24pKTtcbiAgICBcbiAgICBjb25zdCBkZWZpbmVHcm91cHMgPSBbJ2FjY2VzcycsICdhdXRob3JpemVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Jsb2JGaW5hbGl6ZXJzJywgJ2NoYW5nZXNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcnLCAnZGF0YVR5cGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RiQ29uZmlnJywgJ2RiU3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2VuY29kaW5ncycsICdmY250bCcsICdmbG9jaycsICdpb0NhcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdsaW1pdHMnLCAnb3BlbkZsYWdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByZXBhcmVGbGFncycsICdyZXN1bHRDb2RlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdzcWxpdGUzU3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0bXRTdGF0dXMnLCAnc3luY0ZsYWdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWNlJywgJ3R4blN0YXRlJywgJ3VkZkZsYWdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZlcnNpb24nIF07XG4gICAgaWYod2FzbS5iaWdJbnRFbmFibGVkKXtcbiAgICAgIGRlZmluZUdyb3Vwcy5wdXNoKCdzZXJpYWxpemUnLCAnc2Vzc2lvbicsICd2dGFiJyk7XG4gICAgfVxuICAgIGZvcihjb25zdCB0IG9mIGRlZmluZUdyb3Vwcyl7XG4gICAgICBmb3IoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh3YXNtLmN0eXBlW3RdKSl7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgY2FwaVtlWzBdXSA9IGVbMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmKCF3YXNtLmZ1bmN0aW9uRW50cnkoY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKSl7XG4gICAgICB0b3NzKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCByZXNvbHZlIGV4cG9ydGVkIGZ1bmN0aW9uXCIsXG4gICAgICAgICAgIFwiZW50cnkgU1FMSVRFX1dBU01fREVBTExPQyAoPT1cIitjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MrXCIpLlwiKTtcbiAgICB9XG4gICAgY29uc3QgX19yY01hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yKGNvbnN0IHQgb2YgWydyZXN1bHRDb2RlcyddKXtcbiAgICAgIGZvcihjb25zdCBlIG9mIE9iamVjdC5lbnRyaWVzKHdhc20uY3R5cGVbdF0pKXtcbiAgICAgICAgX19yY01hcFtlWzFdXSA9IGVbMF07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIgPSAocmMpPT5fX3JjTWFwW3JjXTtcbiAgICBcbiAgICBjb25zdCBub3RUaGVzZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgICBcbiAgICAgIFdhc21UZXN0U3RydWN0OiB0cnVlLFxuICAgICAgXG4gICAgICBzcWxpdGUzX2t2dmZzX21ldGhvZHM6ICF1dGlsLmlzVUlUaHJlYWQoKSxcbiAgICAgIFxuICAgICAgc3FsaXRlM19pbmRleF9pbmZvOiAhd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgc3FsaXRlM19pbmRleF9jb25zdHJhaW50OiAhd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgc3FsaXRlM19pbmRleF9vcmRlcmJ5OiAhd2FzbS5iaWdJbnRFbmFibGVkLFxuICAgICAgc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlOiAhd2FzbS5iaWdJbnRFbmFibGVkXG4gICAgfSk7XG4gICAgZm9yKGNvbnN0IHMgb2Ygd2FzbS5jdHlwZS5zdHJ1Y3RzKXtcbiAgICAgIGlmKCFub3RUaGVzZVtzLm5hbWVdKXtcbiAgICAgICAgY2FwaVtzLm5hbWVdID0gc3FsaXRlMy5TdHJ1Y3RCaW5kZXIocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGNhcGkuc3FsaXRlM19pbmRleF9pbmZvKXtcbiAgICAgIFxuICAgICAgZm9yKGNvbnN0IGsgb2YgWydzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2luZGV4X29yZGVyYnknLFxuICAgICAgICAgICAgICAgICAgICAgICdzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2UnXSl7XG4gICAgICAgIGNhcGkuc3FsaXRlM19pbmRleF9pbmZvW2tdID0gY2FwaVtrXTtcbiAgICAgICAgZGVsZXRlIGNhcGlba107XG4gICAgICB9XG4gICAgICBjYXBpLnNxbGl0ZTNfdnRhYl9jb25maWcgPSB3YXNtLnhXcmFwKFxuICAgICAgICAnc3FsaXRlM193YXNtX3Z0YWJfY29uZmlnJywnaW50JyxbXG4gICAgICAgICAgJ3NxbGl0ZTMqJywgJ2ludCcsICdpbnQnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBcbiAgY29uc3QgX19kYkFyZ2NNaXNtYXRjaCA9IChwRGIsZixuKT0+e1xuICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihwRGIsIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZitcIigpIHJlcXVpcmVzIFwiK24rXCIgYXJndW1lbnRcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDE9PT1uP1wiXCI6J3MnKStcIi5cIik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fZXJyRW5jb2RpbmcgPSAocERiKT0+e1xuICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgIHBEYiwgY2FwaS5TUUxJVEVfRk9STUFULCBcIlNRTElURV9VVEY4IGlzIHRoZSBvbmx5IHN1cHBvcnRlZCBlbmNvZGluZy5cIlxuICAgICk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fYXJnUERiID0gKHBEYik9Pndhc20ueFdyYXAuYXJnQWRhcHRlcignc3FsaXRlMyonKShwRGIpO1xuICBjb25zdCBfX2FyZ1N0ciA9IChzdHIpPT53YXNtLmlzUHRyKHN0cikgPyB3YXNtLmNzdHJUb0pzKHN0cikgOiBzdHI7XG4gIGNvbnN0IF9fZGJDbGVhbnVwTWFwID0gZnVuY3Rpb24oXG4gICAgcERiLCBtb2RlXG4gICl7XG4gICAgcERiID0gX19hcmdQRGIocERiKTtcbiAgICBsZXQgbSA9IHRoaXMuZGJNYXAuZ2V0KHBEYik7XG4gICAgaWYoIW1vZGUpe1xuICAgICAgdGhpcy5kYk1hcC5kZWxldGUocERiKTtcbiAgICAgIHJldHVybiBtO1xuICAgIH1lbHNlIGlmKCFtICYmIG1vZGU+MCl7XG4gICAgICB0aGlzLmRiTWFwLnNldChwRGIsIChtID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfS5iaW5kKE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgZGJNYXA6IG5ldyBNYXBcbiAgfSkpO1xuXG4gIF9fZGJDbGVhbnVwTWFwLmFkZENvbGxhdGlvbiA9IGZ1bmN0aW9uKHBEYiwgbmFtZSl7XG4gICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgaWYoIW0uY29sbGF0aW9uKSBtLmNvbGxhdGlvbiA9IG5ldyBTZXQ7XG4gICAgbS5jb2xsYXRpb24uYWRkKF9fYXJnU3RyKG5hbWUpLnRvTG93ZXJDYXNlKCkpO1xuICB9O1xuXG4gIF9fZGJDbGVhbnVwTWFwLl9hZGRVREYgPSBmdW5jdGlvbihwRGIsIG5hbWUsIGFyaXR5LCBtYXApe1xuICAgIFxuICAgIG5hbWUgPSBfX2FyZ1N0cihuYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCB1ID0gbWFwLmdldChuYW1lKTtcbiAgICBpZighdSkgbWFwLnNldChuYW1lLCAodSA9IG5ldyBTZXQpKTtcbiAgICB1LmFkZCgoYXJpdHk8MCkgPyAtMSA6IGFyaXR5KTtcbiAgfTtcblxuICBfX2RiQ2xlYW51cE1hcC5hZGRGdW5jdGlvbiA9IGZ1bmN0aW9uKHBEYiwgbmFtZSwgYXJpdHkpe1xuICAgIGNvbnN0IG0gPSBfX2RiQ2xlYW51cE1hcChwRGIsIDEpO1xuICAgIGlmKCFtLnVkZikgbS51ZGYgPSBuZXcgTWFwO1xuICAgIHRoaXMuX2FkZFVERihwRGIsIG5hbWUsIGFyaXR5LCBtLnVkZik7XG4gIH07XG5cbiAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyA9IGZ1bmN0aW9uKHBEYiwgbmFtZSwgYXJpdHkpe1xuICAgIGNvbnN0IG0gPSBfX2RiQ2xlYW51cE1hcChwRGIsIDEpO1xuICAgIGlmKCFtLnd1ZGYpIG0ud3VkZiA9IG5ldyBNYXA7XG4gICAgdGhpcy5fYWRkVURGKHBEYiwgbmFtZSwgYXJpdHksIG0ud3VkZik7XG4gIH07XG5cbiAgXG4gIF9fZGJDbGVhbnVwTWFwLmNsZWFudXAgPSBmdW5jdGlvbihwRGIpe1xuICAgIHBEYiA9IF9fYXJnUERiKHBEYik7XG4gICAgXG4gICAgXG4gICAgY29uc3QgY2xvc2VBcmdzID0gW3BEYl07XG4gICAgZm9yKGNvbnN0IG5hbWUgb2YgW1xuICAgICAgJ3NxbGl0ZTNfYnVzeV9oYW5kbGVyJyxcbiAgICAgICdzcWxpdGUzX2NvbW1pdF9ob29rJyxcbiAgICAgICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICdzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXInLFxuICAgICAgJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAnc3FsaXRlM19zZXRfYXV0aG9yaXplcicsXG4gICAgICAnc3FsaXRlM190cmFjZV92MicsXG4gICAgICAnc3FsaXRlM191cGRhdGVfaG9vaydcbiAgICBdKSB7XG4gICAgICBjb25zdCB4ID0gd2FzbS5leHBvcnRzW25hbWVdO1xuICAgICAgY2xvc2VBcmdzLmxlbmd0aCA9IHgubGVuZ3RoXG4gICAgICA7XG4gICAgICB0cnl7IGNhcGlbbmFtZV0oLi4uY2xvc2VBcmdzKSB9XG4gICAgICBjYXRjaChlKXtcbiAgICAgICAgY29uc29sZS53YXJuKFwiY2xvc2UtdGltZSBjYWxsIG9mXCIsbmFtZStcIihcIixjbG9zZUFyZ3MsXCIpIHRocmV3OlwiLGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAwKTtcbiAgICBpZighbSkgcmV0dXJuO1xuICAgIGlmKG0uY29sbGF0aW9uKXtcbiAgICAgIGZvcihjb25zdCBuYW1lIG9mIG0uY29sbGF0aW9uKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyKFxuICAgICAgICAgICAgcERiLCBuYW1lLCBjYXBpLlNRTElURV9VVEY4LCAwLCAwLCAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgbS5jb2xsYXRpb247XG4gICAgfVxuICAgIGxldCBpO1xuICAgIGZvcihpID0gMDsgaSA8IDI7ICsraSl7IFxuICAgICAgY29uc3QgZm1hcCA9IGkgPyBtLnd1ZGYgOiBtLnVkZjtcbiAgICAgIGlmKCFmbWFwKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGZ1bmMgPSBpXG4gICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXG4gICAgICAgICAgICA6IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjI7XG4gICAgICBmb3IoY29uc3QgZSBvZiBmbWFwKXtcbiAgICAgICAgY29uc3QgbmFtZSA9IGVbMF0sIGFyaXRpZXMgPSBlWzFdO1xuICAgICAgICBjb25zdCBmYXJncyA9IFtwRGIsIG5hbWUsIDAsIGNhcGkuU1FMSVRFX1VURjgsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBpZihpKSBmYXJncy5wdXNoKDApO1xuICAgICAgICBmb3IoY29uc3QgYXJpdHkgb2YgYXJpdGllcyl7XG4gICAgICAgICAgdHJ5eyBmYXJnc1syXSA9IGFyaXR5OyBmdW5jLmFwcGx5KG51bGwsIGZhcmdzKTsgfVxuICAgICAgICAgIGNhdGNoKGUpe31cbiAgICAgICAgfVxuICAgICAgICBhcml0aWVzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBmbWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIGRlbGV0ZSBtLnVkZjtcbiAgICBkZWxldGUgbS53dWRmO1xuICB9O1xuXG4gIHtcbiAgICBjb25zdCBfX3NxbGl0ZTNDbG9zZVYyID0gd2FzbS54V3JhcChcInNxbGl0ZTNfY2xvc2VfdjJcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiKTtcbiAgICBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIgPSBmdW5jdGlvbihwRGIpe1xuICAgICAgaWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY2xvc2VfdjInLCAxKTtcbiAgICAgIGlmKHBEYil7XG4gICAgICAgIHRyeXtfX2RiQ2xlYW51cE1hcC5jbGVhbnVwKHBEYil9IGNhdGNoKGUpe31cbiAgICAgIH1cbiAgICAgIHJldHVybiBfX3NxbGl0ZTNDbG9zZVYyKHBEYik7XG4gICAgfTtcbiAgfVxuXG4gIGlmKGNhcGkuc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyKXtcbiAgICBjb25zdCBfX3NxbGl0ZTNTZXNzaW9uRGVsZXRlID0gd2FzbS54V3JhcChcbiAgICAgICdzcWxpdGUzc2Vzc2lvbl9kZWxldGUnLCB1bmRlZmluZWQsIFsnc3FsaXRlM19zZXNzaW9uKiddXG4gICAgKTtcbiAgICBjYXBpLnNxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IGZ1bmN0aW9uKHBTZXNzaW9uKXtcbiAgICAgIGlmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM3Nlc3Npb25fZGVsZXRlJywgMSk7XG4gICAgICAgIFxuICAgICAgfVxuICAgICAgZWxzZSBpZihwU2Vzc2lvbil7XG4gICAgICAgIFxuICAgICAgICBjYXBpLnNxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcihwU2Vzc2lvbiwgMCwgMCk7XG4gICAgICB9XG4gICAgICBfX3NxbGl0ZTNTZXNzaW9uRGVsZXRlKHBTZXNzaW9uKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIFxuICAgIGNvbnN0IGNvbnRleHRLZXkgPSAoYXJndixhcmdJbmRleCk9PntcbiAgICAgIHJldHVybiAnYXJndlsnK2FyZ0luZGV4KyddOicrYXJndlswXStcbiAgICAgICAgJzonK3dhc20uY3N0clRvSnMoYXJndlsxXSkudG9Mb3dlckNhc2UoKVxuICAgIH07XG4gICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlQ29sbGF0aW9uVjIgPSB3YXNtLnhXcmFwKFxuICAgICAgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MicsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzKicsICdzdHJpbmcnLCAnaW50JywgJyonLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgXG4gICAgICAgICAgbmFtZTogJ3hDb21wYXJlJywgc2lnbmF0dXJlOiAnaShwaXBpcCknLCBjb250ZXh0S2V5XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgXG4gICAgICAgICAgbmFtZTogJ3hEZXN0cm95Jywgc2lnbmF0dXJlOiAndihwKScsIGNvbnRleHRLZXlcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICApO1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIgPSBmdW5jdGlvbihwRGIsek5hbWUsZVRleHRSZXAscEFyZyx4Q29tcGFyZSx4RGVzdHJveSl7XG4gICAgICBpZig2IT09YXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyJywgNik7XG4gICAgICBlbHNlIGlmKCAwID09PSAoZVRleHRSZXAgJiAweGYpICl7XG4gICAgICAgIGVUZXh0UmVwIHw9IGNhcGkuU1FMSVRFX1VURjg7XG4gICAgICB9ZWxzZSBpZiggY2FwaS5TUUxJVEVfVVRGOCAhPT0gKGVUZXh0UmVwICYgMHhmKSApe1xuICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgfVxuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCByYyA9IF9fc3FsaXRlM0NyZWF0ZUNvbGxhdGlvblYyKHBEYiwgek5hbWUsIGVUZXh0UmVwLCBwQXJnLCB4Q29tcGFyZSwgeERlc3Ryb3kpO1xuICAgICAgICBpZigwPT09cmMgJiYgeENvbXBhcmUgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkQ29sbGF0aW9uKHBEYiwgek5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKHBEYiwgZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uID0gKHBEYix6TmFtZSxlVGV4dFJlcCxwQXJnLHhDb21wYXJlKT0+e1xuICAgICAgcmV0dXJuICg1PT09YXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihwRGIsek5hbWUsZVRleHRSZXAscEFyZyx4Q29tcGFyZSwwKVxuICAgICAgICA6IF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uJywgNSk7XG4gICAgfTtcblxuICB9XG5cbiAge1xuICAgIFxuICAgIGNvbnN0IGNvbnRleHRLZXkgPSBmdW5jdGlvbihhcmd2LGFyZ0luZGV4KXtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGFyZ3ZbMF1cbiAgICAgICAgICArJzonKyhhcmd2WzJdIDwgMCA/IC0xIDogYXJndlsyXSlcbiAgICAgICAgICArJzonK2FyZ0luZGV4XG4gICAgICAgICAgKyc6Jyt3YXNtLmNzdHJUb0pzKGFyZ3ZbMV0pLnRvTG93ZXJDYXNlKClcbiAgICAgIClcbiAgICB9O1xuXG4gICAgXG4gICAgY29uc3QgX19jZlByb3h5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICB4SW52ZXJzZUFuZFN0ZXA6IHtcbiAgICAgICAgc2lnbmF0dXJlOid2KHBpcCknLCBjb250ZXh0S2V5LFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KT0+e1xuICAgICAgICAgICAgdHJ5eyBjYWxsYmFjayhwQ3R4LCAuLi5jYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzKGFyZ2MsIHBBcmd2KSkgfVxuICAgICAgICAgICAgY2F0Y2goZSl7IGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgZSkgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4RmluYWxBbmRWYWx1ZToge1xuICAgICAgICBzaWduYXR1cmU6J3YocCknLCBjb250ZXh0S2V5LFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICByZXR1cm4gKHBDdHgpPT57XG4gICAgICAgICAgICB0cnl7IGNhcGkuc3FsaXRlM19yZXN1bHRfanMocEN0eCwgY2FsbGJhY2socEN0eCkpIH1cbiAgICAgICAgICAgIGNhdGNoKGUpeyBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeEZ1bmM6IHtcbiAgICAgICAgc2lnbmF0dXJlOid2KHBpcCknLCBjb250ZXh0S2V5LFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICByZXR1cm4gKHBDdHgsIGFyZ2MsIHBBcmd2KT0+e1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzKFxuICAgICAgICAgICAgICAgIHBDdHgsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socEN0eCwgLi4uY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcyhhcmdjLCBwQXJndikpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4RGVzdHJveToge1xuICAgICAgICBzaWduYXR1cmU6J3YocCknLCBjb250ZXh0S2V5LFxuICAgICAgICBcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgcmV0dXJuIChwVm9pZCk9PntcbiAgICAgICAgICAgIHRyeXsgY2FsbGJhY2socFZvaWQpIH1cbiAgICAgICAgICAgIGNhdGNoKGUpeyBjb25zb2xlLmVycm9yKFwiVURGIHhEZXN0cm95IG1ldGhvZCB0aHJldzpcIixlKSB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlRnVuY3Rpb24gPSB3YXNtLnhXcmFwKFxuICAgICAgXCJzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MlwiLCBcImludFwiLCBbXG4gICAgICAgIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIixcbiAgICAgICAgXCJpbnRcIiwgXCIqXCIsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneEZ1bmMnLCAuLi5fX2NmUHJveHkueEZ1bmN9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4U3RlcCcsIC4uLl9fY2ZQcm94eS54SW52ZXJzZUFuZFN0ZXB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4RmluYWwnLCAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWV9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4RGVzdHJveScsIC4uLl9fY2ZQcm94eS54RGVzdHJveX0pXG4gICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IF9fc3FsaXRlM0NyZWF0ZVdpbmRvd0Z1bmN0aW9uID0gd2FzbS54V3JhcChcbiAgICAgIFwic3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXCIsIFwiaW50XCIsIFtcbiAgICAgICAgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcImludFwiLFxuICAgICAgICBcImludFwiLCBcIipcIixcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4U3RlcCcsIC4uLl9fY2ZQcm94eS54SW52ZXJzZUFuZFN0ZXB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4RmluYWwnLCAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWV9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4VmFsdWUnLCAuLi5fX2NmUHJveHkueEZpbmFsQW5kVmFsdWV9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4SW52ZXJzZScsIC4uLl9fY2ZQcm94eS54SW52ZXJzZUFuZFN0ZXB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4RGVzdHJveScsIC4uLl9fY2ZQcm94eS54RGVzdHJveX0pXG4gICAgICBdXG4gICAgKTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIgPSBmdW5jdGlvbiBmKFxuICAgICAgcERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsIHBBcHAsXG4gICAgICB4RnVuYywgICBcbiAgICAgIHhTdGVwLCAgIFxuICAgICAgeEZpbmFsLCAgXG4gICAgICB4RGVzdHJveSBcbiAgICApe1xuICAgICAgaWYoIGYubGVuZ3RoIT09YXJndW1lbnRzLmxlbmd0aCApe1xuICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsXCJzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MlwiLGYubGVuZ3RoKTtcbiAgICAgIH1lbHNlIGlmKCAwID09PSAoZVRleHRSZXAgJiAweGYpICl7XG4gICAgICAgIGVUZXh0UmVwIHw9IGNhcGkuU1FMSVRFX1VURjg7XG4gICAgICB9ZWxzZSBpZiggY2FwaS5TUUxJVEVfVVRGOCAhPT0gKGVUZXh0UmVwICYgMHhmKSApe1xuICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgfVxuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCByYyA9IF9fc3FsaXRlM0NyZWF0ZUZ1bmN0aW9uKHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBBcHAsIHhGdW5jLCB4U3RlcCwgeEZpbmFsLCB4RGVzdHJveSk7XG4gICAgICAgIGlmKDA9PT1yYyAmJiAoeEZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHx8IHhTdGVwIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8fCB4RmluYWwgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHx8IHhEZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRGdW5jdGlvbihwRGIsIGZ1bmNOYW1lLCBuQXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MigpIHNldHVwIHRocmV3OlwiLGUpO1xuICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IocERiLCBlLCBcIkNyZWF0aW9uIG9mIFVERiB0aHJldzogXCIrZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24gPSBmdW5jdGlvbiBmKFxuICAgICAgcERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsIHBBcHAsXG4gICAgICB4RnVuYywgeFN0ZXAsIHhGaW5hbFxuICAgICl7XG4gICAgICByZXR1cm4gKGYubGVuZ3RoPT09YXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyKHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcEFwcCwgeEZ1bmMsIHhTdGVwLCB4RmluYWwsIDApXG4gICAgICAgIDogX19kYkFyZ2NNaXNtYXRjaChwRGIsXCJzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvblwiLGYubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24gPSBmdW5jdGlvbiBmKFxuICAgICAgcERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsIHBBcHAsXG4gICAgICB4U3RlcCwgICBcbiAgICAgIHhGaW5hbCwgIFxuICAgICAgeFZhbHVlLCAgXG4gICAgICB4SW52ZXJzZSxcbiAgICAgIHhEZXN0cm95IFxuICAgICl7XG4gICAgICBpZiggZi5sZW5ndGghPT1hcmd1bWVudHMubGVuZ3RoICl7XG4gICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYixcInNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblwiLGYubGVuZ3RoKTtcbiAgICAgIH1lbHNlIGlmKCAwID09PSAoZVRleHRSZXAgJiAweGYpICl7XG4gICAgICAgIGVUZXh0UmVwIHw9IGNhcGkuU1FMSVRFX1VURjg7XG4gICAgICB9ZWxzZSBpZiggY2FwaS5TUUxJVEVfVVRGOCAhPT0gKGVUZXh0UmVwICYgMHhmKSApe1xuICAgICAgICByZXR1cm4gX19lcnJFbmNvZGluZyhwRGIpO1xuICAgICAgfVxuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCByYyA9IF9fc3FsaXRlM0NyZWF0ZVdpbmRvd0Z1bmN0aW9uKHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBBcHAsIHhTdGVwLCB4RmluYWwsIHhWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4SW52ZXJzZSwgeERlc3Ryb3kpO1xuICAgICAgICBpZigwPT09cmMgJiYgKHhTdGVwIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8fCB4RmluYWwgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHx8IHhWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfHwgeEludmVyc2UgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHx8IHhEZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRXaW5kb3dGdW5jKHBEYiwgZnVuY05hbWUsIG5BcmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgY29uc29sZS5lcnJvcihcInNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbigpIHNldHVwIHRocmV3OlwiLGUpO1xuICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IocERiLCBlLCBcIkNyZWF0aW9uIG9mIFVERiB0aHJldzogXCIrZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyLnVkZlNldFJlc3VsdCA9XG4gICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uLnVkZlNldFJlc3VsdCA9XG4gICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbi51ZGZTZXRSZXN1bHQgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzO1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mi51ZGZDb252ZXJ0QXJncyA9XG4gICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uLnVkZkNvbnZlcnRBcmdzID1cbiAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZkNvbnZlcnRBcmdzID0gY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcztcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIudWRmU2V0RXJyb3IgPVxuICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbi51ZGZTZXRFcnJvciA9XG4gICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbi51ZGZTZXRFcnJvciA9IGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanM7XG5cbiAgfTtcblxuICB7XG5cbiAgICBcbiAgICBjb25zdCBfX2ZsZXhpU3RyaW5nID0gKHYsbik9PntcbiAgICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIHYpe1xuICAgICAgICBuID0gLTE7XG4gICAgICB9ZWxzZSBpZih1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkodikpe1xuICAgICAgICBuID0gdi5ieXRlTGVuZ3RoO1xuICAgICAgICB2ID0gdXRpbC50eXBlZEFycmF5VG9TdHJpbmcoXG4gICAgICAgICAgKHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgPyBuZXcgVWludDhBcnJheSh2KSA6IHZcbiAgICAgICAgKTtcbiAgICAgIH1lbHNlIGlmKEFycmF5LmlzQXJyYXkodikpe1xuICAgICAgICB2ID0gdi5qb2luKFwiXCIpO1xuICAgICAgICBuID0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3YsIG5dO1xuICAgIH07XG5cbiAgICBcbiAgICBjb25zdCBfX3ByZXBhcmUgPSB7XG4gICAgICBcbiAgICAgIGJhc2ljOiB3YXNtLnhXcmFwKCdzcWxpdGUzX3ByZXBhcmVfdjMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRcIiwgW1wic3FsaXRlMypcIiwgXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRcIiwgXCIqKlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIioqXCJdKSxcbiAgICAgIFxuICAgICAgZnVsbDogd2FzbS54V3JhcCgnc3FsaXRlM19wcmVwYXJlX3YzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgXCJpbnRcIiwgW1wic3FsaXRlMypcIiwgXCIqXCIsIFwiaW50XCIsIFwiaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIqKlwiLCBcIioqXCJdKVxuICAgIH07XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyA9IGZ1bmN0aW9uIGYocERiLCBzcWwsIHNxbExlbiwgcHJlcEZsYWdzLCBwcFN0bXQsIHB6VGFpbCl7XG4gICAgICBpZihmLmxlbmd0aCE9PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsXCJzcWxpdGUzX3ByZXBhcmVfdjNcIixmLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBjb25zdCBbeFNxbCwgeFNxbExlbl0gPSBfX2ZsZXhpU3RyaW5nKHNxbCwgc3FsTGVuKTtcbiAgICAgIHN3aXRjaCh0eXBlb2YgeFNxbCl7XG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuIF9fcHJlcGFyZS5iYXNpYyhwRGIsIHhTcWwsIHhTcWxMZW4sIHByZXBGbGFncywgcHBTdG10LCBudWxsKTtcbiAgICAgICAgICBjYXNlICdudW1iZXInOiByZXR1cm4gX19wcmVwYXJlLmZ1bGwocERiLCB4U3FsLCB4U3FsTGVuLCBwcmVwRmxhZ3MsIHBwU3RtdCwgcHpUYWlsKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgICBwRGIsIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFNRTCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX3ByZXBhcmVfdjIvdjMoKS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjIgPSBmdW5jdGlvbiBmKHBEYiwgc3FsLCBzcWxMZW4sIHBwU3RtdCwgcHpUYWlsKXtcbiAgICAgIHJldHVybiAoZi5sZW5ndGg9PT1hcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICA/IGNhcGkuc3FsaXRlM19wcmVwYXJlX3YzKHBEYiwgc3FsLCBzcWxMZW4sIDAsIHBwU3RtdCwgcHpUYWlsKVxuICAgICAgICA6IF9fZGJBcmdjTWlzbWF0Y2gocERiLFwic3FsaXRlM19wcmVwYXJlX3YyXCIsZi5sZW5ndGgpO1xuICAgIH07XG5cbiAgfVxuXG4gIHtcbiAgICBjb25zdCBfX2JpbmRUZXh0ID0gd2FzbS54V3JhcChcInNxbGl0ZTNfYmluZF90ZXh0XCIsIFwiaW50XCIsIFtcbiAgICAgIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiLCBcInN0cmluZ1wiLCBcImludFwiLCBcIipcIlxuICAgIF0pO1xuICAgIGNvbnN0IF9fYmluZEJsb2IgPSB3YXNtLnhXcmFwKFwic3FsaXRlM19iaW5kX2Jsb2JcIiwgXCJpbnRcIiwgW1xuICAgICAgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCIsIFwiKlwiLCBcImludFwiLCBcIipcIlxuICAgIF0pO1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2JpbmRfdGV4dCA9IGZ1bmN0aW9uIGYocFN0bXQsIGlDb2wsIHRleHQsIG5UZXh0LCB4RGVzdHJveSl7XG4gICAgICBpZihmLmxlbmd0aCE9PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcWxpdGUzX2JpbmRfdGV4dFwiLCBmLmxlbmd0aCk7XG4gICAgICB9ZWxzZSBpZih3YXNtLmlzUHRyKHRleHQpIHx8IG51bGw9PT10ZXh0KXtcbiAgICAgICAgcmV0dXJuIF9fYmluZFRleHQocFN0bXQsIGlDb2wsIHRleHQsIG5UZXh0LCB4RGVzdHJveSk7XG4gICAgICB9ZWxzZSBpZih0ZXh0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICB0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkodGV4dCk7XG4gICAgICB9ZWxzZSBpZihBcnJheS5pc0FycmF5KHBNZW0pKXtcbiAgICAgICAgdGV4dCA9IHBNZW0uam9pbignJyk7XG4gICAgICB9XG4gICAgICBsZXQgcCwgbjtcbiAgICAgIHRyeXtcbiAgICAgICAgaWYodXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KHRleHQpKXtcbiAgICAgICAgICBwID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KHRleHQpO1xuICAgICAgICAgIG4gPSB0ZXh0LmJ5dGVMZW5ndGg7XG4gICAgICAgIH1lbHNlIGlmKCdzdHJpbmcnPT09dHlwZW9mIHRleHQpe1xuICAgICAgICAgIFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHRleHQpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSwgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgXCJJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2JpbmRfdGV4dCgpLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19iaW5kVGV4dChwU3RtdCwgaUNvbCwgcCwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgd2FzbS5kZWFsbG9jKHApO1xuICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksIGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2JpbmRfYmxvYiA9IGZ1bmN0aW9uIGYocFN0bXQsIGlDb2wsIHBNZW0sIG5NZW0sIHhEZXN0cm95KXtcbiAgICAgIGlmKGYubGVuZ3RoIT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNxbGl0ZTNfYmluZF9ibG9iXCIsIGYubGVuZ3RoKTtcbiAgICAgIH1lbHNlIGlmKHdhc20uaXNQdHIocE1lbSkgfHwgbnVsbD09PXBNZW0pe1xuICAgICAgICByZXR1cm4gX19iaW5kQmxvYihwU3RtdCwgaUNvbCwgcE1lbSwgbk1lbSwgeERlc3Ryb3kpO1xuICAgICAgfWVsc2UgaWYocE1lbSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtcbiAgICAgICAgcE1lbSA9IG5ldyBVaW50OEFycmF5KHBNZW0pO1xuICAgICAgfWVsc2UgaWYoQXJyYXkuaXNBcnJheShwTWVtKSl7XG4gICAgICAgIHBNZW0gPSBwTWVtLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgbGV0IHAsIG47XG4gICAgICB0cnl7XG4gICAgICAgIGlmKHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkocE1lbSkpe1xuICAgICAgICAgIHAgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkocE1lbSk7XG4gICAgICAgICAgbiA9IG5NZW0+PTAgPyBuTWVtIDogcE1lbS5ieXRlTGVuZ3RoO1xuICAgICAgICB9ZWxzZSBpZignc3RyaW5nJz09PXR5cGVvZiBwTWVtKXtcbiAgICAgICAgICBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyhwTWVtKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgIFwiSW52YWxpZCAzcmQgYXJndW1lbnQgdHlwZSBmb3Igc3FsaXRlM19iaW5kX2Jsb2IoKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYmluZEJsb2IocFN0bXQsIGlDb2wsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHdhc20uZGVhbGxvYyhwKTtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLCBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICB9XG5cbiAge1xuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jb25maWcgPSBmdW5jdGlvbihvcCwgLi4uYXJncyl7XG4gICAgICBpZihhcmd1bWVudHMubGVuZ3RoPDIpIHJldHVybiBjYXBpLlNRTElURV9NSVNVU0U7XG4gICAgICBzd2l0Y2gob3Ape1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0NPVkVSSU5HX0lOREVYX1NDQU46IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01FTVNUQVRVUzpcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TTUFMTF9NQUxMT0M6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NPUlRFUlJFRl9TSVpFOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TVE1USlJOTF9TUElMTDogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfVVJJOlxuICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fY29uZmlnX2kob3AsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0xPT0tBU0lERTogXG4gICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9jb25maWdfaWkob3AsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01FTURCX01BWFNJWkU6IFxuICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fY29uZmlnX2oob3AsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVE1BTExPQzogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUTVVURVg6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVFBDQUNIRTI6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVFBDQUNIRTogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfSEVBUDogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTE9HOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NQUxMT0M6XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTU1BUF9TSVpFOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NVUxUSVRIUkVBRDogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTVVURVg6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BBR0VDQUNIRTogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUENBQ0hFMjogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUENBQ0hFOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQ0FDSEVfSERSU1o6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BNQVNaOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TRVJJQUxJWkVEOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TSU5HTEVUSFJFQUQ6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NRTExPRzogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfV0lOMzJfSEVBUFNJWkU6IFxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBjb25zdCBfX2F1dG9FeHRGcHRyID0gbmV3IFNldDtcblxuICAgIGNhcGkuc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IGZ1bmN0aW9uKGZQdHIpe1xuICAgICAgaWYoIGZQdHIgaW5zdGFuY2VvZiBGdW5jdGlvbiApe1xuICAgICAgICBmUHRyID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oJ2kocHBwKScsIGZQdHIpO1xuICAgICAgfWVsc2UgaWYoIDEhPT1hcmd1bWVudHMubGVuZ3RoIHx8ICF3YXNtLmlzUHRyKGZQdHIpICl7XG4gICAgICAgIHJldHVybiBjYXBpLlNRTElURV9NSVNVU0U7XG4gICAgICB9XG4gICAgICBjb25zdCByYyA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uKGZQdHIpO1xuICAgICAgaWYoIGZQdHIhPT1hcmd1bWVudHNbMF0gKXtcbiAgICAgICAgaWYoMD09PXJjKSBfX2F1dG9FeHRGcHRyLmFkZChmUHRyKTtcbiAgICAgICAgZWxzZSB3YXNtLnVuaW5zdGFsbEZ1bmN0aW9uKGZQdHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJjO1xuICAgIH07XG5cbiAgICBjYXBpLnNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uID0gZnVuY3Rpb24oZlB0cil7XG4gICAgIDtcbiAgICAgIGlmKCFmUHRyIHx8IDEhPT1hcmd1bWVudHMubGVuZ3RoIHx8ICF3YXNtLmlzUHRyKGZQdHIpKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24oZlB0cik7XG4gICAgICBcbiAgICB9O1xuXG4gICAgY2FwaS5zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uID0gZnVuY3Rpb24oKXtcbiAgICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uKCk7XG4gICAgICBmb3IoY29uc3QgZnAgb2YgX19hdXRvRXh0RnB0cikgd2FzbS51bmluc3RhbGxGdW5jdGlvbihmcCk7XG4gICAgICBfX2F1dG9FeHRGcHRyLmNsZWFyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHBLdnZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZChcImt2dmZzXCIpO1xuICBpZiggcEt2dmZzICl7XG4gICAgaWYodXRpbC5pc1VJVGhyZWFkKCkpe1xuICAgICAgY29uc3Qga3Z2ZnNNZXRob2RzID0gbmV3IGNhcGkuc3FsaXRlM19rdnZmc19tZXRob2RzKFxuICAgICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHMoKVxuICAgICAgKTtcbiAgICAgIGRlbGV0ZSBjYXBpLnNxbGl0ZTNfa3Z2ZnNfbWV0aG9kcztcblxuICAgICAgY29uc3Qga3Z2ZnNNYWtlS2V5ID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjayxcbiAgICAgICAgICAgIHBzdGFjayA9IHdhc20ucHN0YWNrO1xuXG4gICAgICBjb25zdCBrdnZmc1N0b3JhZ2UgPSAoekNsYXNzKT0+XG4gICAgICAgICAgICAoKDExNT09PXdhc20ucGVlayh6Q2xhc3MpKVxuICAgICAgICAgICAgID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpO1xuXG4gICAgICBcbiAgICAgIGNvbnN0IGt2dmZzSW1wbHMgPSB7XG4gICAgICAgIHhSZWFkOiAoekNsYXNzLCB6S2V5LCB6QnVmLCBuQnVmKT0+e1xuICAgICAgICAgIGNvbnN0IHN0YWNrID0gcHN0YWNrLnBvaW50ZXIsXG4gICAgICAgICAgICAgICAgYXN0YWNrID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgelhLZXkgPSBrdnZmc01ha2VLZXkoekNsYXNzLHpLZXkpO1xuICAgICAgICAgICAgaWYoIXpYS2V5KSByZXR1cm4gLTM7XG4gICAgICAgICAgICBjb25zdCBqS2V5ID0gd2FzbS5jc3RyVG9Kcyh6WEtleSk7XG4gICAgICAgICAgICBjb25zdCBqViA9IGt2dmZzU3RvcmFnZSh6Q2xhc3MpLmdldEl0ZW0oaktleSk7XG4gICAgICAgICAgICBpZighalYpIHJldHVybiAtMTtcbiAgICAgICAgICAgIGNvbnN0IG5WID0galYubGVuZ3RoIDtcbiAgICAgICAgICAgIGlmKG5CdWY8PTApIHJldHVybiBuVjtcbiAgICAgICAgICAgIGVsc2UgaWYoMT09PW5CdWYpe1xuICAgICAgICAgICAgICB3YXNtLnBva2UoekJ1ZiwgMCk7XG4gICAgICAgICAgICAgIHJldHVybiBuVjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHpWID0gd2FzbS5zY29wZWRBbGxvY0NTdHJpbmcoalYpO1xuICAgICAgICAgICAgaWYobkJ1ZiA+IG5WICsgMSkgbkJ1ZiA9IG5WICsgMTtcbiAgICAgICAgICAgIHdhc20uaGVhcDh1KCkuY29weVdpdGhpbih6QnVmLCB6ViwgelYgKyBuQnVmIC0gMSk7XG4gICAgICAgICAgICB3YXNtLnBva2UoekJ1ZiArIG5CdWYgLSAxLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBuQnVmIC0gMTtcbiAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwia3ZzdG9yYWdlUmVhZCgpXCIsZSk7XG4gICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgICAgfWZpbmFsbHl7XG4gICAgICAgICAgICBwc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKGFzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB4V3JpdGU6ICh6Q2xhc3MsIHpLZXksIHpEYXRhKT0+e1xuICAgICAgICAgIGNvbnN0IHN0YWNrID0gcHN0YWNrLnBvaW50ZXI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHpYS2V5ID0ga3Z2ZnNNYWtlS2V5KHpDbGFzcyx6S2V5KTtcbiAgICAgICAgICAgIGlmKCF6WEtleSkgcmV0dXJuIDE7XG4gICAgICAgICAgICBjb25zdCBqS2V5ID0gd2FzbS5jc3RyVG9Kcyh6WEtleSk7XG4gICAgICAgICAgICBrdnZmc1N0b3JhZ2UoekNsYXNzKS5zZXRJdGVtKGpLZXksIHdhc20uY3N0clRvSnMoekRhdGEpKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJrdnN0b3JhZ2VXcml0ZSgpXCIsZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgfWZpbmFsbHl7XG4gICAgICAgICAgICBwc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB4RGVsZXRlOiAoekNsYXNzLCB6S2V5KT0+e1xuICAgICAgICAgIGNvbnN0IHN0YWNrID0gcHN0YWNrLnBvaW50ZXI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHpYS2V5ID0ga3Z2ZnNNYWtlS2V5KHpDbGFzcyx6S2V5KTtcbiAgICAgICAgICAgIGlmKCF6WEtleSkgcmV0dXJuIDE7XG4gICAgICAgICAgICBrdnZmc1N0b3JhZ2UoekNsYXNzKS5yZW1vdmVJdGVtKHdhc20uY3N0clRvSnMoelhLZXkpKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJrdnN0b3JhZ2VEZWxldGUoKVwiLGUpO1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPRVJSO1xuICAgICAgICAgIH1maW5hbGx5e1xuICAgICAgICAgICAgcHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvcihjb25zdCBrIG9mIE9iamVjdC5rZXlzKGt2dmZzSW1wbHMpKXtcbiAgICAgICAga3Z2ZnNNZXRob2RzW2t2dmZzTWV0aG9kcy5tZW1iZXJLZXkoayldID1cbiAgICAgICAgICB3YXNtLmluc3RhbGxGdW5jdGlvbihcbiAgICAgICAgICAgIGt2dmZzTWV0aG9kcy5tZW1iZXJTaWduYXR1cmUoayksXG4gICAgICAgICAgICBrdnZmc0ltcGxzW2tdXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIFxuICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHBLdnZmcyk7XG4gICAgfVxuICB9XG5cbiAgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSB0cnVlO1xufSk7XG5cblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uKHNxbGl0ZTMpe1xuICBzcWxpdGUzLnZlcnNpb24gPSB7XCJsaWJWZXJzaW9uXCI6IFwiMy40NS4yXCIsIFwibGliVmVyc2lvbk51bWJlclwiOiAzMDQ1MDAyLCBcInNvdXJjZUlkXCI6IFwiMjAyNC0wMy0xMiAxMTowNjoyMyBkOGNkNmQ0OWI0NmEzOTViMTM5NTUzODdkMDVlOWUxYTJhNDdlNTRmYjk5ZjNjOWI1OTgzNWJiZWZhZDZhZjc3XCIsXCJkb3dubG9hZFZlcnNpb25cIjogMzQ1MDIwMH07XG59KTtcblxuXG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbihzcWxpdGUzKXtcbiAgY29uc3QgdG9zcyA9ICguLi5hcmdzKT0+e3Rocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSl9O1xuICBjb25zdCB0b3NzMyA9ICguLi5hcmdzKT0+e3Rocm93IG5ldyBzcWxpdGUzLlNRTGl0ZTNFcnJvciguLi5hcmdzKX07XG5cbiAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaSwgd2FzbSA9IHNxbGl0ZTMud2FzbSwgdXRpbCA9IHNxbGl0ZTMudXRpbDtcbiAgXG5cbiAgXG4gIGNvbnN0IF9fcHRyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgXG4gIGNvbnN0IF9fc3RtdE1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgXG4gIGNvbnN0IGdldE93bk9wdGlvbiA9IChvcHRzLCBwLCBkZmx0KT0+e1xuICAgIGNvbnN0IGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9wdHMscCk7XG4gICAgcmV0dXJuIGQgPyBkLnZhbHVlIDogZGZsdDtcbiAgfTtcblxuICBcbiAgY29uc3QgY2hlY2tTcWxpdGUzUmMgPSBmdW5jdGlvbihkYlB0ciwgc3FsaXRlUmVzdWx0Q29kZSl7XG4gICAgaWYoc3FsaXRlUmVzdWx0Q29kZSl7XG4gICAgICBpZihkYlB0ciBpbnN0YW5jZW9mIERCKSBkYlB0ciA9IGRiUHRyLnBvaW50ZXI7XG4gICAgICB0b3NzMyhcbiAgICAgICAgc3FsaXRlUmVzdWx0Q29kZSxcbiAgICAgICAgXCJzcWxpdGUzIHJlc3VsdCBjb2RlXCIsc3FsaXRlUmVzdWx0Q29kZStcIjpcIixcbiAgICAgICAgKGRiUHRyXG4gICAgICAgICA/IGNhcGkuc3FsaXRlM19lcnJtc2coZGJQdHIpXG4gICAgICAgICA6IGNhcGkuc3FsaXRlM19lcnJzdHIoc3FsaXRlUmVzdWx0Q29kZSkpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2RiVHJhY2VUb0NvbnNvbGUgPVxuICAgICAgICB3YXNtLmluc3RhbGxGdW5jdGlvbignaShpcHBwKScsIGZ1bmN0aW9uKHQsYyxwLHgpe1xuICAgICAgICAgIGlmKGNhcGkuU1FMSVRFX1RSQUNFX1NUTVQ9PT10KXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJTUUwgVFJBQ0UgI1wiKygrK3RoaXMuY291bnRlcikrJyB2aWEgc3FsaXRlM0AnK2MrJzonLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FzbS5jc3RyVG9Kcyh4KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQoe2NvdW50ZXI6IDB9KSk7XG5cbiAgXG4gIGNvbnN0IF9fdmZzUG9zdE9wZW5TcWwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIFxuICBjb25zdCBkYkN0b3JIZWxwZXIgPSBmdW5jdGlvbiBjdG9yKC4uLmFyZ3Mpe1xuICAgIGlmKCFjdG9yLl9uYW1lMnZmcyl7XG4gICAgICBcbiAgICAgIGN0b3IuX25hbWUydmZzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGNvbnN0IGlzV29ya2VyVGhyZWFkID0gKCdmdW5jdGlvbic9PT10eXBlb2YgaW1wb3J0U2NyaXB0cylcbiAgICAgICAgICAgID8gKG4pPT50b3NzMyhcIlRoZSBWRlMgZm9yXCIsbixcImlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSBtYWluIHdpbmRvdyB0aHJlYWQuXCIpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgY3Rvci5fbmFtZTJ2ZnNbJzpsb2NhbFN0b3JhZ2U6J10gPSB7XG4gICAgICAgIHZmczogJ2t2dmZzJywgZmlsZW5hbWU6IGlzV29ya2VyVGhyZWFkIHx8ICgoKT0+J2xvY2FsJylcbiAgICAgIH07XG4gICAgICBjdG9yLl9uYW1lMnZmc1snOnNlc3Npb25TdG9yYWdlOiddID0ge1xuICAgICAgICB2ZnM6ICdrdnZmcycsIGZpbGVuYW1lOiBpc1dvcmtlclRocmVhZCB8fCAoKCk9PidzZXNzaW9uJylcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9wdCA9IGN0b3Iubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICBsZXQgZm4gPSBvcHQuZmlsZW5hbWUsIHZmc05hbWUgPSBvcHQudmZzLCBmbGFnc1N0ciA9IG9wdC5mbGFncztcbiAgICBpZigoJ3N0cmluZychPT10eXBlb2YgZm4gJiYgJ251bWJlcichPT10eXBlb2YgZm4pXG4gICAgICAgfHwgJ3N0cmluZychPT10eXBlb2YgZmxhZ3NTdHJcbiAgICAgICB8fCAodmZzTmFtZSAmJiAoJ3N0cmluZychPT10eXBlb2YgdmZzTmFtZSAmJiAnbnVtYmVyJyE9PXR5cGVvZiB2ZnNOYW1lKSkpe1xuICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IoXCJJbnZhbGlkIERCIGN0b3IgYXJnc1wiLG9wdCxhcmd1bWVudHMpO1xuICAgICAgdG9zczMoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgREIgY29uc3RydWN0b3IuXCIpO1xuICAgIH1cbiAgICBsZXQgZm5KcyA9ICgnbnVtYmVyJz09PXR5cGVvZiBmbikgPyB3YXNtLmNzdHJUb0pzKGZuKSA6IGZuO1xuICAgIGNvbnN0IHZmc0NoZWNrID0gY3Rvci5fbmFtZTJ2ZnNbZm5Kc107XG4gICAgaWYodmZzQ2hlY2spe1xuICAgICAgdmZzTmFtZSA9IHZmc0NoZWNrLnZmcztcbiAgICAgIGZuID0gZm5KcyA9IHZmc0NoZWNrLmZpbGVuYW1lKGZuSnMpO1xuICAgIH1cbiAgICBsZXQgcERiLCBvZmxhZ3MgPSAwO1xuICAgIGlmKCBmbGFnc1N0ci5pbmRleE9mKCdjJyk+PTAgKXtcbiAgICAgIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX0NSRUFURSB8IGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFO1xuICAgIH1cbiAgICBpZiggZmxhZ3NTdHIuaW5kZXhPZigndycpPj0wICkgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFO1xuICAgIGlmKCAwPT09b2ZsYWdzICkgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFk7XG4gICAgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fRVhSRVNDT0RFO1xuICAgIGNvbnN0IHN0YWNrID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcFB0ciA9IHdhc20ucHN0YWNrLmFsbG9jUHRyKCkgO1xuICAgICAgbGV0IHJjID0gY2FwaS5zcWxpdGUzX29wZW5fdjIoZm4sIHBQdHIsIG9mbGFncywgdmZzTmFtZSB8fCAwKTtcbiAgICAgIHBEYiA9IHdhc20ucGVla1B0cihwUHRyKTtcbiAgICAgIGNoZWNrU3FsaXRlM1JjKHBEYiwgcmMpO1xuICAgICAgY2FwaS5zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyhwRGIsIDEpO1xuICAgICAgaWYoZmxhZ3NTdHIuaW5kZXhPZigndCcpPj0wKXtcbiAgICAgICAgY2FwaS5zcWxpdGUzX3RyYWNlX3YyKHBEYiwgY2FwaS5TUUxJVEVfVFJBQ0VfU1RNVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZGJUcmFjZVRvQ29uc29sZSwgcERiKTtcbiAgICAgIH1cbiAgICB9Y2F0Y2goIGUgKXtcbiAgICAgIGlmKCBwRGIgKSBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgIHRocm93IGU7XG4gICAgfWZpbmFsbHl7XG4gICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICB9XG4gICAgdGhpcy5maWxlbmFtZSA9IGZuSnM7XG4gICAgX19wdHJNYXAuc2V0KHRoaXMsIHBEYik7XG4gICAgX19zdG10TWFwLnNldCh0aGlzLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB0cnl7XG4gICAgICBcbiAgICAgIGNvbnN0IHBWZnMgPSBjYXBpLnNxbGl0ZTNfanNfZGJfdmZzKHBEYik7XG4gICAgICBpZighcFZmcykgdG9zczMoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGdldCBWRlMgZm9yIG5ldyBkYiBoYW5kbGUuXCIpO1xuICAgICAgY29uc3QgcG9zdEluaXRTcWwgPSBfX3Zmc1Bvc3RPcGVuU3FsW3BWZnNdO1xuICAgICAgaWYocG9zdEluaXRTcWwgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgIHBvc3RJbml0U3FsKHRoaXMsIHNxbGl0ZTMpO1xuICAgICAgfWVsc2UgaWYocG9zdEluaXRTcWwpe1xuICAgICAgICBjaGVja1NxbGl0ZTNSYyhcbiAgICAgICAgICBwRGIsIGNhcGkuc3FsaXRlM19leGVjKHBEYiwgcG9zdEluaXRTcWwsIDAsIDAsIDApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfWNhdGNoKGUpe1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGRiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlblNxbCA9IGZ1bmN0aW9uKHBWZnMsIHNxbCl7XG4gICAgX192ZnNQb3N0T3BlblNxbFtwVmZzXSA9IHNxbDtcbiAgfTtcblxuICBcbiAgZGJDdG9ySGVscGVyLm5vcm1hbGl6ZUFyZ3MgPSBmdW5jdGlvbihmaWxlbmFtZT0nOm1lbW9yeTonLGZsYWdzID0gJ2MnLHZmcyA9IG51bGwpe1xuICAgIGNvbnN0IGFyZyA9IHt9O1xuICAgIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAmJiAnb2JqZWN0Jz09PXR5cGVvZiBhcmd1bWVudHNbMF0pe1xuICAgICAgT2JqZWN0LmFzc2lnbihhcmcsIGFyZ3VtZW50c1swXSk7XG4gICAgICBpZih1bmRlZmluZWQ9PT1hcmcuZmxhZ3MpIGFyZy5mbGFncyA9ICdjJztcbiAgICAgIGlmKHVuZGVmaW5lZD09PWFyZy52ZnMpIGFyZy52ZnMgPSBudWxsO1xuICAgICAgaWYodW5kZWZpbmVkPT09YXJnLmZpbGVuYW1lKSBhcmcuZmlsZW5hbWUgPSAnOm1lbW9yeTonO1xuICAgIH1lbHNle1xuICAgICAgYXJnLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICBhcmcuZmxhZ3MgPSBmbGFncztcbiAgICAgIGFyZy52ZnMgPSB2ZnM7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG4gIH07XG4gIFxuICBjb25zdCBEQiA9IGZ1bmN0aW9uKC4uLmFyZ3Mpe1xuICAgIGRiQ3RvckhlbHBlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbiAgREIuZGJDdG9ySGVscGVyID0gZGJDdG9ySGVscGVyO1xuXG4gIFxuICBjb25zdCBCaW5kVHlwZXMgPSB7XG4gICAgbnVsbDogMSxcbiAgICBudW1iZXI6IDIsXG4gICAgc3RyaW5nOiAzLFxuICAgIGJvb2xlYW46IDQsXG4gICAgYmxvYjogNVxuICB9O1xuICBCaW5kVHlwZXNbJ3VuZGVmaW5lZCddID09IEJpbmRUeXBlcy5udWxsO1xuICBpZih3YXNtLmJpZ0ludEVuYWJsZWQpe1xuICAgIEJpbmRUeXBlcy5iaWdpbnQgPSBCaW5kVHlwZXMubnVtYmVyO1xuICB9XG5cbiAgXG4gIGNvbnN0IFN0bXQgPSBmdW5jdGlvbigpe1xuICAgIGlmKEJpbmRUeXBlcyE9PWFyZ3VtZW50c1syXSl7XG4gICAgICB0b3NzMyhjYXBpLlNRTElURV9NSVNVU0UsIFwiRG8gbm90IGNhbGwgdGhlIFN0bXQgY29uc3RydWN0b3IgZGlyZWN0bHkuIFVzZSBEQi5wcmVwYXJlKCkuXCIpO1xuICAgIH1cbiAgICB0aGlzLmRiID0gYXJndW1lbnRzWzBdO1xuICAgIF9fcHRyTWFwLnNldCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgIHRoaXMucGFyYW1ldGVyQ291bnQgPSBjYXBpLnNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQodGhpcy5wb2ludGVyKTtcbiAgfTtcblxuICBcbiAgY29uc3QgYWZmaXJtRGJPcGVuID0gZnVuY3Rpb24oZGIpe1xuICAgIGlmKCFkYi5wb2ludGVyKSB0b3NzMyhcIkRCIGhhcyBiZWVuIGNsb3NlZC5cIik7XG4gICAgcmV0dXJuIGRiO1xuICB9O1xuXG4gIFxuICBjb25zdCBhZmZpcm1Db2xJbmRleCA9IGZ1bmN0aW9uKHN0bXQsbmR4KXtcbiAgICBpZigobmR4ICE9PSAobmR4fDApKSB8fCBuZHg8MCB8fCBuZHg+PXN0bXQuY29sdW1uQ291bnQpe1xuICAgICAgdG9zczMoXCJDb2x1bW4gaW5kZXhcIixuZHgsXCJpcyBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RtdDtcbiAgfTtcblxuICBcbiAgY29uc3QgcGFyc2VFeGVjQXJncyA9IGZ1bmN0aW9uKGRiLCBhcmdzKXtcbiAgICBjb25zdCBvdXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG91dC5vcHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZignc3RyaW5nJz09PXR5cGVvZiBhcmdzWzBdIHx8IHV0aWwuaXNTUUxhYmxlVHlwZWRBcnJheShhcmdzWzBdKSl7XG4gICAgICAgICAgICBvdXQuc3FsID0gYXJnc1swXTtcbiAgICAgICAgICB9ZWxzZSBpZihBcnJheS5pc0FycmF5KGFyZ3NbMF0pKXtcbiAgICAgICAgICAgIG91dC5zcWwgPSBhcmdzWzBdO1xuICAgICAgICAgIH1lbHNlIGlmKGFyZ3NbMF0gJiYgJ29iamVjdCc9PT10eXBlb2YgYXJnc1swXSl7XG4gICAgICAgICAgICBvdXQub3B0ID0gYXJnc1swXTtcbiAgICAgICAgICAgIG91dC5zcWwgPSBvdXQub3B0LnNxbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBvdXQuc3FsID0gYXJnc1swXTtcbiAgICAgICAgICBvdXQub3B0ID0gYXJnc1sxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogdG9zczMoXCJJbnZhbGlkIGFyZ3VtZW50IGNvdW50IGZvciBleGVjKCkuXCIpO1xuICAgIH07XG4gICAgb3V0LnNxbCA9IHV0aWwuZmxleGlibGVTdHJpbmcob3V0LnNxbCk7XG4gICAgaWYoJ3N0cmluZychPT10eXBlb2Ygb3V0LnNxbCl7XG4gICAgICB0b3NzMyhcIk1pc3NpbmcgU1FMIGFyZ3VtZW50IG9yIHVuc3VwcG9ydGVkIFNRTCB2YWx1ZSB0eXBlLlwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0ID0gb3V0Lm9wdDtcbiAgICBzd2l0Y2gob3B0LnJldHVyblZhbHVlKXtcbiAgICAgICAgY2FzZSAncmVzdWx0Um93cyc6XG4gICAgICAgICAgaWYoIW9wdC5yZXN1bHRSb3dzKSBvcHQucmVzdWx0Um93cyA9IFtdO1xuICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKT0+b3B0LnJlc3VsdFJvd3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NhdmVTcWwnOlxuICAgICAgICAgIGlmKCFvcHQuc2F2ZVNxbCkgb3B0LnNhdmVTcWwgPSBbXTtcbiAgICAgICAgICBvdXQucmV0dXJuVmFsID0gKCk9Pm9wdC5zYXZlU3FsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAndGhpcyc6XG4gICAgICAgICAgb3V0LnJldHVyblZhbCA9ICgpPT5kYjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0b3NzMyhcIkludmFsaWQgcmV0dXJuVmFsdWUgdmFsdWU6XCIsb3B0LnJldHVyblZhbHVlKTtcbiAgICB9XG4gICAgaWYoIW9wdC5jYWxsYmFjayAmJiAhb3B0LnJldHVyblZhbHVlICYmIHVuZGVmaW5lZCE9PW9wdC5yb3dNb2RlKXtcbiAgICAgIGlmKCFvcHQucmVzdWx0Um93cykgb3B0LnJlc3VsdFJvd3MgPSBbXTtcbiAgICAgIG91dC5yZXR1cm5WYWwgPSAoKT0+b3B0LnJlc3VsdFJvd3M7XG4gICAgfVxuICAgIGlmKG9wdC5jYWxsYmFjayB8fCBvcHQucmVzdWx0Um93cyl7XG4gICAgICBzd2l0Y2goKHVuZGVmaW5lZD09PW9wdC5yb3dNb2RlKVxuICAgICAgICAgICAgID8gJ2FycmF5JyA6IG9wdC5yb3dNb2RlKSB7XG4gICAgICAgICAgY2FzZSAnb2JqZWN0Jzogb3V0LmNiQXJnID0gKHN0bXQpPT5zdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXJyYXknOiBvdXQuY2JBcmcgPSAoc3RtdCk9PnN0bXQuZ2V0KFtdKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3RtdCc6XG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKSl7XG4gICAgICAgICAgICAgIHRvc3MzKFwiZXhlYygpOiBpbnZhbGlkIHJvd01vZGUgZm9yIGEgcmVzdWx0Um93cyBhcnJheTogbXVzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImJlIG9uZSBvZiAnYXJyYXknLCAnb2JqZWN0JyxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJhIHJlc3VsdCBjb2x1bW4gbnVtYmVyLCBvciBjb2x1bW4gbmFtZSByZWZlcmVuY2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0LmNiQXJnID0gKHN0bXQpPT5zdG10O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmKHV0aWwuaXNJbnQzMihvcHQucm93TW9kZSkpe1xuICAgICAgICAgICAgICBvdXQuY2JBcmcgPSAoc3RtdCk9PnN0bXQuZ2V0KG9wdC5yb3dNb2RlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ZWxzZSBpZignc3RyaW5nJz09PXR5cGVvZiBvcHQucm93TW9kZVxuICAgICAgICAgICAgICAgICAgICAgJiYgb3B0LnJvd01vZGUubGVuZ3RoPjFcbiAgICAgICAgICAgICAgICAgICAgICYmICckJz09PW9wdC5yb3dNb2RlWzBdKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0ICRjb2xOYW1lID0gb3B0LnJvd01vZGUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICBvdXQuY2JBcmcgPSAoc3RtdCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByYyA9IHN0bXQuZ2V0KE9iamVjdC5jcmVhdGUobnVsbCkpWyRjb2xOYW1lXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHVuZGVmaW5lZD09PXJjKVxuICAgICAgICAgICAgICAgICAgPyB0b3NzMyhjYXBpLlNRTElURV9OT1RGT1VORCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJleGVjKCk6IHVua25vd24gcmVzdWx0IGNvbHVtbjpcIiwkY29sTmFtZSlcbiAgICAgICAgICAgICAgICAgIDogcmM7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9zczMoXCJJbnZhbGlkIHJvd01vZGU6XCIsb3B0LnJvd01vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIFxuICBjb25zdCBfX3NlbGVjdEZpcnN0Um93ID0gKGRiLCBzcWwsIGJpbmQsIC4uLmdldEFyZ3MpPT57XG4gICAgY29uc3Qgc3RtdCA9IGRiLnByZXBhcmUoc3FsKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmMgPSBzdG10LmJpbmQoYmluZCkuc3RlcCgpID8gc3RtdC5nZXQoLi4uZ2V0QXJncykgOiB1bmRlZmluZWQ7XG4gICAgICBzdG10LnJlc2V0KCk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfWZpbmFsbHl7XG4gICAgICBzdG10LmZpbmFsaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjb25zdCBfX3NlbGVjdEFsbCA9XG4gICAgICAgIChkYiwgc3FsLCBiaW5kLCByb3dNb2RlKT0+ZGIuZXhlYyh7XG4gICAgICAgICAgc3FsLCBiaW5kLCByb3dNb2RlLCByZXR1cm5WYWx1ZTogJ3Jlc3VsdFJvd3MnXG4gICAgICAgIH0pO1xuXG4gIFxuICBEQi5jaGVja1JjID0gKGRiLHJlc3VsdENvZGUpPT5jaGVja1NxbGl0ZTNSYyhkYixyZXN1bHRDb2RlKTtcblxuICBEQi5wcm90b3R5cGUgPSB7XG4gICAgXG4gICAgaXNPcGVuOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICEhdGhpcy5wb2ludGVyO1xuICAgIH0sXG4gICAgXG4gICAgYWZmaXJtT3BlbjogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgfSxcbiAgICBcbiAgICBjbG9zZTogZnVuY3Rpb24oKXtcbiAgICAgIGlmKHRoaXMucG9pbnRlcil7XG4gICAgICAgIGlmKHRoaXMub25jbG9zZSAmJiAodGhpcy5vbmNsb3NlLmJlZm9yZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgICAgICAgdHJ5e3RoaXMub25jbG9zZS5iZWZvcmUodGhpcyl9XG4gICAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBEYiA9IHRoaXMucG9pbnRlcjtcbiAgICAgICAgT2JqZWN0LmtleXMoX19zdG10TWFwLmdldCh0aGlzKSkuZm9yRWFjaCgoayxzKT0+e1xuICAgICAgICAgIGlmKHMgJiYgcy5wb2ludGVyKXtcbiAgICAgICAgICAgIHRyeXtzLmZpbmFsaXplKCl9XG4gICAgICAgICAgICBjYXRjaChlKXt9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICBfX3N0bXRNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICBjYXBpLnNxbGl0ZTNfY2xvc2VfdjIocERiKTtcbiAgICAgICAgaWYodGhpcy5vbmNsb3NlICYmICh0aGlzLm9uY2xvc2UuYWZ0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgICAgICAgIHRyeXt0aGlzLm9uY2xvc2UuYWZ0ZXIodGhpcyl9XG4gICAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVuYW1lO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2hhbmdlczogZnVuY3Rpb24odG90YWw9ZmFsc2Usc2l4dHlGb3VyPWZhbHNlKXtcbiAgICAgIGNvbnN0IHAgPSBhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlcjtcbiAgICAgIGlmKHRvdGFsKXtcbiAgICAgICAgcmV0dXJuIHNpeHR5Rm91clxuICAgICAgICAgID8gY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXM2NChwKVxuICAgICAgICAgIDogY2FwaS5zcWxpdGUzX3RvdGFsX2NoYW5nZXMocCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIHNpeHR5Rm91clxuICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2NoYW5nZXM2NChwKVxuICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2NoYW5nZXMocCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBkYkZpbGVuYW1lOiBmdW5jdGlvbihkYk5hbWU9J21haW4nKXtcbiAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfZGJfZmlsZW5hbWUoYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXIsIGRiTmFtZSk7XG4gICAgfSxcbiAgICBcbiAgICBkYk5hbWU6IGZ1bmN0aW9uKGRiTnVtYmVyPTApe1xuICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19kYl9uYW1lKGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyLCBkYk51bWJlcik7XG4gICAgfSxcbiAgICBcbiAgICBkYlZmc05hbWU6IGZ1bmN0aW9uKGRiTmFtZT0wKXtcbiAgICAgIGxldCByYztcbiAgICAgIGNvbnN0IHBWZnMgPSBjYXBpLnNxbGl0ZTNfanNfZGJfdmZzKFxuICAgICAgICBhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlciwgZGJOYW1lXG4gICAgICApO1xuICAgICAgaWYocFZmcyl7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcyhwVmZzKTtcbiAgICAgICAgdHJ5eyByYyA9IHdhc20uY3N0clRvSnModi4kek5hbWUpIH1cbiAgICAgICAgZmluYWxseSB7IHYuZGlzcG9zZSgpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuICAgIFxuICAgIHByZXBhcmU6IGZ1bmN0aW9uKHNxbCl7XG4gICAgICBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICBjb25zdCBzdGFjayA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgICBsZXQgcHBTdG10LCBwU3RtdDtcbiAgICAgIHRyeXtcbiAgICAgICAgcHBTdG10ID0gd2FzbS5wc3RhY2suYWxsb2MoOCk7XG4gICAgICAgIERCLmNoZWNrUmModGhpcywgY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjIodGhpcy5wb2ludGVyLCBzcWwsIC0xLCBwcFN0bXQsIG51bGwpKTtcbiAgICAgICAgcFN0bXQgPSB3YXNtLnBlZWtQdHIocHBTdG10KTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkge1xuICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmKCFwU3RtdCkgdG9zczMoXCJDYW5ub3QgcHJlcGFyZSBlbXB0eSBTUUwuXCIpO1xuICAgICAgY29uc3Qgc3RtdCA9IG5ldyBTdG10KHRoaXMsIHBTdG10LCBCaW5kVHlwZXMpO1xuICAgICAgX19zdG10TWFwLmdldCh0aGlzKVtwU3RtdF0gPSBzdG10O1xuICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfSxcbiAgICBcbiAgICBleGVjOiBmdW5jdGlvbigpe1xuICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpO1xuICAgICAgY29uc3QgYXJnID0gcGFyc2VFeGVjQXJncyh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYoIWFyZy5zcWwpe1xuICAgICAgICByZXR1cm4gdG9zczMoXCJleGVjKCkgcmVxdWlyZXMgYW4gU1FMIHN0cmluZy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHQgPSBhcmcub3B0O1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBvcHQuY2FsbGJhY2s7XG4gICAgICBjb25zdCByZXN1bHRSb3dzID1cbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3B0LnJlc3VsdFJvd3MpID8gb3B0LnJlc3VsdFJvd3MgOiB1bmRlZmluZWQ7XG4gICAgICBsZXQgc3RtdDtcbiAgICAgIGxldCBiaW5kID0gb3B0LmJpbmQ7XG4gICAgICBsZXQgZXZhbEZpcnN0UmVzdWx0ID0gISEoXG4gICAgICAgIGFyZy5jYkFyZyB8fCBvcHQuY29sdW1uTmFtZXMgfHwgcmVzdWx0Um93c1xuICAgICAgKSA7XG4gICAgICBjb25zdCBzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICBjb25zdCBzYXZlU3FsID0gQXJyYXkuaXNBcnJheShvcHQuc2F2ZVNxbCkgPyBvcHQuc2F2ZVNxbCA6IHVuZGVmaW5lZDtcbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgaXNUQSA9IHV0aWwuaXNTUUxhYmxlVHlwZWRBcnJheShhcmcuc3FsKVxuICAgICAgICA7XG4gICAgICAgIFxuICAgICAgICBsZXQgc3FsQnl0ZUxlbiA9IGlzVEEgPyBhcmcuc3FsLmJ5dGVMZW5ndGggOiB3YXNtLmpzdHJsZW4oYXJnLnNxbCk7XG4gICAgICAgIGNvbnN0IHBwU3RtdCAgPSB3YXNtLnNjb3BlZEFsbG9jKFxuICAgICAgICAgIFxuICAgICAgICAgICgyICogd2FzbS5wdHJTaXplb2YpICsgKHNxbEJ5dGVMZW4gKyAxKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwelRhaWwgPSBwcFN0bXQgKyB3YXNtLnB0clNpemVvZiA7XG4gICAgICAgIGxldCBwU3FsID0gcHpUYWlsICsgd2FzbS5wdHJTaXplb2Y7XG4gICAgICAgIGNvbnN0IHBTcWxFbmQgPSBwU3FsICsgc3FsQnl0ZUxlbjtcbiAgICAgICAgaWYoaXNUQSkgd2FzbS5oZWFwOCgpLnNldChhcmcuc3FsLCBwU3FsKTtcbiAgICAgICAgZWxzZSB3YXNtLmpzdHJjcHkoYXJnLnNxbCwgd2FzbS5oZWFwOCgpLCBwU3FsLCBzcWxCeXRlTGVuLCBmYWxzZSk7XG4gICAgICAgIHdhc20ucG9rZShwU3FsICsgc3FsQnl0ZUxlbiwgMCk7XG4gICAgICAgIHdoaWxlKHBTcWwgJiYgd2FzbS5wZWVrKHBTcWwsICdpOCcpXG4gICAgICAgICAgICAgICApe1xuICAgICAgICAgIHdhc20ucG9rZVB0cihbcHBTdG10LCBwelRhaWxdLCAwKTtcbiAgICAgICAgICBEQi5jaGVja1JjKHRoaXMsIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YzKFxuICAgICAgICAgICAgdGhpcy5wb2ludGVyLCBwU3FsLCBzcWxCeXRlTGVuLCAwLCBwcFN0bXQsIHB6VGFpbFxuICAgICAgICAgICkpO1xuICAgICAgICAgIGNvbnN0IHBTdG10ID0gd2FzbS5wZWVrUHRyKHBwU3RtdCk7XG4gICAgICAgICAgcFNxbCA9IHdhc20ucGVla1B0cihwelRhaWwpO1xuICAgICAgICAgIHNxbEJ5dGVMZW4gPSBwU3FsRW5kIC0gcFNxbDtcbiAgICAgICAgICBpZighcFN0bXQpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmKHNhdmVTcWwpIHNhdmVTcWwucHVzaChjYXBpLnNxbGl0ZTNfc3FsKHBTdG10KS50cmltKCkpO1xuICAgICAgICAgIHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgICAgICBpZihiaW5kICYmIHN0bXQucGFyYW1ldGVyQ291bnQpe1xuICAgICAgICAgICAgc3RtdC5iaW5kKGJpbmQpO1xuICAgICAgICAgICAgYmluZCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGV2YWxGaXJzdFJlc3VsdCAmJiBzdG10LmNvbHVtbkNvdW50KXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGdvdENvbE5hbWVzID0gQXJyYXkuaXNBcnJheShcbiAgICAgICAgICAgICAgb3B0LmNvbHVtbk5hbWVzXG4gICAgICAgICAgICAgICkgPyAwIDogMTtcbiAgICAgICAgICAgIGV2YWxGaXJzdFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoYXJnLmNiQXJnIHx8IHJlc3VsdFJvd3Mpe1xuICAgICAgICAgICAgICBmb3IoOyBzdG10LnN0ZXAoKTsgc3RtdC5fbG9ja2VkQnlFeGVjID0gZmFsc2Upe1xuICAgICAgICAgICAgICAgIGlmKDA9PT1nb3RDb2xOYW1lcysrKSBzdG10LmdldENvbHVtbk5hbWVzKG9wdC5jb2x1bW5OYW1lcyk7XG4gICAgICAgICAgICAgICAgc3RtdC5fbG9ja2VkQnlFeGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBhcmcuY2JBcmcoc3RtdCk7XG4gICAgICAgICAgICAgICAgaWYocmVzdWx0Um93cykgcmVzdWx0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgaWYoY2FsbGJhY2sgJiYgZmFsc2UgPT09IGNhbGxiYWNrLmNhbGwob3B0LCByb3csIHN0bXQpKXtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG10Ll9sb2NrZWRCeUV4ZWMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKDA9PT1nb3RDb2xOYW1lcyl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzdG10LmdldENvbHVtbk5hbWVzKG9wdC5jb2x1bW5OYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBzdG10LnN0ZXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RtdC5yZXNldChcbiAgICAgICAgICAgICkuZmluYWxpemUoKTtcbiAgICAgICAgICBzdG10ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc3RhY2spO1xuICAgICAgICBpZihzdG10KXtcbiAgICAgICAgICBkZWxldGUgc3RtdC5fbG9ja2VkQnlFeGVjO1xuICAgICAgICAgIHN0bXQuZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZy5yZXR1cm5WYWwoKTtcbiAgICB9LFxuXG4gICAgXG4gICAgY3JlYXRlRnVuY3Rpb246IGZ1bmN0aW9uIGYobmFtZSwgeEZ1bmMsIG9wdCl7XG4gICAgICBjb25zdCBpc0Z1bmMgPSAoZik9PihmIGluc3RhbmNlb2YgRnVuY3Rpb24pO1xuICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgIGNhc2UgMTogXG4gICAgICAgICAgICBvcHQgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IG9wdC5uYW1lO1xuICAgICAgICAgICAgeEZ1bmMgPSBvcHQueEZ1bmMgfHwgMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogXG4gICAgICAgICAgICBpZighaXNGdW5jKHhGdW5jKSl7XG4gICAgICAgICAgICAgIG9wdCA9IHhGdW5jO1xuICAgICAgICAgICAgICB4RnVuYyA9IG9wdC54RnVuYyB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiBcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYoIW9wdCkgb3B0ID0ge307XG4gICAgICBpZignc3RyaW5nJyAhPT0gdHlwZW9mIG5hbWUpe1xuICAgICAgICB0b3NzMyhcIkludmFsaWQgYXJndW1lbnRzOiBtaXNzaW5nIGZ1bmN0aW9uIG5hbWUuXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHhTdGVwID0gb3B0LnhTdGVwIHx8IDA7XG4gICAgICBsZXQgeEZpbmFsID0gb3B0LnhGaW5hbCB8fCAwO1xuICAgICAgY29uc3QgeFZhbHVlID0gb3B0LnhWYWx1ZSB8fCAwO1xuICAgICAgY29uc3QgeEludmVyc2UgPSBvcHQueEludmVyc2UgfHwgMDtcbiAgICAgIGxldCBpc1dpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICAgIGlmKGlzRnVuYyh4RnVuYykpe1xuICAgICAgICBpc1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICBpZihpc0Z1bmMoeFN0ZXApIHx8IGlzRnVuYyh4RmluYWwpKXtcbiAgICAgICAgICB0b3NzMyhcIkFtYmlndW91cyBhcmd1bWVudHM6IHNjYWxhciBvciBhZ2dyZWdhdGU/XCIpO1xuICAgICAgICB9XG4gICAgICAgIHhTdGVwID0geEZpbmFsID0gbnVsbDtcbiAgICAgIH1lbHNlIGlmKGlzRnVuYyh4U3RlcCkpe1xuICAgICAgICBpZighaXNGdW5jKHhGaW5hbCkpe1xuICAgICAgICAgIHRvc3MzKFwiTWlzc2luZyB4RmluYWwoKSBjYWxsYmFjayBmb3IgYWdncmVnYXRlIG9yIHdpbmRvdyBVREYuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHhGdW5jID0gbnVsbDtcbiAgICAgIH1lbHNlIGlmKGlzRnVuYyh4RmluYWwpKXtcbiAgICAgICAgdG9zczMoXCJNaXNzaW5nIHhTdGVwKCkgY2FsbGJhY2sgZm9yIGFnZ3JlZ2F0ZSBvciB3aW5kb3cgVURGLlwiKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0b3NzMyhcIk1pc3NpbmcgZnVuY3Rpb24tdHlwZSBwcm9wZXJ0aWVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmKGZhbHNlID09PSBpc1dpbmRvdyl7XG4gICAgICAgIGlmKGlzRnVuYyh4VmFsdWUpIHx8IGlzRnVuYyh4SW52ZXJzZSkpe1xuICAgICAgICAgIHRvc3MzKFwieFZhbHVlIGFuZCB4SW52ZXJzZSBhcmUgbm90IHBlcm1pdHRlZCBmb3Igbm9uLXdpbmRvdyBVREZzLlwiKTtcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYoaXNGdW5jKHhWYWx1ZSkpe1xuICAgICAgICBpZighaXNGdW5jKHhJbnZlcnNlKSl7XG4gICAgICAgICAgdG9zczMoXCJ4SW52ZXJzZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHhWYWx1ZSBpcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaXNXaW5kb3cgPSB0cnVlO1xuICAgICAgfWVsc2UgaWYoaXNGdW5jKHhJbnZlcnNlKSl7XG4gICAgICAgIHRvc3MzKFwieFZhbHVlIG11c3QgYmUgcHJvdmlkZWQgaWYgeEludmVyc2UgaXMuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcEFwcCA9IG9wdC5wQXBwO1xuICAgICAgaWYodW5kZWZpbmVkIT09cEFwcCAmJlxuICAgICAgICAgbnVsbCE9PXBBcHAgJiZcbiAgICAgICAgICgoJ251bWJlcichPT10eXBlb2YgcEFwcCkgfHwgIXV0aWwuaXNJbnQzMihwQXBwKSkpe1xuICAgICAgICB0b3NzMyhcIkludmFsaWQgdmFsdWUgZm9yIHBBcHAgcHJvcGVydHkuIE11c3QgYmUgYSBsZWdhbCBXQVNNIHBvaW50ZXIgdmFsdWUuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeERlc3Ryb3kgPSBvcHQueERlc3Ryb3kgfHwgMDtcbiAgICAgIGlmKHhEZXN0cm95ICYmICFpc0Z1bmMoeERlc3Ryb3kpKXtcbiAgICAgICAgdG9zczMoXCJ4RGVzdHJveSBwcm9wZXJ0eSBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgfVxuICAgICAgbGV0IGZGbGFncyA9IDAgO1xuICAgICAgaWYoZ2V0T3duT3B0aW9uKG9wdCwgJ2RldGVybWluaXN0aWMnKSkgZkZsYWdzIHw9IGNhcGkuU1FMSVRFX0RFVEVSTUlOSVNUSUM7XG4gICAgICBpZihnZXRPd25PcHRpb24ob3B0LCAnZGlyZWN0T25seScpKSBmRmxhZ3MgfD0gY2FwaS5TUUxJVEVfRElSRUNUT05MWTtcbiAgICAgIGlmKGdldE93bk9wdGlvbihvcHQsICdpbm5vY3VvdXMnKSkgZkZsYWdzIHw9IGNhcGkuU1FMSVRFX0lOTk9DVU9VUztcbiAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCB4QXJpdHkgPSB4RnVuYyB8fCB4U3RlcDtcbiAgICAgIGNvbnN0IGFyaXR5ID0gZ2V0T3duT3B0aW9uKG9wdCwgJ2FyaXR5Jyk7XG4gICAgICBjb25zdCBhcml0eUFyZyA9ICgnbnVtYmVyJz09PXR5cGVvZiBhcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoeEFyaXR5Lmxlbmd0aCA/IHhBcml0eS5sZW5ndGgtMSA6IDApKTtcbiAgICAgIGxldCByYztcbiAgICAgIGlmKCBpc1dpbmRvdyApe1xuICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uKFxuICAgICAgICAgIHRoaXMucG9pbnRlciwgbmFtZSwgYXJpdHlBcmcsXG4gICAgICAgICAgY2FwaS5TUUxJVEVfVVRGOCB8IGZGbGFncywgcEFwcCB8fCAwLFxuICAgICAgICAgIHhTdGVwLCB4RmluYWwsIHhWYWx1ZSwgeEludmVyc2UsIHhEZXN0cm95KTtcbiAgICAgIH1lbHNle1xuICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIoXG4gICAgICAgICAgdGhpcy5wb2ludGVyLCBuYW1lLCBhcml0eUFyZyxcbiAgICAgICAgICBjYXBpLlNRTElURV9VVEY4IHwgZkZsYWdzLCBwQXBwIHx8IDAsXG4gICAgICAgICAgeEZ1bmMsIHhTdGVwLCB4RmluYWwsIHhEZXN0cm95KTtcbiAgICAgIH1cbiAgICAgIERCLmNoZWNrUmModGhpcywgcmMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBcbiAgICBzZWxlY3RWYWx1ZTogZnVuY3Rpb24oc3FsLGJpbmQsYXNUeXBlKXtcbiAgICAgIHJldHVybiBfX3NlbGVjdEZpcnN0Um93KHRoaXMsIHNxbCwgYmluZCwgMCwgYXNUeXBlKTtcbiAgICB9LFxuXG4gICAgXG4gICAgc2VsZWN0VmFsdWVzOiBmdW5jdGlvbihzcWwsYmluZCxhc1R5cGUpe1xuICAgICAgY29uc3Qgc3RtdCA9IHRoaXMucHJlcGFyZShzcWwpLCByYyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RtdC5iaW5kKGJpbmQpO1xuICAgICAgICB3aGlsZShzdG10LnN0ZXAoKSkgcmMucHVzaChzdG10LmdldCgwLGFzVHlwZSkpO1xuICAgICAgICBzdG10LnJlc2V0KCk7XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJjO1xuICAgIH0sXG5cbiAgICBcbiAgICBzZWxlY3RBcnJheTogZnVuY3Rpb24oc3FsLGJpbmQpe1xuICAgICAgcmV0dXJuIF9fc2VsZWN0Rmlyc3RSb3codGhpcywgc3FsLCBiaW5kLCBbXSk7XG4gICAgfSxcblxuICAgIFxuICAgIHNlbGVjdE9iamVjdDogZnVuY3Rpb24oc3FsLGJpbmQpe1xuICAgICAgcmV0dXJuIF9fc2VsZWN0Rmlyc3RSb3codGhpcywgc3FsLCBiaW5kLCB7fSk7XG4gICAgfSxcblxuICAgIFxuICAgIHNlbGVjdEFycmF5czogZnVuY3Rpb24oc3FsLGJpbmQpe1xuICAgICAgcmV0dXJuIF9fc2VsZWN0QWxsKHRoaXMsIHNxbCwgYmluZCwgJ2FycmF5Jyk7XG4gICAgfSxcblxuICAgIFxuICAgIHNlbGVjdE9iamVjdHM6IGZ1bmN0aW9uKHNxbCxiaW5kKXtcbiAgICAgIHJldHVybiBfX3NlbGVjdEFsbCh0aGlzLCBzcWwsIGJpbmQsICdvYmplY3QnKTtcbiAgICB9LFxuXG4gICAgXG4gICAgb3BlblN0YXRlbWVudENvdW50OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRlciA/IE9iamVjdC5rZXlzKF9fc3RtdE1hcC5nZXQodGhpcykpLmxlbmd0aCA6IDA7XG4gICAgfSxcblxuICAgIFxuICAgIHRyYW5zYWN0aW9uOiBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgICBsZXQgb3BlbmVyID0gJ0JFR0lOJztcbiAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGg+MSl7XG4gICAgICAgIGlmKC9bXmEtekEtWl0vLnRlc3QoYXJndW1lbnRzWzBdKSl7XG4gICAgICAgICAgdG9zczMoY2FwaS5TUUxJVEVfTUlTVVNFLCBcIkludmFsaWQgYXJndW1lbnQgZm9yIEJFR0lOIHF1YWxpZmllci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgb3BlbmVyICs9ICcgJythcmd1bWVudHNbMF07XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgICAgfVxuICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpLmV4ZWMob3BlbmVyKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJjID0gY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlYyhcIkNPTU1JVFwiKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICB0aGlzLmV4ZWMoXCJST0xMQkFDS1wiKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXG4gICAgc2F2ZXBvaW50OiBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgICBhZmZpcm1EYk9wZW4odGhpcykuZXhlYyhcIlNBVkVQT0lOVCBvbzFcIik7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByYyA9IGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICB0aGlzLmV4ZWMoXCJSRUxFQVNFIG9vMVwiKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICB0aGlzLmV4ZWMoXCJST0xMQkFDSyB0byBTQVZFUE9JTlQgb28xOyBSRUxFQVNFIFNBVkVQT0lOVCBvbzFcIik7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFxuICAgIGNoZWNrUmM6IGZ1bmN0aW9uKHJlc3VsdENvZGUpe1xuICAgICAgcmV0dXJuIGNoZWNrU3FsaXRlM1JjKHRoaXMsIHJlc3VsdENvZGUpO1xuICAgIH1cbiAgfTtcblxuXG4gIFxuICBjb25zdCBhZmZpcm1TdG10T3BlbiA9IGZ1bmN0aW9uKHN0bXQpe1xuICAgIGlmKCFzdG10LnBvaW50ZXIpIHRvc3MzKFwiU3RtdCBoYXMgYmVlbiBjbG9zZWQuXCIpO1xuICAgIHJldHVybiBzdG10O1xuICB9O1xuXG4gIFxuICBjb25zdCBpc1N1cHBvcnRlZEJpbmRUeXBlID0gZnVuY3Rpb24odil7XG4gICAgbGV0IHQgPSBCaW5kVHlwZXNbKG51bGw9PT12fHx1bmRlZmluZWQ9PT12KSA/ICdudWxsJyA6IHR5cGVvZiB2XTtcbiAgICBzd2l0Y2godCl7XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLmJvb2xlYW46XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLm51bGw6XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLm51bWJlcjpcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICBjYXNlIEJpbmRUeXBlcy5iaWdpbnQ6XG4gICAgICAgICAgaWYod2FzbS5iaWdJbnRFbmFibGVkKSByZXR1cm4gdDtcbiAgICAgICAgICBcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdXRpbC5pc0JpbmRhYmxlVHlwZWRBcnJheSh2KSA/IEJpbmRUeXBlcy5ibG9iIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY29uc3QgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUgPSBmdW5jdGlvbih2KXtcbiAgICBcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWRCaW5kVHlwZSh2KSB8fCB0b3NzMyhcIlVuc3VwcG9ydGVkIGJpbmQoKSBhcmd1bWVudCB0eXBlOlwiLHR5cGVvZiB2KTtcbiAgfTtcblxuICBcbiAgY29uc3QgYWZmaXJtUGFyYW1JbmRleCA9IGZ1bmN0aW9uKHN0bXQsa2V5KXtcbiAgICBjb25zdCBuID0gKCdudW1iZXInPT09dHlwZW9mIGtleSlcbiAgICAgICAgICA/IGtleSA6IGNhcGkuc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleChzdG10LnBvaW50ZXIsIGtleSk7XG4gICAgaWYoMD09PW4gfHwgIXV0aWwuaXNJbnQzMihuKSl7XG4gICAgICB0b3NzMyhcIkludmFsaWQgYmluZCgpIHBhcmFtZXRlciBuYW1lOiBcIitrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmKG48MSB8fCBuPnN0bXQucGFyYW1ldGVyQ291bnQpIHRvc3MzKFwiQmluZCBpbmRleFwiLGtleSxcImlzIG91dCBvZiByYW5nZS5cIik7XG4gICAgcmV0dXJuIG47XG4gIH07XG5cbiAgXG4gIGNvbnN0IGFmZmlybU5vdExvY2tlZEJ5RXhlYyA9IGZ1bmN0aW9uKHN0bXQsY3VycmVudE9wTmFtZSl7XG4gICAgaWYoc3RtdC5fbG9ja2VkQnlFeGVjKXtcbiAgICAgIHRvc3MzKFwiT3BlcmF0aW9uIGlzIGlsbGVnYWwgd2hlbiBzdGF0ZW1lbnQgaXMgbG9ja2VkOlwiLGN1cnJlbnRPcE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RtdDtcbiAgfTtcblxuICBcbiAgY29uc3QgYmluZE9uZSA9IGZ1bmN0aW9uIGYoc3RtdCxuZHgsYmluZFR5cGUsdmFsKXtcbiAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMoYWZmaXJtU3RtdE9wZW4oc3RtdCksICdiaW5kKCknKTtcbiAgICBpZighZi5fKXtcbiAgICAgIGYuX3Rvb0JpZ0ludCA9ICh2KT0+dG9zczMoXG4gICAgICAgIFwiQmlnSW50IHZhbHVlIGlzIHRvbyBiaWcgdG8gc3RvcmUgd2l0aG91dCBwcmVjaXNpb24gbG9zczpcIiwgdlxuICAgICAgKTtcbiAgICAgIGYuXyA9IHtcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbihzdG10LCBuZHgsIHZhbCwgYXNCbG9iKXtcbiAgICAgICAgICBjb25zdCBbcFN0ciwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyh2YWwsIHRydWUpO1xuICAgICAgICAgIGNvbnN0IGYgPSBhc0Jsb2IgPyBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iIDogY2FwaS5zcWxpdGUzX2JpbmRfdGV4dDtcbiAgICAgICAgICByZXR1cm4gZihzdG10LnBvaW50ZXIsIG5keCwgcFN0ciwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUodmFsKTtcbiAgICBuZHggPSBhZmZpcm1QYXJhbUluZGV4KHN0bXQsbmR4KTtcbiAgICBsZXQgcmMgPSAwO1xuICAgIHN3aXRjaCgobnVsbD09PXZhbCB8fCB1bmRlZmluZWQ9PT12YWwpID8gQmluZFR5cGVzLm51bGwgOiBiaW5kVHlwZSl7XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLm51bGw6XG4gICAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfYmluZF9udWxsKHN0bXQucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMuc3RyaW5nOlxuICAgICAgICAgIHJjID0gZi5fLnN0cmluZyhzdG10LCBuZHgsIHZhbCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJpbmRUeXBlcy5udW1iZXI6IHtcbiAgICAgICAgICBsZXQgbTtcbiAgICAgICAgICBpZih1dGlsLmlzSW50MzIodmFsKSkgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2ludDtcbiAgICAgICAgICBlbHNlIGlmKCdiaWdpbnQnPT09dHlwZW9mIHZhbCl7XG4gICAgICAgICAgICBpZighdXRpbC5iaWdJbnRGaXRzNjQodmFsKSl7XG4gICAgICAgICAgICAgIGYuX3Rvb0JpZ0ludCh2YWwpO1xuICAgICAgICAgICAgfWVsc2UgaWYod2FzbS5iaWdJbnRFbmFibGVkKXtcbiAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2ludDY0O1xuICAgICAgICAgICAgfWVsc2UgaWYodXRpbC5iaWdJbnRGaXRzRG91YmxlKHZhbCkpe1xuICAgICAgICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2RvdWJsZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBmLl90b29CaWdJbnQodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXsgXG4gICAgICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICAgICAgICAgIGlmKHdhc20uYmlnSW50RW5hYmxlZCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkpe1xuICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50NjQ7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2RvdWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmMgPSBtKHN0bXQucG9pbnRlciwgbmR4LCB2YWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLmJvb2xlYW46XG4gICAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQoc3RtdC5wb2ludGVyLCBuZHgsIHZhbCA/IDEgOiAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMuYmxvYjoge1xuICAgICAgICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIHZhbCl7XG4gICAgICAgICAgICByYyA9IGYuXy5zdHJpbmcoc3RtdCwgbmR4LCB2YWwsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfWVsc2UgaWYodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICAgICAgdmFsID0gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgICAgICAgICB9ZWxzZSBpZighdXRpbC5pc0JpbmRhYmxlVHlwZWRBcnJheSh2YWwpKXtcbiAgICAgICAgICAgIHRvc3MzKFwiQmluZGluZyBhIHZhbHVlIGFzIGEgYmxvYiByZXF1aXJlc1wiLFxuICAgICAgICAgICAgICAgICAgXCJ0aGF0IGl0IGJlIGEgc3RyaW5nLCBVaW50OEFycmF5LCBJbnQ4QXJyYXksIG9yIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcEJsb2IgPSB3YXNtLmFsbG9jKHZhbC5ieXRlTGVuZ3RoIHx8IDEpO1xuICAgICAgICAgIHdhc20uaGVhcDgoKS5zZXQodmFsLmJ5dGVMZW5ndGggPyB2YWwgOiBbMF0sIHBCbG9iKVxuICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfYmxvYihzdG10LnBvaW50ZXIsIG5keCwgcEJsb2IsIHZhbC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybihcIlVuc3VwcG9ydGVkIGJpbmQoKSBhcmd1bWVudCB0eXBlOlwiLHZhbCk7XG4gICAgICAgICAgdG9zczMoXCJVbnN1cHBvcnRlZCBiaW5kKCkgYXJndW1lbnQgdHlwZTogXCIrKHR5cGVvZiB2YWwpKTtcbiAgICB9XG4gICAgaWYocmMpIERCLmNoZWNrUmMoc3RtdC5kYi5wb2ludGVyLCByYyk7XG4gICAgc3RtdC5fbWF5R2V0ID0gZmFsc2U7XG4gICAgcmV0dXJuIHN0bXQ7XG4gIH07XG5cbiAgU3RtdC5wcm90b3R5cGUgPSB7XG4gICAgXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICBpZih0aGlzLnBvaW50ZXIpe1xuICAgICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWModGhpcywnZmluYWxpemUoKScpO1xuICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19maW5hbGl6ZSh0aGlzLnBvaW50ZXIpO1xuICAgICAgICBkZWxldGUgX19zdG10TWFwLmdldCh0aGlzLmRiKVt0aGlzLnBvaW50ZXJdO1xuICAgICAgICBfX3B0ck1hcC5kZWxldGUodGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tYXlHZXQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlckNvdW50O1xuICAgICAgICBkZWxldGUgdGhpcy5fbG9ja2VkQnlFeGVjO1xuICAgICAgICBkZWxldGUgdGhpcy5kYjtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2xlYXJCaW5kaW5nczogZnVuY3Rpb24oKXtcbiAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyhhZmZpcm1TdG10T3Blbih0aGlzKSwgJ2NsZWFyQmluZGluZ3MoKScpXG4gICAgICBjYXBpLnNxbGl0ZTNfY2xlYXJfYmluZGluZ3ModGhpcy5wb2ludGVyKTtcbiAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBcbiAgICByZXNldDogZnVuY3Rpb24oYWxzb0NsZWFyQmluZHMpe1xuICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKHRoaXMsJ3Jlc2V0KCknKTtcbiAgICAgIGlmKGFsc29DbGVhckJpbmRzKSB0aGlzLmNsZWFyQmluZGluZ3MoKTtcbiAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX3Jlc2V0KGFmZmlybVN0bXRPcGVuKHRoaXMpLnBvaW50ZXIpO1xuICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICBjaGVja1NxbGl0ZTNSYyh0aGlzLmRiLCByYyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIGJpbmQ6IGZ1bmN0aW9uKCl7XG4gICAgICBhZmZpcm1TdG10T3Blbih0aGlzKTtcbiAgICAgIGxldCBuZHgsIGFyZztcbiAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICBjYXNlIDE6IG5keCA9IDE7IGFyZyA9IGFyZ3VtZW50c1swXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiBuZHggPSBhcmd1bWVudHNbMF07IGFyZyA9IGFyZ3VtZW50c1sxXTsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogdG9zczMoXCJJbnZhbGlkIGJpbmQoKSBhcmd1bWVudHMuXCIpO1xuICAgICAgfVxuICAgICAgaWYodW5kZWZpbmVkPT09YXJnKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfWVsc2UgaWYoIXRoaXMucGFyYW1ldGVyQ291bnQpe1xuICAgICAgICB0b3NzMyhcIlRoaXMgc3RhdGVtZW50IGhhcyBubyBiaW5kYWJsZSBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgaWYobnVsbD09PWFyZyl7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYmluZE9uZSh0aGlzLCBuZHgsIEJpbmRUeXBlcy5udWxsLCBhcmcpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KGFyZykpe1xuICAgICAgICBcbiAgICAgICAgaWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgIHRvc3MzKFwiV2hlbiBiaW5kaW5nIGFuIGFycmF5LCBhbiBpbmRleCBhcmd1bWVudCBpcyBub3QgcGVybWl0dGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhcmcuZm9yRWFjaCgodixpKT0+YmluZE9uZSh0aGlzLCBpKzEsIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKHYpLCB2KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfWVsc2UgaWYoYXJnIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICBhcmcgPSBuZXcgVWludDhBcnJheShhcmcpO1xuICAgICAgfVxuICAgICAgaWYoJ29iamVjdCc9PT10eXBlb2YgYXJnXG4gICAgICAgICAgICAgICYmICF1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KGFyZykpe1xuICAgICAgICBcbiAgICAgICAgaWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgIHRvc3MzKFwiV2hlbiBiaW5kaW5nIGFuIG9iamVjdCwgYW4gaW5kZXggYXJndW1lbnQgaXMgbm90IHBlcm1pdHRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoYXJnKVxuICAgICAgICAgIC5mb3JFYWNoKGs9PmJpbmRPbmUodGhpcywgayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKGFyZ1trXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdba10pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmcpLCBhcmcpO1xuICAgICAgfVxuICAgICAgdG9zczMoXCJTaG91bGQgbm90IHJlYWNoIHRoaXMgcG9pbnQuXCIpO1xuICAgIH0sXG4gICAgXG4gICAgYmluZEFzQmxvYjogZnVuY3Rpb24obmR4LGFyZyl7XG4gICAgICBhZmZpcm1TdG10T3Blbih0aGlzKTtcbiAgICAgIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgYXJnID0gbmR4O1xuICAgICAgICBuZHggPSAxO1xuICAgICAgfVxuICAgICAgY29uc3QgdCA9IGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKGFyZyk7XG4gICAgICBpZihCaW5kVHlwZXMuc3RyaW5nICE9PSB0ICYmIEJpbmRUeXBlcy5ibG9iICE9PSB0XG4gICAgICAgICAmJiBCaW5kVHlwZXMubnVsbCAhPT0gdCl7XG4gICAgICAgIHRvc3MzKFwiSW52YWxpZCB2YWx1ZSB0eXBlIGZvciBiaW5kQXNCbG9iKClcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluZE9uZSh0aGlzLCBuZHgsIEJpbmRUeXBlcy5ibG9iLCBhcmcpO1xuICAgIH0sXG4gICAgXG4gICAgc3RlcDogZnVuY3Rpb24oKXtcbiAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyh0aGlzLCAnc3RlcCgpJyk7XG4gICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19zdGVwKGFmZmlybVN0bXRPcGVuKHRoaXMpLnBvaW50ZXIpO1xuICAgICAgc3dpdGNoKHJjKXtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RPTkU6IHJldHVybiB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX1JPVzogcmV0dXJuIHRoaXMuX21heUdldCA9IHRydWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgICAgc3FsaXRlMy5jb25maWcud2FybihcInNxbGl0ZTNfc3RlcCgpIHJjPVwiLHJjLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFwiU1FMID1cIiwgY2FwaS5zcWxpdGUzX3NxbCh0aGlzLnBvaW50ZXIpKTtcbiAgICAgICAgICAgIERCLmNoZWNrUmModGhpcy5kYi5wb2ludGVyLCByYyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzdGVwUmVzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnN0ZXAoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0KCk7XG4gICAgfSxcbiAgICBcbiAgICBzdGVwRmluYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IHJjID0gdGhpcy5zdGVwKCk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIHRyeXt0aGlzLmZpbmFsaXplKCl9XG4gICAgICAgIGNhdGNoKGUpe31cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGdldDogZnVuY3Rpb24obmR4LGFzVHlwZSl7XG4gICAgICBpZighYWZmaXJtU3RtdE9wZW4odGhpcykuX21heUdldCl7XG4gICAgICAgIHRvc3MzKFwiU3RtdC5zdGVwKCkgaGFzIG5vdCAocmVjZW50bHkpIHJldHVybmVkIHRydWUuXCIpO1xuICAgICAgfVxuICAgICAgaWYoQXJyYXkuaXNBcnJheShuZHgpKXtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5jb2x1bW5Db3VudDtcbiAgICAgICAgd2hpbGUoaTxuKXtcbiAgICAgICAgICBuZHhbaV0gPSB0aGlzLmdldChpKyspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZHg7XG4gICAgICB9ZWxzZSBpZihuZHggJiYgJ29iamVjdCc9PT10eXBlb2YgbmR4KXtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5jb2x1bW5Db3VudDtcbiAgICAgICAgd2hpbGUoaTxuKXtcbiAgICAgICAgICBuZHhbY2FwaS5zcWxpdGUzX2NvbHVtbl9uYW1lKHRoaXMucG9pbnRlcixpKV0gPSB0aGlzLmdldChpKyspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZHg7XG4gICAgICB9XG4gICAgICBhZmZpcm1Db2xJbmRleCh0aGlzLCBuZHgpO1xuICAgICAgc3dpdGNoKHVuZGVmaW5lZD09PWFzVHlwZVxuICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2NvbHVtbl90eXBlKHRoaXMucG9pbnRlciwgbmR4KVxuICAgICAgICAgICAgIDogYXNUeXBlKXtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX05VTEw6IHJldHVybiBudWxsO1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfSU5URUdFUjp7XG4gICAgICAgICAgICBpZih3YXNtLmJpZ0ludEVuYWJsZWQpe1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19jb2x1bW5faW50NjQodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBpZihyYz49TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgJiYgcmM8PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHJjKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9kb3VibGUodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgICAgICBpZihyYz5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCByYzxOdW1iZXIuTUlOX1NBRkVfSU5URUdFUil7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9zczMoXCJJbnRlZ2VyIGlzIG91dCBvZiByYW5nZSBmb3IgSlMgaW50ZWdlciByYW5nZTogXCIrcmMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gdXRpbC5pc0ludDMyKHJjKSA/IChyYyB8IDApIDogcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl9kb3VibGUodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfVEVYVDpcbiAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX3RleHQodGhpcy5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQkxPQjoge1xuICAgICAgICAgICAgY29uc3QgbiA9IGNhcGkuc3FsaXRlM19jb2x1bW5fYnl0ZXModGhpcy5wb2ludGVyLCBuZHgpLFxuICAgICAgICAgICAgICAgICAgcHRyID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9ibG9iKHRoaXMucG9pbnRlciwgbmR4KSxcbiAgICAgICAgICAgICAgICAgIHJjID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKG4pIHJjLnNldCh3YXNtLmhlYXA4dSgpLnNsaWNlKHB0ciwgcHRyK24pLCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYobiAmJiB0aGlzLmRiLl9ibG9iWGZlciBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHRoaXMuZGIuX2Jsb2JYZmVyLnB1c2gocmMuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDogdG9zczMoXCJEb24ndCBrbm93IGhvdyB0byB0cmFuc2xhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGUgb2YgcmVzdWx0IGNvbHVtbiAjXCIrbmR4K1wiLlwiKTtcbiAgICAgIH1cbiAgICAgIHRvc3MzKFwiTm90IHJlYWNoZWQuXCIpO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0SW50OiBmdW5jdGlvbihuZHgpe3JldHVybiB0aGlzLmdldChuZHgsY2FwaS5TUUxJVEVfSU5URUdFUil9LFxuICAgIFxuICAgIGdldEZsb2F0OiBmdW5jdGlvbihuZHgpe3JldHVybiB0aGlzLmdldChuZHgsY2FwaS5TUUxJVEVfRkxPQVQpfSxcbiAgICBcbiAgICBnZXRTdHJpbmc6IGZ1bmN0aW9uKG5keCl7cmV0dXJuIHRoaXMuZ2V0KG5keCxjYXBpLlNRTElURV9URVhUKX0sXG4gICAgXG4gICAgZ2V0QmxvYjogZnVuY3Rpb24obmR4KXtyZXR1cm4gdGhpcy5nZXQobmR4LGNhcGkuU1FMSVRFX0JMT0IpfSxcbiAgICBcbiAgICBnZXRKU09OOiBmdW5jdGlvbihuZHgpe1xuICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0KG5keCwgY2FwaS5TUUxJVEVfU1RSSU5HKTtcbiAgICAgIHJldHVybiBudWxsPT09cyA/IHMgOiBKU09OLnBhcnNlKHMpO1xuICAgIH0sXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgZ2V0Q29sdW1uTmFtZTogZnVuY3Rpb24obmR4KXtcbiAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUoXG4gICAgICAgIGFmZmlybUNvbEluZGV4KGFmZmlybVN0bXRPcGVuKHRoaXMpLG5keCkucG9pbnRlciwgbmR4XG4gICAgICApO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0Q29sdW1uTmFtZXM6IGZ1bmN0aW9uKHRndD1bXSl7XG4gICAgICBhZmZpcm1Db2xJbmRleChhZmZpcm1TdG10T3Blbih0aGlzKSwwKTtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG47ICsraSl7XG4gICAgICAgIHRndC5wdXNoKGNhcGkuc3FsaXRlM19jb2x1bW5fbmFtZSh0aGlzLnBvaW50ZXIsIGkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0Z3Q7XG4gICAgfSxcbiAgICBcbiAgICBnZXRQYXJhbUluZGV4OiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHJldHVybiAoYWZmaXJtU3RtdE9wZW4odGhpcykucGFyYW1ldGVyQ291bnRcbiAgICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgodGhpcy5wb2ludGVyLCBuYW1lKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBjb25zdCBwcm9wID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKXtyZXR1cm4gX19wdHJNYXAuZ2V0KHRoaXMpfSxcbiAgICAgIHNldDogKCk9PnRvc3MzKFwiVGhlIHBvaW50ZXIgcHJvcGVydHkgaXMgcmVhZC1vbmx5LlwiKVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RtdC5wcm90b3R5cGUsICdwb2ludGVyJywgcHJvcCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERCLnByb3RvdHlwZSwgJ3BvaW50ZXInLCBwcm9wKTtcbiAgfVxuICBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0bXQucHJvdG90eXBlLCAnY29sdW1uQ291bnQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbigpe3JldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX2NvdW50KHRoaXMucG9pbnRlcil9LFxuICAgIHNldDogKCk9PnRvc3MzKFwiVGhlIGNvbHVtbkNvdW50IHByb3BlcnR5IGlzIHJlYWQtb25seS5cIilcbiAgfSk7XG5cbiAgXG4gIHNxbGl0ZTMub28xID0ge1xuICAgIERCLFxuICAgIFN0bXRcbiAgfTtcblxuICBpZih1dGlsLmlzVUlUaHJlYWQoKSl7XG4gICAgXG4gICAgc3FsaXRlMy5vbzEuSnNTdG9yYWdlRGIgPSBmdW5jdGlvbihzdG9yYWdlTmFtZT0nc2Vzc2lvbicpe1xuICAgICAgaWYoJ3Nlc3Npb24nIT09c3RvcmFnZU5hbWUgJiYgJ2xvY2FsJyE9PXN0b3JhZ2VOYW1lKXtcbiAgICAgICAgdG9zczMoXCJKc1N0b3JhZ2VEYiBkYiBuYW1lIG11c3QgYmUgb25lIG9mICdzZXNzaW9uJyBvciAnbG9jYWwnLlwiKTtcbiAgICAgIH1cbiAgICAgIGRiQ3RvckhlbHBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgZmlsZW5hbWU6IHN0b3JhZ2VOYW1lLFxuICAgICAgICBmbGFnczogJ2MnLFxuICAgICAgICB2ZnM6IFwia3Z2ZnNcIlxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBqZGIgPSBzcWxpdGUzLm9vMS5Kc1N0b3JhZ2VEYjtcbiAgICBqZGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEQi5wcm90b3R5cGUpO1xuICAgIFxuICAgIGpkYi5jbGVhclN0b3JhZ2UgPSBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfY2xlYXI7XG4gICAgXG4gICAgamRiLnByb3RvdHlwZS5jbGVhclN0b3JhZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGpkYi5jbGVhclN0b3JhZ2UoYWZmaXJtRGJPcGVuKHRoaXMpLmZpbGVuYW1lKTtcbiAgICB9O1xuICAgIFxuICAgIGpkYi5zdG9yYWdlU2l6ZSA9IGNhcGkuc3FsaXRlM19qc19rdnZmc19zaXplO1xuICAgIFxuICAgIGpkYi5wcm90b3R5cGUuc3RvcmFnZVNpemUgPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGpkYi5zdG9yYWdlU2l6ZShhZmZpcm1EYk9wZW4odGhpcykuZmlsZW5hbWUpO1xuICAgIH07XG4gIH1cblxufSk7XG5cblxuXG5cblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uKHNxbGl0ZTMpe1xuc3FsaXRlMy5pbml0V29ya2VyMUFQSSA9IGZ1bmN0aW9uKCl7XG4gICd1c2Ugc3RyaWN0JztcbiAgY29uc3QgdG9zcyA9ICguLi5hcmdzKT0+e3Rocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSl9O1xuICBpZighKGdsb2JhbFRoaXMuV29ya2VyR2xvYmFsU2NvcGUgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgIHRvc3MoXCJpbml0V29ya2VyMUFQSSgpIG11c3QgYmUgcnVuIGZyb20gYSBXb3JrZXIgdGhyZWFkLlwiKTtcbiAgfVxuICBjb25zdCBzcWxpdGUzID0gdGhpcy5zcWxpdGUzIHx8IHRvc3MoXCJNaXNzaW5nIHRoaXMuc3FsaXRlMyBvYmplY3QuXCIpO1xuICBjb25zdCBEQiA9IHNxbGl0ZTMub28xLkRCO1xuXG4gIFxuICBjb25zdCBnZXREYklkID0gZnVuY3Rpb24oZGIpe1xuICAgIGxldCBpZCA9IHdTdGF0ZS5pZE1hcC5nZXQoZGIpO1xuICAgIGlmKGlkKSByZXR1cm4gaWQ7XG4gICAgaWQgPSAnZGIjJysoKyt3U3RhdGUuaWRTZXEpKydAJytkYi5wb2ludGVyO1xuICAgIFxuICAgIHdTdGF0ZS5pZE1hcC5zZXQoZGIsIGlkKTtcbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgXG4gIGNvbnN0IHdTdGF0ZSA9IHtcbiAgICBcbiAgICBkYkxpc3Q6IFtdLFxuICAgIFxuICAgIGlkU2VxOiAwLFxuICAgIFxuICAgIGlkTWFwOiBuZXcgV2Vha01hcCxcbiAgICBcbiAgICB4ZmVyOiBbXSxcbiAgICBvcGVuOiBmdW5jdGlvbihvcHQpe1xuICAgICAgY29uc3QgZGIgPSBuZXcgREIob3B0KTtcbiAgICAgIHRoaXMuZGJzW2dldERiSWQoZGIpXSA9IGRiO1xuICAgICAgaWYodGhpcy5kYkxpc3QuaW5kZXhPZihkYik8MCkgdGhpcy5kYkxpc3QucHVzaChkYik7XG4gICAgICByZXR1cm4gZGI7XG4gICAgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24oZGIsYWxzb1VubGluayl7XG4gICAgICBpZihkYil7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRic1tnZXREYklkKGRiKV07XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZGIuZmlsZW5hbWU7XG4gICAgICAgIGNvbnN0IHBWZnMgPSBzcWxpdGUzLndhc20uc3FsaXRlM193YXNtX2RiX3ZmcyhkYi5wb2ludGVyLCAwKTtcbiAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgY29uc3QgZGROZHggPSB0aGlzLmRiTGlzdC5pbmRleE9mKGRiKTtcbiAgICAgICAgaWYoZGROZHg+PTApIHRoaXMuZGJMaXN0LnNwbGljZShkZE5keCwgMSk7XG4gICAgICAgIGlmKGFsc29VbmxpbmsgJiYgZmlsZW5hbWUgJiYgcFZmcyl7XG4gICAgICAgICAgc3FsaXRlMy53YXNtLnNxbGl0ZTNfd2FzbV92ZnNfdW5saW5rKHBWZnMsIGZpbGVuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgcG9zdDogZnVuY3Rpb24obXNnLHhmZXJMaXN0KXtcbiAgICAgIGlmKHhmZXJMaXN0ICYmIHhmZXJMaXN0Lmxlbmd0aCl7XG4gICAgICAgIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2UoIG1zZywgQXJyYXkuZnJvbSh4ZmVyTGlzdCkgKTtcbiAgICAgICAgeGZlckxpc3QubGVuZ3RoID0gMDtcbiAgICAgIH1lbHNle1xuICAgICAgICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBkYnM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgXG4gICAgZ2V0RGI6IGZ1bmN0aW9uKGlkLHJlcXVpcmU9dHJ1ZSl7XG4gICAgICByZXR1cm4gdGhpcy5kYnNbaWRdXG4gICAgICAgIHx8IChyZXF1aXJlID8gdG9zcyhcIlVua25vd24gKG9yIGNsb3NlZCkgREIgSUQ6XCIsaWQpIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNvbnN0IGFmZmlybURiT3BlbiA9IGZ1bmN0aW9uKGRiID0gd1N0YXRlLmRiTGlzdFswXSl7XG4gICAgcmV0dXJuIChkYiAmJiBkYi5wb2ludGVyKSA/IGRiIDogdG9zcyhcIkRCIGlzIG5vdCBvcGVuZWQuXCIpO1xuICB9O1xuXG4gIFxuICBjb25zdCBnZXRNc2dEYiA9IGZ1bmN0aW9uKG1zZ0RhdGEsYWZmaXJtRXhpc3RzPXRydWUpe1xuICAgIGNvbnN0IGRiID0gd1N0YXRlLmdldERiKG1zZ0RhdGEuZGJJZCxmYWxzZSkgfHwgd1N0YXRlLmRiTGlzdFswXTtcbiAgICByZXR1cm4gYWZmaXJtRXhpc3RzID8gYWZmaXJtRGJPcGVuKGRiKSA6IGRiO1xuICB9O1xuXG4gIGNvbnN0IGdldERlZmF1bHREYklkID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gd1N0YXRlLmRiTGlzdFswXSAmJiBnZXREYklkKHdTdGF0ZS5kYkxpc3RbMF0pO1xuICB9O1xuXG4gIGNvbnN0IGd1ZXNzVmZzID0gZnVuY3Rpb24oZmlsZW5hbWUpe1xuICAgIGNvbnN0IG0gPSAvXmZpbGU6LisodmZzPShcXHcrKSkvLmV4ZWMoZmlsZW5hbWUpO1xuICAgIHJldHVybiBzcWxpdGUzLmNhcGkuc3FsaXRlM192ZnNfZmluZChtID8gbVsyXSA6IDApO1xuICB9O1xuXG4gIGNvbnN0IGlzU3BlY2lhbERiRmlsZW5hbWUgPSAobik9PntcbiAgICByZXR1cm4gXCJcIj09PW4gfHwgJzonPT09blswXTtcbiAgfTtcblxuICBcbiAgY29uc3Qgd01zZ0hhbmRsZXIgPSB7XG4gICAgb3BlbjogZnVuY3Rpb24oZXYpe1xuICAgICAgY29uc3Qgb2FyZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBhcmdzID0gKGV2LmFyZ3MgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICBpZihhcmdzLnNpbXVsYXRlRXJyb3IpeyBcbiAgICAgICAgdG9zcyhcIlRocm93aW5nIGJlY2F1c2Ugb2Ygc2ltdWxhdGVFcnJvciBmbGFnLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJjID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGxldCBieXRlQXJyYXksIHBWZnM7XG4gICAgICBvYXJncy52ZnMgPSBhcmdzLnZmcztcbiAgICAgIGlmKGlzU3BlY2lhbERiRmlsZW5hbWUoYXJncy5maWxlbmFtZSkpe1xuICAgICAgICBvYXJncy5maWxlbmFtZSA9IGFyZ3MuZmlsZW5hbWUgfHwgXCJcIjtcbiAgICAgIH1lbHNle1xuICAgICAgICBvYXJncy5maWxlbmFtZSA9IGFyZ3MuZmlsZW5hbWU7XG4gICAgICAgIGJ5dGVBcnJheSA9IGFyZ3MuYnl0ZUFycmF5O1xuICAgICAgICBpZihieXRlQXJyYXkpIHBWZnMgPSBndWVzc1ZmcyhhcmdzLmZpbGVuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmKHBWZnMpe1xuICAgICAgICBcbiAgICAgICAgbGV0IHBNZW07XG4gICAgICAgIHRyeXtcbiAgICAgICAgICBwTWVtID0gc3FsaXRlMy53YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkoYnl0ZUFycmF5KTtcbiAgICAgICAgICBjb25zdCByYyA9IHNxbGl0ZTMud2FzbS5zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlKFxuICAgICAgICAgICAgcFZmcywgb2FyZ3MuZmlsZW5hbWUsIHBNZW0sIGJ5dGVBcnJheS5ieXRlTGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZihyYykgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhyYyk7XG4gICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICB0aHJvdyBuZXcgc3FsaXRlMy5TUUxpdGUzRXJyb3IoXG4gICAgICAgICAgICBlLm5hbWUrJyBjcmVhdGluZyAnK2FyZ3MuZmlsZW5hbWUrXCI6IFwiK2UubWVzc2FnZSwge1xuICAgICAgICAgICAgICBjYXVzZTogZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1maW5hbGx5e1xuICAgICAgICAgIGlmKHBNZW0pIHNxbGl0ZTMud2FzbS5kZWFsbG9jKHBNZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkYiA9IHdTdGF0ZS5vcGVuKG9hcmdzKTtcbiAgICAgIHJjLmZpbGVuYW1lID0gZGIuZmlsZW5hbWU7XG4gICAgICByYy5wZXJzaXN0ZW50ID0gISFzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19kYl91c2VzX3ZmcyhkYi5wb2ludGVyLCBcIm9wZnNcIik7XG4gICAgICByYy5kYklkID0gZ2V0RGJJZChkYik7XG4gICAgICByYy52ZnMgPSBkYi5kYlZmc05hbWUoKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuXG4gICAgY2xvc2U6IGZ1bmN0aW9uKGV2KXtcbiAgICAgIGNvbnN0IGRiID0gZ2V0TXNnRGIoZXYsZmFsc2UpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGZpbGVuYW1lOiBkYiAmJiBkYi5maWxlbmFtZVxuICAgICAgfTtcbiAgICAgIGlmKGRiKXtcbiAgICAgICAgY29uc3QgZG9VbmxpbmsgPSAoKGV2LmFyZ3MgJiYgJ29iamVjdCc9PT10eXBlb2YgZXYuYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgICA/ICEhZXYuYXJncy51bmxpbmsgOiBmYWxzZSk7XG4gICAgICAgIHdTdGF0ZS5jbG9zZShkYiwgZG9VbmxpbmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG5cbiAgICBleGVjOiBmdW5jdGlvbihldil7XG4gICAgICBjb25zdCByYyA9IChcbiAgICAgICAgJ3N0cmluZyc9PT10eXBlb2YgZXYuYXJnc1xuICAgICAgKSA/IHtzcWw6IGV2LmFyZ3N9IDogKGV2LmFyZ3MgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICBpZignc3RtdCc9PT1yYy5yb3dNb2RlKXtcbiAgICAgICAgdG9zcyhcIkludmFsaWQgcm93TW9kZSBmb3IgJ2V4ZWMnOiBzdG10IG1vZGVcIixcbiAgICAgICAgICAgICBcImRvZXMgbm90IHdvcmsgaW4gdGhlIFdvcmtlciBBUEkuXCIpO1xuICAgICAgfWVsc2UgaWYoIXJjLnNxbCl7XG4gICAgICAgIHRvc3MoXCInZXhlYycgcmVxdWlyZXMgaW5wdXQgU1FMLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRiID0gZ2V0TXNnRGIoZXYpO1xuICAgICAgaWYocmMuY2FsbGJhY2sgfHwgQXJyYXkuaXNBcnJheShyYy5yZXN1bHRSb3dzKSl7XG4gICAgICAgIFxuICAgICAgICBkYi5fYmxvYlhmZXIgPSB3U3RhdGUueGZlcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRoZUNhbGxiYWNrID0gcmMuY2FsbGJhY2s7XG4gICAgICBsZXQgcm93TnVtYmVyID0gMDtcbiAgICAgIGNvbnN0IGhhZENvbE5hbWVzID0gISFyYy5jb2x1bW5OYW1lcztcbiAgICAgIGlmKCdzdHJpbmcnID09PSB0eXBlb2YgdGhlQ2FsbGJhY2spe1xuICAgICAgICBpZighaGFkQ29sTmFtZXMpIHJjLmNvbHVtbk5hbWVzID0gW107XG4gICAgICAgIFxuICAgICAgICByYy5jYWxsYmFjayA9IGZ1bmN0aW9uKHJvdyxzdG10KXtcbiAgICAgICAgICB3U3RhdGUucG9zdCh7XG4gICAgICAgICAgICB0eXBlOiB0aGVDYWxsYmFjayxcbiAgICAgICAgICAgIGNvbHVtbk5hbWVzOiByYy5jb2x1bW5OYW1lcyxcbiAgICAgICAgICAgIHJvd051bWJlcjogKytyb3dOdW1iZXIsXG4gICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgIH0sIHdTdGF0ZS54ZmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hhbmdlQ291bnQgPSAhIXJjLmNvdW50Q2hhbmdlc1xuICAgICAgICAgICAgICA/IGRiLmNoYW5nZXModHJ1ZSwoNjQ9PT1yYy5jb3VudENoYW5nZXMpKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgZGIuZXhlYyhyYyk7XG4gICAgICAgIGlmKHVuZGVmaW5lZCAhPT0gY2hhbmdlQ291bnQpe1xuICAgICAgICAgIHJjLmNoYW5nZUNvdW50ID0gZGIuY2hhbmdlcyh0cnVlLDY0PT09cmMuY291bnRDaGFuZ2VzKSAtIGNoYW5nZUNvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmKHJjLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICAgIHJjLmNhbGxiYWNrID0gdGhlQ2FsbGJhY2s7XG4gICAgICAgICAgXG4gICAgICAgICAgd1N0YXRlLnBvc3Qoe1xuICAgICAgICAgICAgdHlwZTogdGhlQ2FsbGJhY2ssXG4gICAgICAgICAgICBjb2x1bW5OYW1lczogcmMuY29sdW1uTmFtZXMsXG4gICAgICAgICAgICByb3dOdW1iZXI6IG51bGwgLFxuICAgICAgICAgICAgcm93OiB1bmRlZmluZWQgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1maW5hbGx5e1xuICAgICAgICBkZWxldGUgZGIuX2Jsb2JYZmVyO1xuICAgICAgICBpZihyYy5jYWxsYmFjaykgcmMuY2FsbGJhY2sgPSB0aGVDYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuXG4gICAgJ2NvbmZpZy1nZXQnOiBmdW5jdGlvbigpe1xuICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBzcmMgPSBzcWxpdGUzLmNvbmZpZztcbiAgICAgIFtcbiAgICAgICAgJ2JpZ0ludEVuYWJsZWQnXG4gICAgICBdLmZvckVhY2goZnVuY3Rpb24oayl7XG4gICAgICAgIGlmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBrKSkgcmNba10gPSBzcmNba107XG4gICAgICB9KTtcbiAgICAgIHJjLnZlcnNpb24gPSBzcWxpdGUzLnZlcnNpb247XG4gICAgICByYy52ZnNMaXN0ID0gc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfdmZzX2xpc3QoKTtcbiAgICAgIHJjLm9wZnNFbmFibGVkID0gISFzcWxpdGUzLm9wZnM7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcblxuICAgIFxuICAgIGV4cG9ydDogZnVuY3Rpb24oZXYpe1xuICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldik7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgYnl0ZUFycmF5OiBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19kYl9leHBvcnQoZGIucG9pbnRlciksXG4gICAgICAgIGZpbGVuYW1lOiBkYi5maWxlbmFtZSxcbiAgICAgICAgbWltZXR5cGU6ICdhcHBsaWNhdGlvbi94LXNxbGl0ZTMnXG4gICAgICB9O1xuICAgICAgd1N0YXRlLnhmZXIucHVzaChyZXNwb25zZS5ieXRlQXJyYXkuYnVmZmVyKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuXG4gICAgdG9zczogZnVuY3Rpb24oZXYpe1xuICAgICAgdG9zcyhcIlRlc3Rpbmcgd29ya2VyIGV4Y2VwdGlvblwiKTtcbiAgICB9LFxuXG4gICAgJ29wZnMtdHJlZSc6IGFzeW5jIGZ1bmN0aW9uKGV2KXtcbiAgICAgIGlmKCFzcWxpdGUzLm9wZnMpIHRvc3MoXCJPUEZTIHN1cHBvcnQgaXMgdW5hdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzcWxpdGUzLm9wZnMudHJlZUxpc3QoKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gIH07XG5cbiAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihldil7XG4gICAgZXYgPSBldi5kYXRhO1xuICAgIGxldCByZXN1bHQsIGRiSWQgPSBldi5kYklkLCBldlR5cGUgPSBldi50eXBlO1xuICAgIGNvbnN0IGFycml2YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKHdNc2dIYW5kbGVyLmhhc093blByb3BlcnR5KGV2VHlwZSkgJiZcbiAgICAgICAgIHdNc2dIYW5kbGVyW2V2VHlwZV0gaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHdNc2dIYW5kbGVyW2V2VHlwZV0oZXYpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRvc3MoXCJVbmtub3duIGRiIHdvcmtlciBtZXNzYWdlIHR5cGU6XCIsZXYudHlwZSk7XG4gICAgICB9XG4gICAgfWNhdGNoKGVycil7XG4gICAgICBldlR5cGUgPSAnZXJyb3InO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvcGVyYXRpb246IGV2LnR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGVyci5tZXNzYWdlLFxuICAgICAgICBlcnJvckNsYXNzOiBlcnIubmFtZSxcbiAgICAgICAgaW5wdXQ6IGV2XG4gICAgICB9O1xuICAgICAgaWYoZXJyLnN0YWNrKXtcbiAgICAgICAgcmVzdWx0LnN0YWNrID0gKCdzdHJpbmcnPT09dHlwZW9mIGVyci5zdGFjaylcbiAgICAgICAgICA/IGVyci5zdGFjay5zcGxpdCgvXFxuXFxzKi8pIDogZXJyLnN0YWNrO1xuICAgICAgfVxuICAgICAgaWYoMCkgc3FsaXRlMy5jb25maWcud2FybihcIldvcmtlciBpcyBwcm9wYWdhdGluZyBhbiBleGNlcHRpb24gdG8gbWFpbiB0aHJlYWQuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVwb3J0aW5nIGl0IF9oZXJlXyBmb3IgdGhlIHN0YWNrIHRyYWNlOlwiLGVycixyZXN1bHQpO1xuICAgIH1cbiAgICBpZighZGJJZCl7XG4gICAgICBkYklkID0gcmVzdWx0LmRiSWRcbiAgICAgICAgfHwgZ2V0RGVmYXVsdERiSWQoKTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgd1N0YXRlLnBvc3Qoe1xuICAgICAgdHlwZTogZXZUeXBlLFxuICAgICAgZGJJZDogZGJJZCxcbiAgICAgIG1lc3NhZ2VJZDogZXYubWVzc2FnZUlkLFxuICAgICAgd29ya2VyUmVjZWl2ZWRUaW1lOiBhcnJpdmFsVGltZSxcbiAgICAgIHdvcmtlclJlc3BvbmRUaW1lOiBwZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgIGRlcGFydHVyZVRpbWU6IGV2LmRlcGFydHVyZVRpbWUsXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICByZXN1bHQ6IHJlc3VsdFxuICAgIH0sIHdTdGF0ZS54ZmVyKTtcbiAgfTtcbiAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSh7dHlwZTonc3FsaXRlMy1hcGknLHJlc3VsdDond29ya2VyMS1yZWFkeSd9KTtcbn0uYmluZCh7c3FsaXRlM30pO1xufSk7XG5cblxuXG5cblxuJ3VzZSBzdHJpY3QnO1xuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uKHNxbGl0ZTMpe1xuICBjb25zdCB3YXNtID0gc3FsaXRlMy53YXNtLCBjYXBpID0gc3FsaXRlMy5jYXBpLCB0b3NzID0gc3FsaXRlMy51dGlsLnRvc3MzO1xuICBjb25zdCB2ZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpLCB2dGFiID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBjb25zdCBTdHJ1Y3RCaW5kZXIgPSBzcWxpdGUzLlN0cnVjdEJpbmRlclxuICA7XG4gIHNxbGl0ZTMudmZzID0gdmZzO1xuICBzcWxpdGUzLnZ0YWIgPSB2dGFiO1xuXG4gIGNvbnN0IHNpaSA9IGNhcGkuc3FsaXRlM19pbmRleF9pbmZvO1xuICBcbiAgc2lpLnByb3RvdHlwZS5udGhDb25zdHJhaW50ID0gZnVuY3Rpb24obiwgYXNQdHI9ZmFsc2Upe1xuICAgIGlmKG48MCB8fCBuPj10aGlzLiRuQ29uc3RyYWludCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHB0ciA9IHRoaXMuJGFDb25zdHJhaW50ICsgKFxuICAgICAgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludC5zdHJ1Y3RJbmZvLnNpemVvZiAqIG5cbiAgICApO1xuICAgIHJldHVybiBhc1B0ciA/IHB0ciA6IG5ldyBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50KHB0cik7XG4gIH07XG5cbiAgXG4gIHNpaS5wcm90b3R5cGUubnRoQ29uc3RyYWludFVzYWdlID0gZnVuY3Rpb24obiwgYXNQdHI9ZmFsc2Upe1xuICAgIGlmKG48MCB8fCBuPj10aGlzLiRuQ29uc3RyYWludCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHB0ciA9IHRoaXMuJGFDb25zdHJhaW50VXNhZ2UgKyAoXG4gICAgICBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlLnN0cnVjdEluZm8uc2l6ZW9mICogblxuICAgICk7XG4gICAgcmV0dXJuIGFzUHRyID8gcHRyIDogbmV3IHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2UocHRyKTtcbiAgfTtcblxuICBcbiAgc2lpLnByb3RvdHlwZS5udGhPcmRlckJ5ID0gZnVuY3Rpb24obiwgYXNQdHI9ZmFsc2Upe1xuICAgIGlmKG48MCB8fCBuPj10aGlzLiRuT3JkZXJCeSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHB0ciA9IHRoaXMuJGFPcmRlckJ5ICsgKFxuICAgICAgc2lpLnNxbGl0ZTNfaW5kZXhfb3JkZXJieS5zdHJ1Y3RJbmZvLnNpemVvZiAqIG5cbiAgICApO1xuICAgIHJldHVybiBhc1B0ciA/IHB0ciA6IG5ldyBzaWkuc3FsaXRlM19pbmRleF9vcmRlcmJ5KHB0cik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgdGd0LCBuYW1lLCBmdW5jLCBhcHBseUFyZ2NDaGVjayA9IGNhbGxlZS5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrXG4gICl7XG4gICAgaWYoISh0Z3QgaW5zdGFuY2VvZiBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZSkpe1xuICAgICAgdG9zcyhcIlVzYWdlIGVycm9yOiB0YXJnZXQgb2JqZWN0IGlzLW5vdC1hIFN0cnVjdFR5cGUuXCIpO1xuICAgIH1lbHNlIGlmKCEoZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJiAhd2FzbS5pc1B0cihmdW5jKSl7XG4gICAgICB0b3NzKFwiVXNhZ2UgZXJycm9yOiBleHBlY3RpbmcgYSBGdW5jdGlvbiBvciBXQVNNIHBvaW50ZXIgdG8gb25lLlwiKTtcbiAgICB9XG4gICAgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgcmV0dXJuIChuLGYpPT5jYWxsZWUodGd0LCBuLCBmLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgfVxuICAgIGlmKCFjYWxsZWUuYXJnY1Byb3h5KXtcbiAgICAgIGNhbGxlZS5hcmdjUHJveHkgPSBmdW5jdGlvbih0Z3QsIGZ1bmNOYW1lLCBmdW5jLHNpZyl7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgICBpZihmdW5jLmxlbmd0aCE9PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgdG9zcyhcIkFyZ3VtZW50IG1pc21hdGNoIGZvclwiLFxuICAgICAgICAgICAgICAgICB0Z3Quc3RydWN0SW5mby5uYW1lK1wiOjpcIitmdW5jTmFtZVxuICAgICAgICAgICAgICAgICArXCI6IE5hdGl2ZSBzaWduYXR1cmUgaXM6XCIsc2lnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNhbGxlZS5yZW1vdmVGdW5jTGlzdCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3Qpe1xuICAgICAgICAgIHRoaXMub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QuZm9yRWFjaChcbiAgICAgICAgICAgICh2LG5keCk9PntcbiAgICAgICAgICAgICAgaWYoJ251bWJlcic9PT10eXBlb2Ygdil7XG4gICAgICAgICAgICAgICAgdHJ5e3dhc20udW5pbnN0YWxsRnVuY3Rpb24odil9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3Q7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNpZ04gPSB0Z3QubWVtYmVyU2lnbmF0dXJlKG5hbWUpO1xuICAgIGlmKHNpZ04ubGVuZ3RoPDIpe1xuICAgICAgdG9zcyhcIk1lbWJlclwiLG5hbWUsXCJkb2VzIG5vdCBoYXZlIGEgZnVuY3Rpb24gcG9pbnRlciBzaWduYXR1cmU6XCIsc2lnTik7XG4gICAgfVxuICAgIGNvbnN0IG1lbUtleSA9IHRndC5tZW1iZXJLZXkobmFtZSk7XG4gICAgY29uc3QgZlByb3h5ID0gKGFwcGx5QXJnY0NoZWNrICYmICF3YXNtLmlzUHRyKGZ1bmMpKVxuICAgIFxuICAgICAgICAgID8gY2FsbGVlLmFyZ2NQcm94eSh0Z3QsIG1lbUtleSwgZnVuYywgc2lnTilcbiAgICAgICAgICA6IGZ1bmM7XG4gICAgaWYod2FzbS5pc1B0cihmUHJveHkpKXtcbiAgICAgIGlmKGZQcm94eSAmJiAhd2FzbS5mdW5jdGlvbkVudHJ5KGZQcm94eSkpe1xuICAgICAgICB0b3NzKFwiUG9pbnRlclwiLGZQcm94eSxcImlzIG5vdCBhIFdBU00gZnVuY3Rpb24gdGFibGUgZW50cnkuXCIpO1xuICAgICAgfVxuICAgICAgdGd0W21lbUtleV0gPSBmUHJveHk7XG4gICAgfWVsc2V7XG4gICAgICBjb25zdCBwRnVuYyA9IHdhc20uaW5zdGFsbEZ1bmN0aW9uKGZQcm94eSwgdGd0Lm1lbWJlclNpZ25hdHVyZShuYW1lLCB0cnVlKSk7XG4gICAgICB0Z3RbbWVtS2V5XSA9IHBGdW5jO1xuICAgICAgaWYoIXRndC5vbmRpc3Bvc2UgfHwgIXRndC5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCl7XG4gICAgICAgIHRndC5hZGRPbkRpc3Bvc2UoJ29uZGlzcG9zZS5fX3JlbW92ZUZ1bmNMaXN0IGhhbmRsZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZS5yZW1vdmVGdW5jTGlzdCk7XG4gICAgICAgIHRndC5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgdGd0Lm9uZGlzcG9zZS5fX3JlbW92ZUZ1bmNMaXN0LnB1c2gobWVtS2V5LCBwRnVuYyk7XG4gICAgfVxuICAgIHJldHVybiAobixmKT0+Y2FsbGVlKHRndCwgbiwgZiwgYXBwbHlBcmdjQ2hlY2spO1xuICB9O1xuICBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2sgPSBmYWxzZTtcblxuICBcbiAgY29uc3QgaW5zdGFsbE1ldGhvZHMgPSBmdW5jdGlvbihcbiAgICBzdHJ1Y3RJbnN0YW5jZSwgbWV0aG9kcywgYXBwbHlBcmdjQ2hlY2sgPSBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2tcbiAgKXtcbiAgICBjb25zdCBzZWVuID0gbmV3IE1hcCA7XG4gICAgZm9yKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMobWV0aG9kcykpe1xuICAgICAgY29uc3QgbSA9IG1ldGhvZHNba107XG4gICAgICBjb25zdCBwcmlvciA9IHNlZW4uZ2V0KG0pO1xuICAgICAgaWYocHJpb3Ipe1xuICAgICAgICBjb25zdCBta2V5ID0gc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KGspO1xuICAgICAgICBzdHJ1Y3RJbnN0YW5jZVtta2V5XSA9IHN0cnVjdEluc3RhbmNlW3N0cnVjdEluc3RhbmNlLm1lbWJlcktleShwcmlvcildO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGluc3RhbGxNZXRob2Qoc3RydWN0SW5zdGFuY2UsIGssIG0sIGFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgc2Vlbi5zZXQobSwgayk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3RJbnN0YW5jZTtcbiAgfTtcblxuICBcbiAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiBjYWxsZWUoXG4gICAgbmFtZSwgZnVuYywgYXBwbHlBcmdjQ2hlY2sgPSBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2tcbiAgKXtcbiAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIG5hbWUgJiYgJ29iamVjdCc9PT10eXBlb2YgbmFtZSlcbiAgICAgID8gaW5zdGFsbE1ldGhvZHModGhpcywgLi4uYXJndW1lbnRzKVxuICAgICAgOiBpbnN0YWxsTWV0aG9kKHRoaXMsIC4uLmFyZ3VtZW50cyk7XG4gIH07XG5cbiAgXG4gIFN0cnVjdEJpbmRlci5TdHJ1Y3RUeXBlLnByb3RvdHlwZS5pbnN0YWxsTWV0aG9kcyA9IGZ1bmN0aW9uKFxuICAgIG1ldGhvZHMsIGFwcGx5QXJnY0NoZWNrID0gaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrXG4gICl7XG4gICAgcmV0dXJuIGluc3RhbGxNZXRob2RzKHRoaXMsIG1ldGhvZHMsIGFwcGx5QXJnY0NoZWNrKTtcbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3Zmcy5wcm90b3R5cGUucmVnaXN0ZXJWZnMgPSBmdW5jdGlvbihhc0RlZmF1bHQ9ZmFsc2Upe1xuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX3Zmcykpe1xuICAgICAgdG9zcyhcIkV4cGVjdGluZyBhIHNxbGl0ZTNfdmZzLXR5cGUgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM192ZnNfcmVnaXN0ZXIodGhpcywgYXNEZWZhdWx0ID8gMSA6IDApO1xuICAgIGlmKHJjKXtcbiAgICAgIHRvc3MoXCJzcWxpdGUzX3Zmc19yZWdpc3RlcihcIix0aGlzLFwiKSBmYWlsZWQgd2l0aCByY1wiLHJjKTtcbiAgICB9XG4gICAgaWYodGhpcy5wb2ludGVyICE9PSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodGhpcy4kek5hbWUpKXtcbiAgICAgIHRvc3MoXCJCVUc6IHNxbGl0ZTNfdmZzX2ZpbmQodmZzLiR6TmFtZSkgZmFpbGVkIGZvciBqdXN0LWluc3RhbGxlZCBWRlNcIixcbiAgICAgICAgICAgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFxuICB2ZnMuaW5zdGFsbFZmcyA9IGZ1bmN0aW9uKG9wdCl7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBwcm9wTGlzdCA9IFsnaW8nLCd2ZnMnXTtcbiAgICBmb3IoY29uc3Qga2V5IG9mIHByb3BMaXN0KXtcbiAgICAgIGNvbnN0IG8gPSBvcHRba2V5XTtcbiAgICAgIGlmKG8pe1xuICAgICAgICArK2NvdW50O1xuICAgICAgICBpbnN0YWxsTWV0aG9kcyhvLnN0cnVjdCwgby5tZXRob2RzLCAhIW8uYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICBpZigndmZzJz09PWtleSl7XG4gICAgICAgICAgaWYoIW8uc3RydWN0LiR6TmFtZSAmJiAnc3RyaW5nJz09PXR5cGVvZiBvLm5hbWUpe1xuICAgICAgICAgICAgby5zdHJ1Y3QuYWRkT25EaXNwb3NlKFxuICAgICAgICAgICAgICBvLnN0cnVjdC4kek5hbWUgPSB3YXNtLmFsbG9jQ1N0cmluZyhvLm5hbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvLnN0cnVjdC5yZWdpc3RlclZmcyghIW8uYXNEZWZhdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZighY291bnQpIHRvc3MoXCJNaXN1c2U6IGluc3RhbGxWZnMoKSBvcHRpb25zIG9iamVjdCByZXF1aXJlcyBhdCBsZWFzdFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm9uZSBvZjpcIiwgcHJvcExpc3QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX3hXcmFwRmFjdG9yeSA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsU3RydWN0VHlwZSl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHB0cixyZW1vdmVNYXBwaW5nPWZhbHNlKXtcbiAgICAgIGlmKDA9PT1hcmd1bWVudHMubGVuZ3RoKSBwdHIgPSBuZXcgU3RydWN0VHlwZTtcbiAgICAgIGlmKHB0ciBpbnN0YW5jZW9mIFN0cnVjdFR5cGUpe1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXQocHRyLnBvaW50ZXIsIHB0cik7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgICB9ZWxzZSBpZighd2FzbS5pc1B0cihwdHIpKXtcbiAgICAgICAgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhcIkludmFsaWQgYXJndW1lbnQgdG9cIixtZXRob2ROYW1lK1wiKClcIik7XG4gICAgICB9XG4gICAgICBsZXQgcmMgPSB0aGlzLmdldChwdHIpO1xuICAgICAgaWYocmVtb3ZlTWFwcGluZykgdGhpcy5kZWxldGUocHRyKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9LmJpbmQobmV3IE1hcCk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IFN0cnVjdFB0ck1hcHBlciA9IGZ1bmN0aW9uKG5hbWUsIFN0cnVjdFR5cGUpe1xuICAgIGNvbnN0IF9feFdyYXAgPSBfX3hXcmFwRmFjdG9yeShuYW1lLFN0cnVjdFR5cGUpO1xuICAgIFxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgICAgXG4gICAgICBTdHJ1Y3RUeXBlLFxuICAgICAgXG4gICAgICBjcmVhdGU6IChwcE91dCk9PntcbiAgICAgICAgY29uc3QgcmMgPSBfX3hXcmFwKCk7XG4gICAgICAgIHdhc20ucG9rZVB0cihwcE91dCwgcmMucG9pbnRlcik7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGdldDogKHBDT2JqKT0+X194V3JhcChwQ09iaiksXG4gICAgICBcbiAgICAgIHVuZ2V0OiAocENPYmopPT5fX3hXcmFwKHBDT2JqLHRydWUpLFxuICAgICAgXG4gICAgICBkaXNwb3NlOiAocENPYmopPT57XG4gICAgICAgIGNvbnN0IG8gPSBfX3hXcmFwKHBDT2JqLHRydWUpO1xuICAgICAgICBpZihvKSBvLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBcbiAgdnRhYi54VnRhYiA9IFN0cnVjdFB0ck1hcHBlcigneFZ0YWInLCBjYXBpLnNxbGl0ZTNfdnRhYik7XG5cbiAgXG4gIHZ0YWIueEN1cnNvciA9IFN0cnVjdFB0ck1hcHBlcigneEN1cnNvcicsIGNhcGkuc3FsaXRlM192dGFiX2N1cnNvcik7XG5cbiAgXG4gIHZ0YWIueEluZGV4SW5mbyA9IChwSWR4SW5mbyk9Pm5ldyBjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mbyhwSWR4SW5mbyk7XG5cbiAgXG4gIFxuXG4gIFxuICB2dGFiLnhFcnJvciA9IGZ1bmN0aW9uIGYobWV0aG9kTmFtZSwgZXJyLCBkZWZhdWx0UmMpe1xuICAgIGlmKGYuZXJyb3JSZXBvcnRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgIHRyeXtmLmVycm9yUmVwb3J0ZXIoXCJzcWxpdGUzX21vZHVsZTo6XCIrbWV0aG9kTmFtZStcIigpOiBcIitlcnIubWVzc2FnZSk7fVxuICAgICAgY2F0Y2goZSl7fVxuICAgIH1cbiAgICBsZXQgcmM7XG4gICAgaWYoZXJyIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikgcmMgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGg+MikgcmMgPSBkZWZhdWx0UmM7XG4gICAgZWxzZSBpZihlcnIgaW5zdGFuY2VvZiBzcWxpdGUzLlNRTGl0ZTNFcnJvcikgcmMgPSBlcnIucmVzdWx0Q29kZTtcbiAgICByZXR1cm4gcmMgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gIH07XG4gIHZ0YWIueEVycm9yLmVycm9yUmVwb3J0ZXIgPSAxID8gY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpIDogZmFsc2U7XG5cbiAgXG4gIFxuXG4gIFxuICB2dGFiLnhSb3dpZCA9IChwcFJvd2lkNjQsIHZhbHVlKT0+d2FzbS5wb2tlKHBwUm93aWQ2NCwgdmFsdWUsICdpNjQnKTtcblxuICBcbiAgdnRhYi5zZXR1cE1vZHVsZSA9IGZ1bmN0aW9uKG9wdCl7XG4gICAgbGV0IGNyZWF0ZWRNb2QgPSBmYWxzZTtcbiAgICBjb25zdCBtb2QgPSAodGhpcyBpbnN0YW5jZW9mIGNhcGkuc3FsaXRlM19tb2R1bGUpXG4gICAgICAgICAgPyB0aGlzIDogKG9wdC5zdHJ1Y3QgfHwgKGNyZWF0ZWRNb2QgPSBuZXcgY2FwaS5zcWxpdGUzX21vZHVsZSgpKSk7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgbWV0aG9kcyA9IG9wdC5tZXRob2RzIHx8IHRvc3MoXCJNaXNzaW5nICdtZXRob2RzJyBvYmplY3QuXCIpO1xuICAgICAgZm9yKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHhDb25uZWN0OiAneENyZWF0ZScsIHhEaXNjb25uZWN0OiAneERlc3Ryb3knXG4gICAgICB9KSl7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBrID0gZVswXSwgdiA9IGVbMV07XG4gICAgICAgIGlmKHRydWUgPT09IG1ldGhvZHNba10pIG1ldGhvZHNba10gPSBtZXRob2RzW3ZdO1xuICAgICAgICBlbHNlIGlmKHRydWUgPT09IG1ldGhvZHNbdl0pIG1ldGhvZHNbdl0gPSBtZXRob2RzW2tdO1xuICAgICAgfVxuICAgICAgaWYob3B0LmNhdGNoRXhjZXB0aW9ucyl7XG4gICAgICAgIGNvbnN0IGZ3cmFwID0gZnVuY3Rpb24obWV0aG9kTmFtZSwgZnVuYyl7XG4gICAgICAgICAgaWYoWyd4Q29ubmVjdCcsJ3hDcmVhdGUnXS5pbmRleE9mKG1ldGhvZE5hbWUpID49IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBEYiwgcEF1eCwgYXJnYywgYXJndiwgcHBWdGFiLCBwekVycil7XG4gICAgICAgICAgICAgIHRyeXtyZXR1cm4gZnVuYyguLi5hcmd1bWVudHMpIHx8IDB9XG4gICAgICAgICAgICAgIGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIGlmKCEoZSBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IpKXtcbiAgICAgICAgICAgICAgICAgIHdhc20uZGVhbGxvYyh3YXNtLnBlZWtQdHIocHpFcnIpKTtcbiAgICAgICAgICAgICAgICAgIHdhc20ucG9rZVB0cihwekVyciwgd2FzbS5hbGxvY0NTdHJpbmcoZS5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2dGFiLnhFcnJvcihtZXRob2ROYW1lLCBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgICAgICAgdHJ5e3JldHVybiBmdW5jKC4uLmFyZ3MpIHx8IDB9XG4gICAgICAgICAgICAgIGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiB2dGFiLnhFcnJvcihtZXRob2ROYW1lLCBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1uYW1lcyA9IFtcbiAgICAgICAgICAneENyZWF0ZScsICd4Q29ubmVjdCcsICd4QmVzdEluZGV4JywgJ3hEaXNjb25uZWN0JyxcbiAgICAgICAgICAneERlc3Ryb3knLCAneE9wZW4nLCAneENsb3NlJywgJ3hGaWx0ZXInLCAneE5leHQnLFxuICAgICAgICAgICd4RW9mJywgJ3hDb2x1bW4nLCAneFJvd2lkJywgJ3hVcGRhdGUnLFxuICAgICAgICAgICd4QmVnaW4nLCAneFN5bmMnLCAneENvbW1pdCcsICd4Um9sbGJhY2snLFxuICAgICAgICAgICd4RmluZEZ1bmN0aW9uJywgJ3hSZW5hbWUnLCAneFNhdmVwb2ludCcsICd4UmVsZWFzZScsXG4gICAgICAgICAgJ3hSb2xsYmFja1RvJywgJ3hTaGFkb3dOYW1lJ1xuICAgICAgICBdO1xuICAgICAgICBjb25zdCByZW1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IoY29uc3QgayBvZiBtbmFtZXMpe1xuICAgICAgICAgIGNvbnN0IG0gPSBtZXRob2RzW2tdO1xuICAgICAgICAgIGlmKCEobSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgY29udGludWU7XG4gICAgICAgICAgZWxzZSBpZigneENvbm5lY3QnPT09ayAmJiBtZXRob2RzLnhDcmVhdGU9PT1tKXtcbiAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IG1ldGhvZHMueENyZWF0ZTtcbiAgICAgICAgICB9ZWxzZSBpZigneENyZWF0ZSc9PT1rICYmIG1ldGhvZHMueENvbm5lY3Q9PT1tKXtcbiAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IG1ldGhvZHMueENvbm5lY3Q7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZW1ldGhvZHNba10gPSBmd3JhcChrLCBtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFsbE1ldGhvZHMobW9kLCByZW1ldGhvZHMsIGZhbHNlKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGluc3RhbGxNZXRob2RzKFxuICAgICAgICAgIG1vZCwgbWV0aG9kcywgISFvcHQuYXBwbHlBcmdjQ2hlY2tcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmKDA9PT1tb2QuJGlWZXJzaW9uKXtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmKCdudW1iZXInPT09dHlwZW9mIG9wdC5pVmVyc2lvbikgdiA9IG9wdC5pVmVyc2lvbjtcbiAgICAgICAgZWxzZSBpZihtb2QuJHhTaGFkb3dOYW1lKSB2ID0gMztcbiAgICAgICAgZWxzZSBpZihtb2QuJHhTYXZlUG9pbnQgfHwgbW9kLiR4UmVsZWFzZSB8fCBtb2QuJHhSb2xsYmFja1RvKSB2ID0gMjtcbiAgICAgICAgZWxzZSB2ID0gMTtcbiAgICAgICAgbW9kLiRpVmVyc2lvbiA9IHY7XG4gICAgICB9XG4gICAgfWNhdGNoKGUpe1xuICAgICAgaWYoY3JlYXRlZE1vZCkgY3JlYXRlZE1vZC5kaXNwb3NlKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gbW9kO1xuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfbW9kdWxlLnByb3RvdHlwZS5zZXR1cE1vZHVsZSA9IGZ1bmN0aW9uKG9wdCl7XG4gICAgcmV0dXJuIHZ0YWIuc2V0dXBNb2R1bGUuY2FsbCh0aGlzLCBvcHQpO1xuICB9O1xufSk7XG5cblxuXG4ndXNlIHN0cmljdCc7XG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oc3FsaXRlMyl7XG5cbmNvbnN0IGluc3RhbGxPcGZzVmZzID0gZnVuY3Rpb24gY2FsbGVlKG9wdGlvbnMpe1xuICBpZighZ2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlclxuICAgIHx8ICFnbG9iYWxUaGlzLkF0b21pY3Mpe1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgIG5ldyBFcnJvcihcIkNhbm5vdCBpbnN0YWxsIE9QRlM6IE1pc3NpbmcgU2hhcmVkQXJyYXlCdWZmZXIgYW5kL29yIEF0b21pY3MuIFwiK1xuICAgICAgICAgICAgICAgIFwiVGhlIHNlcnZlciBtdXN0IGVtaXQgdGhlIENPT1AvQ09FUCByZXNwb25zZSBoZWFkZXJzIHRvIGVuYWJsZSB0aG9zZS4gXCIrXG4gICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9zcWxpdGUub3JnL3dhc20vZG9jL3RydW5rL3BlcnNpc3RlbmNlLm1kI2Nvb3AtY29lcFwiKVxuICAgICk7XG4gIH1lbHNlIGlmKCd1bmRlZmluZWQnPT09dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlKXtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoXCJUaGUgT1BGUyBzcWxpdGUzX3ZmcyBjYW5ub3QgcnVuIGluIHRoZSBtYWluIHRocmVhZCBcIitcbiAgICAgICAgICAgICAgICBcImJlY2F1c2UgaXQgcmVxdWlyZXMgQXRvbWljcy53YWl0KCkuXCIpXG4gICAgKTtcbiAgfWVsc2UgaWYoIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSB8fFxuICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlIHx8XG4gICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlIHx8XG4gICAgICAgICAgICFuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeSl7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBPUEZTIEFQSXMuXCIpXG4gICAgKTtcbiAgfVxuICBpZighb3B0aW9ucyB8fCAnb2JqZWN0JyE9PXR5cGVvZiBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zO1xuICBpZih1cmxQYXJhbXMuaGFzKCdvcGZzLWRpc2FibGUnKSl7XG4gICAgXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzcWxpdGUzKTtcbiAgfVxuICBpZih1bmRlZmluZWQ9PT1vcHRpb25zLnZlcmJvc2Upe1xuICAgIG9wdGlvbnMudmVyYm9zZSA9IHVybFBhcmFtcy5oYXMoJ29wZnMtdmVyYm9zZScpXG4gICAgICA/ICgrdXJsUGFyYW1zLmdldCgnb3Bmcy12ZXJib3NlJykgfHwgMikgOiAxO1xuICB9XG4gIGlmKHVuZGVmaW5lZD09PW9wdGlvbnMuc2FuaXR5Q2hlY2tzKXtcbiAgICBvcHRpb25zLnNhbml0eUNoZWNrcyA9IHVybFBhcmFtcy5oYXMoJ29wZnMtc2FuaXR5LWNoZWNrJyk7XG4gIH1cbiAgaWYodW5kZWZpbmVkPT09b3B0aW9ucy5wcm94eVVyaSl7XG4gICAgb3B0aW9ucy5wcm94eVVyaSA9IGNhbGxlZS5kZWZhdWx0UHJveHlVcmk7XG4gIH1cblxuICBcblxuICBpZignZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0aW9ucy5wcm94eVVyaSl7XG4gICAgb3B0aW9ucy5wcm94eVVyaSA9IG9wdGlvbnMucHJveHlVcmkoKTtcbiAgfVxuICBjb25zdCB0aGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocHJvbWlzZVJlc29sdmVfLCBwcm9taXNlUmVqZWN0Xyl7XG4gICAgY29uc3QgbG9nZ2VycyA9IFtcbiAgICAgIHNxbGl0ZTMuY29uZmlnLmVycm9yLFxuICAgICAgc3FsaXRlMy5jb25maWcud2FybixcbiAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZ1xuICAgIF07XG4gICAgY29uc3QgbG9nSW1wbCA9IChsZXZlbCwuLi5hcmdzKT0+e1xuICAgICAgaWYob3B0aW9ucy52ZXJib3NlPmxldmVsKSBsb2dnZXJzW2xldmVsXShcIk9QRlMgc3luY2VyOlwiLC4uLmFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgbG9nID0gICAgKC4uLmFyZ3MpPT5sb2dJbXBsKDIsIC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdhcm4gPSAgICguLi5hcmdzKT0+bG9nSW1wbCgxLCAuLi5hcmdzKTtcbiAgICBjb25zdCBlcnJvciA9ICAoLi4uYXJncyk9PmxvZ0ltcGwoMCwgLi4uYXJncyk7XG4gICAgY29uc3QgdG9zcyA9IHNxbGl0ZTMudXRpbC50b3NzO1xuICAgIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGk7XG4gICAgY29uc3QgdXRpbCA9IHNxbGl0ZTMudXRpbDtcbiAgICBjb25zdCB3YXNtID0gc3FsaXRlMy53YXNtO1xuICAgIGNvbnN0IHNxbGl0ZTNfdmZzID0gY2FwaS5zcWxpdGUzX3ZmcztcbiAgICBjb25zdCBzcWxpdGUzX2ZpbGUgPSBjYXBpLnNxbGl0ZTNfZmlsZTtcbiAgICBjb25zdCBzcWxpdGUzX2lvX21ldGhvZHMgPSBjYXBpLnNxbGl0ZTNfaW9fbWV0aG9kcztcbiAgICBcbiAgICBjb25zdCBvcGZzVXRpbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBcbiAgICBjb25zdCB0aGlzVGhyZWFkSGFzT1BGUyA9ICgpPT57XG4gICAgICByZXR1cm4gZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlICYmXG4gICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSAmJlxuICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlICYmXG4gICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUucHJvdG90eXBlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgJiZcbiAgICAgICAgbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3Rvcnk7XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLm1ldHJpY3MgPSB7XG4gICAgICBkdW1wOiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgaywgbiA9IDAsIHQgPSAwLCB3ID0gMDtcbiAgICAgICAgZm9yKGsgaW4gc3RhdGUub3BJZHMpe1xuICAgICAgICAgIGNvbnN0IG0gPSBtZXRyaWNzW2tdO1xuICAgICAgICAgIG4gKz0gbS5jb3VudDtcbiAgICAgICAgICB0ICs9IG0udGltZTtcbiAgICAgICAgICB3ICs9IG0ud2FpdDtcbiAgICAgICAgICBtLmF2Z1RpbWUgPSAobS5jb3VudCAmJiBtLnRpbWUpID8gKG0udGltZSAvIG0uY291bnQpIDogMDtcbiAgICAgICAgICBtLmF2Z1dhaXQgPSAobS5jb3VudCAmJiBtLndhaXQpID8gKG0ud2FpdCAvIG0uY291bnQpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2coZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBcIm1ldHJpY3MgZm9yXCIsZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmLFwiOlwiLG1ldHJpY3MsXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuVG90YWwgb2ZcIixuLFwib3AocykgZm9yXCIsdCxcbiAgICAgICAgICAgICAgICAgICAgXCJtcyAoaW5jbC4gXCIrdytcIiBtcyBvZiB3YWl0aW5nIG9uIHRoZSBhc3luYyBzaWRlKVwiKTtcbiAgICAgICAgc3FsaXRlMy5jb25maWcubG9nKFwiU2VyaWFsaXphdGlvbiBtZXRyaWNzOlwiLG1ldHJpY3MuczExbik7XG4gICAgICAgIFcucG9zdE1lc3NhZ2Uoe3R5cGU6J29wZnMtYXN5bmMtbWV0cmljcyd9KTtcbiAgICAgIH0sXG4gICAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGs7XG4gICAgICAgIGNvbnN0IHIgPSAobSk9PihtLmNvdW50ID0gbS50aW1lID0gbS53YWl0ID0gMCk7XG4gICAgICAgIGZvcihrIGluIHN0YXRlLm9wSWRzKXtcbiAgICAgICAgICByKG1ldHJpY3Nba10gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcyA9IG1ldHJpY3MuczExbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHMgPSBzLnNlcmlhbGl6ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICAgICAgICBzID0gbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcy5jb3VudCA9IHMudGltZSA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvcGZzSW9NZXRob2RzID0gbmV3IHNxbGl0ZTNfaW9fbWV0aG9kcygpO1xuICAgIGNvbnN0IG9wZnNWZnMgPSBuZXcgc3FsaXRlM192ZnMoKVxuICAgICAgICAgIC5hZGRPbkRpc3Bvc2UoICgpPT5vcGZzSW9NZXRob2RzLmRpc3Bvc2UoKSk7XG4gICAgbGV0IHByb21pc2VXYXNSZWplY3RlZCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm9taXNlUmVqZWN0ID0gKGVycik9PntcbiAgICAgIHByb21pc2VXYXNSZWplY3RlZCA9IHRydWU7XG4gICAgICBvcGZzVmZzLmRpc3Bvc2UoKTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0XyhlcnIpO1xuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZVJlc29sdmUgPSAoKT0+e1xuICAgICAgcHJvbWlzZVdhc1JlamVjdGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVfKHNxbGl0ZTMpO1xuICAgIH07XG4gICAgY29uc3QgVyA9XG4gICAgbmV3IFdvcmtlcihvcHRpb25zLnByb3h5VXJpKTtcbiAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICBcbiAgICAgIGlmKHVuZGVmaW5lZD09PXByb21pc2VXYXNSZWplY3RlZCl7XG4gICAgICAgIHByb21pc2VSZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKFwiVGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBPUEZTIGFzeW5jIHByb3h5IHdvcmtlci5cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCA0MDAwKTtcbiAgICBXLl9vcmlnaW5hbE9uRXJyb3IgPSBXLm9uZXJyb3IgO1xuICAgIFcub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gICAgICBcbiAgICAgIFxuICAgICAgZXJyb3IoXCJFcnJvciBpbml0aWFsaXppbmcgT1BGUyBhc3luY2VyOlwiLGVycik7XG4gICAgICBwcm9taXNlUmVqZWN0KG5ldyBFcnJvcihcIkxvYWRpbmcgT1BGUyBhc3luYyBXb3JrZXIgZmFpbGVkIGZvciB1bmtub3duIHJlYXNvbnMuXCIpKTtcbiAgICB9O1xuICAgIGNvbnN0IHBEVmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKG51bGwpO1xuICAgIGNvbnN0IGRWZnMgPSBwRFZmc1xuICAgICAgICAgID8gbmV3IHNxbGl0ZTNfdmZzKHBEVmZzKVxuICAgICAgICAgIDogbnVsbCA7XG4gICAgb3Bmc0lvTWV0aG9kcy4kaVZlcnNpb24gPSAxO1xuICAgIG9wZnNWZnMuJGlWZXJzaW9uID0gMjtcbiAgICBvcGZzVmZzLiRzek9zRmlsZSA9IGNhcGkuc3FsaXRlM19maWxlLnN0cnVjdEluZm8uc2l6ZW9mO1xuICAgIG9wZnNWZnMuJG14UGF0aG5hbWUgPSAxMDI0O1xuICAgIG9wZnNWZnMuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcoXCJvcGZzXCIpO1xuICAgIFxuICAgIG9wZnNWZnMuJHhEbE9wZW4gPSBvcGZzVmZzLiR4RGxFcnJvciA9IG9wZnNWZnMuJHhEbFN5bSA9IG9wZnNWZnMuJHhEbENsb3NlID0gbnVsbDtcbiAgICBvcGZzVmZzLmFkZE9uRGlzcG9zZShcbiAgICAgICckek5hbWUnLCBvcGZzVmZzLiR6TmFtZSxcbiAgICAgICdjbGVhbnVwIGRlZmF1bHQgVkZTIHdyYXBwZXInLCAoKT0+KGRWZnMgPyBkVmZzLmRpc3Bvc2UoKSA6IG51bGwpXG4gICAgKTtcbiAgICBcbiAgICBcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc3RhdGUudmVyYm9zZSA9IG9wdGlvbnMudmVyYm9zZTtcbiAgICBzdGF0ZS5saXR0bGVFbmRpYW4gPSAoKCk9PntcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyKTtcbiAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSApO1xuICAgICAgXG4gICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyKVswXSA9PT0gMjU2O1xuICAgIH0pKCk7XG4gICAgXG4gICAgc3RhdGUuYXN5bmNJZGxlV2FpdFRpbWUgPSAxNTA7XG5cbiAgICBcbiAgICBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zID0gMTtcbiAgICBcbiAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZSA9IDEwMjQgKiA2NDtcbiAgICBzdGF0ZS5zYWJTMTFuT2Zmc2V0ID0gc3RhdGUuZmlsZUJ1ZmZlclNpemU7XG4gICAgXG4gICAgc3RhdGUuc2FiUzExblNpemUgPSBvcGZzVmZzLiRteFBhdGhuYW1lICogMjtcbiAgICBcbiAgICBzdGF0ZS5zYWJJTyA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihcbiAgICAgIHN0YXRlLmZpbGVCdWZmZXJTaXplXG4gICAgICArIHN0YXRlLnNhYlMxMW5TaXplXG4gICAgKTtcbiAgICBzdGF0ZS5vcElkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbWV0cmljcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAge1xuICAgICAgXG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBcbiAgICAgIHN0YXRlLm9wSWRzLndoaWNoT3AgPSBpKys7XG4gICAgICBcbiAgICAgIHN0YXRlLm9wSWRzLnJjID0gaSsrO1xuICAgICAgXG4gICAgICBzdGF0ZS5vcElkcy54QWNjZXNzID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueENsb3NlID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueERlbGV0ZSA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhEZWxldGVOb1dhaXQgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54RmlsZVNpemUgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54TG9jayA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhPcGVuID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueFJlYWQgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54U2xlZXAgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54U3luYyA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhUcnVuY2F0ZSA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhVbmxvY2sgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54V3JpdGUgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy5ta2RpciA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzWydvcGZzLWFzeW5jLW1ldHJpY3MnXSA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzWydvcGZzLWFzeW5jLXNodXRkb3duJ10gPSBpKys7XG4gICAgICBcbiAgICAgIHN0YXRlLm9wSWRzLnJldHJ5ID0gaSsrO1xuICAgICAgc3RhdGUuc2FiT1AgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoXG4gICAgICAgIGkgKiA0KTtcbiAgICAgIG9wZnNVdGlsLm1ldHJpY3MucmVzZXQoKTtcbiAgICB9XG4gICAgXG4gICAgc3RhdGUuc3EzQ29kZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIFtcbiAgICAgICdTUUxJVEVfQUNDRVNTX0VYSVNUUycsXG4gICAgICAnU1FMSVRFX0FDQ0VTU19SRUFEV1JJVEUnLFxuICAgICAgJ1NRTElURV9CVVNZJyxcbiAgICAgICdTUUxJVEVfRVJST1InLFxuICAgICAgJ1NRTElURV9JT0VSUicsXG4gICAgICAnU1FMSVRFX0lPRVJSX0FDQ0VTUycsXG4gICAgICAnU1FMSVRFX0lPRVJSX0NMT1NFJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfREVMRVRFJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfRlNZTkMnLFxuICAgICAgJ1NRTElURV9JT0VSUl9MT0NLJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfUkVBRCcsXG4gICAgICAnU1FMSVRFX0lPRVJSX1NIT1JUX1JFQUQnLFxuICAgICAgJ1NRTElURV9JT0VSUl9UUlVOQ0FURScsXG4gICAgICAnU1FMSVRFX0lPRVJSX1VOTE9DSycsXG4gICAgICAnU1FMSVRFX0lPRVJSX1dSSVRFJyxcbiAgICAgICdTUUxJVEVfTE9DS19FWENMVVNJVkUnLFxuICAgICAgJ1NRTElURV9MT0NLX05PTkUnLFxuICAgICAgJ1NRTElURV9MT0NLX1BFTkRJTkcnLFxuICAgICAgJ1NRTElURV9MT0NLX1JFU0VSVkVEJyxcbiAgICAgICdTUUxJVEVfTE9DS19TSEFSRUQnLFxuICAgICAgJ1NRTElURV9MT0NLRUQnLFxuICAgICAgJ1NRTElURV9NSVNVU0UnLFxuICAgICAgJ1NRTElURV9OT1RGT1VORCcsXG4gICAgICAnU1FMSVRFX09QRU5fQ1JFQVRFJyxcbiAgICAgICdTUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFJyxcbiAgICAgICdTUUxJVEVfT1BFTl9NQUlOX0RCJyxcbiAgICAgICdTUUxJVEVfT1BFTl9SRUFET05MWSdcbiAgICBdLmZvckVhY2goKGspPT57XG4gICAgICBpZih1bmRlZmluZWQgPT09IChzdGF0ZS5zcTNDb2Rlc1trXSA9IGNhcGlba10pKXtcbiAgICAgICAgdG9zcyhcIk1haW50ZW5hbmNlIHJlcXVpcmVkOiBub3QgZm91bmQ6XCIsayk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RhdGUub3Bmc0ZsYWdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICAgIFxuICAgICAgT1BGU19VTkxPQ0tfQVNBUDogMHgwMSxcbiAgICAgIFxuICAgICAgZGVmYXVsdFVubG9ja0FzYXA6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBcbiAgICBjb25zdCBvcFJ1biA9IChvcCwuLi5hcmdzKT0+e1xuICAgICAgY29uc3Qgb3BOZHggPSBzdGF0ZS5vcElkc1tvcF0gfHwgdG9zcyhcIkludmFsaWQgb3AgSUQ6XCIsb3ApO1xuICAgICAgc3RhdGUuczExbi5zZXJpYWxpemUoLi4uYXJncyk7XG4gICAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKTtcbiAgICAgIEF0b21pY3Muc3RvcmUoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy53aGljaE9wLCBvcE5keCk7XG4gICAgICBBdG9taWNzLm5vdGlmeShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3ApXG4gICAgICA7XG4gICAgICBjb25zdCB0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBBdG9taWNzLndhaXQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYywgLTEpXG4gICAgICA7XG4gICAgICBjb25zdCByYyA9IEF0b21pY3MubG9hZChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJjKTtcbiAgICAgIG1ldHJpY3Nbb3BdLndhaXQgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgaWYocmMgJiYgc3RhdGUuYXN5bmNTMTFuRXhjZXB0aW9ucyl7XG4gICAgICAgIGNvbnN0IGVyciA9IHN0YXRlLnMxMW4uZGVzZXJpYWxpemUoKTtcbiAgICAgICAgaWYoZXJyKSBlcnJvcihvcCtcIigpIGFzeW5jIGVycm9yOlwiLC4uLmVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmM7XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLmRlYnVnID0ge1xuICAgICAgYXN5bmNTaHV0ZG93bjogKCk9PntcbiAgICAgICAgd2FybihcIlNodXR0aW5nIGRvd24gT1BGUyBhc3luYyBsaXN0ZW5lci4gVGhlIE9QRlMgVkZTIHdpbGwgbm8gbG9uZ2VyIHdvcmsuXCIpO1xuICAgICAgICBvcFJ1bignb3Bmcy1hc3luYy1zaHV0ZG93bicpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jUmVzdGFydDogKCk9PntcbiAgICAgICAgd2FybihcIkF0dGVtcHRpbmcgdG8gcmVzdGFydCBPUEZTIFZGUyBhc3luYyBsaXN0ZW5lci4gTWlnaHQgd29yaywgbWlnaHQgbm90LlwiKTtcbiAgICAgICAgVy5wb3N0TWVzc2FnZSh7dHlwZTogJ29wZnMtYXN5bmMtcmVzdGFydCd9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaW5pdFMxMW4gPSAoKT0+e1xuICAgICAgXG4gICAgICBpZihzdGF0ZS5zMTFuKSByZXR1cm4gc3RhdGUuczExbjtcbiAgICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCksXG4gICAgICAgICAgICB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKSxcbiAgICAgICAgICAgIHZpZXdVOCA9IG5ldyBVaW50OEFycmF5KHN0YXRlLnNhYklPLCBzdGF0ZS5zYWJTMTFuT2Zmc2V0LCBzdGF0ZS5zYWJTMTFuU2l6ZSksXG4gICAgICAgICAgICB2aWV3RFYgPSBuZXcgRGF0YVZpZXcoc3RhdGUuc2FiSU8sIHN0YXRlLnNhYlMxMW5PZmZzZXQsIHN0YXRlLnNhYlMxMW5TaXplKTtcbiAgICAgIHN0YXRlLnMxMW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgXG4gICAgICBjb25zdCBUeXBlSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIFR5cGVJZHMubnVtYmVyICA9IHsgaWQ6IDEsIHNpemU6IDgsIGdldHRlcjogJ2dldEZsb2F0NjQnLCBzZXR0ZXI6ICdzZXRGbG9hdDY0JyB9O1xuICAgICAgVHlwZUlkcy5iaWdpbnQgID0geyBpZDogMiwgc2l6ZTogOCwgZ2V0dGVyOiAnZ2V0QmlnSW50NjQnLCBzZXR0ZXI6ICdzZXRCaWdJbnQ2NCcgfTtcbiAgICAgIFR5cGVJZHMuYm9vbGVhbiA9IHsgaWQ6IDMsIHNpemU6IDQsIGdldHRlcjogJ2dldEludDMyJywgc2V0dGVyOiAnc2V0SW50MzInIH07XG4gICAgICBUeXBlSWRzLnN0cmluZyA9ICB7IGlkOiA0IH07XG5cbiAgICAgIGNvbnN0IGdldFR5cGVJZCA9ICh2KT0+KFxuICAgICAgICBUeXBlSWRzW3R5cGVvZiB2XVxuICAgICAgICAgIHx8IHRvc3MoXCJNYWludGVuYW5jZSByZXF1aXJlZDogdGhpcyB2YWx1ZSB0eXBlIGNhbm5vdCBiZSBzZXJpYWxpemVkLlwiLHYpXG4gICAgICApO1xuICAgICAgY29uc3QgZ2V0VHlwZUlkQnlJZCA9ICh0aWQpPT57XG4gICAgICAgIHN3aXRjaCh0aWQpe1xuICAgICAgICAgICAgY2FzZSBUeXBlSWRzLm51bWJlci5pZDogcmV0dXJuIFR5cGVJZHMubnVtYmVyO1xuICAgICAgICAgICAgY2FzZSBUeXBlSWRzLmJpZ2ludC5pZDogcmV0dXJuIFR5cGVJZHMuYmlnaW50O1xuICAgICAgICAgICAgY2FzZSBUeXBlSWRzLmJvb2xlYW4uaWQ6IHJldHVybiBUeXBlSWRzLmJvb2xlYW47XG4gICAgICAgICAgICBjYXNlIFR5cGVJZHMuc3RyaW5nLmlkOiByZXR1cm4gVHlwZUlkcy5zdHJpbmc7XG4gICAgICAgICAgICBkZWZhdWx0OiB0b3NzKFwiSW52YWxpZCB0eXBlIElEOlwiLHRpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFxuICAgICAgc3RhdGUuczExbi5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGNsZWFyPWZhbHNlKXtcbiAgICAgICAgKyttZXRyaWNzLnMxMW4uZGVzZXJpYWxpemUuY291bnQ7XG4gICAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgYXJnYyA9IHZpZXdVOFswXTtcbiAgICAgICAgY29uc3QgcmMgPSBhcmdjID8gW10gOiBudWxsO1xuICAgICAgICBpZihhcmdjKXtcbiAgICAgICAgICBjb25zdCB0eXBlSWRzID0gW107XG4gICAgICAgICAgbGV0IG9mZnNldCA9IDEsIGksIG4sIHY7XG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgYXJnYzsgKytpLCArK29mZnNldCl7XG4gICAgICAgICAgICB0eXBlSWRzLnB1c2goZ2V0VHlwZUlkQnlJZCh2aWV3VThbb2Zmc2V0XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBhcmdjOyArK2kpe1xuICAgICAgICAgICAgY29uc3QgdCA9IHR5cGVJZHNbaV07XG4gICAgICAgICAgICBpZih0LmdldHRlcil7XG4gICAgICAgICAgICAgIHYgPSB2aWV3RFZbdC5nZXR0ZXJdKG9mZnNldCwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IHQuc2l6ZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBuID0gdmlld0RWLmdldEludDMyKG9mZnNldCwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIHYgPSB0ZXh0RGVjb2Rlci5kZWNvZGUodmlld1U4LnNsaWNlKG9mZnNldCwgb2Zmc2V0K24pKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYy5wdXNoKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihjbGVhcikgdmlld1U4WzBdID0gMDtcbiAgICAgICAgXG4gICAgICAgIG1ldHJpY3MuczExbi5kZXNlcmlhbGl6ZS50aW1lICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdDtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfTtcblxuICAgICAgXG4gICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKC4uLmFyZ3Mpe1xuICAgICAgICBjb25zdCB0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICsrbWV0cmljcy5zMTFuLnNlcmlhbGl6ZS5jb3VudDtcbiAgICAgICAgaWYoYXJncy5sZW5ndGgpe1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgICBsZXQgaSA9IDAsIG9mZnNldCA9IDE7XG4gICAgICAgICAgdmlld1U4WzBdID0gYXJncy5sZW5ndGggJiAweGZmIDtcbiAgICAgICAgICBmb3IoOyBpIDwgYXJncy5sZW5ndGg7ICsraSwgKytvZmZzZXQpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0eXBlSWRzLnB1c2goZ2V0VHlwZUlkKGFyZ3NbaV0pKTtcbiAgICAgICAgICAgIHZpZXdVOFtvZmZzZXRdID0gdHlwZUlkc1tpXS5pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB0ID0gdHlwZUlkc1tpXTtcbiAgICAgICAgICAgIGlmKHQuc2V0dGVyKXtcbiAgICAgICAgICAgICAgdmlld0RWW3Quc2V0dGVyXShvZmZzZXQsIGFyZ3NbaV0sIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgIG9mZnNldCArPSB0LnNpemU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgY29uc3QgcyA9IHRleHRFbmNvZGVyLmVuY29kZShhcmdzW2ldKTtcbiAgICAgICAgICAgICAgdmlld0RWLnNldEludDMyKG9mZnNldCwgcy5ieXRlTGVuZ3RoLCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgdmlld1U4LnNldChzLCBvZmZzZXQpO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdmlld1U4WzBdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBtZXRyaWNzLnMxMW4uc2VyaWFsaXplLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzdGF0ZS5zMTFuO1xuICAgIH07XG5cbiAgICBcbiAgICBjb25zdCByYW5kb21GaWxlbmFtZSA9IGZ1bmN0aW9uIGYobGVuPTE2KXtcbiAgICAgIGlmKCFmLl9jaGFycyl7XG4gICAgICAgIGYuX2NoYXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiK1xuICAgICAgICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIitcbiAgICAgICAgICBcIjAxMjM0Njc4OVwiO1xuICAgICAgICBmLl9uID0gZi5fY2hhcnMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yKCA7IGkgPCBsZW47ICsraSl7XG4gICAgICAgIGNvbnN0IG5keCA9IE1hdGgucmFuZG9tKCkgKiAoZi5fbiAqIDY0KSAlIGYuX24gfCAwO1xuICAgICAgICBhW2ldID0gZi5fY2hhcnNbbmR4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmpvaW4oXCJcIik7XG4gICAgICBcbiAgICB9O1xuXG4gICAgXG4gICAgY29uc3QgX19vcGVuRmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgY29uc3Qgb3BUaW1lciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgb3BUaW1lci5vcCA9IHVuZGVmaW5lZDtcbiAgICBvcFRpbWVyLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1UaW1lU3RhcnQgPSAob3ApPT57XG4gICAgICBvcFRpbWVyLnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBvcFRpbWVyLm9wID0gb3A7XG4gICAgICArK21ldHJpY3Nbb3BdLmNvdW50O1xuICAgIH07XG4gICAgY29uc3QgbVRpbWVFbmQgPSAoKT0+KFxuICAgICAgbWV0cmljc1tvcFRpbWVyLm9wXS50aW1lICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gb3BUaW1lci5zdGFydFxuICAgICk7XG5cbiAgICBcbiAgICBjb25zdCBpb1N5bmNXcmFwcGVycyA9IHtcbiAgICAgIHhDaGVja1Jlc2VydmVkTG9jazogZnVuY3Rpb24ocEZpbGUscE91dCl7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICB3YXNtLnBva2UocE91dCwgZi5sb2NrVHlwZSA/IDEgOiAwLCAnaTMyJyk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIHhDbG9zZTogZnVuY3Rpb24ocEZpbGUpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4Q2xvc2UnKTtcbiAgICAgICAgbGV0IHJjID0gMDtcbiAgICAgICAgY29uc3QgZiA9IF9fb3BlbkZpbGVzW3BGaWxlXTtcbiAgICAgICAgaWYoZil7XG4gICAgICAgICAgZGVsZXRlIF9fb3BlbkZpbGVzW3BGaWxlXTtcbiAgICAgICAgICByYyA9IG9wUnVuKCd4Q2xvc2UnLCBwRmlsZSk7XG4gICAgICAgICAgaWYoZi5zcTNGaWxlKSBmLnNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4RGV2aWNlQ2hhcmFjdGVyaXN0aWNzOiBmdW5jdGlvbihwRmlsZSl7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9DQVBfVU5ERUxFVEFCTEVfV0hFTl9PUEVOO1xuICAgICAgfSxcbiAgICAgIHhGaWxlQ29udHJvbDogZnVuY3Rpb24ocEZpbGUsIG9wSWQsIHBBcmcpe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PVEZPVU5EO1xuICAgICAgfSxcbiAgICAgIHhGaWxlU2l6ZTogZnVuY3Rpb24ocEZpbGUscFN6NjQpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4RmlsZVNpemUnKTtcbiAgICAgICAgbGV0IHJjID0gb3BSdW4oJ3hGaWxlU2l6ZScsIHBGaWxlKTtcbiAgICAgICAgaWYoMD09cmMpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzeiA9IHN0YXRlLnMxMW4uZGVzZXJpYWxpemUoKVswXTtcbiAgICAgICAgICAgIHdhc20ucG9rZShwU3o2NCwgc3osICdpNjQnKTtcbiAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3IgcmVhZGluZyB4RmlsZVNpemUoKSByZXN1bHQ6XCIsZSk7XG4gICAgICAgICAgICByYyA9IHN0YXRlLnNxM0NvZGVzLlNRTElURV9JT0VSUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhMb2NrOiBmdW5jdGlvbihwRmlsZSxsb2NrVHlwZSl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hMb2NrJyk7XG4gICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgIFxuICAgICAgICBpZiggIWYubG9ja1R5cGUgKSB7XG4gICAgICAgICAgcmMgPSBvcFJ1bigneExvY2snLCBwRmlsZSwgbG9ja1R5cGUpO1xuICAgICAgICAgIGlmKCAwPT09cmMgKSBmLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGYubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeFJlYWQ6IGZ1bmN0aW9uKHBGaWxlLHBEZXN0LG4sb2Zmc2V0NjQpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4UmVhZCcpO1xuICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICBsZXQgcmM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmMgPSBvcFJ1bigneFJlYWQnLHBGaWxlLCBuLCBOdW1iZXIob2Zmc2V0NjQpKTtcbiAgICAgICAgICBpZigwPT09cmMgfHwgY2FwaS5TUUxJVEVfSU9FUlJfU0hPUlRfUkVBRD09PXJjKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5zZXQoZi5zYWJWaWV3LnN1YmFycmF5KDAsIG4pLCBwRGVzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgZXJyb3IoXCJ4UmVhZChcIixhcmd1bWVudHMsXCIpIGZhaWxlZDpcIixlLGYpO1xuICAgICAgICAgIHJjID0gY2FwaS5TUUxJVEVfSU9FUlJfUkVBRDtcbiAgICAgICAgfVxuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeFN5bmM6IGZ1bmN0aW9uKHBGaWxlLGZsYWdzKXtcbiAgICAgICAgbVRpbWVTdGFydCgneFN5bmMnKTtcbiAgICAgICAgKyttZXRyaWNzLnhTeW5jLmNvdW50O1xuICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4U3luYycsIHBGaWxlLCBmbGFncyk7XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4VHJ1bmNhdGU6IGZ1bmN0aW9uKHBGaWxlLHN6NjQpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4VHJ1bmNhdGUnKTtcbiAgICAgICAgY29uc3QgcmMgPSBvcFJ1bigneFRydW5jYXRlJywgcEZpbGUsIE51bWJlcihzejY0KSk7XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4VW5sb2NrOiBmdW5jdGlvbihwRmlsZSxsb2NrVHlwZSl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hVbmxvY2snKTtcbiAgICAgICAgY29uc3QgZiA9IF9fb3BlbkZpbGVzW3BGaWxlXTtcbiAgICAgICAgbGV0IHJjID0gMDtcbiAgICAgICAgaWYoIGNhcGkuU1FMSVRFX0xPQ0tfTk9ORSA9PT0gbG9ja1R5cGVcbiAgICAgICAgICAmJiBmLmxvY2tUeXBlICl7XG4gICAgICAgICAgcmMgPSBvcFJ1bigneFVubG9jaycsIHBGaWxlLCBsb2NrVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIDA9PT1yYyApIGYubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhXcml0ZTogZnVuY3Rpb24ocEZpbGUscFNyYyxuLG9mZnNldDY0KXtcbiAgICAgICAgbVRpbWVTdGFydCgneFdyaXRlJyk7XG4gICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgIGxldCByYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmLnNhYlZpZXcuc2V0KHdhc20uaGVhcDh1KCkuc3ViYXJyYXkocFNyYywgcFNyYytuKSk7XG4gICAgICAgICAgcmMgPSBvcFJ1bigneFdyaXRlJywgcEZpbGUsIG4sIE51bWJlcihvZmZzZXQ2NCkpO1xuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgZXJyb3IoXCJ4V3JpdGUoXCIsYXJndW1lbnRzLFwiKSBmYWlsZWQ6XCIsZSxmKTtcbiAgICAgICAgICByYyA9IGNhcGkuU1FMSVRFX0lPRVJSX1dSSVRFO1xuICAgICAgICB9XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgY29uc3QgdmZzU3luY1dyYXBwZXJzID0ge1xuICAgICAgeEFjY2VzczogZnVuY3Rpb24ocFZmcyx6TmFtZSxmbGFncyxwT3V0KXtcbiAgICAgICAgbVRpbWVTdGFydCgneEFjY2VzcycpO1xuICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4QWNjZXNzJywgd2FzbS5jc3RyVG9Kcyh6TmFtZSkpO1xuICAgICAgICB3YXNtLnBva2UoIHBPdXQsIChyYyA/IDAgOiAxKSwgJ2kzMicgKTtcbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgeEN1cnJlbnRUaW1lOiBmdW5jdGlvbihwVmZzLHBPdXQpe1xuICAgICAgICBcbiAgICAgICAgd2FzbS5wb2tlKHBPdXQsIDI0NDA1ODcuNSArIChuZXcgRGF0ZSgpLmdldFRpbWUoKS84NjQwMDAwMCksXG4gICAgICAgICAgICAgICAgICAnZG91YmxlJyk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIHhDdXJyZW50VGltZUludDY0OiBmdW5jdGlvbihwVmZzLHBPdXQpe1xuICAgICAgICB3YXNtLnBva2UocE91dCwgKDI0NDA1ODcuNSAqIDg2NDAwMDAwKSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgJ2k2NCcpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICB4RGVsZXRlOiBmdW5jdGlvbihwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKXtcbiAgICAgICAgbVRpbWVTdGFydCgneERlbGV0ZScpO1xuICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4RGVsZXRlJywgd2FzbS5jc3RyVG9Kcyh6TmFtZSksIGRvU3luY0RpciwgZmFsc2UpO1xuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeEZ1bGxQYXRobmFtZTogZnVuY3Rpb24ocFZmcyx6TmFtZSxuT3V0LHBPdXQpe1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaSA9IHdhc20uY3N0cm5jcHkocE91dCwgek5hbWUsIG5PdXQpO1xuICAgICAgICByZXR1cm4gaTxuT3V0ID8gMCA6IGNhcGkuU1FMSVRFX0NBTlRPUEVOXG4gICAgICAgIDtcbiAgICAgIH0sXG4gICAgICB4R2V0TGFzdEVycm9yOiBmdW5jdGlvbihwVmZzLG5PdXQscE91dCl7XG4gICAgICAgIFxuICAgICAgICB3YXJuKFwiT1BGUyB4R2V0TGFzdEVycm9yKCkgaGFzIG5vdGhpbmcgc2Vuc2libGUgdG8gcmV0dXJuLlwiKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgXG4gICAgICB4T3BlbjogZnVuY3Rpb24gZihwVmZzLCB6TmFtZSwgcEZpbGUsIGZsYWdzLCBwT3V0RmxhZ3Mpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4T3BlbicpO1xuICAgICAgICBsZXQgb3Bmc0ZsYWdzID0gMDtcbiAgICAgICAgaWYoMD09PXpOYW1lKXtcbiAgICAgICAgICB6TmFtZSA9IHJhbmRvbUZpbGVuYW1lKCk7XG4gICAgICAgIH1lbHNlIGlmKCdudW1iZXInPT09dHlwZW9mIHpOYW1lKXtcbiAgICAgICAgICBpZihjYXBpLnNxbGl0ZTNfdXJpX2Jvb2xlYW4oek5hbWUsIFwib3Bmcy11bmxvY2stYXNhcFwiLCAwKSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG9wZnNGbGFncyB8PSBzdGF0ZS5vcGZzRmxhZ3MuT1BGU19VTkxPQ0tfQVNBUDtcbiAgICAgICAgICB9XG4gICAgICAgICAgek5hbWUgPSB3YXNtLmNzdHJUb0pzKHpOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZoLmZpZCA9IHBGaWxlO1xuICAgICAgICBmaC5maWxlbmFtZSA9IHpOYW1lO1xuICAgICAgICBmaC5zYWIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoc3RhdGUuZmlsZUJ1ZmZlclNpemUpO1xuICAgICAgICBmaC5mbGFncyA9IGZsYWdzO1xuICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4T3BlbicsIHBGaWxlLCB6TmFtZSwgZmxhZ3MsIG9wZnNGbGFncyk7XG4gICAgICAgIGlmKCFyYyl7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoZmgucmVhZE9ubHkpe1xuICAgICAgICAgICAgd2FzbS5wb2tlKHBPdXRGbGFncywgY2FwaS5TUUxJVEVfT1BFTl9SRUFET05MWSwgJ2kzMicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfX29wZW5GaWxlc1twRmlsZV0gPSBmaDtcbiAgICAgICAgICBmaC5zYWJWaWV3ID0gc3RhdGUuc2FiRmlsZUJ1ZlZpZXc7XG4gICAgICAgICAgZmguc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUocEZpbGUpO1xuICAgICAgICAgIGZoLnNxM0ZpbGUuJHBNZXRob2RzID0gb3Bmc0lvTWV0aG9kcy5wb2ludGVyO1xuICAgICAgICAgIGZoLmxvY2tUeXBlID0gY2FwaS5TUUxJVEVfTE9DS19OT05FO1xuICAgICAgICB9XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYoZFZmcyl7XG4gICAgICBvcGZzVmZzLiR4UmFuZG9tbmVzcyA9IGRWZnMuJHhSYW5kb21uZXNzO1xuICAgICAgb3Bmc1Zmcy4keFNsZWVwID0gZFZmcy4keFNsZWVwO1xuICAgIH1cbiAgICBpZighb3Bmc1Zmcy4keFJhbmRvbW5lc3Mpe1xuICAgICAgXG4gICAgICB2ZnNTeW5jV3JhcHBlcnMueFJhbmRvbW5lc3MgPSBmdW5jdGlvbihwVmZzLCBuT3V0LCBwT3V0KXtcbiAgICAgICAgY29uc3QgaGVhcCA9IHdhc20uaGVhcDh1KCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yKDsgaSA8IG5PdXQ7ICsraSkgaGVhcFtwT3V0ICsgaV0gPSAoTWF0aC5yYW5kb20oKSoyNTUwMDApICYgMHhGRjtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZighb3Bmc1Zmcy4keFNsZWVwKXtcbiAgICAgIFxuICAgICAgdmZzU3luY1dyYXBwZXJzLnhTbGVlcCA9IGZ1bmN0aW9uKHBWZnMsbXMpe1xuICAgICAgICBBdG9taWNzLndhaXQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy54U2xlZXAsIDAsIG1zKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9O1xuICAgIH1cblxuICAgIFxuICAgIG9wZnNVdGlsLmdldFJlc29sdmVkUGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lLHNwbGl0SXQpe1xuICAgICAgY29uc3QgcCA9IG5ldyBVUkwoZmlsZW5hbWUsIFwiZmlsZTovL2lycmVsZXZhbnRcIikucGF0aG5hbWU7XG4gICAgICByZXR1cm4gc3BsaXRJdCA/IHAuc3BsaXQoJy8nKS5maWx0ZXIoKHYpPT4hIXYpIDogcDtcbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUgPSBhc3luYyBmdW5jdGlvbiBmKGFic0ZpbGVuYW1lLCBjcmVhdGVEaXJzID0gZmFsc2Upe1xuICAgICAgY29uc3QgcGF0aCA9IG9wZnNVdGlsLmdldFJlc29sdmVkUGF0aChhYnNGaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGgucG9wKCk7XG4gICAgICBsZXQgZGggPSBvcGZzVXRpbC5yb290RGlyZWN0b3J5O1xuICAgICAgZm9yKGNvbnN0IGRpck5hbWUgb2YgcGF0aCl7XG4gICAgICAgIGlmKGRpck5hbWUpe1xuICAgICAgICAgIGRoID0gYXdhaXQgZGguZ2V0RGlyZWN0b3J5SGFuZGxlKGRpck5hbWUsIHtjcmVhdGU6ICEhY3JlYXRlRGlyc30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW2RoLCBmaWxlbmFtZV07XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLm1rZGlyID0gYXN5bmMgZnVuY3Rpb24oYWJzRGlyTmFtZSl7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShhYnNEaXJOYW1lK1wiL2ZpbGVwYXJ0XCIsIHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIG9wZnNVdGlsLmVudHJ5RXhpc3RzID0gYXN5bmMgZnVuY3Rpb24oZnNFbnRyeU5hbWUpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2RoLCBmbl0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShmc0VudHJ5TmFtZSk7XG4gICAgICAgIGF3YWl0IGRoLmdldEZpbGVIYW5kbGUoZm4pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC5yYW5kb21GaWxlbmFtZSA9IHJhbmRvbUZpbGVuYW1lO1xuXG4gICAgXG4gICAgb3Bmc1V0aWwucmVnaXN0ZXJWZnMgPSAoYXNEZWZhdWx0PWZhbHNlKT0+e1xuICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX3Zmc19yZWdpc3RlcihcbiAgICAgICAgb3Bmc1Zmcy5wb2ludGVyLCBhc0RlZmF1bHQgPyAxIDogMFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwudHJlZUxpc3QgPSBhc3luYyBmdW5jdGlvbigpe1xuICAgICAgY29uc3QgZG9EaXIgPSBhc3luYyBmdW5jdGlvbiBjYWxsZWUoZGlySGFuZGxlLHRndCl7XG4gICAgICAgIHRndC5uYW1lID0gZGlySGFuZGxlLm5hbWU7XG4gICAgICAgIHRndC5kaXJzID0gW107XG4gICAgICAgIHRndC5maWxlcyA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpe1xuICAgICAgICAgIGlmKCdkaXJlY3RvcnknID09PSBoYW5kbGUua2luZCl7XG4gICAgICAgICAgICBjb25zdCBzdWJEaXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGd0LmRpcnMucHVzaChzdWJEaXIpO1xuICAgICAgICAgICAgYXdhaXQgY2FsbGVlKGhhbmRsZSwgc3ViRGlyKTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRndC5maWxlcy5wdXNoKGhhbmRsZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCByb290ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGF3YWl0IGRvRGlyKG9wZnNVdGlsLnJvb3REaXJlY3RvcnksIHJvb3QpO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLnJtZnIgPSBhc3luYyBmdW5jdGlvbigpe1xuICAgICAgY29uc3QgZGlyID0gb3Bmc1V0aWwucm9vdERpcmVjdG9yeSwgb3B0ID0ge3JlY3Vyc2U6IHRydWV9O1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBoYW5kbGUgb2YgZGlyLnZhbHVlcygpKXtcbiAgICAgICAgZGlyLnJlbW92ZUVudHJ5KGhhbmRsZS5uYW1lLCBvcHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC51bmxpbmsgPSBhc3luYyBmdW5jdGlvbihmc0VudHJ5TmFtZSwgcmVjdXJzaXZlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yID0gZmFsc2Upe1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2hEaXIsIGZpbGVuYW1lUGFydF0gPVxuICAgICAgICAgICAgICBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShmc0VudHJ5TmFtZSwgZmFsc2UpO1xuICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KGZpbGVuYW1lUGFydCwge3JlY3Vyc2l2ZX0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgaWYodGhyb3dPbkVycm9yKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmxpbmsoXCIsYXJndW1lbnRzWzBdLFwiKSBmYWlsZWQ6IFwiK2UubWVzc2FnZSx7XG4gICAgICAgICAgICBjYXVzZTogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwudHJhdmVyc2UgPSBhc3luYyBmdW5jdGlvbihvcHQpe1xuICAgICAgY29uc3QgZGVmYXVsdE9wdCA9IHtcbiAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICBkaXJlY3Rvcnk6IG9wZnNVdGlsLnJvb3REaXJlY3RvcnlcbiAgICAgIH07XG4gICAgICBpZignZnVuY3Rpb24nPT09dHlwZW9mIG9wdCl7XG4gICAgICAgIG9wdCA9IHtjYWxsYmFjazpvcHR9O1xuICAgICAgfVxuICAgICAgb3B0ID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0LCBvcHR8fHt9KTtcbiAgICAgIGNvbnN0IGRvRGlyID0gYXN5bmMgZnVuY3Rpb24gY2FsbGVlKGRpckhhbmRsZSwgZGVwdGgpe1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXJIYW5kbGUudmFsdWVzKCkpe1xuICAgICAgICAgIGlmKGZhbHNlID09PSBvcHQuY2FsbGJhY2soaGFuZGxlLCBkaXJIYW5kbGUsIGRlcHRoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGVsc2UgaWYob3B0LnJlY3Vyc2l2ZSAmJiAnZGlyZWN0b3J5JyA9PT0gaGFuZGxlLmtpbmQpe1xuICAgICAgICAgICAgaWYoZmFsc2UgPT09IGF3YWl0IGNhbGxlZShoYW5kbGUsIGRlcHRoICsgMSkpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRvRGlyKG9wdC5kaXJlY3RvcnksIDApO1xuICAgIH07XG5cbiAgICBcbiAgICBjb25zdCBpbXBvcnREYkNodW5rZWQgPSBhc3luYyBmdW5jdGlvbihmaWxlbmFtZSwgY2FsbGJhY2spe1xuICAgICAgY29uc3QgW2hEaXIsIGZuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICBjb25zdCBoRmlsZSA9IGF3YWl0IGhEaXIuZ2V0RmlsZUhhbmRsZShmbmFtZVBhcnQsIHtjcmVhdGU6dHJ1ZX0pO1xuICAgICAgbGV0IHNhaCA9IGF3YWl0IGhGaWxlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgIGxldCBuV3JvdGUgPSAwLCBjaHVuaywgY2hlY2tlZEhlYWRlciA9IGZhbHNlLCBlcnIgPSBmYWxzZTtcbiAgICAgIHRyeXtcbiAgICAgICAgc2FoLnRydW5jYXRlKDApO1xuICAgICAgICB3aGlsZSggdW5kZWZpbmVkICE9PSAoY2h1bmsgPSBhd2FpdCBjYWxsYmFjaygpKSApe1xuICAgICAgICAgIGlmKGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICAgIGlmKCAwPT09bldyb3RlICYmIGNodW5rLmJ5dGVMZW5ndGg+PTE1ICl7XG4gICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHthdDogbldyb3RlfSk7XG4gICAgICAgICAgbldyb3RlICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIG5Xcm90ZSA8IDUxMiB8fCAwIT09bldyb3RlICUgNTEyICl7XG4gICAgICAgICAgdG9zcyhcIklucHV0IHNpemVcIixuV3JvdGUsXCJpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiggIWNoZWNrZWRIZWFkZXIgKXtcbiAgICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgyMCk7XG4gICAgICAgICAgc2FoLnJlYWQoIGhlYWRlciwge2F0OiAwfSApO1xuICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoIGhlYWRlciApO1xuICAgICAgICB9XG4gICAgICAgIHNhaC53cml0ZShuZXcgVWludDhBcnJheShbMSwxXSksIHthdDogMTh9KTtcbiAgICAgICAgcmV0dXJuIG5Xcm90ZTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgYXdhaXQgc2FoLmNsb3NlKCk7XG4gICAgICAgIHNhaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeSggZm5hbWVQYXJ0ICkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1maW5hbGx5IHtcbiAgICAgICAgaWYoIHNhaCApIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC5pbXBvcnREYiA9IGFzeW5jIGZ1bmN0aW9uKGZpbGVuYW1lLCBieXRlcyl7XG4gICAgICBpZiggYnl0ZXMgaW5zdGFuY2VvZiBGdW5jdGlvbiApe1xuICAgICAgICByZXR1cm4gaW1wb3J0RGJDaHVua2VkKGZpbGVuYW1lLCBieXRlcyk7XG4gICAgICB9XG4gICAgICBpZihieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgIHV0aWwuYWZmaXJtSXNEYihieXRlcyk7XG4gICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgIGNvbnN0IFtoRGlyLCBmbmFtZVBhcnRdID0gYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoZmlsZW5hbWUsIHRydWUpO1xuICAgICAgbGV0IHNhaCwgZXJyLCBuV3JvdGUgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaEZpbGUgPSBhd2FpdCBoRGlyLmdldEZpbGVIYW5kbGUoZm5hbWVQYXJ0LCB7Y3JlYXRlOnRydWV9KTtcbiAgICAgICAgc2FoID0gYXdhaXQgaEZpbGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSgpO1xuICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgIG5Xcm90ZSA9IHNhaC53cml0ZShieXRlcywge2F0OiAwfSk7XG4gICAgICAgIGlmKG5Xcm90ZSAhPSBuKXtcbiAgICAgICAgICB0b3NzKFwiRXhwZWN0ZWQgdG8gd3JpdGUgXCIrbitcIiBieXRlcyBidXQgd3JvdGUgXCIrbldyb3RlK1wiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsMV0pLCB7YXQ6IDE4fSkgO1xuICAgICAgICByZXR1cm4gbldyb3RlO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBpZiggc2FoICl7IGF3YWl0IHNhaC5jbG9zZSgpOyBzYWggPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeSggZm5hbWVQYXJ0ICkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1maW5hbGx5e1xuICAgICAgICBpZiggc2FoICkgYXdhaXQgc2FoLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmKHNxbGl0ZTMub28xKXtcbiAgICAgIGNvbnN0IE9wZnNEYiA9IGZ1bmN0aW9uKC4uLmFyZ3Mpe1xuICAgICAgICBjb25zdCBvcHQgPSBzcWxpdGUzLm9vMS5EQi5kYkN0b3JIZWxwZXIubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgb3B0LnZmcyA9IG9wZnNWZnMuJHpOYW1lO1xuICAgICAgICBzcWxpdGUzLm9vMS5EQi5kYkN0b3JIZWxwZXIuY2FsbCh0aGlzLCBvcHQpO1xuICAgICAgfTtcbiAgICAgIE9wZnNEYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHNxbGl0ZTMub28xLkRCLnByb3RvdHlwZSk7XG4gICAgICBzcWxpdGUzLm9vMS5PcGZzRGIgPSBPcGZzRGI7XG4gICAgICBPcGZzRGIuaW1wb3J0RGIgPSBvcGZzVXRpbC5pbXBvcnREYjtcbiAgICAgIHNxbGl0ZTMub28xLkRCLmRiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlblNxbChcbiAgICAgICAgb3Bmc1Zmcy5wb2ludGVyLFxuICAgICAgICBmdW5jdGlvbihvbzFEYiwgc3FsaXRlMyl7XG4gICAgICAgICAgXG4gICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfYnVzeV90aW1lb3V0KG9vMURiLCAxMDAwMCk7XG4gICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfZXhlYyhvbzFEYiwgW1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcInByYWdtYSBqb3VybmFsX21vZGU9REVMRVRFO1wiLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcInByYWdtYSBjYWNoZV9zaXplPS0xNjM4NDtcIlxuICAgICAgICAgIF0sIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHNhbml0eUNoZWNrID0gZnVuY3Rpb24oKXtcbiAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgIGNvbnN0IHNxM0ZpbGUgPSBuZXcgc3FsaXRlM19maWxlKCk7XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IGZpZCA9IHNxM0ZpbGUucG9pbnRlcjtcbiAgICAgICAgY29uc3Qgb3BlbkZsYWdzID0gY2FwaS5TUUxJVEVfT1BFTl9DUkVBVEVcbiAgICAgICAgICAgICAgfCBjYXBpLlNRTElURV9PUEVOX1JFQURXUklURVxuICAgICAgICBcbiAgICAgICAgICAgICAgfCBjYXBpLlNRTElURV9PUEVOX01BSU5fREI7XG4gICAgICAgIGNvbnN0IHBPdXQgPSB3YXNtLnNjb3BlZEFsbG9jKDgpO1xuICAgICAgICBjb25zdCBkYkZpbGUgPSBcIi9zYW5pdHkvY2hlY2svZmlsZVwiK3JhbmRvbUZpbGVuYW1lKDgpO1xuICAgICAgICBjb25zdCB6RGJGaWxlID0gd2FzbS5zY29wZWRBbGxvY0NTdHJpbmcoZGJGaWxlKTtcbiAgICAgICAgbGV0IHJjO1xuICAgICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZShcIlRoaXMgaXMgw6Qgc3RyaW5nLlwiKTtcbiAgICAgICAgcmMgPSBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplKCk7XG4gICAgICAgIGxvZyhcImRlc2VyaWFsaXplKCkgc2F5czpcIixyYyk7XG4gICAgICAgIGlmKFwiVGhpcyBpcyDDpCBzdHJpbmcuXCIhPT1yY1swXSkgdG9zcyhcIlN0cmluZyBkMTNuIGVycm9yLlwiKTtcbiAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhBY2Nlc3Mob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAwLCBwT3V0KTtcbiAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwnaTMyJyk7XG4gICAgICAgIGxvZyhcInhBY2Nlc3MoXCIsZGJGaWxlLFwiKSBleGlzdHMgPz1cIixyYyk7XG4gICAgICAgIHJjID0gdmZzU3luY1dyYXBwZXJzLnhPcGVuKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlkLCBvcGVuRmxhZ3MsIHBPdXQpO1xuICAgICAgICBsb2coXCJvcGVuIHJjID1cIixyYyxcInN0YXRlLnNhYk9QVmlld1t4T3Blbl0gPVwiLFxuICAgICAgICAgICAgc3RhdGUuc2FiT1BWaWV3W3N0YXRlLm9wSWRzLnhPcGVuXSk7XG4gICAgICAgIGlmKDAhPT1yYyl7XG4gICAgICAgICAgZXJyb3IoXCJvcGVuIGZhaWxlZCB3aXRoIGNvZGVcIixyYyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgIHJjID0gd2FzbS5wZWVrKHBPdXQsJ2kzMicpO1xuICAgICAgICBpZighcmMpIHRvc3MoXCJ4QWNjZXNzKCkgZmFpbGVkIHRvIGRldGVjdCBmaWxlLlwiKTtcbiAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54U3luYyhzcTNGaWxlLnBvaW50ZXIsIDApO1xuICAgICAgICBpZihyYykgdG9zcygnc3luYyBmYWlsZWQgdy8gcmMnLHJjKTtcbiAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54VHJ1bmNhdGUoc3EzRmlsZS5wb2ludGVyLCAxMDI0KTtcbiAgICAgICAgaWYocmMpIHRvc3MoJ3RydW5jYXRlIGZhaWxlZCB3LyByYycscmMpO1xuICAgICAgICB3YXNtLnBva2UocE91dCwwLCdpNjQnKTtcbiAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54RmlsZVNpemUoc3EzRmlsZS5wb2ludGVyLCBwT3V0KTtcbiAgICAgICAgaWYocmMpIHRvc3MoJ3hGaWxlU2l6ZSBmYWlsZWQgdy8gcmMnLHJjKTtcbiAgICAgICAgbG9nKFwieEZpbGVTaXplIHNheXM6XCIsd2FzbS5wZWVrKHBPdXQsICdpNjQnKSk7XG4gICAgICAgIHJjID0gaW9TeW5jV3JhcHBlcnMueFdyaXRlKHNxM0ZpbGUucG9pbnRlciwgekRiRmlsZSwgMTAsIDEpO1xuICAgICAgICBpZihyYykgdG9zcyhcInhXcml0ZSgpIGZhaWxlZCFcIik7XG4gICAgICAgIGNvbnN0IHJlYWRCdWYgPSB3YXNtLnNjb3BlZEFsbG9jKDE2KTtcbiAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54UmVhZChzcTNGaWxlLnBvaW50ZXIsIHJlYWRCdWYsIDYsIDIpO1xuICAgICAgICB3YXNtLnBva2UocmVhZEJ1Zis2LDApO1xuICAgICAgICBsZXQgalJlYWQgPSB3YXNtLmNzdHJUb0pzKHJlYWRCdWYpO1xuICAgICAgICBsb2coXCJ4UmVhZCgpIGdvdDpcIixqUmVhZCk7XG4gICAgICAgIGlmKFwic2FuaXR5XCIhPT1qUmVhZCkgdG9zcyhcIlVuZXhwZWN0ZWQgeFJlYWQoKSB2YWx1ZS5cIik7XG4gICAgICAgIGlmKHZmc1N5bmNXcmFwcGVycy54U2xlZXApe1xuICAgICAgICAgIGxvZyhcInhTbGVlcCgpaW5nIGJlZm9yZSBjbG9zZSgpaW5nLi4uXCIpO1xuICAgICAgICAgIHZmc1N5bmNXcmFwcGVycy54U2xlZXAob3Bmc1Zmcy5wb2ludGVyLDIwMDApO1xuICAgICAgICAgIGxvZyhcIndha2luZyB1cCBmcm9tIHhTbGVlcCgpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJjID0gaW9TeW5jV3JhcHBlcnMueENsb3NlKGZpZCk7XG4gICAgICAgIGxvZyhcInhDbG9zZSByYyA9XCIscmMsXCJzYWJPUFZpZXcgPVwiLHN0YXRlLnNhYk9QVmlldyk7XG4gICAgICAgIGxvZyhcIkRlbGV0aW5nIGZpbGU6XCIsZGJGaWxlKTtcbiAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhEZWxldGUob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAweDEyMzQpO1xuICAgICAgICB2ZnNTeW5jV3JhcHBlcnMueEFjY2VzcyhvcGZzVmZzLnBvaW50ZXIsIHpEYkZpbGUsIDAsIHBPdXQpO1xuICAgICAgICByYyA9IHdhc20ucGVlayhwT3V0LCdpMzInKTtcbiAgICAgICAgaWYocmMpIHRvc3MoXCJFeHBlY3RpbmcgMCBmcm9tIHhBY2Nlc3MoXCIsZGJGaWxlLFwiKSBhZnRlciB4RGVsZXRlKCkuXCIpO1xuICAgICAgICB3YXJuKFwiRW5kIG9mIE9QRlMgc2FuaXR5IGNoZWNrcy5cIik7XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgc3EzRmlsZS5kaXNwb3NlKCk7XG4gICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBXLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKHtkYXRhfSl7XG4gICAgICBcbiAgICAgIHN3aXRjaChkYXRhLnR5cGUpe1xuICAgICAgICAgIGNhc2UgJ29wZnMtdW5hdmFpbGFibGUnOlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBwcm9taXNlUmVqZWN0KG5ldyBFcnJvcihkYXRhLnBheWxvYWQuam9pbignICcpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvcGZzLWFzeW5jLWxvYWRlZCc6XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFcucG9zdE1lc3NhZ2Uoe3R5cGU6ICdvcGZzLWFzeW5jLWluaXQnLGFyZ3M6IHN0YXRlfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvcGZzLWFzeW5jLWluaXRlZCc6IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodHJ1ZT09PXByb21pc2VXYXNSZWplY3RlZCl7XG4gICAgICAgICAgICAgIGJyZWFrIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNxbGl0ZTMudmZzLmluc3RhbGxWZnMoe1xuICAgICAgICAgICAgICAgIGlvOiB7c3RydWN0OiBvcGZzSW9NZXRob2RzLCBtZXRob2RzOiBpb1N5bmNXcmFwcGVyc30sXG4gICAgICAgICAgICAgICAgdmZzOiB7c3RydWN0OiBvcGZzVmZzLCBtZXRob2RzOiB2ZnNTeW5jV3JhcHBlcnN9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzdGF0ZS5zYWJPUFZpZXcgPSBuZXcgSW50MzJBcnJheShzdGF0ZS5zYWJPUCk7XG4gICAgICAgICAgICAgIHN0YXRlLnNhYkZpbGVCdWZWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUuc2FiSU8sIDAsIHN0YXRlLmZpbGVCdWZmZXJTaXplKTtcbiAgICAgICAgICAgICAgc3RhdGUuc2FiUzExblZpZXcgPSBuZXcgVWludDhBcnJheShzdGF0ZS5zYWJJTywgc3RhdGUuc2FiUzExbk9mZnNldCwgc3RhdGUuc2FiUzExblNpemUpO1xuICAgICAgICAgICAgICBpbml0UzExbigpO1xuICAgICAgICAgICAgICBpZihvcHRpb25zLnNhbml0eUNoZWNrcyl7XG4gICAgICAgICAgICAgICAgd2FybihcIlJ1bm5pbmcgc2FuaXR5IGNoZWNrcyBiZWNhdXNlIG9mIG9wZnMtc2FuaXR5LWNoZWNrIFVSTCBhcmcuLi5cIik7XG4gICAgICAgICAgICAgICAgc2FuaXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZih0aGlzVGhyZWFkSGFzT1BGUygpKXtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKS50aGVuKChkKT0+e1xuICAgICAgICAgICAgICAgICAgVy5vbmVycm9yID0gVy5fb3JpZ2luYWxPbkVycm9yO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgIHNxbGl0ZTMub3BmcyA9IG9wZnNVdGlsO1xuICAgICAgICAgICAgICAgICAgb3Bmc1V0aWwucm9vdERpcmVjdG9yeSA9IGQ7XG4gICAgICAgICAgICAgICAgICBsb2coXCJFbmQgb2YgT1BGUyBzcWxpdGUzX3ZmcyBzZXR1cC5cIiwgb3Bmc1Zmcyk7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHByb21pc2VSZWplY3QpO1xuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICAgIGVycm9yKGUpO1xuICAgICAgICAgICAgICBwcm9taXNlUmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IChcbiAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1lc3NhZ2UgZnJvbSB0aGUgT1BGUyBhc3luYyB3b3JrZXI6IFwiICtcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgcHJvbWlzZVJlamVjdChuZXcgRXJyb3IoZXJyTXNnKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB0aGVQcm9taXNlO1xufTtcbmluc3RhbGxPcGZzVmZzLmRlZmF1bHRQcm94eVVyaSA9XG4gIFwic3FsaXRlMy1vcGZzLWFzeW5jLXByb3h5LmpzXCI7XG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzQXN5bmMucHVzaChhc3luYyAoc3FsaXRlMyk9PntcbiAgdHJ5e1xuICAgIGxldCBwcm94eUpzID0gaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpO1xuICAgIGlmKHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyKXtcbiAgICAgIGluc3RhbGxPcGZzVmZzLmRlZmF1bHRQcm94eVVyaSA9XG4gICAgICAgIHNxbGl0ZTMuc2NyaXB0SW5mby5zcWxpdGUzRGlyICsgcHJveHlKcztcbiAgICAgIFxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFsbE9wZnNWZnMoKS5jYXRjaCgoZSk9PntcbiAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXCJJZ25vcmluZyBpbmFiaWxpdHkgdG8gaW5zdGFsbCBPUEZTIHNxbGl0ZTNfdmZzOlwiLGUubWVzc2FnZSk7XG4gICAgfSk7XG4gIH1jYXRjaChlKXtcbiAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcihcImluc3RhbGxPcGZzVmZzKCkgZXhjZXB0aW9uOlwiLGUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufSk7XG59KTtcblxuXG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbihzcWxpdGUzKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBjb25zdCB0b3NzID0gc3FsaXRlMy51dGlsLnRvc3M7XG4gIGNvbnN0IHRvc3MzID0gc3FsaXRlMy51dGlsLnRvc3MzO1xuICBjb25zdCBpbml0UHJvbWlzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpO1xuICBjb25zdCB1dGlsID0gc3FsaXRlMy51dGlsO1xuICBjb25zdCB3YXNtID0gc3FsaXRlMy53YXNtO1xuICBcbiAgY29uc3QgU0VDVE9SX1NJWkUgPSA0MDk2O1xuICBjb25zdCBIRUFERVJfTUFYX1BBVEhfU0laRSA9IDUxMjtcbiAgY29uc3QgSEVBREVSX0ZMQUdTX1NJWkUgPSA0O1xuICBjb25zdCBIRUFERVJfRElHRVNUX1NJWkUgPSA4O1xuICBjb25zdCBIRUFERVJfQ09SUFVTX1NJWkUgPSBIRUFERVJfTUFYX1BBVEhfU0laRSArIEhFQURFUl9GTEFHU19TSVpFO1xuICBjb25zdCBIRUFERVJfT0ZGU0VUX0ZMQUdTID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gIGNvbnN0IEhFQURFUl9PRkZTRVRfRElHRVNUID0gSEVBREVSX0NPUlBVU19TSVpFO1xuICBjb25zdCBIRUFERVJfT0ZGU0VUX0RBVEEgPSBTRUNUT1JfU0laRTtcbiAgXG4gIGNvbnN0IFBFUlNJU1RFTlRfRklMRV9UWVBFUyA9XG4gICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQiB8XG4gICAgICAgIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9KT1VSTkFMIHxcbiAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9TVVBFUl9KT1VSTkFMIHxcbiAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9XQUwgO1xuXG4gIFxuICBjb25zdCBPUEFRVUVfRElSX05BTUUgPSBcIi5vcGFxdWVcIjtcblxuICBcbiAgY29uc3QgZ2V0UmFuZG9tTmFtZSA9ICgpPT5NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIGNvbnN0IG9wdGlvbkRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICBuYW1lOiAnb3Bmcy1zYWhwb29sJyxcbiAgICBkaXJlY3Rvcnk6IHVuZGVmaW5lZCAsXG4gICAgaW5pdGlhbENhcGFjaXR5OiA2LFxuICAgIGNsZWFyT25Jbml0OiBmYWxzZSxcbiAgICBcbiAgICB2ZXJib3NpdHk6IDJcbiAgfSk7XG5cbiAgXG4gIGNvbnN0IGxvZ2dlcnMgPSBbXG4gICAgc3FsaXRlMy5jb25maWcuZXJyb3IsXG4gICAgc3FsaXRlMy5jb25maWcud2FybixcbiAgICBzcWxpdGUzLmNvbmZpZy5sb2dcbiAgXTtcbiAgY29uc3QgbG9nID0gc3FsaXRlMy5jb25maWcubG9nO1xuICBjb25zdCB3YXJuID0gc3FsaXRlMy5jb25maWcud2FybjtcbiAgY29uc3QgZXJyb3IgPSBzcWxpdGUzLmNvbmZpZy5lcnJvcjtcblxuICBcbiAgY29uc3QgX19tYXBWZnNUb1Bvb2wgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGdldFBvb2xGb3JWZnMgPSAocFZmcyk9Pl9fbWFwVmZzVG9Qb29sLmdldChwVmZzKTtcbiAgY29uc3Qgc2V0UG9vbEZvclZmcyA9IChwVmZzLHBvb2wpPT57XG4gICAgaWYocG9vbCkgX19tYXBWZnNUb1Bvb2wuc2V0KHBWZnMsIHBvb2wpO1xuICAgIGVsc2UgX19tYXBWZnNUb1Bvb2wuZGVsZXRlKHBWZnMpO1xuICB9O1xuICBcbiAgY29uc3QgX19tYXBTcWxpdGUzRmlsZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0UG9vbEZvclBGaWxlID0gKHBGaWxlKT0+X19tYXBTcWxpdGUzRmlsZS5nZXQocEZpbGUpO1xuICBjb25zdCBzZXRQb29sRm9yUEZpbGUgPSAocEZpbGUscG9vbCk9PntcbiAgICBpZihwb29sKSBfX21hcFNxbGl0ZTNGaWxlLnNldChwRmlsZSwgcG9vbCk7XG4gICAgZWxzZSBfX21hcFNxbGl0ZTNGaWxlLmRlbGV0ZShwRmlsZSk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGlvTWV0aG9kcyA9IHtcbiAgICB4Q2hlY2tSZXNlcnZlZExvY2s6IGZ1bmN0aW9uKHBGaWxlLHBPdXQpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZygneENoZWNrUmVzZXJ2ZWRMb2NrJyk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICB3YXNtLnBva2UzMihwT3V0LCAxKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeENsb3NlOiBmdW5jdGlvbihwRmlsZSl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIGlmKGZpbGUpIHtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIHBvb2wubG9nKGB4Q2xvc2UgJHtmaWxlLnBhdGh9YCk7XG4gICAgICAgICAgcG9vbC5tYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmYWxzZSk7XG4gICAgICAgICAgZmlsZS5zYWguZmx1c2goKTtcbiAgICAgICAgICBpZihmaWxlLmZsYWdzICYgY2FwaS5TUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFKXtcbiAgICAgICAgICAgIHBvb2wuZGVsZXRlUGF0aChmaWxlLnBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4RGV2aWNlQ2hhcmFjdGVyaXN0aWNzOiBmdW5jdGlvbihwRmlsZSl7XG4gICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9DQVBfVU5ERUxFVEFCTEVfV0hFTl9PUEVOO1xuICAgIH0sXG4gICAgeEZpbGVDb250cm9sOiBmdW5jdGlvbihwRmlsZSwgb3BJZCwgcEFyZyl7XG4gICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgfSxcbiAgICB4RmlsZVNpemU6IGZ1bmN0aW9uKHBGaWxlLHBTejY0KXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coYHhGaWxlU2l6ZWApO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgY29uc3Qgc2l6ZSA9IGZpbGUuc2FoLmdldFNpemUoKSAtIEhFQURFUl9PRkZTRVRfREFUQTtcbiAgICAgIFxuICAgICAgd2FzbS5wb2tlNjQocFN6NjQsIEJpZ0ludChzaXplKSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhMb2NrOiBmdW5jdGlvbihwRmlsZSxsb2NrVHlwZSl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKGB4TG9jayAke2xvY2tUeXBlfWApO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgZmlsZS5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4UmVhZDogZnVuY3Rpb24ocEZpbGUscERlc3QsbixvZmZzZXQ2NCl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKGB4UmVhZCAke2ZpbGUucGF0aH0gJHtufSBAICR7b2Zmc2V0NjR9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuUmVhZCA9IGZpbGUuc2FoLnJlYWQoXG4gICAgICAgICAgd2FzbS5oZWFwOHUoKS5zdWJhcnJheShwRGVzdCwgcERlc3QrbiksXG4gICAgICAgICAge2F0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyBOdW1iZXIob2Zmc2V0NjQpfVxuICAgICAgICApO1xuICAgICAgICBpZihuUmVhZCA8IG4pe1xuICAgICAgICAgIHdhc20uaGVhcDh1KCkuZmlsbCgwLCBwRGVzdCArIG5SZWFkLCBwRGVzdCArIG4pO1xuICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICB9XG4gICAgfSxcbiAgICB4U2VjdG9yU2l6ZTogZnVuY3Rpb24ocEZpbGUpe1xuICAgICAgcmV0dXJuIFNFQ1RPUl9TSVpFO1xuICAgIH0sXG4gICAgeFN5bmM6IGZ1bmN0aW9uKHBGaWxlLGZsYWdzKXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coYHhTeW5jICR7ZmxhZ3N9YCk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBcbiAgICAgIHRyeXtcbiAgICAgICAgZmlsZS5zYWguZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHhUcnVuY2F0ZTogZnVuY3Rpb24ocEZpbGUsc3o2NCl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKGB4VHJ1bmNhdGUgJHtzejY0fWApO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgXG4gICAgICB0cnl7XG4gICAgICAgIGZpbGUuc2FoLnRydW5jYXRlKEhFQURFUl9PRkZTRVRfREFUQSArIE51bWJlcihzejY0KSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICB9XG4gICAgfSxcbiAgICB4VW5sb2NrOiBmdW5jdGlvbihwRmlsZSxsb2NrVHlwZSl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKCd4VW5sb2NrJyk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBmaWxlLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhXcml0ZTogZnVuY3Rpb24ocEZpbGUscFNyYyxuLG9mZnNldDY0KXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coYHhXcml0ZSAke2ZpbGUucGF0aH0gJHtufSAke29mZnNldDY0fWApO1xuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCBuQnl0ZXMgPSBmaWxlLnNhaC53cml0ZShcbiAgICAgICAgICB3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBTcmMsIHBTcmMrbiksXG4gICAgICAgICAgeyBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgTnVtYmVyKG9mZnNldDY0KSB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuPT09bkJ5dGVzID8gMCA6IHRvc3MoXCJVbmtub3duIHdyaXRlKCkgZmFpbHVyZS5cIik7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgb3Bmc0lvTWV0aG9kcyA9IG5ldyBjYXBpLnNxbGl0ZTNfaW9fbWV0aG9kcygpO1xuICBvcGZzSW9NZXRob2RzLiRpVmVyc2lvbiA9IDE7XG4gIHNxbGl0ZTMudmZzLmluc3RhbGxWZnMoe1xuICAgIGlvOiB7c3RydWN0OiBvcGZzSW9NZXRob2RzLCBtZXRob2RzOiBpb01ldGhvZHN9XG4gIH0pO1xuXG4gIFxuICBjb25zdCB2ZnNNZXRob2RzID0ge1xuICAgIHhBY2Nlc3M6IGZ1bmN0aW9uKHBWZnMsek5hbWUsZmxhZ3MscE91dCl7XG4gICAgICBcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCBuYW1lID0gcG9vbC5nZXRQYXRoKHpOYW1lKTtcbiAgICAgICAgd2FzbS5wb2tlMzIocE91dCwgcG9vbC5oYXNGaWxlbmFtZShuYW1lKSA/IDEgOiAwKTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgXG4gICAgICAgIHdhc20ucG9rZTMyKHBPdXQsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4Q3VycmVudFRpbWU6IGZ1bmN0aW9uKHBWZnMscE91dCl7XG4gICAgICB3YXNtLnBva2UocE91dCwgMjQ0MDU4Ny41ICsgKG5ldyBEYXRlKCkuZ2V0VGltZSgpLzg2NDAwMDAwKSxcbiAgICAgICAgICAgICAgICAnZG91YmxlJyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhDdXJyZW50VGltZUludDY0OiBmdW5jdGlvbihwVmZzLHBPdXQpe1xuICAgICAgd2FzbS5wb2tlKHBPdXQsICgyNDQwNTg3LjUgKiA4NjQwMDAwMCkgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAnaTY0Jyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhEZWxldGU6IGZ1bmN0aW9uKHBWZnMsIHpOYW1lLCBkb1N5bmNEaXIpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICBwb29sLmxvZyhgeERlbGV0ZSAke3dhc20uY3N0clRvSnMoek5hbWUpfWApO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgdHJ5e1xuICAgICAgICBwb29sLmRlbGV0ZVBhdGgocG9vbC5nZXRQYXRoKHpOYW1lKSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBwb29sLnN0b3JlRXJyKGUpO1xuICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlJfREVMRVRFO1xuICAgICAgfVxuICAgIH0sXG4gICAgeEZ1bGxQYXRobmFtZTogZnVuY3Rpb24ocFZmcyx6TmFtZSxuT3V0LHBPdXQpe1xuICAgICAgXG4gICAgICBcbiAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgIHJldHVybiBpPG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgfSxcbiAgICB4R2V0TGFzdEVycm9yOiBmdW5jdGlvbihwVmZzLG5PdXQscE91dCl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgIGNvbnN0IGUgPSBwb29sLnBvcEVycigpO1xuICAgICAgcG9vbC5sb2coYHhHZXRMYXN0RXJyb3IgJHtuT3V0fSBlID1gLGUpO1xuICAgICAgaWYoZSl7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIGNvbnN0IFtjTXNnLCBuXSA9IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKGUubWVzc2FnZSwgdHJ1ZSk7XG4gICAgICAgICAgd2FzbS5jc3RybmNweShwT3V0LCBjTXNnLCBuT3V0KTtcbiAgICAgICAgICBpZihuID4gbk91dCkgd2FzbS5wb2tlOChwT3V0ICsgbk91dCAtIDEsIDApO1xuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PTUVNO1xuICAgICAgICB9ZmluYWxseXtcbiAgICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGUgPyAoZS5zcWxpdGUzUmMgfHwgY2FwaS5TUUxJVEVfSU9FUlIpIDogMDtcbiAgICB9LFxuICAgIFxuICAgIHhPcGVuOiBmdW5jdGlvbiBmKHBWZnMsIHpOYW1lLCBwRmlsZSwgZmxhZ3MsIHBPdXRGbGFncyl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgIHRyeXtcbiAgICAgICAgcG9vbC5sb2coYHhPcGVuICR7d2FzbS5jc3RyVG9Kcyh6TmFtZSl9ICR7ZmxhZ3N9YCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYXRoID0gKHpOYW1lICYmIHdhc20ucGVlazgoek5hbWUpKVxuICAgICAgICAgICAgICA/IHBvb2wuZ2V0UGF0aCh6TmFtZSlcbiAgICAgICAgICAgICAgOiBnZXRSYW5kb21OYW1lKCk7XG4gICAgICAgIGxldCBzYWggPSBwb29sLmdldFNBSEZvclBhdGgocGF0aCk7XG4gICAgICAgIGlmKCFzYWggJiYgKGZsYWdzICYgY2FwaS5TUUxJVEVfT1BFTl9DUkVBVEUpKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYocG9vbC5nZXRGaWxlQ291bnQoKSA8IHBvb2wuZ2V0Q2FwYWNpdHkoKSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzYWggPSBwb29sLm5leHRBdmFpbGFibGVTQUgoKTtcbiAgICAgICAgICAgIHBvb2wuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBwYXRoLCBmbGFncyk7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRvc3MoJ1NBSCBwb29sIGlzIGZ1bGwuIENhbm5vdCBjcmVhdGUgZmlsZScscGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKCFzYWgpe1xuICAgICAgICAgIHRvc3MoJ2ZpbGUgbm90IGZvdW5kOicscGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBjb25zdCBmaWxlID0ge3BhdGgsIGZsYWdzLCBzYWh9O1xuICAgICAgICBwb29sLm1hcFMzRmlsZVRvT0ZpbGUocEZpbGUsIGZpbGUpO1xuICAgICAgICBmaWxlLmxvY2tUeXBlID0gY2FwaS5TUUxJVEVfTE9DS19OT05FO1xuICAgICAgICBjb25zdCBzcTNGaWxlID0gbmV3IGNhcGkuc3FsaXRlM19maWxlKHBGaWxlKTtcbiAgICAgICAgc3EzRmlsZS4kcE1ldGhvZHMgPSBvcGZzSW9NZXRob2RzLnBvaW50ZXI7XG4gICAgICAgIHNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICB3YXNtLnBva2UzMihwT3V0RmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHBvb2wuc3RvcmVFcnIoZSk7XG4gICAgICAgIHJldHVybiBjYXBpLlNRTElURV9DQU5UT1BFTjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgXG4gIGNvbnN0IGNyZWF0ZU9wZnNWZnMgPSBmdW5jdGlvbih2ZnNOYW1lKXtcbiAgICBpZiggc3FsaXRlMy5jYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodmZzTmFtZSkpe1xuICAgICAgdG9zczMoXCJWRlMgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQ6XCIsIHZmc05hbWUpO1xuICAgIH1cbiAgICBjb25zdCBvcGZzVmZzID0gbmV3IGNhcGkuc3FsaXRlM192ZnMoKTtcbiAgICBcbiAgICBjb25zdCBwRFZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZChudWxsKTtcbiAgICBjb25zdCBkVmZzID0gcERWZnNcbiAgICAgICAgICA/IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBEVmZzKVxuICAgICAgICAgIDogbnVsbCA7XG4gICAgb3Bmc1Zmcy4kaVZlcnNpb24gPSAyO1xuICAgIG9wZnNWZnMuJHN6T3NGaWxlID0gY2FwaS5zcWxpdGUzX2ZpbGUuc3RydWN0SW5mby5zaXplb2Y7XG4gICAgb3Bmc1Zmcy4kbXhQYXRobmFtZSA9IEhFQURFUl9NQVhfUEFUSF9TSVpFO1xuICAgIG9wZnNWZnMuYWRkT25EaXNwb3NlKFxuICAgICAgb3Bmc1Zmcy4kek5hbWUgPSB3YXNtLmFsbG9jQ1N0cmluZyh2ZnNOYW1lKSxcbiAgICAgICgpPT5zZXRQb29sRm9yVmZzKG9wZnNWZnMucG9pbnRlciwgMClcbiAgICApO1xuXG4gICAgaWYoZFZmcyl7XG4gICAgICBcbiAgICAgIG9wZnNWZnMuJHhSYW5kb21uZXNzID0gZFZmcy4keFJhbmRvbW5lc3M7XG4gICAgICBvcGZzVmZzLiR4U2xlZXAgPSBkVmZzLiR4U2xlZXA7XG4gICAgICBkVmZzLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaWYoIW9wZnNWZnMuJHhSYW5kb21uZXNzICYmICF2ZnNNZXRob2RzLnhSYW5kb21uZXNzKXtcbiAgICAgIFxuICAgICAgdmZzTWV0aG9kcy54UmFuZG9tbmVzcyA9IGZ1bmN0aW9uKHBWZnMsIG5PdXQsIHBPdXQpe1xuICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IoOyBpIDwgbk91dDsgKytpKSBoZWFwW3BPdXQgKyBpXSA9IChNYXRoLnJhbmRvbSgpKjI1NTAwMCkgJiAweEZGO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmKCFvcGZzVmZzLiR4U2xlZXAgJiYgIXZmc01ldGhvZHMueFNsZWVwKXtcbiAgICAgIHZmc01ldGhvZHMueFNsZWVwID0gKHBWZnMsbXMpPT4wO1xuICAgIH1cbiAgICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICAgIHZmczoge3N0cnVjdDogb3Bmc1ZmcywgbWV0aG9kczogdmZzTWV0aG9kc31cbiAgICB9KTtcbiAgICByZXR1cm4gb3Bmc1ZmcztcbiAgfTtcblxuICBcbiAgY2xhc3MgT3Bmc1NBSFBvb2wge1xuICAgIFxuICAgIHZmc0RpcjtcbiAgICBcbiAgICAjZGhWZnNSb290O1xuICAgIFxuICAgICNkaE9wYXF1ZTtcbiAgICBcbiAgICAjZGhWZnNQYXJlbnQ7XG4gICAgXG4gICAgI21hcFNBSFRvTmFtZSA9IG5ldyBNYXAoKTtcbiAgICBcbiAgICAjbWFwRmlsZW5hbWVUb1NBSCA9IG5ldyBNYXAoKTtcbiAgICBcbiAgICAjYXZhaWxhYmxlU0FIID0gbmV3IFNldCgpO1xuICAgIFxuICAgICNtYXBTM0ZpbGVUb09GaWxlXyA9IG5ldyBNYXAoKTtcblxuICAgIFxuICAgIFxuXG4gICAgXG4gICAgI2FwQm9keSA9IG5ldyBVaW50OEFycmF5KEhFQURFUl9DT1JQVVNfU0laRSk7XG4gICAgXG4gICAgI2R2Qm9keTtcblxuICAgIFxuICAgICNjVmZzO1xuXG4gICAgXG4gICAgI3ZlcmJvc2l0eTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKXtcbiAgICAgIHRoaXMuI3ZlcmJvc2l0eSA9IG9wdGlvbnMudmVyYm9zaXR5ID8/IG9wdGlvbkRlZmF1bHRzLnZlcmJvc2l0eTtcbiAgICAgIHRoaXMudmZzTmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25EZWZhdWx0cy5uYW1lO1xuICAgICAgdGhpcy4jY1ZmcyA9IGNyZWF0ZU9wZnNWZnModGhpcy52ZnNOYW1lKTtcbiAgICAgIHNldFBvb2xGb3JWZnModGhpcy4jY1Zmcy5wb2ludGVyLCB0aGlzKTtcbiAgICAgIHRoaXMudmZzRGlyID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgKFwiLlwiK3RoaXMudmZzTmFtZSk7XG4gICAgICB0aGlzLiNkdkJvZHkgPVxuICAgICAgICBuZXcgRGF0YVZpZXcodGhpcy4jYXBCb2R5LmJ1ZmZlciwgdGhpcy4jYXBCb2R5LmJ5dGVPZmZzZXQpO1xuICAgICAgdGhpcy5pc1JlYWR5ID0gdGhpc1xuICAgICAgICAucmVzZXQoISEob3B0aW9ucy5jbGVhck9uSW5pdCA/PyBvcHRpb25EZWZhdWx0cy5jbGVhck9uSW5pdCkpXG4gICAgICAgIC50aGVuKCgpPT57XG4gICAgICAgICAgaWYodGhpcy4kZXJyb3IpIHRocm93IHRoaXMuJGVycm9yO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldENhcGFjaXR5KClcbiAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgIDogdGhpcy5hZGRDYXBhY2l0eShvcHRpb25zLmluaXRpYWxDYXBhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IG9wdGlvbkRlZmF1bHRzLmluaXRpYWxDYXBhY2l0eSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICNsb2dJbXBsKGxldmVsLC4uLmFyZ3Mpe1xuICAgICAgaWYodGhpcy4jdmVyYm9zaXR5PmxldmVsKSBsb2dnZXJzW2xldmVsXSh0aGlzLnZmc05hbWUrXCI6XCIsLi4uYXJncyk7XG4gICAgfTtcbiAgICBsb2coLi4uYXJncyl7dGhpcy4jbG9nSW1wbCgyLCAuLi5hcmdzKX07XG4gICAgd2FybiguLi5hcmdzKXt0aGlzLiNsb2dJbXBsKDEsIC4uLmFyZ3MpfTtcbiAgICBlcnJvciguLi5hcmdzKXt0aGlzLiNsb2dJbXBsKDAsIC4uLmFyZ3MpfTtcblxuICAgIGdldFZmcygpe3JldHVybiB0aGlzLiNjVmZzfVxuXG4gICAgXG4gICAgZ2V0Q2FwYWNpdHkoKXtyZXR1cm4gdGhpcy4jbWFwU0FIVG9OYW1lLnNpemV9XG5cbiAgICBcbiAgICBnZXRGaWxlQ291bnQoKXtyZXR1cm4gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5zaXplfVxuXG4gICAgXG4gICAgZ2V0RmlsZU5hbWVzKCl7XG4gICAgICBjb25zdCByYyA9IFtdO1xuICAgICAgY29uc3QgaXRlciA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUgua2V5cygpO1xuICAgICAgZm9yKGNvbnN0IG4gb2YgaXRlcikgcmMucHVzaChuKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgXG4gICAgYXN5bmMgYWRkQ2FwYWNpdHkobil7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbjsgKytpKXtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldFJhbmRvbU5hbWUoKTtcbiAgICAgICAgY29uc3QgaCA9IGF3YWl0IHRoaXMuI2RoT3BhcXVlLmdldEZpbGVIYW5kbGUobmFtZSwge2NyZWF0ZTp0cnVlfSk7XG4gICAgICAgIGNvbnN0IGFoID0gYXdhaXQgaC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5zZXQoYWgsbmFtZSk7XG4gICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoYWgsICcnLCAwKTtcbiAgICAgICAgXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRDYXBhY2l0eSgpO1xuICAgIH1cblxuICAgIFxuICAgIGFzeW5jIHJlZHVjZUNhcGFjaXR5KG4pe1xuICAgICAgbGV0IG5SbSA9IDA7XG4gICAgICBmb3IoY29uc3QgYWggb2YgQXJyYXkuZnJvbSh0aGlzLiNhdmFpbGFibGVTQUgpKXtcbiAgICAgICAgaWYoblJtID09PSBuIHx8IHRoaXMuZ2V0RmlsZUNvdW50KCkgPT09IHRoaXMuZ2V0Q2FwYWNpdHkoKSl7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuI21hcFNBSFRvTmFtZS5nZXQoYWgpO1xuICAgICAgICBcbiAgICAgICAgYWguY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jZGhPcGFxdWUucmVtb3ZlRW50cnkobmFtZSk7XG4gICAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5kZWxldGUoYWgpO1xuICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguZGVsZXRlKGFoKTtcbiAgICAgICAgKytuUm07XG4gICAgICB9XG4gICAgICByZXR1cm4gblJtO1xuICAgIH1cblxuICAgIFxuICAgIHJlbGVhc2VBY2Nlc3NIYW5kbGVzKCl7XG4gICAgICBmb3IoY29uc3QgYWggb2YgdGhpcy4jbWFwU0FIVG9OYW1lLmtleXMoKSkgYWguY2xvc2UoKTtcbiAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5jbGVhcigpO1xuICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5jbGVhcigpO1xuICAgICAgdGhpcy4jYXZhaWxhYmxlU0FILmNsZWFyKCk7XG4gICAgfVxuXG4gICAgXG4gICAgYXN5bmMgYWNxdWlyZUFjY2Vzc0hhbmRsZXMoY2xlYXJGaWxlcyl7XG4gICAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBbbmFtZSxoXSBvZiB0aGlzLiNkaE9wYXF1ZSl7XG4gICAgICAgIGlmKCdmaWxlJz09PWgua2luZCl7XG4gICAgICAgICAgZmlsZXMucHVzaChbbmFtZSxoXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAoYXN5bmMoW25hbWUsaF0pPT57XG4gICAgICAgIHRyeXtcbiAgICAgICAgICBjb25zdCBhaCA9IGF3YWl0IGguY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSgpXG4gICAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLnNldChhaCwgbmFtZSk7XG4gICAgICAgICAgaWYoY2xlYXJGaWxlcyl7XG4gICAgICAgICAgICBhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChhaCwgJycsIDApO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuZ2V0QXNzb2NpYXRlZFBhdGgoYWgpO1xuICAgICAgICAgICAgaWYocGF0aCl7XG4gICAgICAgICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2V0KHBhdGgsIGFoKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguYWRkKGFoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICB0aGlzLnN0b3JlRXJyKGUpO1xuICAgICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgXG4gICAgZ2V0QXNzb2NpYXRlZFBhdGgoc2FoKXtcbiAgICAgIHNhaC5yZWFkKHRoaXMuI2FwQm9keSwge2F0OiAwfSk7XG4gICAgICBcbiAgICAgIFxuICAgICAgY29uc3QgZmxhZ3MgPSB0aGlzLiNkdkJvZHkuZ2V0VWludDMyKEhFQURFUl9PRkZTRVRfRkxBR1MpO1xuICAgICAgaWYodGhpcy4jYXBCb2R5WzBdICYmXG4gICAgICAgICAoKGZsYWdzICYgY2FwaS5TUUxJVEVfT1BFTl9ERUxFVEVPTkNMT1NFKSB8fFxuICAgICAgICAgIChmbGFncyAmIFBFUlNJU1RFTlRfRklMRV9UWVBFUyk9PT0wKSl7XG4gICAgICAgIHdhcm4oYFJlbW92aW5nIGZpbGUgd2l0aCB1bmV4cGVjdGVkIGZsYWdzICR7ZmxhZ3MudG9TdHJpbmcoMTYpfWAsXG4gICAgICAgICAgICAgdGhpcy4jYXBCb2R5KTtcbiAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlRGlnZXN0ID0gbmV3IFVpbnQzMkFycmF5KEhFQURFUl9ESUdFU1RfU0laRSAvIDQpO1xuICAgICAgc2FoLnJlYWQoZmlsZURpZ2VzdCwge2F0OiBIRUFERVJfT0ZGU0VUX0RJR0VTVH0pO1xuICAgICAgY29uc3QgY29tcERpZ2VzdCA9IHRoaXMuY29tcHV0ZURpZ2VzdCh0aGlzLiNhcEJvZHkpO1xuICAgICAgaWYoZmlsZURpZ2VzdC5ldmVyeSgodixpKSA9PiB2PT09Y29tcERpZ2VzdFtpXSkpe1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGF0aEJ5dGVzID0gdGhpcy4jYXBCb2R5LmZpbmRJbmRleCgodik9PjA9PT12KTtcbiAgICAgICAgaWYoMD09PXBhdGhCeXRlcyl7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgc2FoLnRydW5jYXRlKEhFQURFUl9PRkZTRVRfREFUQSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhCeXRlc1xuICAgICAgICAgID8gdGV4dERlY29kZXIuZGVjb2RlKHRoaXMuI2FwQm9keS5zdWJhcnJheSgwLHBhdGhCeXRlcykpXG4gICAgICAgICAgOiAnJztcbiAgICAgIH1lbHNle1xuICAgICAgICBcbiAgICAgICAgd2FybignRGlzYXNzb2NpYXRpbmcgZmlsZSB3aXRoIGJhZCBkaWdlc3QuJyk7XG4gICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBcbiAgICBzZXRBc3NvY2lhdGVkUGF0aChzYWgsIHBhdGgsIGZsYWdzKXtcbiAgICAgIGNvbnN0IGVuYyA9IHRleHRFbmNvZGVyLmVuY29kZUludG8ocGF0aCwgdGhpcy4jYXBCb2R5KTtcbiAgICAgIGlmKEhFQURFUl9NQVhfUEFUSF9TSVpFIDw9IGVuYy53cml0dGVuICsgMSl7XG4gICAgICAgIHRvc3MoXCJQYXRoIHRvbyBsb25nOlwiLHBhdGgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jYXBCb2R5LmZpbGwoMCwgZW5jLndyaXR0ZW4sIEhFQURFUl9NQVhfUEFUSF9TSVpFKTtcbiAgICAgIHRoaXMuI2R2Qm9keS5zZXRVaW50MzIoSEVBREVSX09GRlNFVF9GTEFHUywgZmxhZ3MpO1xuXG4gICAgICBjb25zdCBkaWdlc3QgPSB0aGlzLmNvbXB1dGVEaWdlc3QodGhpcy4jYXBCb2R5KTtcbiAgICAgIHNhaC53cml0ZSh0aGlzLiNhcEJvZHksIHthdDogMH0pO1xuICAgICAgc2FoLndyaXRlKGRpZ2VzdCwge2F0OiBIRUFERVJfT0ZGU0VUX0RJR0VTVH0pO1xuICAgICAgc2FoLmZsdXNoKCk7XG5cbiAgICAgIGlmKHBhdGgpe1xuICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILnNldChwYXRoLCBzYWgpO1xuICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguZGVsZXRlKHNhaCk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgXG4gICAgICAgIHNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICB0aGlzLiNhdmFpbGFibGVTQUguYWRkKHNhaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgXG4gICAgY29tcHV0ZURpZ2VzdChieXRlQXJyYXkpe1xuICAgICAgbGV0IGgxID0gMHhkZWFkYmVlZjtcbiAgICAgIGxldCBoMiA9IDB4NDFjNmNlNTc7XG4gICAgICBmb3IoY29uc3QgdiBvZiBieXRlQXJyYXkpe1xuICAgICAgICBoMSA9IDMxICogaDEgKyAodiAqIDMwNyk7XG4gICAgICAgIGgyID0gMzEgKiBoMiArICh2ICogMzA3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoW2gxPj4+MCwgaDI+Pj4wXSk7XG4gICAgfVxuXG4gICAgXG4gICAgYXN5bmMgcmVzZXQoY2xlYXJGaWxlcyl7XG4gICAgICBhd2FpdCB0aGlzLmlzUmVhZHk7XG4gICAgICBsZXQgaCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgICAgbGV0IHByZXYsIHByZXZOYW1lO1xuICAgICAgZm9yKGNvbnN0IGQgb2YgdGhpcy52ZnNEaXIuc3BsaXQoJy8nKSl7XG4gICAgICAgIGlmKGQpe1xuICAgICAgICAgIHByZXYgPSBoO1xuICAgICAgICAgIGggPSBhd2FpdCBoLmdldERpcmVjdG9yeUhhbmRsZShkLHtjcmVhdGU6dHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiNkaFZmc1Jvb3QgPSBoO1xuICAgICAgdGhpcy4jZGhWZnNQYXJlbnQgPSBwcmV2O1xuICAgICAgdGhpcy4jZGhPcGFxdWUgPSBhd2FpdCB0aGlzLiNkaFZmc1Jvb3QuZ2V0RGlyZWN0b3J5SGFuZGxlKFxuICAgICAgICBPUEFRVUVfRElSX05BTUUse2NyZWF0ZTp0cnVlfVxuICAgICAgKTtcbiAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgIHJldHVybiB0aGlzLmFjcXVpcmVBY2Nlc3NIYW5kbGVzKGNsZWFyRmlsZXMpO1xuICAgIH1cblxuICAgIFxuICAgIGdldFBhdGgoYXJnKSB7XG4gICAgICBpZih3YXNtLmlzUHRyKGFyZykpIGFyZyA9IHdhc20uY3N0clRvSnMoYXJnKTtcbiAgICAgIHJldHVybiAoKGFyZyBpbnN0YW5jZW9mIFVSTClcbiAgICAgICAgICAgICAgPyBhcmdcbiAgICAgICAgICAgICAgOiBuZXcgVVJMKGFyZywgJ2ZpbGU6Ly9sb2NhbGhvc3QvJykpLnBhdGhuYW1lO1xuICAgIH1cblxuICAgIFxuICAgIGRlbGV0ZVBhdGgocGF0aCkge1xuICAgICAgY29uc3Qgc2FoID0gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQocGF0aCk7XG4gICAgICBpZihzYWgpIHtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZGVsZXRlKHBhdGgpO1xuICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhc2FoO1xuICAgIH1cblxuICAgIFxuICAgIHN0b3JlRXJyKGUsY29kZSl7XG4gICAgICBpZihlKXtcbiAgICAgICAgZS5zcWxpdGUzUmMgPSBjb2RlIHx8IGNhcGkuU1FMSVRFX0lPRVJSO1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgfVxuICAgICAgdGhpcy4kZXJyb3IgPSBlO1xuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIFxuICAgIHBvcEVycigpe1xuICAgICAgY29uc3QgcmMgPSB0aGlzLiRlcnJvcjtcbiAgICAgIHRoaXMuJGVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH1cblxuICAgIFxuICAgIG5leHRBdmFpbGFibGVTQUgoKXtcbiAgICAgIGNvbnN0IFtyY10gPSB0aGlzLiNhdmFpbGFibGVTQUgua2V5cygpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH1cblxuICAgIFxuICAgIGdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKXtcbiAgICAgIHJldHVybiB0aGlzLiNtYXBTM0ZpbGVUb09GaWxlXy5nZXQocEZpbGUpO1xuICAgIH1cbiAgICBcbiAgICBtYXBTM0ZpbGVUb09GaWxlKHBGaWxlLGZpbGUpe1xuICAgICAgaWYoZmlsZSl7XG4gICAgICAgIHRoaXMuI21hcFMzRmlsZVRvT0ZpbGVfLnNldChwRmlsZSwgZmlsZSk7XG4gICAgICAgIHNldFBvb2xGb3JQRmlsZShwRmlsZSwgdGhpcyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uZGVsZXRlKHBGaWxlKTtcbiAgICAgICAgc2V0UG9vbEZvclBGaWxlKHBGaWxlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgXG4gICAgaGFzRmlsZW5hbWUobmFtZSl7XG4gICAgICByZXR1cm4gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5oYXMobmFtZSlcbiAgICB9XG5cbiAgICBcbiAgICBnZXRTQUhGb3JQYXRoKHBhdGgpe1xuICAgICAgcmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KHBhdGgpO1xuICAgIH1cblxuICAgIFxuICAgIGFzeW5jIHJlbW92ZVZmcygpe1xuICAgICAgaWYoIXRoaXMuI2NWZnMucG9pbnRlciB8fCAhdGhpcy4jZGhPcGFxdWUpIHJldHVybiBmYWxzZTtcbiAgICAgIGNhcGkuc3FsaXRlM192ZnNfdW5yZWdpc3Rlcih0aGlzLiNjVmZzLnBvaW50ZXIpO1xuICAgICAgdGhpcy4jY1Zmcy5kaXNwb3NlKCk7XG4gICAgICB0cnl7XG4gICAgICAgIHRoaXMucmVsZWFzZUFjY2Vzc0hhbmRsZXMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jZGhWZnNSb290LnJlbW92ZUVudHJ5KE9QQVFVRV9ESVJfTkFNRSwge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xuICAgICAgICB0aGlzLiNkaE9wYXF1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgdGhpcy4jZGhWZnNQYXJlbnQucmVtb3ZlRW50cnkoXG4gICAgICAgICAgdGhpcy4jZGhWZnNSb290Lm5hbWUsIHtyZWN1cnNpdmU6IHRydWV9XG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuI2RoVmZzUm9vdCA9IHRoaXMuI2RoVmZzUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcih0aGlzLnZmc05hbWUsXCJyZW1vdmVWZnMoKSBmYWlsZWQ6XCIsZSk7XG4gICAgICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbiAgICBcbiAgICBleHBvcnRGaWxlKG5hbWUpe1xuICAgICAgY29uc3Qgc2FoID0gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQobmFtZSkgfHwgdG9zcyhcIkZpbGUgbm90IGZvdW5kOlwiLG5hbWUpO1xuICAgICAgY29uc3QgbiA9IHNhaC5nZXRTaXplKCkgLSBIRUFERVJfT0ZGU0VUX0RBVEE7XG4gICAgICBjb25zdCBiID0gbmV3IFVpbnQ4QXJyYXkobj4wID8gbiA6IDApO1xuICAgICAgaWYobj4wKXtcbiAgICAgICAgY29uc3QgblJlYWQgPSBzYWgucmVhZChiLCB7YXQ6IEhFQURFUl9PRkZTRVRfREFUQX0pO1xuICAgICAgICBpZihuUmVhZCAhPSBuKXtcbiAgICAgICAgICB0b3NzKFwiRXhwZWN0ZWQgdG8gcmVhZCBcIituK1wiIGJ5dGVzIGJ1dCByZWFkIFwiK25SZWFkK1wiLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuXG4gICAgXG4gICAgYXN5bmMgaW1wb3J0RGJDaHVua2VkKG5hbWUsIGNhbGxiYWNrKXtcbiAgICAgIGNvbnN0IHNhaCA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KG5hbWUpXG4gICAgICAgICAgICB8fCB0aGlzLm5leHRBdmFpbGFibGVTQUgoKVxuICAgICAgICAgICAgfHwgdG9zcyhcIk5vIGF2YWlsYWJsZSBoYW5kbGVzIHRvIGltcG9ydCB0by5cIik7XG4gICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICBsZXQgbldyb3RlID0gMCwgY2h1bmssIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSwgZXJyID0gZmFsc2U7XG4gICAgICB0cnl7XG4gICAgICAgIHdoaWxlKCB1bmRlZmluZWQgIT09IChjaHVuayA9IGF3YWl0IGNhbGxiYWNrKCkpICl7XG4gICAgICAgICAgaWYoY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgY2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgaWYoIDA9PT1uV3JvdGUgJiYgY2h1bmsuYnl0ZUxlbmd0aD49MTUgKXtcbiAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoY2h1bmspO1xuICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhaC53cml0ZShjaHVuaywge2F0OiAgSEVBREVSX09GRlNFVF9EQVRBICsgbldyb3RlfSk7XG4gICAgICAgICAgbldyb3RlICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIG5Xcm90ZSA8IDUxMiB8fCAwIT09bldyb3RlICUgNTEyICl7XG4gICAgICAgICAgdG9zcyhcIklucHV0IHNpemVcIixuV3JvdGUsXCJpcyBub3QgY29ycmVjdCBmb3IgYW4gU1FMaXRlIGRhdGFiYXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiggIWNoZWNrZWRIZWFkZXIgKXtcbiAgICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgyMCk7XG4gICAgICAgICAgc2FoLnJlYWQoIGhlYWRlciwge2F0OiAwfSApO1xuICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoIGhlYWRlciApO1xuICAgICAgICB9XG4gICAgICAgIHNhaC53cml0ZShuZXcgVWludDhBcnJheShbMSwxXSksIHtcbiAgICAgICAgICBhdDogSEVBREVSX09GRlNFVF9EQVRBICsgMThcbiAgICAgICAgfSk7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgbmFtZSwgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCKTtcbiAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgfVxuXG4gICAgXG4gICAgaW1wb3J0RGIobmFtZSwgYnl0ZXMpe1xuICAgICAgaWYoIGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgIGVsc2UgaWYoIGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24gKSByZXR1cm4gdGhpcy5pbXBvcnREYkNodW5rZWQobmFtZSwgYnl0ZXMpO1xuICAgICAgY29uc3Qgc2FoID0gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQobmFtZSlcbiAgICAgICAgICAgIHx8IHRoaXMubmV4dEF2YWlsYWJsZVNBSCgpXG4gICAgICAgICAgICB8fCB0b3NzKFwiTm8gYXZhaWxhYmxlIGhhbmRsZXMgdG8gaW1wb3J0IHRvLlwiKTtcbiAgICAgIGNvbnN0IG4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgaWYobjw1MTIgfHwgbiU1MTIhPTApe1xuICAgICAgICB0b3NzKFwiQnl0ZSBhcnJheSBzaXplIGlzIGludmFsaWQgZm9yIGFuIFNRTGl0ZSBkYi5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWFkZXIgPSBcIlNRTGl0ZSBmb3JtYXQgM1wiO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGhlYWRlci5sZW5ndGg7ICsraSl7XG4gICAgICAgIGlmKCBoZWFkZXIuY2hhckNvZGVBdChpKSAhPT0gYnl0ZXNbaV0gKXtcbiAgICAgICAgICB0b3NzKFwiSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUgZGF0YWJhc2UgaGVhZGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7YXQ6IEhFQURFUl9PRkZTRVRfREFUQX0pO1xuICAgICAgaWYobldyb3RlICE9IG4pe1xuICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICB0b3NzKFwiRXhwZWN0ZWQgdG8gd3JpdGUgXCIrbitcIiBieXRlcyBidXQgd3JvdGUgXCIrbldyb3RlK1wiLlwiKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsMV0pLCB7YXQ6IEhFQURFUl9PRkZTRVRfREFUQSsxOH1cbiAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgbmFtZSwgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgfVxuXG4gIH07XG5cblxuICBcbiAgY2xhc3MgT3Bmc1NBSFBvb2xVdGlsIHtcbiAgICBcbiAgICAjcDtcblxuICAgIGNvbnN0cnVjdG9yKHNhaFBvb2wpe1xuICAgICAgdGhpcy4jcCA9IHNhaFBvb2w7XG4gICAgICB0aGlzLnZmc05hbWUgPSBzYWhQb29sLnZmc05hbWU7XG4gICAgfVxuXG4gICAgYXN5bmMgYWRkQ2FwYWNpdHkobil7IHJldHVybiB0aGlzLiNwLmFkZENhcGFjaXR5KG4pIH1cblxuICAgIGFzeW5jIHJlZHVjZUNhcGFjaXR5KG4peyByZXR1cm4gdGhpcy4jcC5yZWR1Y2VDYXBhY2l0eShuKSB9XG5cbiAgICBnZXRDYXBhY2l0eSgpeyByZXR1cm4gdGhpcy4jcC5nZXRDYXBhY2l0eSh0aGlzLiNwKSB9XG5cbiAgICBnZXRGaWxlQ291bnQoKXsgcmV0dXJuIHRoaXMuI3AuZ2V0RmlsZUNvdW50KCkgfVxuICAgIGdldEZpbGVOYW1lcygpeyByZXR1cm4gdGhpcy4jcC5nZXRGaWxlTmFtZXMoKSB9XG5cbiAgICBhc3luYyByZXNlcnZlTWluaW11bUNhcGFjaXR5KG1pbil7XG4gICAgICBjb25zdCBjID0gdGhpcy4jcC5nZXRDYXBhY2l0eSgpO1xuICAgICAgcmV0dXJuIChjIDwgbWluKSA/IHRoaXMuI3AuYWRkQ2FwYWNpdHkobWluIC0gYykgOiBjO1xuICAgIH1cblxuICAgIGV4cG9ydEZpbGUobmFtZSl7IHJldHVybiB0aGlzLiNwLmV4cG9ydEZpbGUobmFtZSkgfVxuXG4gICAgaW1wb3J0RGIobmFtZSwgYnl0ZXMpeyByZXR1cm4gdGhpcy4jcC5pbXBvcnREYihuYW1lLGJ5dGVzKSB9XG5cbiAgICBhc3luYyB3aXBlRmlsZXMoKXsgcmV0dXJuIHRoaXMuI3AucmVzZXQodHJ1ZSkgfVxuXG4gICAgdW5saW5rKGZpbGVuYW1lKXsgcmV0dXJuIHRoaXMuI3AuZGVsZXRlUGF0aChmaWxlbmFtZSkgfVxuXG4gICAgYXN5bmMgcmVtb3ZlVmZzKCl7IHJldHVybiB0aGlzLiNwLnJlbW92ZVZmcygpIH1cblxuICB9O1xuXG4gIFxuICBjb25zdCBhcGlWZXJzaW9uQ2hlY2sgPSBhc3luYyAoKT0+e1xuICAgIGNvbnN0IGRoID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgY29uc3QgZm4gPSAnLm9wZnMtc2FocG9vbC1zeW5jLWNoZWNrLScrZ2V0UmFuZG9tTmFtZSgpO1xuICAgIGNvbnN0IGZoID0gYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbiwgeyBjcmVhdGU6IHRydWUgfSk7XG4gICAgY29uc3QgYWggPSBhd2FpdCBmaC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgY29uc3QgY2xvc2UgPSBhaC5jbG9zZSgpO1xuICAgIGF3YWl0IGNsb3NlO1xuICAgIGF3YWl0IGRoLnJlbW92ZUVudHJ5KGZuKTtcbiAgICBpZihjbG9zZT8udGhlbil7XG4gICAgICB0b3NzKFwiVGhlIGxvY2FsIE9QRlMgQVBJIGlzIHRvbyBvbGQgZm9yIG9wZnMtc2FocG9vbDpcIixcbiAgICAgICAgICAgXCJpdCBoYXMgYW4gYXN5bmMgRmlsZVN5c3RlbVN5bmNBY2Nlc3NIYW5kbGUuY2xvc2UoKSBtZXRob2QuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBcbiAgbGV0IGluc3RhbmNlQ291bnRlciA9IDA7XG5cbiAgXG4gIHNxbGl0ZTMuaW5zdGFsbE9wZnNTQUhQb29sVmZzID0gYXN5bmMgZnVuY3Rpb24ob3B0aW9ucz1PYmplY3QuY3JlYXRlKG51bGwpKXtcbiAgICBjb25zdCB2ZnNOYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbkRlZmF1bHRzLm5hbWU7XG4gICAgaWYoMCAmJiAyPT09KytpbnN0YW5jZUNvdW50ZXIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSnVzdCB0ZXN0aW5nIHJlamVjdGlvbi5cIik7XG4gICAgfVxuICAgIGlmKGluaXRQcm9taXNlc1t2ZnNOYW1lXSl7XG4gICAgICBcbiAgICAgIHJldHVybiBpbml0UHJvbWlzZXNbdmZzTmFtZV07XG4gICAgfVxuICAgIGlmKCFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgfHxcbiAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlIHx8XG4gICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUgfHxcbiAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSB8fFxuICAgICAgICFuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeSl7XG4gICAgICByZXR1cm4gKGluaXRQcm9taXNlc1t2ZnNOYW1lXSA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgT1BGUyBBUElzLlwiKSkpO1xuICAgIH1cblxuICAgIFxuICAgIHJldHVybiBpbml0UHJvbWlzZXNbdmZzTmFtZV0gPSBhcGlWZXJzaW9uQ2hlY2soKS50aGVuKGFzeW5jIGZ1bmN0aW9uKCl7XG4gICAgICBpZihvcHRpb25zLiR0ZXN0VGhyb3dJbkluaXQpe1xuICAgICAgICB0aHJvdyBvcHRpb25zLiR0ZXN0VGhyb3dJbkluaXQ7XG4gICAgICB9XG4gICAgICBjb25zdCB0aGVQb29sID0gbmV3IE9wZnNTQUhQb29sKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoZVBvb2wuaXNSZWFkeS50aGVuKGFzeW5jKCk9PntcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBvb2xVdGlsID0gbmV3IE9wZnNTQUhQb29sVXRpbCh0aGVQb29sKTtcbiAgICAgICAgaWYoc3FsaXRlMy5vbzEpe1xuICAgICAgICAgIGNvbnN0IG9vMSA9IHNxbGl0ZTMub28xO1xuICAgICAgICAgIGNvbnN0IHRoZVZmcyA9IHRoZVBvb2wuZ2V0VmZzKCk7XG4gICAgICAgICAgY29uc3QgT3Bmc1NBSFBvb2xEYiA9IGZ1bmN0aW9uKC4uLmFyZ3Mpe1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gb28xLkRCLmRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICAgICAgb3B0LnZmcyA9IHRoZVZmcy4kek5hbWU7XG4gICAgICAgICAgICBvbzEuREIuZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9wZnNTQUhQb29sRGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvbzEuREIucHJvdG90eXBlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBwb29sVXRpbC5PcGZzU0FIUG9vbERiID0gT3Bmc1NBSFBvb2xEYjtcbiAgICAgICAgICBvbzEuREIuZGJDdG9ySGVscGVyLnNldFZmc1Bvc3RPcGVuU3FsKFxuICAgICAgICAgICAgdGhlVmZzLnBvaW50ZXIsXG4gICAgICAgICAgICBmdW5jdGlvbihvbzFEYiwgc3FsaXRlMyl7XG4gICAgICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2V4ZWMob28xRGIsIFtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcInByYWdtYSBqb3VybmFsX21vZGU9REVMRVRFO1wiLFxuICAgICAgICAgICAgICAgIFwicHJhZ21hIGNhY2hlX3NpemU9LTE2Mzg0O1wiXG4gICAgICAgICAgICAgIF0sIDAsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhlUG9vbC5sb2coXCJWRlMgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgICByZXR1cm4gcG9vbFV0aWw7XG4gICAgICB9KS5jYXRjaChhc3luYyAoZSk9PntcbiAgICAgICAgYXdhaXQgdGhlUG9vbC5yZW1vdmVWZnMoKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICBcbiAgICAgIHJldHVybiBpbml0UHJvbWlzZXNbdmZzTmFtZV0gPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9O1xufSk7XG5cblxuXG4ndXNlIHN0cmljdCc7XG5pZigndW5kZWZpbmVkJyAhPT0gdHlwZW9mIE1vZHVsZSl7IFxuICBcbiAgY29uc3QgU0FCQyA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgZXhwb3J0czogKCd1bmRlZmluZWQnPT09dHlwZW9mIHdhc21FeHBvcnRzKVxuICAgICAgICA/IE1vZHVsZVsnYXNtJ11cbiAgICAgICAgOiB3YXNtRXhwb3J0cyAgLFxuICAgICAgbWVtb3J5OiBNb2R1bGUud2FzbU1lbW9yeSBcbiAgICB9LFxuICAgIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyB8fCB7fVxuICApO1xuXG4gIFxuICBcbiAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQ29uZmlnID0gU0FCQztcbiAgbGV0IHNxbGl0ZTM7XG4gIHRyeXtcbiAgICBzcWxpdGUzID0gZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwKCk7XG4gIH1jYXRjaChlKXtcbiAgICBjb25zb2xlLmVycm9yKFwic3FsaXRlM0FwaUJvb3RzdHJhcCgpIGVycm9yOlwiLGUpO1xuICAgIHRocm93IGU7XG4gIH1maW5hbGx5e1xuICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXA7XG4gICAgZGVsZXRlIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZztcbiAgfVxuXG4gIE1vZHVsZS5zcWxpdGUzID0gc3FsaXRlMyA7XG59ZWxzZXtcbiAgY29uc29sZS53YXJuKFwiVGhpcyBpcyBub3QgcnVubmluZyBpbiBhbiBFbXNjcmlwdGVuIG1vZHVsZSBjb250ZXh0LCBzb1wiLFxuICAgICAgICAgICAgICAgXCJnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAoKSBpcyBfbm90XyBiZWluZyBjYWxsZWQgZHVlIHRvIGxhY2tcIixcbiAgICAgICAgICAgICAgIFwib2YgY29uZmlnIGluZm8gZm9yIHRoZSBXQVNNIGVudmlyb25tZW50LlwiLFxuICAgICAgICAgICAgICAgXCJJdCBtdXN0IGJlIGNhbGxlZCBtYW51YWxseS5cIik7XG59XG5cblxuXG5cbn0pO1xuXG5cblxuICByZXR1cm4gc3FsaXRlM0luaXRNb2R1bGUucmVhZHlcbn1cbik7XG59KSgpO1xuaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcbiAgbW9kdWxlLmV4cG9ydHMgPSBzcWxpdGUzSW5pdE1vZHVsZTtcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNxbGl0ZTNJbml0TW9kdWxlOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcbiAgZXhwb3J0c1tcInNxbGl0ZTNJbml0TW9kdWxlXCJdID0gc3FsaXRlM0luaXRNb2R1bGU7XG5cblxuXG4oZnVuY3Rpb24oKXtcbiAgXG4gIGNvbnN0IG9yaWdpbmFsSW5pdCA9IHNxbGl0ZTNJbml0TW9kdWxlO1xuICBpZighb3JpZ2luYWxJbml0KXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZSB0byBiZSBkZWZpbmVkIGJ5IHRoZSBFbXNjcmlwdGVuIGJ1aWxkLlwiKTtcbiAgfVxuICBcbiAgY29uc3QgaW5pdE1vZHVsZVN0YXRlID0gZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICBtb2R1bGVTY3JpcHQ6IGdsb2JhbFRoaXM/LmRvY3VtZW50Py5jdXJyZW50U2NyaXB0LFxuICAgIGlzV29ya2VyOiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSksXG4gICAgbG9jYXRpb246IGdsb2JhbFRoaXMubG9jYXRpb24sXG4gICAgdXJsUGFyYW1zOiAgZ2xvYmFsVGhpcz8ubG9jYXRpb24/LmhyZWZcbiAgICAgID8gbmV3IFVSTChnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYpLnNlYXJjaFBhcmFtc1xuICAgICAgOiBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgfSk7XG4gIGluaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZSA9XG4gICAgaW5pdE1vZHVsZVN0YXRlLnVybFBhcmFtcy5oYXMoJ3NxbGl0ZTMuZGVidWdNb2R1bGUnKVxuICAgID8gKC4uLmFyZ3MpPT5jb25zb2xlLndhcm4oJ3NxbGl0ZTMuZGVidWdNb2R1bGU6JywuLi5hcmdzKVxuICAgIDogKCk9Pnt9O1xuXG4gIGlmKGluaXRNb2R1bGVTdGF0ZS51cmxQYXJhbXMuaGFzKCdzcWxpdGUzLmRpcicpKXtcbiAgICBpbml0TW9kdWxlU3RhdGUuc3FsaXRlM0RpciA9IGluaXRNb2R1bGVTdGF0ZS51cmxQYXJhbXMuZ2V0KCdzcWxpdGUzLmRpcicpICsnLyc7XG4gIH1lbHNlIGlmKGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQpe1xuICAgIGNvbnN0IGxpID0gaW5pdE1vZHVsZVN0YXRlLm1vZHVsZVNjcmlwdC5zcmMuc3BsaXQoJy8nKTtcbiAgICBsaS5wb3AoKTtcbiAgICBpbml0TW9kdWxlU3RhdGUuc3FsaXRlM0RpciA9IGxpLmpvaW4oJy8nKSArICcvJztcbiAgfVxuXG4gIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGUgPSBmdW5jdGlvbiBmZiguLi5hcmdzKXtcbiAgICBcbiAgICByZXR1cm4gb3JpZ2luYWxJbml0KC4uLmFyZ3MpLnRoZW4oKEVtc2NyaXB0ZW5Nb2R1bGUpPT57XG4gICAgICBcbiAgICAgIGNvbnN0IHMgPSBFbXNjcmlwdGVuTW9kdWxlLnNxbGl0ZTM7XG4gICAgICBzLnNjcmlwdEluZm8gPSBpbml0TW9kdWxlU3RhdGU7XG4gICAgICBcbiAgICAgIGlmKGZmLl9faXNVbmRlclRlc3QpIHMuX19pc1VuZGVyVGVzdCA9IHRydWU7XG4gICAgICBjb25zdCBmID0gcy5hc3luY1Bvc3RJbml0O1xuICAgICAgZGVsZXRlIHMuYXN5bmNQb3N0SW5pdDtcbiAgICAgIHJldHVybiBmKCk7XG4gICAgfSkuY2F0Y2goKGUpPT57XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXhjZXB0aW9uIGxvYWRpbmcgc3FsaXRlMyBtb2R1bGU6XCIsZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9O1xuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlLnJlYWR5ID0gb3JpZ2luYWxJbml0LnJlYWR5O1xuXG4gIGlmKGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQpe1xuICAgIGNvbnN0IHNpbSA9IGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZTtcbiAgICBsZXQgc3JjID0gc2ltLm1vZHVsZVNjcmlwdC5zcmMuc3BsaXQoJy8nKTtcbiAgICBzcmMucG9wKCk7XG4gICAgc2ltLnNjcmlwdERpciA9IHNyYy5qb2luKCcvJykgKyAnLyc7XG4gIH1cbiAgaW5pdE1vZHVsZVN0YXRlLmRlYnVnTW9kdWxlKCdzcWxpdGUzSW5pdE1vZHVsZVN0YXRlID0nLGluaXRNb2R1bGVTdGF0ZSk7XG4gIGlmKDApe1xuICAgIGNvbnNvbGUud2FybihcIlJlcGxhY2VkIHNxbGl0ZTNJbml0TW9kdWxlKClcIik7XG4gICAgY29uc29sZS53YXJuKFwiZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmID1cIixnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYpO1xuICAgIGlmKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZG9jdW1lbnQpe1xuICAgICAgY29uc29sZS53YXJuKFwiZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgPVwiLFxuICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Py5jdXJyZW50U2NyaXB0Py5zcmMpO1xuICAgIH1cbiAgfVxuXG5cblxuICBcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jyl7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzcWxpdGUzSW5pdE1vZHVsZTtcbiAgfWVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jyl7XG4gICAgZXhwb3J0c1tcInNxbGl0ZTNJbml0TW9kdWxlXCJdID0gc3FsaXRlM0luaXRNb2R1bGU7XG4gIH1cbiAgXG4gIHJldHVybiBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlIDtcbn0pKCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfaHR0cHNfcmF3X2dpdGhhY2tfY29tX2RlbmlzX21pZ2RhbF9MSVNTX21haW5faW5kZXhfanNfYmI2YTNjYWVfXzsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwidmFyIHdlYnBhY2tRdWV1ZXMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2woXCJ3ZWJwYWNrIHF1ZXVlc1wiKSA6IFwiX193ZWJwYWNrX3F1ZXVlc19fXCI7XG52YXIgd2VicGFja0V4cG9ydHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2woXCJ3ZWJwYWNrIGV4cG9ydHNcIikgOiBcIl9fd2VicGFja19leHBvcnRzX19cIjtcbnZhciB3ZWJwYWNrRXJyb3IgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2woXCJ3ZWJwYWNrIGVycm9yXCIpIDogXCJfX3dlYnBhY2tfZXJyb3JfX1wiO1xudmFyIHJlc29sdmVRdWV1ZSA9IChxdWV1ZSkgPT4ge1xuXHRpZihxdWV1ZSAmJiBxdWV1ZS5kIDwgMSkge1xuXHRcdHF1ZXVlLmQgPSAxO1xuXHRcdHF1ZXVlLmZvckVhY2goKGZuKSA9PiAoZm4uci0tKSk7XG5cdFx0cXVldWUuZm9yRWFjaCgoZm4pID0+IChmbi5yLS0gPyBmbi5yKysgOiBmbigpKSk7XG5cdH1cbn1cbnZhciB3cmFwRGVwcyA9IChkZXBzKSA9PiAoZGVwcy5tYXAoKGRlcCkgPT4ge1xuXHRpZihkZXAgIT09IG51bGwgJiYgdHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIikge1xuXHRcdGlmKGRlcFt3ZWJwYWNrUXVldWVzXSkgcmV0dXJuIGRlcDtcblx0XHRpZihkZXAudGhlbikge1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0XHRxdWV1ZS5kID0gMDtcblx0XHRcdGRlcC50aGVuKChyKSA9PiB7XG5cdFx0XHRcdG9ialt3ZWJwYWNrRXhwb3J0c10gPSByO1xuXHRcdFx0XHRyZXNvbHZlUXVldWUocXVldWUpO1xuXHRcdFx0fSwgKGUpID0+IHtcblx0XHRcdFx0b2JqW3dlYnBhY2tFcnJvcl0gPSBlO1xuXHRcdFx0XHRyZXNvbHZlUXVldWUocXVldWUpO1xuXHRcdFx0fSk7XG5cdFx0XHR2YXIgb2JqID0ge307XG5cdFx0XHRvYmpbd2VicGFja1F1ZXVlc10gPSAoZm4pID0+IChmbihxdWV1ZSkpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9XG5cdH1cblx0dmFyIHJldCA9IHt9O1xuXHRyZXRbd2VicGFja1F1ZXVlc10gPSB4ID0+IHt9O1xuXHRyZXRbd2VicGFja0V4cG9ydHNdID0gZGVwO1xuXHRyZXR1cm4gcmV0O1xufSkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5hID0gKG1vZHVsZSwgYm9keSwgaGFzQXdhaXQpID0+IHtcblx0dmFyIHF1ZXVlO1xuXHRoYXNBd2FpdCAmJiAoKHF1ZXVlID0gW10pLmQgPSAtMSk7XG5cdHZhciBkZXBRdWV1ZXMgPSBuZXcgU2V0KCk7XG5cdHZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHM7XG5cdHZhciBjdXJyZW50RGVwcztcblx0dmFyIG91dGVyUmVzb2x2ZTtcblx0dmFyIHJlamVjdDtcblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqKSA9PiB7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHRcdG91dGVyUmVzb2x2ZSA9IHJlc29sdmU7XG5cdH0pO1xuXHRwcm9taXNlW3dlYnBhY2tFeHBvcnRzXSA9IGV4cG9ydHM7XG5cdHByb21pc2Vbd2VicGFja1F1ZXVlc10gPSAoZm4pID0+IChxdWV1ZSAmJiBmbihxdWV1ZSksIGRlcFF1ZXVlcy5mb3JFYWNoKGZuKSwgcHJvbWlzZVtcImNhdGNoXCJdKHggPT4ge30pKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBwcm9taXNlO1xuXHRib2R5KChkZXBzKSA9PiB7XG5cdFx0Y3VycmVudERlcHMgPSB3cmFwRGVwcyhkZXBzKTtcblx0XHR2YXIgZm47XG5cdFx0dmFyIGdldFJlc3VsdCA9ICgpID0+IChjdXJyZW50RGVwcy5tYXAoKGQpID0+IHtcblx0XHRcdGlmKGRbd2VicGFja0Vycm9yXSkgdGhyb3cgZFt3ZWJwYWNrRXJyb3JdO1xuXHRcdFx0cmV0dXJuIGRbd2VicGFja0V4cG9ydHNdO1xuXHRcdH0pKVxuXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdGZuID0gKCkgPT4gKHJlc29sdmUoZ2V0UmVzdWx0KSk7XG5cdFx0XHRmbi5yID0gMDtcblx0XHRcdHZhciBmblF1ZXVlID0gKHEpID0+IChxICE9PSBxdWV1ZSAmJiAhZGVwUXVldWVzLmhhcyhxKSAmJiAoZGVwUXVldWVzLmFkZChxKSwgcSAmJiAhcS5kICYmIChmbi5yKyssIHEucHVzaChmbikpKSk7XG5cdFx0XHRjdXJyZW50RGVwcy5tYXAoKGRlcCkgPT4gKGRlcFt3ZWJwYWNrUXVldWVzXShmblF1ZXVlKSkpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBmbi5yID8gcHJvbWlzZSA6IGdldFJlc3VsdCgpO1xuXHR9LCAoZXJyKSA9PiAoKGVyciA/IHJlamVjdChwcm9taXNlW3dlYnBhY2tFcnJvcl0gPSBlcnIpIDogb3V0ZXJSZXNvbHZlKGV4cG9ydHMpKSwgcmVzb2x2ZVF1ZXVlKHF1ZXVlKSkpO1xuXHRxdWV1ZSAmJiBxdWV1ZS5kIDwgMCAmJiAocXVldWUuZCA9IDApO1xufTsiLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgdXNlZCAnbW9kdWxlJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvcGFnZXMvUiAxLTAyIEJhc2VzIGRlIERvbm7DqWVzIFJlbGF0aW9ubmVsbGVzIDEvQ00vaW5kZXgudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvcGFnZXMvUiAxLTAyIEJhc2VzIGRlIERvbm7DqWVzIFJlbGF0aW9ubmVsbGVzIDEvQ00vaW5kZXguY3NzXCIpO1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvcGFnZXMvUiAxLTAyIEJhc2VzIGRlIERvbm7DqWVzIFJlbGF0aW9ubmVsbGVzIDEvQ00vaW5kZXgubWRcIik7XG4iLCIiXSwibmFtZXMiOlsibWFpbiIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImhlYWRlciIsInRpdGxlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJodHJlZSIsImh0bWwiLCJsZXZlbCIsInBhcmVudCIsImNoaWxkcmVuIiwiaHRyZWVfY3Vyc29yIiwidGl0bGUiLCJ0YWdOYW1lIiwic2xpY2UiLCJlbGVtIiwicHVzaCIsInNlYXJjaEN1ckhlYWRlciIsInBvc2l0aW9uIiwiaGVhZGVycyIsImkiLCJsZW5ndGgiLCJvZmZzZXRUb3AiLCJoaWQiLCJnZXRUaXRsZVByZWZpeCIsInMiLCJpZHgiLCJpbmRleE9mIiwibnVtIiwiYnVpbGRNZW51Iiwibm9kZXMiLCJtZW51IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImFwcGVuZCIsIm1hcCIsIml0ZW0iLCJ0ZXh0Q29udGVudCIsInNldEF0dHJpYnV0ZSIsImlkIiwidXBkYXRlSGVhZGVyIiwibGFzdCIsInNjcm9sbFRvcCIsImN1cnNvciIsInJldmVyc2UiLCJobm9kZSIsImgiLCJoX2h0bWwiLCJsaW5rIiwiZW1wdHkiLCJyZXBsYWNlQ2hpbGRyZW4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVxdWlyZSIsInNxbGl0ZTMiLCJvbzEiLCJqczJzcWwiLCJ2YWx1ZSIsIkVycm9yIiwiREIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJkZXNjIiwiZXhlYyIsImZ1bGxSZXNldCIsImNvbHMiLCJPYmplY3QiLCJlbnRyaWVzIiwic2NoZW1hIiwidHlwZSIsImpvaW4iLCJjb25zdHJhaW50cyIsInZhbHVlcyIsImUiLCJjIiwicmVzZXRUYWJsZSIsIlNldCIsInJlc2V0IiwiaGFzIiwiY2xlYXIiLCJuYW1lcyIsImtleXMiLCJ0YWJsZSIsInNxbCIsInR5cGVzIiwic3FsX3R5cGUiLCJmaW5kIiwidiIsInN0YXJ0c1dpdGgiLCJzdGFydF9wb3MiLCJlbmRfcG9zIiwidGFibGVfbmFtZSIsImV4ZWNfb25lIiwic2VsZWN0T2JqZWN0cyIsImV4ZWNfbWFueSIsInJlc3VsdHMiLCJjb25zb2xlIiwid2FybiIsIm1lc3NhZ2UiLCJzcGxpdCIsImRiMiIsIlVzZXJzIiwiSUQiLCJOb20iLCJQcmVub20iLCJBZ2UiLCJQcm9kdWl0cyIsIkRhdGUiLCJSZWYiLCJRIiwiVDEiLCJUMiJdLCJzb3VyY2VSb290IjoiIn0=