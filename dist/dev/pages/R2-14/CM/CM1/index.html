<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf8"/>
        <title>CM1 (AdmSys)</title>
        <meta name="color-scheme" content="dark light">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link rel="stylesheet" href="./index.css">
        <script type="module" src="./index.js" blocking="render"></script>
    </head>
    <body class="hide_h1">
        <header></header>
        <main>

<h1 id="commandes-shell">Commandes SHELL</h1>
<h2 id="introduction">Introduction</h2>
<h3 id="pourquoi-administrer-un-syst√®me-">Pourquoi administrer un syst√®me ?</h3>
<p>L&#39;administration d&#39;un ordinateur a (entre autres) pour objectifs :</p>
<ul>
<li>d&#39;installer et de configurer les outils n√©cessaire √† vos usages ;</li>
<li>programmer (<em>schedule</em>) et automatiser des s√©ries d&#39;actions (e.g. sauvegardes, g√©n√©rations de rapports, etc).</li>
</ul>
<p>Dans le cadre de votre formation, ce module vous permettra :</p>
<ul>
<li>d&#39;acqu√©rir des notions de cybers√©curit√© relatives au fonctionnement d&#39;un ordinateur ;</li>
<li>d&#39;utiliser certains outils m√©tiers (e.g. serveurs de calculs) ;</li>
<li>personnaliser et administrer votre poste de travail ou un serveur (e.g. dans une PME).</li>
</ul>
<p>Ce module se concentrera sur le syst√®me d&#39;exploitation Linux. En effet, si Windows domine les parts de march√©s pour les ordinateurs de bureaux (69% contre 4,5% pour Linux), Linux est majoritaire sur les serveurs (96,4%), et les mobiles (71% avec Android). Linux est aussi tr√®s utilis√© comme poste de travail par les d√©veloppeurs.</p>
<p>En effet les serveurs sont tr√®s utiles dans le cadre de vos activit√©s (notamment pour effectuer des calculs intensifs) :</p>
<ul>
<li>ils restent allum√©s h24 7j/7, avec des protections en cas de coupures d&#39;√©lectricit√© (e.g. onduleur).</li>
<li>ils ont des capacit√©s bien sup√©rieures √† un poste de travail classique (e.g. 100+ CPU, 1To+ de RAM, etc).</li>
<li>ils mutualisent des ressources (CPU/RAM/licences logicielles) entre plusieurs utilisateurs.</li>
<li>ils fournissent des services sans avoir √† les installer sur le poste de travail (e.g. Intranet, webmails, etc.).</li>
<li>ils permettent de synchroniser des donn√©es entre plusieurs postes de travail (e.g. serveur de fichiers).</li>
<li>etc.</li>
</ul>
<p>Dans le cadre de ce module, il ne vous sera pas demand√© de retenir les √©tapes de configurations par coeur, mais d&#39;√™tre capable de suivre des s√©ries d&#39;instructions, en comprenant ce que vous faites, leur effets et raisons. Vous devrez ainsi :</p>
<ul>
<li>comprendre les diff√©rents concepts pr√©sent√©s dans ce module ;</li>
<li>√™tre capable d&#39;exploiter les documents fournis (e.g. cheat sheet) ;</li>
<li>faire preuve de rigueur et de m√©thode.</li>
</ul>
<h3 id="repl-et-scripts">REPL et scripts</h3>
<p>Dans le cadre de vos cours pr√©c√©dents, vous avez d√©j√† manipul√© plusieurs langages de scripts (R, Python, SQL). Vous utilisiez alors un interpr√©teur (Rscript, python3, sqlite3) pour ex√©cuter des instructions √©crites dans ces langages.</p>
<p>En Python, vous saisissiez vos instructions dans un fichier <script type="c-text">.py</script> qui √©tait lu et ex√©cut√© par l&#39;interpr√©teur Python. On parlait alors de <em>script Python</em>.</p>
<p>En revanche, en SQL, vous utilisiez une interface <em>REPL</em> (<em>Read-Eval-Print Loop</em>). Vous √©criviez alors une ligne que sqlite3 lisait (<em>read</em>), interpr√©tait (<em>eval</em>), puis vous en affichait le r√©sultat (<em>print</em>). Apr√®s chaque ex√©cution, l&#39;interpr√©teur vous affichait une <strong>invite</strong> (ici <script type="c-text">sqlite> </script>) pour vous indiquer que vous pouviez saisir une nouvelle instruction :</p>
<script type="c-text">
    sqlite> SELECT 1+1 as result;
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ result ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ 2      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    sqlite> 
</script>

<p>Les interpr√©teurs supportent bien souvent ces deux modes (scripts et REPL). Il est par exemple tout √† fait possible de donner un fichier SQL √† sqlite3, ou de lancer python3 en mode REPL :</p>
<script type="c-python">
    >>> print("Hello")
    Hello
</script>

<p>Pour administrer un syst√®me Linux, on utilise principalement <em>Shell</em> (un autre langage de script), avec l&#39;interpr√©teur shell <em>Bash</em>. Comme pour les autres langages de script, il est possible de l&#39;utiliser avec des <em>scripts Shell</em>, mais aussi via une interface REPL.</p>
<p>Cependant, le vocabulaire sera l√©g√®rement diff√©rent. On parlera de :</p>
<ul>
<li><em>ligne de commande</em> pour la ligne saisie puis lue par l&#39;interpr√©teur ;</li>
<li><em>invite de commande</em> (<em>prompt</em>) pour l&#39;invite ;</li>
<li><em>interface en lignes de commande</em> (<em>CLI</em>) pour l&#39;interface REPL.</li>
</ul>
<h3 id="pourquoi-les-lignes-de-commandes-">Pourquoi les lignes de commandes ?</h3>
<p>On distingue 3 mani√®res d&#39;int√©ragir avec un ordinateur :</p>
<ul>
<li><strong>CLI</strong> : interface <em>en lignes de commande</em> (<em>Command Line Interface</em>) ;</li>
<li><strong>GUI</strong> : interface <em>graphique</em> (<em>Graphical User Interface</em>) ;</li>
<li><strong>TUI</strong> : interface <em>textuelle</em> (<em>Text-based User Interface</em>).</li>
</ul>
<p>Pourquoi donc administrer un ordinateur en lignes de commande, plut√¥t que d&#39;utiliser une interface graphique ?</p>
<p>La raison premi√®re est tout simplement qu&#39;il n&#39;y a pas n√©cessairement d&#39;interfaces graphiques install√©es sur l&#39;ordinateur. C&#39;est le g√©n√©ralement cas pour les serveurs afin d&#39;en √©conomiser les ressources (GPU/CPU/RAM/r√©seau) et de r√©duire les surfaces d&#39;attaques.</p>
<p>De plus, les interfaces en lignes de commandes comportent de nombreux avantages par rapport aux interfaces graphiques :</p>
<ul>
<li>on peut copier/coller des lignes de commandes (c&#39;est du texte).</li>
<li>les lignes de commandes sont ind√©pendantes de la langue de l&#39;utilisateur (i.e. pas de traductions).</li>
<li>on a toute la puissance qu&#39;offre un langage de programmation (variables, conditions, boucles, etc).</li>
<li>on peut automatiser une s√©rie d&#39;instructions en enregistrant les lignes de commandes dans un fichier (script).</li>
</ul>
<h2 id="le-shell">Le Shell</h2>
<h3 id="la-ligne-de-commande">La ligne de commande</h3>
<p>Une ligne de commande est une mani√®re de formuler, par le biais d&#39;une ligne de texte, une instruction √† ex√©cuter. Elle est assimilable √† l&#39;appel d&#39;une fonction, avec :</p>
<ul>
<li>une <strong>commande</strong> √† ex√©cuter (‚âà une fonction √† ex√©cuter) ;</li>
<li>des <strong>arguments</strong> pass√©s en param√®tres de la commande.</li>
</ul>
<p>üïÆ Les <strong>arguments</strong> sont les <em>valeurs</em> qu&#39;on transmets (appel) aux <strong>param√®tres</strong> d&#39;une commande/fonction (d√©finition).</p>
<p>Sa syntaxe est cependant diff√©rente des appels de fonction dont vous avez l&#39;habitude en R ou en Python. En effet, les diff√©rents √©l√©ments ne sont pas s√©par√©s par une virgule, mais par un espace :</p>
<ul>
<li><i>Fonction python :</i> <script type="c-python">foo(1, 2, 3)</script> ;</li>
<li><i>Ligne de commande :</i> <script type="c-bash">foo 1 2 3</script>.</li>
</ul>
<p>Quand l&#39;ordinateur interpr√®te une ligne de commande, il ex√©cute la commande indiqu√©e par le premier √©l√©ment, en lui transmettant les arguments sous la forme d&#39;une liste.</p>
<h3 id="les-commandes">Les commandes</h3>
<p>En soit, une commande n&#39;est rien de plus qu&#39;un ex√©cutable (i.e. un script ou un programme). Vous pouvez ainsi cr√©er une commande en √©crivant un simple script Python :</p>
<script type="c-python">
    #!/usr/bin/env -S python3
    import sys

    print('args', sys.argv) # liste des arguments de la ligne de commande.
</script>

<p>‚ö† <script type="c-python">sys.argv[0]</script> est le nom de la commande.</p>
<script type="c-shell">
    $ foo 1 2 3
    args ['foo', '1', '2', '3']
</script>

<p>Vous noterez la premi√®re ligne un peu bizarre du script :</p>
<script type="c-python">
    #!/usr/bin/env -S python3
</script>

<p>Cette ligne est le <strong>Shebang</strong>. Il permet d&#39;indiquer √† l&#39;ordinateur quel interpr√©teur utiliser pour ex√©cuter le script (ici python3).<br/>
Il est aussi possible d&#39;indiquer des arguments √† transmettre √† l&#39;interpr√©teur :</p>
<script type="c-python">
    #!/usr/bin/env -S <h>$INTERPRETEUR</h> <h>[$INTERPRETEUR_ARGS...]</h>
</script>

<h3 id="les-arguments">Les arguments</h3>
<p>Comme nous l&#39;avons vu, une commande re√ßoit ses diff√©rents arguments sous la forme d&#39;un tableau. Elle peut ensuite les interpr√©ter de mani√®re totalement arbitraire.</p>
<p>Il est cependant pr√©f√©rable d&#39;utiliser une biblioth√®que d√©di√©e (e.g. <a href="https://docs.python.org/3/library/argparse.html">argparse</a> en Python) qui fournira diverses fonctionnalit√©s :</p>
<ul>
<li>interpr√©tation des arguments (<em>arguments parsing</em>) ;</li>
<li>d√©tection et affichage des erreurs dans l&#39;usage de la commande ;</li>
<li>g√©n√©ration automatique de la documentation de la commande.</li>
</ul>
<p>Il suffit alors de d√©clarer les diff√©rents arguments de la commande et la biblioth√®que se chargera alors du reste :</p>
<script type="c-python">
    import sys
    from argparse import ArgumentParser

    parser = ArgumentParser()

    # d√©clarer ici les arguments de la commande

    args = parser.parse_args(sys.argv[1:])
    print(args) # les arguments apr√®s interpr√©tation
</script>

<p>Les arguments/param√®tres <strong>positionnels</strong> suivent le m√™me principe qu&#39;en Python : le i-√®me argument positionnel est mis dans le i-√®me param√®tre positionnel. Avec <a href="https://docs.python.org/3/library/argparse.html">argparse</a>, ils se d√©clarent ainsi :</p>
<div class="flex-2">
    <script type="c-python">
        parser.add_argument("src")
        parser.add_argument("dst")
    </script>
    <script type="c-shell">
        $ foo 1 2
        Namespace(src='1', dst='2')
    </script>
</div>

<p>De m√™me, les arguments/param√®tres <strong>nomm√©s</strong> fonctionnent de la m√™me mani√®re qu&#39;en Python. Ils ont cependant une syntaxe diff√©rente : <script type="c-bash">--<h>$NAME</h> <h>$VALUE</h></script> ou <script type="c-bash">--<h>$NAME</h>=<h>$VALUE</h></script>. Avec <a href="https://docs.python.org/3/library/argparse.html">argparse</a>, ils se d√©clarent ainsi :</p>
<div class="flex-2">
    <script type="c-python">
        parser.add_argument("--faa")
        parser.add_argument("--fuu")
    </script>
    <script type="c-shell">
        $ foo --fuu 42 --faa=toto
        Namespace(faa='toto', fuu='42')
    </script>
</div>

<p>Petite nouveaut√©, les drapeaux (<em>flags</em>), o√π les param√®tres sont des bool√©ans mis √† vrai ou faux en fonction de la pr√©sence de l&#39;argument. Avec <a href="https://docs.python.org/3/library/argparse.html">argparse</a>, ils se d√©clarent ainsi :</p>
<div class="flex-2">
    <script type="c-python">
        parser.add_argument("--list",
                            action="store_true")
        parser.add_argument("--human",
                            action="store_true")
    </script>
    <script type="c-shell">
        $ foo --list
        Namespace(list=True, human=False)
        $ foo --list --human
        Namespace(list=True, human=True)
    </script>
</div>

<p>Il est aussi possible d&#39;associer une lettre √† un param√®tre. Il est alors possible de fusionner les arguments de drapeaux :</p>
<div class="flex-2">
    <script type="c-python">
        parser.add_argument("-l", "--list",
                            action="store_true")
        parser.add_argument("-H", "--human",
                            action="store_true")
    </script>
    <script type="c-shell">
        $ foo -l
        Namespace(list=True, human=False)
        $ foo -lH
        Namespace(list=True, human=True)
    </script>
</div>

<p>Une fois les param√®tres d√©clar√©s, vous pouvez alors utiliser la commande et en afficher l&#39;usage :</p>
<script type="c-shell">
$ foo --help
usage: foo [-h] [--faa FAA] [--fuu FUU] [-l] [-H] src dst

positional arguments:
  src
  dst

options:
  -h, --help   show this help message and exit
  --faa FAA
  --fuu FUU
  -l, --list
  -H, --human
</script>

<p>üí° <script type="c-text">[]</script> indique le caract√®re facultatif d&#39;un argument.</p>
<p>üí° <script type="c-python">add_argument()</script> a de nombreux autres arguments notamment :</p>
<ul>
<li><script type="c-python">help</script> pour ajouter une description au param√®tre qui s'affichera dans l'usage.</li>
<li><script type="c-python">type</script> pour convertir l'argument en un type python (e.g. bool√©en, int, etc).</li>
<li><script type="c-python">choices</script> pour fixer les valeurs possibles pour l'argument.</li>
<li><script type="c-python">default</script> pour fixer une valeur par d√©faut si l'argument n'est pas fourni.</li>
<li><script type="c-python">required</script> pour indiquer si l'argument est requis.</li>
</ul>
<p>üí° <a href="https://docs.python.org/3/library/argparse.html">argparse</a> a encore bien d&#39;autres options que vous pourrez d√©couvrir en lisant sa documentation.</p>
<h3 id="espaces-dans-les-arguments">Espaces dans les arguments</h3>
<p>Pour inclure un espace dans un argument, il convient de soit les √©chapper, soit de mettre le texte entre guillements simples :</p>
<script type="c-shell">
$ foo 'a b' c\ d
Namespace(src='a b', dst='c d')
</script>

<p>üí° Il est aussi possible de ne mettre qu&#39;une partie de l&#39;argument entre guillements :</p>
<script type="c-shell">
$ foo a' 'b c\ d
Namespace(src='a b', dst='c d')
</script>

<p>üí° <script type="c-bash">$'<h>$TXT</h>'</script> permet d&#39;interpr√©ter les caract√®res √©chapp√©s, e.g. :</p>
<ul>
<li><script type="c-text">\n</script> : retour √† la ligne ;</li>
<li><script type="c-text">\t</script> : tabulation ;</li>
<li><script type="c-text">\e</script> : pour le formattage du texte (cf TP).</li>
</ul>
<script type="c-python">
    #¬†commande faa :
    print( sys.argv[1] )
</script>

<div class="flex-2">
    <script type="c-shell">
        $ faa '-\n\t-'
        -\n\t-
    </script>
    <script type="c-shell">
        $ faa $'-\n\t-'
        -
            -
    </script>
</div>

<h2 id="tui-terminal-et-shell">TUI, Terminal, et Shell</h2>
<p>Term vs shell
TUI ?</p>
<p>Transformation des arguments</p>
<p>Usage du shell/terminal</p>
<h2 id="quelques-commandes-de-bases">Quelques commandes de bases</h2>
<h3 id="attendus-rappeler-cmd">Attendus (rappeler cmd)</h3>
<p>Objectif</p>
<ul>
<li>liste d&#39;√©tapes : √™tre capable de suivre rigoureusement des instruction √† partir des documents fournis (sujet, cheat sheet, etc).</li>
<li>pour cela comprendre les concepts sous-jacent / ce que vous faites, sans savoir tout par coeur.</li>
<li>.</li>
</ul>
<p>Il est attendu de vous que vous soyez capable de suivre de mani√®re <strong>rigoureuse</strong> des instructions </p>
<p>=&gt; concept vs par coeur comment faire.
=&gt; comp√©tences (aide docs/cheat sheet) vs connaissances par coeur.
=&gt; suivre instructions</p>
<h2 id="y">Y</h2>
<p>xxx</p>
<p>Contrairement √† une application graphique, qui regroupe un ensemble de fonctionnalit√©s coh√©rentes, chaque commande ne fait qu&#39;une seule chose, mais le fait bien. Par exemple, un logiciel graphique d&#39;administration de serveurs fournira diverses fonctionnalit√©s pour e.g. :</p>
<ul>
<li>obtenir la liste des serveurs ;</li>
<li>obtenir l&#39;√©tat d&#39;un serveur donn√© ;</li>
<li>d√©marrer un serveur donn√© ;</li>
<li>mettre √† jour un serveur ;</li>
<li>etc.</li>
</ul>
<p>=&gt; pareil que fonctions.
Dans le cadre d&#39;une interface en ligne de commande, chacune de ces fonctionnalit√©s correspondra √† une commande. Il est alors possible d&#39;automatiser une s√©rie d&#39;actions, e.g. d√©marrer, mettre √† jour, puis √©teindre un serveur donn√© :</p>
<script type="c-python">
    sid = 1

    server_start (sid)
    server_update(sid)
    server_stop  (sid)
</script>


<p>-&gt; cha√Æner et param√©trer (pas vu ici). =&gt; S4 Test et auto en prog.</p>
<p>-&gt; ajouter une option ais√©e :
    --x -x
    doc.
    dictionnaire associatif
    et traiter.
    pas de mise en page, d&#39;√©cran trop charg√© ou autre.</p>
<h2 id="x">X</h2>
<p>üí° Pour effectuer certaines actions, un executable peut utiliser des biblioth√®ques, mais aussi appeler d&#39;autres commandes :</p>
<script type="c-python">
    # Dans un script Python, ex√©cuter la ligne de commande "foo 1 2 3".
    print( shell_exec("foo 1 2 3") )
</script>

<details>
    <summary>Cliquez pour afficher l'impl√©mentation de <script type="c-python">shell_exec()</script></summary>
    <script type="c-python">
        from subprocess import run
        #
        def shell_exec(cmd, input=None,  env=None):
            return run(cmd, input=input, env=env,
                        executable="/usr/bin/bash",
                        capture_output=True, text=True, shell=True, check=True)
    </script>
</details>

<h3 id="r√©√©critures-de-la-ligne-de-commande-alias--tard">R√©√©critures de la ligne de commande (alias + tard)</h3>
<p>Avant d&#39;ex√©cuter la ligne de commande, le shell (Bash) proc√®de √©ventuellement √† quelques r√©√©critures de la ligne de commande. La commande <script type="c-bash">set -x</script> permet d&#39;afficher la ligne de commande r√©ellement ex√©cut√©e (<script type="c-bash">set +x</script> pour annuler) :</p>
<script type='c-shell'>
$ set -x
$ foo a b
+ foo a b
</script>

<p>üí° <script type="c-bash">set -x</script> est aussi utilis√© pour d√©boguer les scripts shell, en affichant l&#39;execution du script pas √† pas.</p>
<p>Cela est par exemple le cas lorsqu&#39;on utilise des <em>alias</em>, </p>
<ul>
<li>alias (unalias) + liste</li>
</ul>
</main>
    </body>
</html>