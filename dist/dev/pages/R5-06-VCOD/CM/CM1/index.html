<!DOCTYPE html>
<html>
    <head>
        <title>CM1 (Dev Log)</title>
        <link rel="stylesheet" href="./index.css">
        <script type="module" src="./index.js" defer></script>
    </head>
    <body>
        <style>
        </style>
        <header></header>
        <main>

<p>⚠ [Draft] Document en cours de rédaction.</p>
<h1 id="motivations-au-développement-logiciel">Motivations au développement logiciel</h1>
<h2 id="trouver-son-chemin">Trouver son chemin</h2>
<p>-&gt; Problème -&gt; Solution : si seulement c&#39;était aussi simple...</p>
<ul>
<li>plusieurs solutions possibles</li>
<li>et plusieurs chemins pour arriver à un même résultat.</li>
</ul>
<p>-&gt; comment choisir la &quot;bonne&quot; solution et le &quot;bon&quot; chemin approprié aux besoins actuels et futurs ?</p>
<h3 id="que-faire">Que faire</h3>
<p>-&gt; quels sont déjà nos réels besoins actuels et futurs ?</p>
<p>Les envies : je veux une fonctionnalité, corriger un bug, etc.
Est-ce :</p>
<ol>
<li>utiles (besoins) : est-ce réellement utile ?</li>
<li>réalisables (à faire) : est-ce utile et réaliste en considérant les ressources disponibles ?</li>
<li>prioritaires (que faire) :</li>
</ol>
<p>-&gt; gestion de projet, de planning, etc.</p>
<h3 id="comment-faire">Comment faire</h3>
<ul>
<li>comment (bien le) faire [avec quoi] ?</li>
<li>comment vérifier que c&#39;est (bien) fait ?</li>
</ul>
<p>-&gt; que signifie &quot;bien&quot; fait ?
-&gt; bons principe de développement
-&gt; pipeline de développement</p>
<h3 id="contexte">Contexte</h3>
<p>Tous les projets sont différent avec des contextes différents :</p>
<ul>
<li>contraintes : deadline, qualité, garanties</li>
<li>ressources : temps, personnes</li>
</ul>
<p>Il n&#39;y a pas d&#39;absolu dans le développement logiciels et la gestion de projets. Tout dépend du contexte, et une règle approprié dans un contexte ne le sera pas nécessairement dans un autre.</p>
<p>Par exemple, un code produit en 2 minutes dans le cadre d&#39;un exercice de TP n&#39;a pas les mêmes besoins en qualité, tests, etc. qu&#39;un code critique pour une centrale nucléaire.</p>
<p>Différents types de contextes :</p>
<ul>
<li>développé à plusieurs :<ul>
<li>organiser l&#39;équipe (gestion de projet / pipeline de dev)</li>
<li>communiquer (documentation/UML).</li>
</ul>
</li>
<li>utilisé par un tiers :<ul>
<li>stabilité, évolutions/besoins futurs, maintenance</li>
</ul>
</li>
<li>commandité par un tier : relation contractuelle (CdC = contract)<ul>
<li>commandité : apporter des garanties travail bien réalisé</li>
<li>commanditaire : expliciter ce qu&#39;il demande.</li>
</ul>
</li>
</ul>
<h2 id="autres-à-trier">Autres (à trier)</h2>
<ul>
<li>architecture</li>
</ul>
<p><a href="https://fr.wikipedia.org/wiki/Qualit%C3%A9_logicielle">https://fr.wikipedia.org/wiki/Qualit%C3%A9_logicielle</a></p>
<p><a href="https://fr.wikipedia.org/wiki/Qualit%C3%A9_logicielle#Indicateurs_de_qualit%C3%A9_logicielle">https://fr.wikipedia.org/wiki/Qualit%C3%A9_logicielle#Indicateurs_de_qualit%C3%A9_logicielle</a></p>
<ul>
<li><p>Maintenance Optimisation de code Réusinage de code (Règle de trois)</p>
</li>
<li><p>pipeline de dev (write - build - test - bundle - distribute).</p>
</li>
<li><p>Exceptions vs Errors values
  -&gt; if no strongly typed : may miss error value
  -&gt; if Exceptions : may miss to handle this Exception
  -&gt; Exception : exceptionnel : e.g. bad usage, should not occurs.</p>
</li>
<li><p>pure fonctions</p>
</li>
<li><p>codé rapidement</p>
<ul>
<li>réutiliser existant (ext). [-&gt; DRY]</li>
<li>réutiliser son propre code
  -&gt; valeur immutable
  -&gt; (aussi sémantique vs structure - e.g. Resultats -&gt; Dict&lt;string, any&gt;[] ).
  - impl et &quot;est-un/instanceof&quot; pour distinguer.</li>
</ul>
</li>
<li><p>interrop (code / modules / API-lib / autres logiciels)
  -&gt; représenter données ou API.</p>
</li>
<li><p>extensible/refactor sans tout casser + test de non-regressions.</p>
<ul>
<li>MOCK / découper pour manipuler et substituer.</li>
<li>modifier en // : maintenir la version précédente en état de fonctionnement =&gt; cloner le dépôt git si travail local (sérieux - évite checkouts et problème des modifications locales).
  -&gt; tester/comparer + consulter ancien code facilement.
  -&gt; peut avoir un flag pour switch ancienne version/nouvelle version (classe 1 / classe 2 : 2 files.</li>
</ul>
</li>
<li><p>pour un utilisateur : garantir stabilité</p>
<ul>
<li>besoin import/vital ou pas (prioritiser) ?</li>
<li>gérer cas d&#39;exceptions non prévus (ou pas) &lt;- tps + complexité &#39;(effets du bug , perte de data ? vs importance de l&#39;appli / API vs app)</li>
<li>code écrit de manière stable (éviter les bugs) + maintenable (corriger les bugs).</li>
<li>orga   : versions de logiciels pour garantir stabilité (stagging vs prod).
  -&gt; release candidate
  -&gt; v1 vs v1.1</li>
<li>debug : prod vs testing</li>
</ul>
</li>
<li><p>à plusieurs : se coordonner + transmettre/archiver information</p>
<ul>
<li>anticiper imprévus, truc plus dur/ss estimé, absent, etc.</li>
<li>compiler le travail de tout le monde (git).</li>
<li>code lisible/compréhensible par d&#39;autres</li>
<li>documentation + représenter idées pour les partager (UML).</li>
<li>éviter une pers en attente des autres</li>
<li>se répartir les tâches :<ul>
<li>outils : trello / git</li>
</ul>
</li>
</ul>
</li>
<li><p>pour qq d&#39;autres [délégation]  (externe entreprise, interne autre service, ou son patron) : CdC / obligations contractuelles / apporter garanties // exprimer ses besoins [cf next cours]</p>
<ul>
<li>cycles en V / Agile</li>
<li>anticiper changements besoins</li>
<li>prévisionnel</li>
<li>coût / besoins humains / licences [ext].</li>
<li>PoC</li>
<li>tester (TDD/unit test/etc)</li>
</ul>
</li>
</ul>
<p>=&gt; estimations du temps requis souvent mauvaises
    =&gt; imprévus (chose plus difficile qu&#39;il n&#39;y paraît, bug bizarre, etc)
    =&gt; on peut pas penser à tout (à zut y&#39;a d&#39;autres cas à gérer, ça implique de faire ça).</p>
<p>-&gt; utiliser les bons outils : tests différents types (unit, statiques/types checks, etc).</p>
<h2 id="bon-principes-de-développement">Bon principes de développement</h2>
<h3 id="motivation">Motivation</h3>
<ul>
<li>réduire les bugs, facilité leur correction, cela passe par rendre le code lisible.</li>
<li>rendre le dev plus &quot;confortable&quot;/&quot;pratique&quot;, si inconfortable/pas pratique à coder, signe que qq chose ne va pas.</li>
<li>potentiellement un investissement, mais sinon dette technique qui s&#39;accumule. Explose, rapidement impossible à corriger car trop important. D&#39;autant plus si code avec beaucoup d&#39;interdépendances où modifier la moindre chose fait tout exploser.</li>
</ul>
<h3 id="la-trinité">La trinité</h3>
<h4 id="yagni">YAGNI</h4>
<p>YAGNI : &quot;You aren&#39;t gonna need it&quot;</p>
<h4 id="kiss">KISS</h4>
<p>KISS : <a href="https://www.geeksforgeeks.org/kiss-principle-in-software-development/">https://www.geeksforgeeks.org/kiss-principle-in-software-development/</a></p>
<p>[pkoi?]</p>
<p>-&gt; Éviter effets de bords + pas de global state / variables locales.</p>
<p>[KISS même si pas opti :]</p>
<p>-&gt; RO même si non opti
    -&gt; sémantique entité (état interne - p-e une valeur...)
        vs valeur (csnt)...
    -&gt; + si orienté events simplifie</p>
<ul>
<li>Par défaut structures with events constantes (surtout si events/partagés) =&gt; seule la référence change.
  =&gt; pas opti mais plus simple
  =&gt; seulement si BESOIN : complexifier.
  =&gt; uniformiser (notamment events)
  =&gt; 1/60e de seconde GUI : le temps. Lourds calculs, c&#39;est seulement là où on optimise.</li>
</ul>
<h4 id="dry">DRY</h4>
<p>DRY (Don&#39;t repeat yourself) =&gt; sync diff version</p>
<h3 id="solid">SOLID</h3>
<p>SOLID</p>
<ul>
<li>SRP (single resp).
  Single-responsibility principle: &quot;There should never be more than one reason for a class to change.&quot;[2] In other words, every class should have only one responsibility.[3]
  aussi : SOC (séparation des responsabilités)</li>
<li>Open–closed principle: &quot;Software entities ... should be open for extension, but closed for modification.&quot;[4]</li>
<li>Liskov substitution principle: &quot;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.&quot;[5] See also design by contract.[5]</li>
<li>Interface segregation principle: &quot;Clients should not be forced to depend upon interfaces that they do not use.&quot;[6][7]</li>
<li>Dependency inversion principle: &quot;Depend upon abstractions, [not] concretes.&quot;[8][7]</li>
</ul>
<h4 id="tdd--lod">TDD + LOD</h4>
<p>=&gt; écrire top down (~= TDD).
    =&gt; qq chose à montrer + motivant + garantie que c&#39;est utile</p>
<p>=&gt; <del>TDD
    =&gt; main task : to not handle too specific features or anticipate some cases =&gt; write them
    =&gt; [proto] =&gt; it works
    =&gt; refactor
    =&gt; next features (</del>= agile)
    =&gt; parts : potentiellement partir de la fin (affichage) avec fausses données, et remplacer progressivement les fausses données.
    =&gt; Avantage : système complexe conception difficile car trop de choses à prendre en compte, on fait un truc difficile.
    =&gt; le plus feignant possible =&gt; rester simple.
    =&gt; (difficile : anticiper vs direct).</p>
<p>=&gt; abstraction (plusieurs levels of) - code doit être compréhensible en lisant.</p>
<ul>
<li><p>encapsulation (dérive Liskov) : attention pas tout à fait vrai, e.g. SQL opti / git : besoin de comprendre le fonctionnement grossier pour bien utiliser.</p>
<pre><code>  =&gt; éviter de coder des cas d&#x27;utilisations inutiles ou 1% des cas d&#x27;usages quand 90% manquant... =&gt; y&#x27;a plus important
      =&gt; sauf si pas de bug est priorité absolue.
      =&gt; mais possibilité TDD puis revenir dessus pour gérer les cas =&gt; force à rester simple plutôt que de partir sur une solution complexe directement =&gt; parfois compliqué (faut être astucieux).
  =&gt; pareto : 80% =&gt; 20% (temps/fonctions/usages-intérêts)
</code></pre><p>  LOD (level of details) - lié à encapsulation
  -&gt; Pythhon =&gt; Linux =&gt; read binary</p>
</li>
</ul>
<h4 id="optimisations-dans-autres-">Optimisations (dans autres ?)</h4>
<ul>
<li><p>bon résultat / perfs raisonnables (/!\ opti prématurées - impression de gâche mais osef, mais si gratuit/lisible oui).</p>
</li>
<li><p>opti prématuré evil
  -&gt; moins lisibile, gains nuls, perte.
  -&gt; qqs trucs &quot;gratuits&quot;.
  -&gt; où optimiser / comment savoir où optimiser ?
  -&gt; commencer par le plus simple -&gt; optimiser progressivement (et mesurer à chaque fois).</p>
</li>
</ul>
<h4 id="dépendances">Dépendances</h4>
<ul>
<li>décorrélation / inverser les dépendances / interfaces (données vs API).
-&gt; évite de tout casser quand on modifie un bout de code...
  -&gt; a peut être TRÈS VIOLENT
-&gt; composants/éléments aussi indépendants que possibles.</li>
</ul>
<p>=&gt; dépendance ordre de création [code -build- et instantiation -runtime-]
    =&gt; créer une structure qui notifiera lorsque valeur disponible.
    =&gt; ou un callback qui creera le truc lorsque valeur disponible.
=&gt; éviter le cas où je dois exécuter ce fichier avant celui-là : cycles de dépendances...</p>
<h4 id="généricité">Généricité</h4>
<p>=&gt; genericity (permettre l&#39;extension future sans forcément la planifier tout de suite).
    =&gt; mais pas trop anticiper/se projeter dans le futur, lisible, rapide.
        =&gt; besoin futur n&#39;existera p-e pas. 
    =&gt; refactor futur possible (laisser la porte ouverte sans plus).
    =&gt; tradeoff parfois.</p>
<p>exemple avec Float3D.</p>
<h4 id="indenter-le-code-code-lisible">Indenter le code (code lisible)</h4>
<p>-&gt; indenter le code (techniques)
-&gt; éviter documentation redondante avec le code
-&gt; éviter fct trop longues
-&gt; bien nommer, etc.</p>
<ul>
<li>éviter les commentaires à chaque ligne (problème mise à jour) - générer auto + indiquer info nécessaires/git issues/trucs non-triviaux mais pas redondant avec le code.</li>
</ul>
<h2 id="conception--umldpanti-dp">Conception : UML/DP/Anti-DP</h2>
<p>[Motivation]</p>
<h3 id="uml-quick-recap">UML (quick recap)</h3>
<p>Concevoir et Documenter.</p>
<ul>
<li>death by UML/TODO/doc fevers.</li>
<li>nom explicites + architecture de fichiers explicite<ul>
<li>pas tout mettre dans le même fichier, savoir les features à l&#39;arborescence (évite des conflits de version en travail collabo).</li>
</ul>
</li>
</ul>
<h3 id="anti-dp">Anti-DP</h3>
<p>Dev : on a de l&#39;expérience, des choses qui ne marchent pas.</p>
<p>[Extraire une sous-liste]</p>
<h4 id="les-autres-mauvaises-pratiques">Les autres mauvaises pratiques</h4>
<p><a href="https://fr.wikipedia.org/wiki/Antipattern">https://fr.wikipedia.org/wiki/Antipattern</a>
<a href="https://fr.wikipedia.org/wiki/Code_smell">https://fr.wikipedia.org/wiki/Code_smell</a></p>
<h3 id="dp">DP</h3>
<p>[Motivations]</p>
<h4 id="composition">Composition</h4>
<ul>
<li><p>à la place de héritage</p>
</li>
<li><p>Composition vs if/else (si option alors ça alors si =&gt; OptionHandler/Generator/Output) =&gt; + lisible/simple à gérer/modifier/ajouter (évite c/c de code aussi).</p>
<ul>
<li>éviter else. (gérer cas d&#39;erreurs en premier [throw/break/return] + fct + finally).<ul>
<li>tableau assos</li>
<li>valeur =&gt; ternaire</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="adapter">Adapter</h4>
<h4 id="une-section-par-dp-important">Une section par DP important</h4>
<h4 id="les-autres-dp">Les autres DP</h4>
<p><a href="https://fr.wikipedia.org/wiki/Patron_de_conception">https://fr.wikipedia.org/wiki/Patron_de_conception</a></p>
<p>============================================================</p>
<p>code doc vs code comment
<a href="https://www.youtube.com/watch?v=Bf7vDBBOBUA">https://www.youtube.com/watch?v=Bf7vDBBOBUA</a></p>
<p>Opti can be less performant.</p>
<p>If vs composition
<a href="https://www.youtube.com/watch?v=J1f5b4vcxCQ">https://www.youtube.com/watch?v=J1f5b4vcxCQ</a></p>
<ul>
<li>careful float (use int when possible / fixed decimals, etc)</li>
</ul>
<p>============================================================</p>
<p><a href="https://thucnc.medium.com/how-to-show-current-git-branch-with-colors-in-bash-prompt-380d05a24745">https://thucnc.medium.com/how-to-show-current-git-branch-with-colors-in-bash-prompt-380d05a24745</a></p>
<p>UML [beaucoup de bêtises) <a href="https://www.urbanisation-si.com/que-faut-il-garder-d-uml-quelles-seraient-les-evolutions-va-t-on-vers-un-reboot-d-uml-les-alternatives-a-uml">https://www.urbanisation-si.com/que-faut-il-garder-d-uml-quelles-seraient-les-evolutions-va-t-on-vers-un-reboot-d-uml-les-alternatives-a-uml</a></p>
<p>Compo vs Héritage.
as a : is a</p>
<p>Fragile base class problem
    -&gt; super class change -&gt; impact children
    -&gt; one subdivision ok : mani-subdivision = break
    -&gt; child that doesn&#39;t have all base property : intermediate prop.</p>
<p>DevLOG : corrigé + Fiche 2 &lt;2h ?</p>
<p>Etat-transition vs activité :</p>
<ul>
<li>Etat transition : node = état, vs activité node = action.</li>
<li>Etat transition : 1 élément vs activité = système ou ss-system</li>
</ul>
<h2 id="devlog">DevLog</h2>
<p>memoization : cacher les résultats e.g. Fibbo</p>
<ul>
<li>initialize</li>
</ul>
<p>-&gt; graph/subproblem.</p>
<ul>
<li>greedy solution</li>
</ul>
<p>-&gt; trier souvent simplifie problèmes
-&gt; start from the end</p>
<p><a href="https://www.youtube.com/watch?v=Hdr64lKQ3e4">https://www.youtube.com/watch?v=Hdr64lKQ3e4</a></p>
</main>
    </body>
</html>