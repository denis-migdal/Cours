<!DOCTYPE html>
<html>
    <head>
        <title>TP3 (BDR1)</title>
        <link rel="stylesheet" href="./index.css">
        <script type="module" src="./index.js" defer></script>
    </head>
    <body>
        <header></header>
        <main>

<h1 id="tp3--tables-et-contraintes">TP3 : Tables et contraintes</h1>
<h2 id="consignes">Consignes</h2>
<p><tp-consignes></tp-consignes></p>
<h2 id="cr√©ation-dune-table">Cr√©ation d&#39;une table</h2>
<ul>
<li>create table</li>
<li>.fullschema/.schema/sql CM</li>
</ul>
<h2 id="contraintes">Contraintes</h2>
<ul>
<li>(dont clefs primaires)</li>
</ul>
<ul>
<li><p>PRAGMA optimize;  / OPTIMIZE =&gt; avant chaque fermeture de la database.</p>
</li>
<li><p>FK + on delete/on update/cascade.</p>
</li>
</ul>
<h2 id="exportimport">Export/import</h2>
<p>Fr√©quent CSV (e.g. tableur)</p>
<p>import/export/save table (schema/data)
  -&gt; as SQL
  -&gt; as CSV
  ?</p>
<ul>
<li>.mode (exports) / .dump  // .import</li>
</ul>
<h2 id="mesurer-la-performance-des-index">Mesurer la performance des index</h2>
<p>Nous allons d√©sormais voir √† quel point les index sont vitaux lors de requ√™tes SQL sur de tr√®s larges tables. Pour cela nous suivrons le protocole suivant :</p>
<ul>
<li>cr√©er 3 tables avec une colonne <sql-code>ID INTEGER NOT NULL</sql-code> avec :<ul>
<li><code>U_NC</code> : table sans contrainte.</li>
<li><code>U_PK</code> : table avec <sql-code>PRIMARY KEY</sql-code>.</li>
<li><code>U_UN</code> : table avec <sql-code>UNIQUE</sql-code>.</li>
</ul>
</li>
<li>remplir ces tables de mani√®re identique, avec <code>10 000 000</code> entr√©es unique.</li>
<li>pour chaque, mesurer la dur√©e de recherche de l&#39;entr√©e o√π <sql-code class="d4rk">ID == 42</sql-code>.</li>
</ul>
<h3 id="cr√©ation-et-remplissage-des-tables">Cr√©ation et remplissage des tables</h3>
<p>Dans un premier temps, nous cr√©ons une table contenant nos <code>10 000 000</code> entr√©es :</p>
<sql-code class='block d4rk'>
CREATE TABLE U_NC (ID INTEGER NOT NULL);
WITH gen(rowid) AS (
  VALUES (0)
  UNION ALL
    SELECT rowid+1 FROM gen
  LIMIT <var>$NB</var>)
INSERT INTO U_NC SELECT rowid FROM gen ORDER BY RANDOM();</sql-code>

<p>üí° On ne vous demandera pas de comprendre le fonctionnement de <sql-code>gen</sql-code>.</p>
<ol>
<li>Cr√©ez les tables <code>U_PK</code> et <code>U_UN</code> que vous remplirez ensuite √† partir de <code>U_NC</code>.<pre lang="sql" contenteditable></pre></li>
</ol>
<h3 id="mesurer-la-dur√©e-dex√©cution-dune-requ√™te">Mesurer la dur√©e d&#39;ex√©cution d&#39;une requ√™te</h3>
<ol>
<li>Activez la mesure de la dur√©e d&#39;ex√©cution des requ√™tes via <code>.timer on</code>.</li>
<li>Activez l&#39;explication des requ√™tes via <code>.eqp on</code>.<ul>
<li><code>SCAN $T</code> : lis les lignes de la table <code>$T</code> unes √† unes ;</li>
<li><code>SEARCH $T USING</code> : recherche des entr√©es dans la table <code>$T</code> via un index,</li>
</ul>
</li>
<li>Sur <code>U_NC</code>, <code>U_PK</code>, et <code>U_UN</code>, mesurez la dur√©e d&#39;ex√©cution de la requ√™te suivante : <sql-code class="d4rk">SELECT * FROM <var>$T</var> WHERE ID == 42;</sql-code><br/><pre contenteditable></pre></li>
<li>Comment expliquez-vous la diff√©rence de r√©sultats entre <code>U_NC</code>, et <code>U_PK</code>/<code>U_UN</code> ?<br/><pre contenteditable></pre></li>
</ol>
<p>üí° Pr√©fixer une requ√™te SQL par <sql-code>EXPLAIN QUERY PLAN </sql-code> permet de l&#39;expliquer sans l&#39;ex√©cuter.</p>
<h3 id="cr√©er-un-index">Cr√©er un INDEX</h3>
<p>Comme nous l&#39;avons vu en CM, les SGBD ajoutent un index sur les contraintes <sql-code>UNIQUE</sql-code>. Cela s&#39;explique par le fait qu&#39;√† chaque insertions, le SGBD doit v√©rifier la contrainte, et donc rechercher si la valeur existe d√©j√† dans la(les) colonne(s).</p>
<p>üí° La commande <code>.indexes $T</code> permet d&#39;afficher la liste des index de la table <code>$T</code>.</p>
<ol>
<li>V√©rifiez que <code>U_UN</code> poss√®de bien un index, et que <code>U_NC</code> n&#39;en poss√®de pas.</li>
<li>Cr√©ez un index sur <code>U_NC</code> via <sql-code class="d4rk">CREATE INDEX _<var>$T</var>_<var>$COL</var> ON <var>$T</var>(<var>$COL</var>);</sql-code>.<pre lang="sql" contenteditable></pre></li>
<li>Listez les index de <code>U_NC</code>, puis ex√©cutez la requ√™te <sql-code>SELECT</sql-code> pr√©c√©dente.</li>
<li>Qu&#39;observez-vous quant √† la vitesse d&#39;ex√©cution ?<pre contenteditable></pre></li>
<li>Cr√©ez une table <code>D(ID INTEGER NOT NULL)</code>.<pre lang="sql" contenteditable></pre></li>
<li>Remplissez cette table via la requ√™te SQL suivante (ins√®re duplicats) :
<sql-code class="block">INSERT INTO D SELECT RANDOM()%10000000 FROM U_NC;</sql-code></li>
<li>Mesurez la vitesse d&#39;execution de la requ√™te <sql-code>SELECT</sql-code> sur cette table :<pre contenteditable></pre></li>
<li>Cr√©ez un index sur cette table.<pre lang="sql" contenteditable></pre></li>
<li>Mesurez √† nouveau la vitesse d&#39;execution, qu&#39;observez-vous ?<pre contenteditable></pre></li>
</ol>
<p>‚ö† Les index ont un co√ªt sur les insertions/modifications. Il ne faut ainsi pas en abuser.</p>
<p>üí° En r√©alit√©, il est rare de devoir cr√©er des index manuellement.</p>
</main>
    </body>
</html>