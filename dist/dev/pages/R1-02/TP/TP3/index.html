<!DOCTYPE html>
<html>
    <head>
        <title>TP3 (BDR1)</title>
        <link rel="stylesheet" href="./index.css">
        <script type="module" src="./index.js" defer></script>
    </head>
    <body>
        <header></header>
        <main>

<h1 id="tp3--tables-et-contraintes">TP3 : Tables et contraintes</h1>
<h2 id="consignes">Consignes</h2>
<p><tp-consignes></tp-consignes></p>
<h2 id="cr√©ation-dune-table-et-contraintes-de-colonnes">Cr√©ation d&#39;une table et contraintes de colonnes</h2>
<ol>
<li>Cr√©ez une table <code>T_PK</code> ayant pour colonnes :<ul>
<li><code>ID</code> : une clef primaire auto-increment.</li>
<li><code>A</code>  : un texte dont la valeur par d√©faut sera <code>N/A</code>.</li>
<li><code>B</code>  : un entier qui ne peut √™tre <code>NULL</code>.</li>
<li><code>C</code>  : un entier impair (utilisez <code>CHECK</code>).<pre lang="sql" contenteditable></pre></li>
</ul>
</li>
<li>Via une requ√™te SQL affichez le sch√©ma de la table <code>T_PK</code><pre lang="sql" contenteditable></pre></li>
<li>Via une requ√™te SQL affichez la requ√™te SQL de cr√©ation de la table <code>T_PK</code><pre lang="sql" contenteditable></pre></li>
<li>Ins√©rez 3 entr√©es dans la table <code>T_PK</code> en ne renseignant que les colonnes <code>B</code> et <code>C</code>.<pre lang="sql" contenteditable></pre></li>
<li>Affichez les entr√©es de la table <code>T_PK</code>.</li>
</ol>
<h2 id="contraintes-de-tables">Contraintes de tables</h2>
<ol>
<li>Cr√©ez une table <code>T_TCSTR</code> ayant pour colonnes :<ul>
<li><code>A</code>  : un entier qui ne peut √™tre <code>NULL</code>.</li>
<li><code>B</code>  : un entier qui doit √™tre sup√©rieur √† <code>A</code><pre lang="sql" contenteditable></pre></li>
</ul>
</li>
</ol>
<h2 id="clefs-√©trang√®res">Clefs √©trang√®res</h2>
<ol>
<li>Cr√©ez une table <code>T_FK</code> ayant pour colonnes :<ul>
<li><code>A</code>  : une clef √©trang√®re non-nulle vers la table <code>T_PK</code>.<pre lang="sql" contenteditable></pre></li>
</ul>
</li>
<li>Ins√©rez une entr√©e dans <code>T_FK</code> r√©f√©ren√ßant la premi√®re entr√©e de <code>T_PK</code>.<pre lang="sql" contenteditable></pre></li>
<li>Incr√©mentez la colonne <code>ID</code> de l&#39;entr√©e r√©f√©renc√©e. Que se passe-t-il ? Pourquoi ?<pre contenteditable></pre></li>
<li>Supprimez l&#39;entr√©e r√©f√©renc√©e. Que se passe-t-il ? Pourquoi ?<pre contenteditable></pre></li>
<li>Supprimez la table <code>T_FK</code>.<pre lang="sql" contenteditable></pre></li>
<li>Recommencez les op√©rations pr√©c√©dentes, cette fois de sorte √† ce que la clef √©trang√®res soit supprim√©e/modifi√©e lors de la suppression/modification de la clef primaire.<br/>
a. Cr√©ation de <code>T_FK</code><pre lang="sql" contenteditable></pre>
b. Que se passe-t-il lors de la modification ? Pourquoi ?<pre contenteditable></pre>
a. Que se passe-t-il lors de la suppression ? Pourquoi ?<pre contenteditable></pre></li>
<li>Recommencez les op√©rations pr√©c√©dentes, cette fois de sorte √† ce que la clef √©trang√®res soit mise √† <code>NULL</code> lors de la suppression de la clef primaire, et modifi√©e lors de la modification de la clef primaire.<br/>
a. Cr√©ation de <code>T_FK</code><pre lang="sql" contenteditable></pre>
b. Que se passe-t-il lors de la suppression ? Pourquoi ?<pre contenteditable></pre></li>
</ol>
<h2 id="mesurer-la-performance-des-index">Mesurer la performance des index</h2>
<p>Nous allons d√©sormais voir √† quel point les index sont vitaux lors de requ√™tes SQL sur de tr√®s larges tables. Pour cela nous suivrons le protocole suivant :</p>
<ul>
<li>cr√©er 3 tables (<sql-code>ID INTEGER NOT NULL, Data TEXT</sql-code>) :<ul>
<li>table <code>U_NC</code> : <sql-code>ID</sql-code> sans contraintes suppl√©mentaires.</li>
<li>table <code>U_PK</code> : <sql-code>ID</sql-code> <sql-code>PRIMARY KEY</sql-code>.</li>
<li>table <code>U_UN</code> : <sql-code>ID</sql-code> <sql-code>UNIQUE</sql-code>.</li>
</ul>
</li>
<li>remplir ces tables de mani√®re identique, avec <sql-code class="d4rk"><var>$NB</var></sql-code> = <code>10000000</code> entr√©es unique.</li>
<li>pour chaque, mesurer la dur√©e de recherche de l&#39;entr√©e o√π <sql-code class="d4rk">ID == 42</sql-code>.</li>
</ul>
<h3 id="cr√©ation-et-remplissage-des-tables">Cr√©ation et remplissage des tables</h3>
<p>Dans un premier temps, nous cr√©ons une table contenant nos <code>10 000 000</code> entr√©es :</p>
<sql-code class='block d4rk'>
CREATE TABLE U_NC (ID INTEGER NOT NULL, Data TEXT);
WITH gen(rowid) AS (
  VALUES (0)
  UNION ALL
    SELECT rowid+1 FROM gen
  LIMIT <var>$NB</var>)
INSERT INTO U_NC SELECT rowid, '('||rowid||')' FROM gen ORDER BY RANDOM();</sql-code>

<p>üí° On ne vous demandera pas de comprendre le fonctionnement de <sql-code>gen</sql-code>.</p>
<ol>
<li>Cr√©ez les tables <code>U_PK</code> et <code>U_UN</code> que vous remplirez ensuite √† partir de <code>U_NC</code>.<pre lang="sql" contenteditable></pre></li>
</ol>
<h3 id="mesurer-la-dur√©e-dex√©cution-dune-requ√™te">Mesurer la dur√©e d&#39;ex√©cution d&#39;une requ√™te</h3>
<ol>
<li>Activez la mesure de la dur√©e d&#39;ex√©cution des requ√™tes via <code>.timer on</code>.</li>
<li>Activez l&#39;explication des requ√™tes via <code>.eqp on</code>.<ul>
<li><code>SCAN $T</code> : lis les lignes de la table <code>$T</code> unes √† unes ;</li>
<li><code>SEARCH $T USING</code> : recherche des entr√©es dans la table <code>$T</code> via un index,</li>
</ul>
</li>
<li>Sur <code>U_NC</code>, <code>U_PK</code>, et <code>U_UN</code>, mesurez la dur√©e d&#39;ex√©cution de la requ√™te suivante : <sql-code class="d4rk">SELECT * FROM <var>$T</var> WHERE ID == 42;</sql-code><br/><pre contenteditable></pre></li>
<li>Comment expliquez-vous la diff√©rence de r√©sultats entre <code>U_NC</code>, et <code>U_PK</code>/<code>U_UN</code> ?<br/><pre contenteditable></pre></li>
<li>Ex√©cutez <sql-code class="d4rk">SELECT * FROM <var>$T</var> LIMIT 20;</sql-code> sur <code>U_PK</code> et <code>U_UN</code>, qu&#39;observez-vous ?<pre contenteditable></pre></li>
<li>Ex√©cutez la requ√™te suivante sur <code>U_PK</code> et <code>U_UN</code> :<br/><sql-code class="d4rk">SELECT COUNT(Data) FROM <var>$T</var> WHERE ID BETWEEN 200000 AND 400000;</sql-code></li>
<li>Comment pourriez-vous expliquer la diff√©rence sur les temps d&#39;ex√©cution ?<br/><pre contenteditable></pre></li>
</ol>
<p>üí° Pr√©fixer une requ√™te SQL par <sql-code>EXPLAIN QUERY PLAN </sql-code> permet de l&#39;expliquer sans l&#39;ex√©cuter.</p>
<h3 id="cr√©er-un-index">Cr√©er un INDEX</h3>
<p>Comme nous l&#39;avons vu en CM, les SGBD ajoutent un index sur les contraintes <sql-code>UNIQUE</sql-code>. Cela s&#39;explique par le fait qu&#39;√† chaque insertions, le SGBD doit v√©rifier la contrainte, et donc rechercher si la valeur existe d√©j√† dans la(les) colonne(s).</p>
<p>üí° La commande <code>.indexes $T</code> permet d&#39;afficher la liste des index de la table <code>$T</code>.</p>
<ol>
<li>V√©rifiez que <code>U_UN</code> poss√®de bien un index, et que <code>U_NC</code> n&#39;en poss√®de pas.</li>
<li>Cr√©ez un index sur <code>U_NC</code> via <sql-code class="d4rk">CREATE INDEX _<var>$T</var>_<var>$COL</var> ON <var>$T</var>(<var>$COL</var>);</sql-code>.<pre lang="sql" contenteditable></pre></li>
<li>Listez les index de <code>U_NC</code>, puis ex√©cutez la requ√™te <sql-code>SELECT</sql-code> pr√©c√©dente.</li>
<li>Qu&#39;observez-vous quant √† la vitesse d&#39;ex√©cution ?<pre contenteditable></pre></li>
<li>Cr√©ez une table <code>D(ID INTEGER NOT NULL)</code>.<pre lang="sql" contenteditable></pre></li>
<li>Remplissez cette table via la requ√™te SQL suivante (ins√®re duplicats) :
<sql-code class="block d4rk">INSERT INTO D SELECT ABS(RANDOM())%<var>$NB</var> FROM U_NC;</sql-code></li>
<li>Mesurez la vitesse d&#39;execution de la requ√™te <sql-code>SELECT</sql-code> sur cette table :<pre contenteditable></pre></li>
<li>Cr√©ez un index sur cette table.<pre lang="sql" contenteditable></pre></li>
<li>Mesurez √† nouveau la vitesse d&#39;execution, qu&#39;observez-vous ?<pre contenteditable></pre></li>
</ol>
<p>‚ö† Les index ont un co√ªt lors des <sql-code>INSERT</sql-code>/<sql-code>UPDATE</sql-code>/<sql-code>DELETE</sql-code>, il ne faut pas en abuser.</p>
<p>üí° En r√©alit√©, il est rare de devoir cr√©er des index manuellement.</p>
</main>
    </body>
</html>