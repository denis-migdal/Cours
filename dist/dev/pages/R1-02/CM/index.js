import * as __WEBPACK_EXTERNAL_MODULE_https_raw_githack_com_denis_migdal_LISS_main_index_js_bb6a3cae__ from "https://raw.githack.com/denis-migdal/LISS/main/index.js";
/******/ var __webpack_modules__ = ({

/***/ "./src/pages/R1-02/CM/index.css":
/*!**************************************!*\
  !*** ./src/pages/R1-02/CM/index.css ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/pages/R1-02/CM/index.md":
/*!*************************************!*\
  !*** ./src/pages/R1-02/CM/index.md ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "pages/R1-02/CM/index.html");

/***/ }),

/***/ "./libs/LISS/index.ts":
/*!****************************!*\
  !*** ./libs/LISS/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CstmEvent: () => (/* binding */ CstmEvent),
/* harmony export */   LISS_Auto: () => (/* binding */ LISS_Auto),
/* harmony export */   ShadowCfg: () => (/* binding */ ShadowCfg),
/* harmony export */   "default": () => (/* binding */ LISS)
/* harmony export */ });
// ================================================
// =============== LISS exported types ============
// ================================================
/*
type S<A,B> = {
	A: A,
	B: B
};
type LH = S<unknown,unknown>;

type inferA<T> = T extends S<infer A, any> ? A : never;

function foo<T extends LH>(t: T): inferA<T> {
	return t.A as inferA<T>;
}

let X = {
	A: 32,
	B: "str"
};

let c = foo(X);
*/ var ShadowCfg;
(function(ShadowCfg) {
    ShadowCfg["NONE"] = "none";
    ShadowCfg["OPEN"] = "open";
    ShadowCfg["CLOSE"] = "closed";
})(ShadowCfg || (ShadowCfg = {}));
// ================================================
// =============== LISS Class =====================
// ================================================
let __cstr_host = null;
// https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow
const CAN_HAVE_SHADOW = [
    null,
    'article',
    'aside',
    'blockquote',
    'body',
    'div',
    'footer',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'main',
    'nav',
    'p',
    'section',
    'span'
];
function _canHasShadow(tag) {
    return CAN_HAVE_SHADOW.includes(_element2tagname(tag));
}
function LISS({ extends: p_extends, host: p_host, dependencies: p_deps, attributes: p_attrs, params, content, css, shadow: p_shadow } = {}) {
    //TODO merge prop if extends LISS...
    const host = p_host ?? HTMLElement;
    const _extends = p_extends ?? Object;
    const attributes = p_attrs ?? [];
    const dependencies = p_deps ? [
        ...p_deps
    ] : [];
    const canHasShadow = _canHasShadow(host);
    const shadow = p_shadow ?? (canHasShadow ? "closed" : "none");
    if (!canHasShadow && shadow !== "none") throw new Error(`Host element ${_element2tagname(host)} does not support ShadowRoot`);
    // CONTENT processing
    if (content !== undefined) {
        dependencies.push((async ()=>{
            content = await content;
            if (content instanceof HTMLTemplateElement) content = content.innerHTML;
            if (typeof content === "string") {
                content = content.trim(); // Never return a text node of whitespace as the result
                if (content === '') content = undefined;
            }
            if (content instanceof Response) content = await content.text();
            return LISSBase.Parameters.content = content;
        })());
    }
    // CSS processing
    let stylesheets = [];
    if (css !== undefined) {
        if (!Array.isArray(css)) css = [
            css
        ];
        stylesheets = new Array(css.length);
        const fetch_css = async (css)=>{
            css = await css;
            if (css instanceof CSSStyleSheet) return css;
            if (css instanceof HTMLStyleElement) return css.sheet;
            let style = new CSSStyleSheet();
            if (typeof css === "string") {
                await style.replace(css);
                return style;
            }
            //if( css instanceof Response )
            await style.replace(await css.text());
            return style;
        };
        dependencies.push(...css.map(async (css, idx)=>stylesheets[idx] = await fetch_css(css)));
    }
    // @ts-ignore
    class LISSBase extends _extends {
        #host;
        constructor(){
            super();
            // h4ck, okay because JS is monothreaded.
            if (__cstr_host === null) throw new Error("Please do not directly call this constructor");
            this.#host = __cstr_host;
            __cstr_host = null;
        }
        get host() {
            return this.#host;
        }
        get attrs() {
            return this.#host.attrs;
        }
        setAttrDefault(attr, value) {
            return this.#host.setAttrDefault(attr, value);
        }
        get params() {
            return this.#host.params;
        }
        setParam(name, value) {
            this.#host.params[name] = value;
        }
        get content() {
            return this.#host.content;
        }
        static Parameters = {
            host,
            dependencies,
            attributes,
            params,
            content,
            stylesheets,
            shadow
        };
        onAttrChanged(_name, _oldValue, _newValue) {}
        get isInDOM() {
            return this.#host.isInDOM;
        }
        onDOMConnected() {}
        onDOMDisconnected() {}
    }
    return LISSBase;
}
//TODO: other options...
function extendsLISS(Liss, parameters) {
    const attributes = [
        ...Liss.Parameters.attributes,
        ...parameters.attributes ?? []
    ];
    const dependencies = [
        ...Liss.Parameters.dependencies,
        ...parameters.dependencies ?? []
    ];
    const params = Object.assign({}, Liss.Parameters, {
        attributes,
        dependencies
    });
    if (parameters.shadow !== undefined) params.shadow = parameters.shadow;
    // @ts-ignore : because TS stupid
    class ExtendedLISS extends Liss {
        constructor(...t){
            // @ts-ignore : because TS stupid
            super(...t);
        }
        get attrs() {
            return super.attrs;
        }
        static Parameters = params;
    }
    return ExtendedLISS;
}
LISS.extendsLISS = extendsLISS;
// ================================================
// =============== LISSHost class =================
// ================================================
let id = 0;
function buildLISSHost(Liss, _params = {}) {
    const { host, attributes, content, stylesheets, shadow } = Liss.Parameters;
    const alreadyDeclaredCSS = new Set();
    const GET = Symbol('get');
    const SET = Symbol('set');
    const properties = Object.fromEntries(attributes.map((n)=>[
            n,
            {
                enumerable: true,
                get: function() {
                    return this[GET](n);
                },
                set: function(value) {
                    return this[SET](n, value);
                }
            }
        ]));
    class Attributes {
        #data;
        #defaults;
        #setter;
        [GET](name) {
            return this.#data[name] ?? this.#defaults[name] ?? null;
        }
        [SET](name, value) {
            return this.#setter(name, value); // required to get a clean object when doing {...attrs}
        }
        constructor(data, defaults, setter){
            this.#data = data;
            this.#defaults = defaults;
            this.#setter = setter;
            Object.defineProperties(this, properties);
        }
    }
    // @ts-ignore : because TS is stupid.
    class LISSHostBase extends host {
        #params;
        #id = ++id;
        constructor(params = {}){
            super();
            this.#params = Object.assign({}, Liss.Parameters.params, _params, params);
            this.#waitInit = new Promise((resolve)=>{
                if (this.isInit) return resolve(this.#API);
                this.#resolve = resolve;
            });
        }
        /**** public API *************/ get isInit() {
            return this.#API !== null;
        }
        initialize(params = {}) {
            if (this.isInit) throw new Error('Element already initialized!');
            Object.assign(this.#params, params);
            const api = this.init();
            if (this.#isInDOM) api.onDOMConnected();
            return api;
        }
        get LISSSync() {
            if (!this.isInit) throw new Error('Accessing API before WebComponent initialization!');
            return this.#API;
        }
        get LISS() {
            return this.#waitInit;
        }
        /*** init ***/ #waitInit;
        #resolve = null;
        #API = null;
        #isInDOM = false;
        get isInDOM() {
            return this.#isInDOM;
        }
        disconnectedCallback() {
            this.#isInDOM = false;
            this.#API.onDOMDisconnected();
        }
        connectedCallback() {
            this.#isInDOM = true;
            if (!this.isInit) this.init();
            this.#API.onDOMConnected();
        }
        init() {
            customElements.upgrade(this);
            // shadow
            this.#content = this;
            if (shadow !== 'none') {
                this.#content = this.attachShadow({
                    mode: shadow
                });
                //@ts-ignore
                this.#content.addEventListener('click', onClickEvent);
                //@ts-ignore
                this.#content.addEventListener('dblclick', onClickEvent);
            }
            // attrs
            for (let obs of attributes)this.#attributes[obs] = this.getAttribute(obs);
            // css
            if (shadow !== 'none') this.#content.adoptedStyleSheets.push(sharedCSS);
            if (stylesheets.length) {
                if (shadow !== 'none') this.#content.adoptedStyleSheets.push(...stylesheets);
                else {
                    const cssselector = this.CSSSelector;
                    // if not yet inserted :
                    if (!alreadyDeclaredCSS.has(cssselector)) {
                        let style = document.createElement('style');
                        style.setAttribute('for', cssselector);
                        let html_stylesheets = "";
                        for (let style of stylesheets)for (let rule of style.cssRules)html_stylesheets += rule.cssText + '\n';
                        style.innerHTML = html_stylesheets.replace(':host', `:is(${cssselector})`);
                        document.head.append(style);
                        alreadyDeclaredCSS.add(cssselector);
                    }
                }
            }
            // content
            if (content !== undefined) {
                let template_elem = document.createElement('template');
                let str = content.replace(/\$\{(.+?)\}/g, (_, match)=>this.getAttribute(match) ?? '');
                template_elem.innerHTML = str;
                this.#content.append(...template_elem.content.childNodes);
            }
            // build
            // h4ck, okay because JS is monothreaded.
            __cstr_host = this;
            let obj = new Liss();
            /*if( obj instanceof Promise)
	    		obj = await obj;*/ this.#API = obj;
            // default slot
            if (this.hasShadow && this.#content.childNodes.length === 0) this.#content.append(document.createElement('slot'));
            if (this.#resolve !== null) this.#resolve(this.#API);
            return this.#API;
        }
        get params() {
            return this.#params;
        }
        setParam(name, value) {
            if (this.isInit) return this.#API.setParam(name, value);
            this.#params[name] = value; // will be given to constructor.
        }
        /*** content ***/ #content = null;
        get content() {
            return this.#content;
        }
        getPart(name) {
            return this.hasShadow ? this.#content?.querySelector(`::part(${name})`) : this.#content?.querySelector(`[part="${name}"]`);
        }
        getParts(name) {
            return this.hasShadow ? this.#content?.querySelectorAll(`::part(${name})`) : this.#content?.querySelectorAll(`[part="${name}"]`);
        }
        get hasShadow() {
            return shadow !== 'none';
        }
        /*** CSS ***/ get CSSSelector() {
            if (this.hasShadow || !this.hasAttribute("is")) return this.tagName;
            return `${this.tagName}[is="${this.getAttribute("is")}"]`;
        }
        /*** attrs ***/ #attrs_flag = false;
        #attributes = {};
        #attributesDefaults = {};
        #attrs = new Attributes(this.#attributes, this.#attributesDefaults, (name, value)=>{
            this.#attributes[name] = value;
            this.#attrs_flag = true; // do not trigger onAttrsChanged.
            if (value === null) this.removeAttribute(name);
            else this.setAttribute(name, value);
        });
        setAttrDefault(name, value) {
            if (value === null) delete this.#attributesDefaults[name];
            else this.#attributesDefaults[name] = value;
        }
        get attrs() {
            return this.#attrs;
        }
        static observedAttributes = attributes;
        attributeChangedCallback(name, oldValue, newValue) {
            if (this.#attrs_flag) {
                this.#attrs_flag = false;
                return;
            }
            this.#attributes[name] = newValue;
            if (!this.isInit) return;
            if (this.#API.onAttrChanged(name, oldValue, newValue) === false) {
                this.#attrs[name] = oldValue; // revert the change.
            }
        }
    }
    return LISSHostBase;
}
// ================================================
// =============== LISS define ====================
// ================================================
const _DOMContentLoaded = new Promise((resolve)=>{
    if (document.readyState === "interactive" || document.readyState === "complete") return resolve();
    document.addEventListener('DOMContentLoaded', ()=>{
        resolve();
    }, true);
});
LISS.define = async function(tagname, ComponentClass, { dependencies, params } = {}) {
    dependencies ??= [];
    params ??= {};
    const Class = ComponentClass.Parameters.host;
    let LISSBase = ComponentClass;
    let htmltag = _element2tagname(Class) ?? undefined;
    await Promise.all([
        _DOMContentLoaded,
        ...dependencies,
        ...LISSBase.Parameters.dependencies
    ]);
    const LISSclass = buildLISSHost(ComponentClass, params);
    const opts = htmltag === undefined ? {} : {
        extends: htmltag
    };
    customElements.define(tagname, LISSclass, opts);
};
// ================================================
// =============== LISS ShadowRoot tools ==========
// ================================================
const sharedCSS = new CSSStyleSheet();
document.adoptedStyleSheets.push(sharedCSS);
LISS.insertGlobalCSSRules = function(css) {
    let css_style;
    if (css instanceof HTMLStyleElement) css_style = css.sheet;
    if (typeof css === "string") {
        css_style = new CSSStyleSheet();
        css_style.replaceSync(css);
    }
    for (let rule of css_style.cssRules)sharedCSS.insertRule(rule.cssText);
};
const DELEGATED_EVENTS = {
    "click": [],
    "dblclick": []
};
const ALREADY_PROCESSED = Symbol();
function onClickEvent(ev) {
    if (ev[ALREADY_PROCESSED] === true) return;
    ev[ALREADY_PROCESSED] = true;
    const handlers = DELEGATED_EVENTS[ev.type];
    for (let elem of ev.composedPath()){
        if (elem instanceof ShadowRoot || elem === document || elem === window) continue;
        var target = elem;
        for (let [selector, handler] of handlers){
            if (target.matches(selector)) handler(ev);
        }
    }
}
LISS.insertGlobalDelegatedListener = function(event_name, selector, handler) {
    DELEGATED_EVENTS[event_name].push([
        selector,
        handler
    ]);
};
document.addEventListener('click', onClickEvent);
document.addEventListener('dblclick', onClickEvent);
LISS.closest = function closest(selector, element) {
    while(true){
        var result = element.closest(selector);
        if (result !== null) return result;
        const root = element.getRootNode();
        if (!("host" in root)) return null;
        element = root.host;
    }
};
async function build(tagname, { params = {}, initialize = true, content = [], parent = undefined, id = undefined, classes = [], cssvars = {}, attrs = {}, data = {}, listeners = {} } = {}) {
    if (!initialize && parent === null) throw new Error("A parent must be given if initialize is false");
    let CustomClass = await customElements.whenDefined(tagname);
    let elem = new CustomClass(params);
    // Fix issue #2
    if (elem.tagName.toLowerCase() !== tagname) elem.setAttribute("is", tagname);
    if (id !== undefined) elem.id = id;
    if (classes.length > 0) elem.classList.add(...classes);
    for(let name in cssvars)elem.style.setProperty(`--${name}`, cssvars[name]);
    for(let name in attrs){
        let value = attrs[name];
        if (typeof value === "boolean") elem.toggleAttribute(name, value);
        else elem.setAttribute(name, value);
    }
    for(let name in data){
        let value = data[name];
        if (value === false) delete elem.dataset[name];
        else if (value === true) elem.dataset[name] = "";
        else elem.dataset[name] = value;
    }
    if (!Array.isArray(content)) content = [
        content
    ];
    elem.replaceChildren(...content);
    for(let name in listeners)elem.addEventListener(name, listeners[name]);
    if (parent !== undefined) parent.append(elem);
    if (!elem.isInit && initialize) return await LISS.initialize(elem);
    return await LISS.getLISS(elem);
}
LISS.build = build;
function buildSync(tagname, { params = {}, initialize = true, content = [], parent = undefined, id = undefined, classes = [], cssvars = {}, attrs = {}, data = {}, listeners = {} } = {}) {
    if (!initialize && parent === null) throw new Error("A parent must be given if initialize is false");
    let CustomClass = customElements.get(tagname);
    if (CustomClass === undefined) throw new Error(`${tagname} not defined`);
    let elem = new CustomClass(params);
    //TODO: factorize...
    // Fix issue #2
    if (elem.tagName.toLowerCase() !== tagname) elem.setAttribute("is", tagname);
    if (id !== undefined) elem.id = id;
    if (classes.length > 0) elem.classList.add(...classes);
    for(let name in cssvars)elem.style.setProperty(`--${name}`, cssvars[name]);
    for(let name in attrs){
        let value = attrs[name];
        if (typeof value === "boolean") elem.toggleAttribute(name, value);
        else elem.setAttribute(name, value);
    }
    for(let name in data){
        let value = data[name];
        if (value === false) delete elem.dataset[name];
        else if (value === true) elem.dataset[name] = "";
        else elem.dataset[name] = value;
    }
    if (!Array.isArray(content)) content = [
        content
    ];
    elem.replaceChildren(...content);
    for(let name in listeners)elem.addEventListener(name, listeners[name]);
    if (parent !== undefined) parent.append(elem);
    if (!elem.isInit && initialize) LISS.initializeSync(elem);
    return LISS.getLISSSync(elem);
}
LISS.buildSync = buildSync;
LISS.whenDefined = async function(tagname, callback) {
    await customElements.whenDefined(tagname);
    if (callback !== undefined) callback();
    return;
};
LISS.whenAllDefined = async function(tagnames, callback) {
    await Promise.all(tagnames.map((t)=>customElements.whenDefined(t)));
    if (callback !== undefined) callback();
};
LISS.isDefined = function(name) {
    return customElements.get(name);
};
LISS.selector = function(name) {
    if (name === undefined) return "";
    return `:is(${name}, [is="${name}"])`;
};
LISS.getLISS = async function(element) {
    await LISS.whenDefined(LISS.getName(element));
    return element.LISS; // ensure initialized.
};
LISS.getLISSSync = function(element) {
    const name = LISS.getName(element);
    if (!LISS.isDefined(name)) throw new Error(`${name} hasn't been defined yet.`);
    let host = element;
    if (!host.isInit) throw new Error("Instance hasn't been initialized yet.");
    return host.LISSSync;
};
LISS.initialize = async function(element) {
    await LISS.whenDefined(LISS.getName(element));
    return await element.initialize(); // ensure initialization.
};
LISS.initializeSync = function(element) {
    const name = LISS.getName(element);
    if (!LISS.isDefined(name)) throw new Error(`${name} not defined`);
    return element.initialize(); // ensure initialization.
};
LISS.getName = function(element) {
    const name = element.getAttribute('is') ?? element.tagName.toLowerCase();
    if (!name.includes('-')) throw new Error(`Element ${name} is not a WebComponent`);
    return name;
};
function _buildQS(selector, tagname_or_parent, parent = document) {
    if (tagname_or_parent !== undefined && typeof tagname_or_parent !== 'string') {
        parent = tagname_or_parent;
        tagname_or_parent = undefined;
    }
    return [
        `${selector}${LISS.selector(tagname_or_parent)}`,
        parent
    ];
}
async function qs(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    let result = await LISS.qso(selector, parent);
    if (result === null) throw new Error(`Element ${selector} not found`);
    return result;
}
LISS.qs = qs;
async function qso(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const element = parent.querySelector(selector);
    if (element === null) return null;
    return await LISS.getLISS(element);
}
LISS.qso = qso;
async function qsa(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const elements = parent.querySelectorAll(selector);
    let idx = 0;
    const promises = new Array(elements.length);
    for (let element of elements)promises[idx++] = LISS.getLISS(element);
    return await Promise.all(promises);
}
LISS.qsa = qsa;
async function qsc(selector, tagname_or_parent, element) {
    const res = _buildQS(selector, tagname_or_parent, element);
    const result = res[1].closest(res[0]);
    if (result === null) return null;
    return await LISS.getLISS(result);
}
LISS.qsc = qsc;
function qsSync(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const element = parent.querySelector(selector);
    if (element === null) throw new Error(`Element ${selector} not found`);
    return LISS.getLISSSync(element);
}
LISS.qsSync = qsSync;
function qsaSync(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const elements = parent.querySelectorAll(selector);
    let idx = 0;
    const result = new Array(elements.length);
    for (let element of elements)result[idx++] = LISS.getLISSSync(element);
    return result;
}
LISS.qsaSync = qsaSync;
function qscSync(selector, tagname_or_parent, element) {
    const res = _buildQS(selector, tagname_or_parent, element);
    const result = res[1].closest(res[0]);
    if (result === null) return null;
    return LISS.getLISSSync(result);
}
LISS.qscSync = qscSync;
// ================================================
// =============== LISS Auto ======================
// ================================================
class LISS_Auto extends LISS({
    attributes: [
        "src"
    ]
}) {
    #known_tag = new Set();
    #directory;
    #sw;
    constructor(){
        super();
        this.#sw = new Promise(async (resolve)=>{
            await navigator.serviceWorker.register(`./sw.js`);
            if (navigator.serviceWorker.controller) resolve();
            navigator.serviceWorker.addEventListener('controllerchange', ()=>{
                resolve();
            });
        });
        const src = this.attrs.src;
        if (src === null) throw new Error("src attribute is missing.");
        this.#directory = src[0] === '.' ? `${window.location.pathname}/${src}` : src;
        new MutationObserver((mutations)=>{
            for (let mutation of mutations)for (let addition of mutation.addedNodes)if (addition instanceof Element) this.#addTag(addition.tagName);
        }).observe(document, {
            childList: true,
            subtree: true
        });
        for (let elem of document.querySelectorAll("*"))this.#addTag(elem.tagName);
    }
    resources() {
        return [
            "index.js",
            "index.html",
            "index.css"
        ];
    }
    defineWebComponent(tagname, files, opts) {
        const js = files["index.js"];
        const content = files["index.html"];
        let klass = null;
        if (js !== undefined) klass = js(opts);
        else if (content !== undefined) klass = class WebComponent extends LISS(opts) {
        };
        if (klass === null) throw new Error(`Missing files for WebComponent ${tagname}.`);
        return LISS.define(tagname, klass);
    }
    async #addTag(tagname) {
        tagname = tagname.toLowerCase();
        if (tagname === 'liss-auto' || tagname === 'bliss-auto' || !tagname.includes('-') || this.#known_tag.has(tagname)) return;
        this.#known_tag.add(tagname);
        await this.#sw; // ensure SW is installed.
        const filenames = this.resources();
        const resources = await Promise.all(filenames.map((file)=>file.endsWith('.js') ? _import(`${this.#directory}/${tagname}/${file}`, true) : _fetchText(`${this.#directory}/${tagname}/${file}`, true)));
        const files = {};
        for(let i = 0; i < filenames.length; ++i)if (resources[i] !== undefined) files[filenames[i]] = resources[i];
        const content = files["index.html"];
        const css = files["index.css"];
        const opts = {
            ...content !== undefined && {
                content
            },
            ...css !== undefined && {
                css
            }
        };
        return this.defineWebComponent(tagname, files, opts);
    }
}
LISS.define("liss-auto", LISS_Auto);
class CstmEvent extends CustomEvent {
    get type() {
        return super.type;
    }
    constructor(type, args){
        super(type, {
            detail: args
        });
    }
}
// ================================================
// =============== LISS internal tools ============
// ================================================
async function fetchResource(resource) {
    resource = await resource;
    if (!(resource instanceof Response)) resource = await fetch(resource);
    return await resource.text();
}
async function _fetchText(uri, isLissAuto = false) {
    const options = isLissAuto ? {
        headers: {
            "liss-auto": "true"
        }
    } : {};
    const response = await fetch(uri, options);
    if (response.status !== 200) return undefined;
    if (isLissAuto && response.headers.get("status") === "404") return undefined;
    return await response.text();
}
async function _import(uri, isLissAuto = false) {
    // test for the module existance.
    if (isLissAuto && await _fetchText(uri, isLissAuto) === undefined) return undefined;
    try {
        return (await import(/* webpackIgnore: true */ uri)).default;
    } catch (e) {
        console.log(e);
        return undefined;
    }
}
// from https://stackoverflow.com/questions/51000461/html-element-tag-name-from-constructor
const HTMLCLASS_REGEX = /HTML(\w+)Element/;
const elementNameLookupTable = {
    'UList': 'ul',
    'TableCaption': 'caption',
    'TableCell': 'td',
    'TableCol': 'col',
    'TableRow': 'tr',
    'TableSection': 'tbody',
    'Quote': 'q',
    'Paragraph': 'p',
    'OList': 'ol',
    'Mod': 'ins',
    'Media': 'video',
    'Image': 'img',
    'Heading': 'h1',
    'Directory': 'dir',
    'DList': 'dl',
    'Anchor': 'a'
};
function _element2tagname(Class) {
    if (Class === HTMLElement) return null;
    let htmltag = HTMLCLASS_REGEX.exec(Class.name)[1];
    return elementNameLookupTable[htmltag] ?? htmltag.toLowerCase();
}


/***/ }),

/***/ "./src/pages/R1-02/CM/index.ts":
/*!*************************************!*\
  !*** ./src/pages/R1-02/CM/index.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../struct/sql-interactive.js */ "./src/struct/sql-interactive.js");
/* harmony import */ var _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../struct/sql-dym-table.js */ "./src/struct/sql-dym-table.js");
/* harmony import */ var _struct_anim_player_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../struct/anim-player.js */ "./src/struct/anim-player.js");
/* harmony import */ var _struct_menu_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../struct/menu.ts */ "./src/struct/menu.ts");
/* harmony import */ var _struct_struct_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../struct/struct.ts */ "./src/struct/struct.ts");
/* harmony import */ var _struct_struct_ts__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_struct_struct_ts__WEBPACK_IMPORTED_MODULE_4__);
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_0__, _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_1__]);
([_struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_0__, _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);






__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/SQLite.ts":
/*!******************************!*\
  !*** ./src/struct/SQLite.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   db2: () => (/* binding */ db2)
/* harmony export */ });
/* harmony import */ var _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite/sqlite3.js */ "./src/struct/sqlite/sqlite3.js");
/* harmony import */ var _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__);
//TODO: better (assets)

__webpack_require__(/*! ../pages/R1-02/CM/sqlite3.wasm */ "./src/pages/R1-02/CM/sqlite3.wasm");
//require("../../../struct/sqlite/sqlite3.wasm");

const sqlite3 = (await _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__()).sqlite3.oo1;
function js2sql(value) {
    if (value === null) return "NULL";
    if (typeof value === "number") return `${value}`;
    if (typeof value === "string") return `'${value}'`;
    throw new Error('???');
}
//TODO merge queries...
class DB {
    #desc;
    #db;
    constructor(name, desc){
        this.#desc = desc;
        // add t for tracing.
        this.#db = new sqlite3.DB(name, 'c');
        this.#db.exec('PRAGMA foreign_keys=ON;');
        this.fullReset();
    }
    #dropTable(name) {
        this.#db.exec(`drop table if exists ${name}`);
    }
    #createTable(name) {
        const desc = this.#desc[name];
        const cols = Object.entries(desc.schema).map(([name, type])=>`${name} ${type}`).join(", ");
        let constraints = "";
        if ("constraints" in desc) constraints = `, ${desc.constraints}`;
        this.#db.exec(`CREATE TABLE IF NOT EXISTS ${name}(${cols}${constraints}) STRICT;`);
        // Populate...
        const values = desc.entries.map((e)=>`(${e.map((c)=>js2sql(c)).join(', ')})`).join(", ");
        this.#db.exec(`INSERT INTO ${name} VALUES ${values};`);
    }
    resetTable(name) {
        this.#dropTable(name);
        this.#createTable(name);
    }
    #created_table = new Set();
    #updated_table = new Set();
    reset() {
        for (let name of [
            ...this.#created_table.values()
        ].reverse())this.#db.exec(`drop table if exists ${name};`);
        for(let name in this.#desc)if (this.#updated_table.has(name)) this.resetTable(name);
        this.#created_table.clear();
        this.#updated_table.clear();
    }
    fullReset() {
        for (let name of [
            ...this.#created_table.values()
        ].reverse())this.#db.exec(`drop table if exists ${name}`);
        const names = Object.keys(this.#desc);
        // required due to FK...
        for (let table of names.reverse())this.#dropTable(table);
        for (let table of names.reverse())this.#createTable(table);
        this.#created_table.clear();
        this.#updated_table.clear();
    }
    #isTableName(c) {
        return c !== " " && c !== ";" && c !== "\n";
    }
    #extractTableNameFromSQL(sql) {
        const types = [
            "CREATE TABLE IF NOT EXISTS ",
            "CREATE TABLE ",
            "ALTER TABLE ",
            "DROP TABLE ",
            "UPDATE ",
            "INSERT INTO ",
            "DELETE FROM "
        ];
        const sql_type = types.find((v)=>sql.startsWith(v));
        let start_pos = sql_type.length;
        while(!this.#isTableName(sql[start_pos]))++start_pos;
        let end_pos = start_pos;
        while(this.#isTableName(sql[end_pos]))++end_pos;
        const table_name = sql.slice(start_pos, end_pos);
        return [
            sql_type,
            table_name
        ];
    }
    exec_one(sql) {
        if (sql.startsWith("VALUES ") || sql.startsWith("SELECT ")) return this.#db.selectObjects(sql);
        this.#db.exec(sql);
        const [type, name] = this.#extractTableNameFromSQL(sql);
        if (name in this.#desc) this.#updated_table.add(name);
        else this.#created_table.add(name);
        return null;
    }
    exec_many(sql) {
        let results = [];
        for(let i = 0; i < sql.length; ++i){
            try {
                results.push(this.exec_one(sql[i]));
            } catch (e) {
                console.warn(e);
                const message = "Error:" + e.message.split(':').slice(2).join(':');
                results.push(message);
                break;
            }
        }
        return results;
    }
}
const db2 = new DB("BDR1_CM", {
    Users: {
        schema: {
            ID: "INTEGER PRIMARY KEY AUTOINCREMENT",
            Nom: "TEXT",
            Prenom: "TEXT",
            Age: "INT"
        },
        entries: [
            [
                null,
                'Doe',
                'John',
                43
            ],
            [
                null,
                'Durant',
                'Paul',
                9
            ],
            [
                null,
                'Nescio',
                'Nomen',
                43
            ]
        ]
    },
    Produits: {
        schema: {
            Date: "TEXT",
            Ref: "TEXT",
            Q: "INT"
        },
        entries: [
            [
                '2023-01-01',
                'Gomme',
                10
            ],
            [
                '2023-02-23',
                'Gomme',
                9
            ],
            [
                '2023-06-13',
                'Gomme',
                24
            ],
            [
                '2023-01-01',
                'Crayon',
                20
            ],
            [
                '2023-02-23',
                'Crayon',
                18
            ],
            [
                '2023-06-13',
                'Crayon',
                50
            ]
        ]
    },
    T1: {
        schema: {
            ID: "INTEGER PRIMARY KEY AUTOINCREMENT",
            T1: "TEXT"
        },
        entries: [
            [
                null,
                '1'
            ],
            [
                null,
                '2'
            ],
            [
                null,
                '3'
            ]
        ]
    },
    T2: {
        schema: {
            ID: "INT",
            T2: "TEXT"
        },
        constraints: "FOREIGN KEY(ID) REFERENCES T1(ID)",
        entries: [
            [
                1,
                '1'
            ],
            [
                3,
                '2'
            ],
            [
                3,
                '3'
            ],
            [
                null,
                '4'
            ]
        ]
    }
});


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./src/struct/content.ts":
/*!*******************************!*\
  !*** ./src/struct/content.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root_path: () => (/* binding */ root_path)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    {
        name: "R 1-01 Tableur et Reporting",
        sname: "R1-01 Tableur",
        path: "R1-01",
        children: [
            {
                name: "CM",
                path: "CM",
                children: [
                    "CM1",
                    "CM2"
                ]
            },
            {
                name: "TP",
                path: "TP",
                children: [
                    "TP1",
                    "TP2"
                ]
            }
        ]
    },
    {
        name: "R 1-02 Bases de Données Relationnelles 1",
        sname: "R1-02 BDR1",
        path: "R1-02",
        children: [
            "CM",
            {
                name: "Slides",
                path: "Slides",
                children: [
                    "CM1",
                    "CM2",
                    "CM3",
                    "CM4"
                ]
            },
            {
                name: "TP",
                path: "TP",
                children: [
                    "TP1",
                    "TP2",
                    "TP3",
                    "TP4",
                    "TP5"
                ]
            },
            {
                name: "Cheat Sheet",
                path: "/assets/sql/cheat sheet.svg"
            }
        ]
    },
    {
        name: "R 3-03 Technologies Web",
        sname: "R3-03 Web1",
        path: "R3-03",
        children: [
            {
                name: "CM",
                path: "CM",
                children: [
                    "CM1",
                    "CM2",
                    "CM3"
                ]
            },
            {
                name: "TP",
                path: "TP",
                children: [
                    "TP1"
                ]
            },
            {
                name: "Cheat Sheet HTML",
                path: "/assets/web/HTML5/cheat sheet.svg"
            }
        ]
    },
    {
        name: "R 5-06-VCOD Développement Logiciel",
        sname: "R5-06-VCOD Dev Log",
        path: "R5-06-VCOD",
        children: [
            {
                name: "CM",
                path: "CM",
                children: [
                    "CM1"
                ]
            }
        ]
    }
]);
const root_path = [
    "localhost",
    "127.0.0.1"
].includes(location.hostname) ? "/dist/dev/pages/" : "/Cours/dist/dev/pages/";


/***/ }),

/***/ "./src/struct/menu.ts":
/*!****************************!*\
  !*** ./src/struct/menu.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _content__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content */ "./src/struct/content.ts");

/*
window.addEventListener('beforeprint', () => {
  //...
});
*/ //TODO: links...
const main = document.querySelector("main");
const header = document.querySelector("header");
const titles = document.querySelectorAll("h1, h2, h3, h4");
const htree = {
    html: main,
    level: 0,
    parent: null,
    children: []
};
let htree_cursor = htree;
for (let title of titles){
    const level = +title.tagName.slice(1);
    while(level <= htree_cursor.level)htree_cursor = htree_cursor.parent;
    const elem = {
        html: title,
        level,
        children: [],
        parent: htree_cursor
    };
    htree_cursor.children.push(elem);
    htree_cursor = elem;
}
function searchCurHeader(htree, position) {
    const headers = htree.children;
    for(let i = headers.length - 1; i >= 0; --i)if (headers[i].html.offsetTop <= position + 32) return searchCurHeader(headers[i], position) ?? headers[i];
    return null;
}
const hid = [
    [],
    [
        "I",
        "II",
        "III",
        "IV"
    ],
    [
        "1",
        "2",
        "3",
        "5",
        "6",
        "7",
        "8",
        "9"
    ],
    [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h"
    ]
];
function getTitlePrefix(s) {
    if (s.level >= hid.length) return "";
    const idx = s.parent.children.indexOf(s);
    const num = hid[s.level][idx];
    return `${num}. `;
}
function buildMenu(nodes) {
    const menu = document.createElement("div");
    menu.classList.add("menu");
    menu.append(...nodes.map((s, idx)=>{
        const item = document.createElement("a");
        item.textContent = `${getTitlePrefix(s)}${s.html.textContent}`;
        item.setAttribute("href", `#${s.html.id}`);
        return item;
    }));
    return menu;
}
function updateHeader() {
    const last = searchCurHeader(htree, main.scrollTop);
    let headers = [];
    let cursor = last;
    if (cursor !== null) while(cursor.html !== main){
        headers.push(cursor);
        cursor = cursor.parent;
    }
    const html = headers.reverse().map((hnode, i)=>{
        const h = hnode.html;
        const h_html = document.createElement("span");
        const link = document.createElement("a");
        link.textContent = `${getTitlePrefix(hnode)}${h.textContent}`;
        link.setAttribute('href', `#${h.id}`);
        const menu = buildMenu(hnode.parent.children);
        h_html.append(link, menu);
        return h_html;
    });
    if (last !== null && last.children.length !== 0) {
        const empty = document.createElement("span");
        empty.append(buildMenu(last.children));
        html.push(empty);
    }
    function make_page_href(pathprefix, path, desc) {
        // h4ck...
        if (path[0] === "/") return `${_content__WEBPACK_IMPORTED_MODULE_0__.root_path.slice(0, -6)}/${path}`;
        let href = `${pathprefix}${path}/`;
        while(desc.children?.length){
            desc = desc.children[0];
            href += `${desc.path ?? desc}/`;
        }
        return href;
    }
    function make_page_menu(pathprefix, path, pages) {
        const desc = pages.find((page)=>page === path || page.path === path);
        const html = document.createElement("span");
        {
            const link = document.createElement("a");
            link.textContent = desc.sname ?? desc.name ?? desc;
            link.setAttribute('href', make_page_href(pathprefix, path, desc));
            const menu = document.createElement("div");
            menu.classList.add("menu");
            menu.append(...pages.map((page)=>{
                const item = document.createElement("a");
                item.textContent = page.name ?? page;
                item.setAttribute("href", make_page_href(pathprefix, page.path ?? page, page));
                return item;
            }));
            html.append(link, menu);
        }
        return html;
    }
    let curpage = window.location.pathname.slice(_content__WEBPACK_IMPORTED_MODULE_0__.root_path.length).split('/');
    const module_html = make_page_menu(_content__WEBPACK_IMPORTED_MODULE_0__.root_path, curpage[0], _content__WEBPACK_IMPORTED_MODULE_0__["default"]);
    const desc = _content__WEBPACK_IMPORTED_MODULE_0__["default"].find((page)=>page.path === curpage[0]);
    const type_html = make_page_menu(_content__WEBPACK_IMPORTED_MODULE_0__.root_path + curpage[0] + "/", curpage[1], desc.children);
    const desc_type = desc.children.find((page)=>(page?.path ?? page) === curpage[1]);
    if (typeof desc_type !== "string") {
        // title num
        const desc2_idx = desc_type.children.findIndex((page)=>page?.path ?? page === curpage[2]);
        document.body.style.setProperty("--header_start_id", `${desc2_idx}`);
        // menu
        const session_html = make_page_menu(_content__WEBPACK_IMPORTED_MODULE_0__.root_path + curpage[0] + "/" + curpage[1] + "/", curpage[2], desc_type.children);
        html[0] = session_html;
    }
    header.replaceChildren(module_html, type_html, ...html);
}
const p = new URLSearchParams(location.search);
if (!p.has('ds')) {
    main.addEventListener('scroll', updateHeader);
    updateHeader();
}


/***/ }),

/***/ "./src/struct/struct.ts":
/*!******************************!*\
  !*** ./src/struct/struct.ts ***!
  \******************************/
/***/ (() => {

window.addEventListener('resize', ()=>{
    document.documentElement.style.setProperty('--screen_width', `${window.innerWidth}`);
});
document.documentElement.style.setProperty('--screen_width', `${window.innerWidth}`);


/***/ }),

/***/ "./src/struct/anim-player.js":
/*!***********************************!*\
  !*** ./src/struct/anim-player.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https://raw.githack.com/denis-migdal/LISS/main/index.js */ "https://raw.githack.com/denis-migdal/LISS/main/index.js");



const content = `<span class="reset">[Reset]</span><span class="prev">[Prev]</span><span class="play">[Play/Pause]</span><span class="next">[Next]</span>`;

const css = `
`;

const styles = [...document.querySelectorAll('style')].map(s => {
    let style = new CSSStyleSheet();
    style.replaceSync(s.textContent);
    return style;
});

class AnimPlayer extends (0,https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    content,
    css: [css, ...styles],
    attributes: ["speed"]
}) {

    constructor() {
        super();

        this.id = null;
        this.stepID = 0;

        this.content.querySelector(".prev" ).addEventListener("click", () => this.prev());
        this.content.querySelector(".next" ).addEventListener("click", () => this.next());
        this.content.querySelector(".play" ).addEventListener("click", () => this.play());
        this.content.querySelector(".reset").addEventListener("click", () => this.reset());
    }

    nextStep() {
        ++this.stepID;
        this.host.dispatchEvent( new CustomEvent("step", {detail: this.stepID}) );
    }


    cancelAutoPlay() {

        if(this.id === null)
            return false;

        clearInterval(this.id);
        this.id = null;
        return true;
    }

    prev() {
        const newStepID = this.stepID - 1;
        this.reset();
        while(this.stepID !== newStepID)
            this.nextStep();
    }
    next() {
        this.cancelAutoPlay();
        this.nextStep();
    }
    reset() {
        this.cancelAutoPlay();
        this.stepID = 0;
        this.host.dispatchEvent( new CustomEvent("reset") );
    }
    play() {

        if( this.cancelAutoPlay() )
            return;
        this.id = setInterval( () => this.nextStep(), +(this.attrs.speed ?? 500) );
    }
}

https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].define("anim-player", AnimPlayer)

/***/ }),

/***/ "./src/struct/sql-dym-table.js":
/*!*************************************!*\
  !*** ./src/struct/sql-dym-table.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https://raw.githack.com/denis-migdal/LISS/main/index.js */ "https://raw.githack.com/denis-migdal/LISS/main/index.js");
/* harmony import */ var _SQLite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SQLite */ "./src/struct/SQLite.ts");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_SQLite__WEBPACK_IMPORTED_MODULE_1__]);
_SQLite__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




const CSS =
`:host {
    display: inline-block;
}

:host table {
    border-collapse: collapse;

    & caption {
        font-weight: bold;
        font-size: 20px;
        line-height: 26px;
        font-style: italic;
    }
    
    & .highlight {
        background-color: #8B8000;
        print-color-adjust: exact;
    }

    /* TODO: make style adoptable through LISS... */
    .high_1 {
        background-color: red;
    }
    .high_2 {
        background-color: blue;
    }
    .high_3 {
        background-color: green;
    }
    .high_null {
        background-color: orange;
    }
    .hide {
        display: none;
    }
    .cur {
        border : 4px solid yellow;
        opacity: 0.5;
    }
    .lowlight {
        opacity: 0.25;
    }

    & td, & th {
        padding: 5px 10px;
        text-align: left;
    }

    & td {
        font-size: 16px;
        line-height: 22px;
    }

    & th {
        font-size: 20px;
        line-height: 26px;
    }
    
    & > tbody > tr + tr > td {
        border-top: 1px solid;
    }
}`;

class SQLDymTable extends (0,https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    attributes: ["table", "header", "cols"],
    css: CSS
}) {
    constructor() {
        super();

        let cols = this.attrs.cols ?? "*";

        this.exec(`SELECT ${cols} FROM ${this.attrs.table};`)
    }

    get nbRows() {
        return this.rows.length;
    }
    getRow(rowid) {
        return this.rows[rowid];
    }

    exec(query) {

        this.data = _SQLite__WEBPACK_IMPORTED_MODULE_1__.db2.exec_one(query);

        const table = document.createElement('table');

        const caption = document.createElement('caption');

        if( this.attrs.header === null)
            caption.textContent = `Table ${this.attrs.table} :`;
        else
            caption.textContent = this.attrs.header;

        //TODO: colgroup (for highlight).

        const colgroup = document.createElement('colgroup');
        const thead = document.createElement('thead');
        const trhead = document.createElement('tr');

        this.cols = {};

        const colnames =  Object.keys(this.data[0]);
        for(let colname of colnames) {
            const col = document.createElement('col');
            //col.classList.add('highlight');
            colgroup.append(col);

            this.cols[colname] = col;

            const th = document.createElement('th');
            th.textContent = colname;
            trhead.append(th);
        }
        thead.append(trhead);

        this.rows = [];

        const tbody = document.createElement('tbody');
        for(let line of this.data) {

            const tr = document.createElement('tr');
            for(let colname of colnames) {
                const td = document.createElement('td');
                td.textContent = line[colname] ?? "N/A";
                tr.append(td);
            }
            tbody.append(tr);

            this.rows.push([line,tr]);
        }

        table.append(caption, colgroup, thead, tbody);
        this.content.replaceChildren(table);
    }

    groupBy( group_colname ) {

        const tbody = this.content.querySelector("tbody");

        let groups = {};

        for(let line of this.data) {
            const group = line[group_colname];
            (groups[group] ??= []).push( line );
        }

        let rows = [];
        for(let groupname in groups) {

            const group = groups[groupname];

            for(let i = 0; i < group.length; ++i) {

                const entry = group[i];
                const tr = document.createElement('tr');

                for(let col in group[i]) {

                    const cell = document.createElement('td');
                    cell.textContent = entry[col];

                    if( col === group_colname ){
                        if(i !== 0)
                            continue;

                        cell.setAttribute("rowspan", group.length);
                    }

                    tr.append(cell);
                }
                rows.push(tr);
            }
                
            rows.push(document.createElement("tr"));
        }

        tbody.replaceChildren(...rows);
    }

    highlightCol( filter ) {
        for(let colname in this.cols)
            this.#highlight(this.cols[colname], filter(colname) );
    }

    #highlight(target, highlight) { // target: HTMLElement, highlight: boolean|string|Record<string, boolean> ) {

        if( typeof highlight === "boolean")
            return target.classList.toggle('highlight', highlight);
        if( typeof highlight === "string" )
            return target.classList.add(highlight);
        
        for(let name in highlight)
            target.classList.toggle(name, highlight[name]);

    }

    highlightRow( filter ) {
        for(let i = 0; i < this.rows.length; ++i)
            this.#highlight( this.rows[i][1], filter(this.rows[i][0], i) );
    }

    highlightCells( filter ) {

        for(let i = 0; i < this.rows.length; ++i) {

            const [row_data, row_html] = this.rows[i];
            const cols = Object.keys(row_data);

            for(let j = 0; j < cols.length; ++j)
                this.#highlight( row_html.children[j] , filter(row_data, cols[j]) );
        }
    }
};


https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].define("sql-dymtable", SQLDymTable)
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/sql-interactive.js":
/*!***************************************!*\
  !*** ./src/struct/sql-interactive.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SQLite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SQLite */ "./src/struct/SQLite.ts");
/* harmony import */ var LISS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! LISS */ "./libs/LISS/index.ts");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_SQLite__WEBPACK_IMPORTED_MODULE_0__]);
_SQLite__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


// LISS



const content = `
    <slot name="select"></slot>
    <slot name="options"></slot>
    <slot></slot>
    <slot name="pre"></slot>
    <div class="choices">
        <div class="options"></div>
        <div class="query"></div>
    </div>
    <pre class="hljs"><code><div class="result"></div></code></pre>
    <div class="spacing"></div>
    <slot name="post"></slot>`;

const css = `
    :host([option]) pre {
        margin: 0;
    }

    :host {
        font-size: 14px;
        line-height: 19px;
    }

    .selected, .highlight {
        background-color: gold;
    }
    :host .spacing {
        flex-grow: 1;
    }
    :host .query pre.hljs {
        padding-right: 0;

        & > code > div {
            padding-right: 0;
        }
    }
    :host pre.hljs {

        margin: 2px;

        & > code > div {
           padding: 8px;
        }
    }
    .options pre {
        position: relative;
        padding-bottom: 4px;
        padding-right: 25px;

        &.withdesc {
            padding-top: 0px;
        }
    }
    .options pre::after {
        content: ">";
        position: absolute;
        right: 0px;
        top: 0px;
        height: 100%;
        width: 25px;
        background-color: orange;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        
    }
    .options pre:hover {
        opacity: 0.5;
    }
    :host {
        /*display: inline-flex;*/
        display: flex;
        gap: 5px;
    }
    slot:not([name="post"]):not([name="pre"]) {
        display: none;
    }
    span.value {
        border: 1px solid black;
        padding-left: 5px;
        padding-right: 5px;
    }

    .option {
        cursor: pointer;
    }

    .error {
        background-color: #FFA07A !important;
    }

    .query > pre .value {
        position: relative;
        margin-right: 13px;
    }

    .query > pre .value::after {

        right: -18px;
        position: absolute;
        content: "🖉";
    }

    :host > pre.hljs {
        /*flex-grow: 1;*/
    }

    :host .desc {
        margin-left: -0.5em;
        /*position: absolute;
        top: 0px;
        left: 0px;*/

        font-size: 14px;
        line-height: 19px;

        width: calc(100% + 0.5em);
        border-left: none;
        border-top: none;
        padding-left: 5px;
        font-style: italic;

        box-sizing: border-box;

        background-color: lightgray;
        opacity: 0.6;
    }

    pre {
        padding: 0.5em;
        background-color: white;
        color: black;
    }

    code {
        font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
    }

    /* Tomorrow Theme */
    /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
    /* Original theme - https://github.com/chriskempson/tomorrow-theme */

    /* Tomorrow Comment */
    .hljs-comment,
    .hljs-quote {
        color: #8e908c;
    }

    /* Tomorrow Red */
    .hljs-variable,
    .hljs-template-variable,
    .hljs-tag,
    .hljs-name,
    .hljs-selector-id,
    .hljs-selector-class,
    .hljs-regexp,
    .hljs-deletion {
        color: #c82829;
    }

    /* Tomorrow Orange */
    .hljs-number,
    .hljs-built_in,
    .hljs-builtin-name,
    .hljs-literal,
    .hljs-type,
    .hljs-params,
    .hljs-meta,
    .hljs-link {
        color: #f5871f;
    }

    /* Tomorrow Yellow */
    .hljs-attribute {
        color: #eab700;
    }

    /* Tomorrow Green */
    .hljs-string,
    .hljs-symbol,
    .hljs-bullet,
    .hljs-addition {
        color: #718c00;
    }

    /* Tomorrow Blue */
    .hljs-title,
    .hljs-section {
        color: #4271ae;
    }

    /* Tomorrow Purple */
    .hljs-keyword,
    .hljs-selector-tag {
        color: #8959a8;
    }

    .hljs {
        display: block;
        overflow-x: auto;
        color: #4d4d4c;
        padding: 0.5em;
    }

    .hljs-emphasis {
        font-style: italic;
    }

    .hljs-strong {
        font-weight: bold;
    }
`;

/*
const styles = [...document.querySelectorAll('style')].map(s => {
    let style = new CSSStyleSheet();
    style.replaceSync(s.textContent);
    return style;
});*/

class SQLInteractive extends (0,LISS__WEBPACK_IMPORTED_MODULE_1__["default"])({
    content,
    css: [css],
    attributes: ["full-reset", "option"]
}) {

    #result   = "";
    #query    = null;
    #options  = null;
    #input    = null;
    #selected = null;

    #selectQuery = null;

    onAttrChanged(name, _old, value) {
        if(name !== "option")
            return;

        setOption(+value);
    }

    setOption(idx) {

        for(let i = 0; i < this.#options.children.length; ++i) {
            const opt = this.#options.children[i];
            opt.style.setProperty("display", i === idx ? null : "none");
            if( i === idx)
                opt.click();
        }
        this.#query.style.setProperty("display", "none");

        this.host.style.setProperty("flex-wrap", "wrap");

    }

    constructor() {
        super();

        this.#result   = this.content.querySelector(".result");
        this.#query    = this.content.querySelector(".query");
        this.#options  = this.content.querySelector(".options");
 
        let selectQuery = this.content.querySelector("slot[name='select']").assignedElements();
        if(selectQuery.length === 1)
            this.#selectQuery  = selectQuery[0].textContent;

        this.#options.addEventListener("click", (ev) => {

            let option = ev.target.closest(".option");
            if(option === null)
                return;
            ev.preventDefault();

            if(this.#selected !== null)
                this.#selected.classList.remove('selected');
            option.classList.add('selected');
            this.#selected = option;

            this.lastVars = {};

            const optsvalues = option.querySelectorAll('.value');
            for( let optsvalue of optsvalues) { // not optimal but it works

                this.lastVars[optsvalue.dataset.name] = optsvalue.textContent;

                const values = this.#input.querySelectorAll(`.value[data-name="${optsvalue.dataset.name}"]`);
                for(let value of values)
                    value.textContent = optsvalue.textContent;
            }

            this.#execQuery( );
        });

        let query = this.content.querySelector("slot:not([name])").assignedElements()[0];
        //TODO: find & replace...

        this.#input = query.cloneNode(true);

        this.#query.append(this.#input);

        let options = this.content.querySelector("slot[name='options']").assignedElements();

        const childNodes = [...this.#input.children[0].childNodes];

        for(let i = 0; i < childNodes.length; ++i) {

            const node = childNodes[i];
            if( node.nodeType !== Node.TEXT_NODE)
                continue;

            let text = node.textContent;
            let start = text.indexOf('$');
            if( start === -1)
                continue;

            let result = [];

            while( start !== -1) { // not optimal but it works...
                
                let end = text.slice(start+1).search(/[\W]/);
                
                if( end === -1) {
                    console.log( text, start, text.slice(start+1) );
                    throw new Error('End of SQL variable not found (you likely used a reserved keyword)');
                }
                end += start + 1;

                const value = document.createElement("span");
                value.classList.add("value");
                value.dataset.name = text.slice(start+1, end).toLowerCase();

                result.push(... text.slice(0, start), value );

                text = text.slice(end);
                start = text.indexOf('$');
            }

            result.push(text);

            node.replaceWith(...result);
        }

        let option_template = this.#input.cloneNode(true);

        const values = this.#input.querySelectorAll('.value');
        for(let value of values) {

            value.toggleAttribute('contenteditable');
            if( ! value.dataset.name.startsWith('m_') ) {
                value.addEventListener('keypress', (ev) => {

                    if(ev.key === "Enter") {
                        ev.preventDefault();
                        value.blur();
                        return;
                    }
                });
            }


            value.addEventListener('input', (ev) => {

                if(this.#selected !== null)
                    this.#selected.classList.remove('selected');
                this.#input.classList.add('selected');
                this.#selected = this.#input;

                const syncinputs = this.#input.querySelectorAll(`.value[data-name="${ev.target.dataset.name}"]`);
                for( let input of syncinputs ) {
                    if(input === ev.target)
                        continue;
                    input.textContent = ev.target.textContent;
                }

                this.#execQuery();
            });
        }

        for(let option of options) {

            const opt = option_template.cloneNode(true);
            opt.classList.add("option");

            const values = opt.querySelectorAll('.value');
            for(let value of values) {
                const name  = value.dataset.name;
                value.textContent = option.dataset[ name ];
            }

            if( option.textContent !== "") {
                opt.classList.add('withdesc');

                const desc = document.createElement('div');
                desc.classList.add("desc");
                desc.textContent = option.textContent.trim() + " :";

                opt.firstElementChild.before(desc);
            }

            this.#options.append( opt );
        }

        if( this.attrs.option !== null) {
            this.setOption(+this.attrs.option);
            return;
        }

        if( this.#selectQuery === null)
            this.#options.firstElementChild.click();
    }

    #getQuery() {

        let query = "";
        for(let elem of this.#input.firstElementChild.childNodes ) {

            const content = elem.textContent;
            if(content === "" && elem instanceof HTMLElement && elem.classList.contains("value")) {
                if( query[query.length-1] === " " )
                    query = query.slice(0,-1);
            }
            query += elem.textContent;
        }

        return query;
    }

    #execQuery() {


        let queries = this.#getQuery().split(';\n').slice(0,-1).map( q => q + ";");

        // build queries to execute...

        const exec_queries = [];
        let show_table = true;

        let show_queries = null;
        if( this.#selectQuery !== null ) {
            show_queries = this.#selectQuery.split(';').slice(0,-1).map( q => q.trim() + ";");
        }

        const show = () => {
            show_table = false;
            if( show_queries === null )
                return;
            exec_queries.push(...show_queries);
        }

        for(let i = 0; i < queries.length; ++i) {
            const query = queries[i];

            if( query.startsWith("SELECT ") || query.startsWith("VALUES ") ) {
                exec_queries.push(query);
                continue;
            }

            if( query.startsWith("CREATE TABLE ") ) {

                let q = "CREATE TABLE ";
                if( query.startsWith("CREATE TABLE IF EXISTS ") )
                    q = "CREATE TABLE IF EXISTS ";

                exec_queries.push(query);
                const tb_name = query.slice(13, query.indexOf(" ", q.length) );
                exec_queries.push(`SELECT name, type, "notnull", dflt_value, pk, hidden\n        FROM pragma_table_xinfo('${tb_name}');`);
                show_table = false;
                continue;
            }

            if( show_table )
                show();

            exec_queries.push(query);

            show();
        }

        let results = _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.exec_many(exec_queries);
        this.updateResult(exec_queries, results);
        
        if( this.attrs["full-reset"] === "true")
            _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.fullReset();
        else
            _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.reset();
    }


    #hline(colsizes) {
        let result = '+';
        for(let colsize of colsizes)
            result += "".padEnd(colsize + 2, "-") + '+';

        return result;
    }

    #padRow(row, colsizes) {
        return row.map( (_, i) => row[i].padEnd(colsizes[i] + 1, " ") );
    }
    #rawline(row) {
        let result = "|";
        for(let i = 0; i < row.length; ++i)
            result += " " + row[i] + "|";

        result += "\n";
        return result;

    }

    #line(row, colsizes) {
        let result = "|";
        for(let i = 0; i < colsizes.length; ++i)
            result += " " + row[i].padEnd(colsizes[i] + 1, " ") + "|";

        result += "\n";
        return result;
    }

    updateResult(queries, datas) {

        this.#input.classList.remove('error');
        this.#result.classList.remove('error');
        let content = '';

        for(let i = 0; i < datas.length; ++i) {

            let compare_to = null;

            // correct select
            if( datas[i] !== null && typeof datas[i] !== "string") {

                // compare_to last or first
                for(let j = datas.length - 1; j > i; --j)
                    if( queries[j] === queries[i] && datas[j] !== null && typeof datas[j] !== "string" ) {
                        compare_to = datas[j];
                        break;
                    }
                
                if( compare_to === null) {

                    for(let j = 0; j < i; ++j)
                        if( queries[j] === queries[i] && datas[j] !== null && typeof datas[j] !== "string" ) {
                            compare_to = datas[j];
                            break;
                        }
                }
            }

            const query = queries[i];
            const data  = datas[i];

            content += `sqlite> ${query}\n`;

            if( data === null )
                continue;

            if( typeof data === "string") { // exception

                this.#input.classList.add('error');
                this.#result.classList.add('error');

                content += data;

                continue;
            }

            if( data.length === 0 ) {
                content += `No row returned.\n`;
                continue;
            }

            const headers = Object.keys(data[0]);
            const results = [
                ... data.map(entry => Object.values(entry).map(value => {
                        if( value === null )
                            return 'N/A';
                        if(typeof value === 'string')
                            return `'${value}'`;
                        return value.toString()
                    }) )   
            ];
    
            const colsizes = new Array(headers.length);
            for(let i = 0; i < colsizes.length; ++i) {
                colsizes[i] = headers[i].length;
                for(let row of results)
                    if( row[i].length > colsizes[i] )
                        colsizes[i] = row[i].length;
            }
    
    
            let result_text = this.#hline(colsizes) + "\n";
            result_text +=  this.#line(headers, colsizes);
            result_text +=  this.#hline(colsizes) + "\n";
            for(let j = 0; j < results.length; ++j) {

                let row = results[j];

                if( compare_to === null) {
                    result_text += this.#line(row, colsizes);
                    continue;
                }

                // highlight changes

                let key = "ID";
                if( ! (key in data[j]) )
                    key = "name";

                let cmp_line = compare_to.find( e => e[key] === data[j][key]); // h4cky

                row = this.#padRow(row, colsizes);

                if( cmp_line === undefined) {
                    row = row.map( c => `<strong><em>${c}</em></strong>`);
                    let line = this.#rawline(row);
                    result_text += `<span class="highlight">${line}</span>`;
                    continue;
                }

                for(let i = 0; i < headers.length; ++i) {
                    const colname = headers[i];

                    if( data[j][colname] !== cmp_line[colname])
                        row[i] = `<span class=highlight><em><strong>${row[i]}</strong></em></span>`;
                    
                }

                result_text += this.#rawline(row);
            }
            result_text +=  this.#hline(colsizes);
    
            content += result_text + '\n';   
        }

        this.#result.innerHTML = content;

        this.#lastDatas = datas;

        this.host.dispatchEvent( new CustomEvent("change", {detail: {
            datas
        }}) );
    }

    #lastDatas = null;

    get lastDatas() {
        return this.#lastDatas;
    }
}

LISS__WEBPACK_IMPORTED_MODULE_1__["default"].define("sql-interactive", SQLInteractive)
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/sqlite/sqlite3.js":
/*!**************************************!*\
  !*** ./src/struct/sqlite/sqlite3.js ***!
  \**************************************/
/***/ ((module) => {

/*
** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.
**
** This bundle (typically released as sqlite3.js or sqlite3.mjs)
** is an amalgamation of JavaScript source code from two projects:
**
** 1) https://emscripten.org: the Emscripten "glue code" is covered by
**    the terms of the MIT license and University of Illinois/NCSA
**    Open Source License, as described at:
**
**    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html
**
** 2) https://sqlite.org: all code and documentation labeled as being
**    from this source are released under the same terms as the sqlite3
**    C library:
**
** 2022-10-16
**
** The author disclaims copyright to this source code.  In place of a
** legal notice, here is a blessing:
**
** *   May you do good and not evil.
** *   May you find forgiveness for yourself and forgive others.
** *   May you share freely, never taking more than you give.
*/
/*
** This code was built from sqlite3 version...
**
** SQLITE_VERSION "3.45.2"
** SQLITE_VERSION_NUMBER 3045002
** SQLITE_SOURCE_ID "2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77"
**
** Using the Emscripten SDK version 3.1.30.
*/

var sqlite3InitModule = (() => {
  //var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  const ROOT = ["localhost", "127.0.0.1"].includes(location.hostname) ? "/dist/dev/" : "/Cours/dist/dev/";
  const _scriptDir = `${ROOT}assets/sql/sqlite3.wasm`;

  return (
function(config) {
  var sqlite3InitModule = config || {};
















var Module = typeof sqlite3InitModule != 'undefined' ? sqlite3InitModule : {};


var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});






const sqlite3InitModuleState = globalThis.sqlite3InitModuleState
      || Object.assign(Object.create(null),{
        debugModule: ()=>{}
      });
delete globalThis.sqlite3InitModuleState;
sqlite3InitModuleState.debugModule('globalThis.location =',globalThis.location);


Module['locateFile'] = function(path, prefix) {
  'use strict';
  let theFile;
  const up = this.urlParams;
  if(up.has(path)){
    theFile = up.get(path);
  }else if(this.sqlite3Dir){
    theFile = this.sqlite3Dir + path;
  }else if(this.scriptDir){
    theFile = this.scriptDir + path;
  }else{
    theFile = prefix + path;
  }
  sqlite3InitModuleState.debugModule(
    "locateFile(",arguments[0], ',', arguments[1],")",
    'sqlite3InitModuleState.scriptDir =',this.scriptDir,
    'up.entries() =',Array.from(up.entries()),
    "result =", theFile
  );
  return theFile;
}.bind(sqlite3InitModuleState);


const xNameOfInstantiateWasm =  false
      ? 0
      : 'emscripten-bug-17951';
Module[xNameOfInstantiateWasm] = function callee(imports,onSuccess){
  imports.env.foo = function(){};
  const uri = Module.locateFile(
    callee.uri, (
      ('undefined'===typeof scriptDirectory)
        ? "" : scriptDirectory)
  );
  sqlite3InitModuleState.debugModule(
    "instantiateWasm() uri =", uri
  );
  const wfetch = ()=>fetch(uri, {credentials: 'same-origin'});
  const loadWasm = WebAssembly.instantiateStreaming
        ? async ()=>{
          return WebAssembly.instantiateStreaming(wfetch(), imports)
            .then((arg)=>onSuccess(arg.instance, arg.module));
        }
        : async ()=>{ 
          return wfetch()
            .then(response => response.arrayBuffer())
            .then(bytes => WebAssembly.instantiate(bytes, imports))
            .then((arg)=>onSuccess(arg.instance, arg.module));
        };
  loadWasm();
  return {};
};

Module[xNameOfInstantiateWasm].uri = 'sqlite3.wasm';








var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};





var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';


var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;


var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}


var read_,
    readAsync,
    readBinary,
    setWindowTitle;




if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { 
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { 
    scriptDirectory = document.currentScript.src;
  }
  
  
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  
  
  
  
  
  
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  
  
  {



  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array((xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { 
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }


  }

  setWindowTitle = (title) => document.title = title;
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);


Object.assign(Module, moduleOverrides);


moduleOverrides = null;






if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];






var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': case 'u8': return 1;
    case 'i16': case 'u16': return 2;
    case 'i32': case 'u32': return 4;
    case 'i64': case 'u64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      }
      if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      }
      return 0;
    }
  }
}



















var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}



var wasmMemory;







var ABORT = false;




var EXITSTATUS;


function assert(condition, text) {
  if (!condition) {
    
    
    
    abort(text);
  }
}







var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;


function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  
  
  
  
  
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  }
  var str = '';
  
  
  while (idx < endPtr) {
    
    
    
    
    var u0 = heapOrArray[idx++];
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    var u1 = heapOrArray[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    var u2 = heapOrArray[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
    }

    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
  return str;
}


function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}


function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  
  
  if (!(maxBytesToWrite > 0))
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; 
  for (var i = 0; i < str.length; ++i) {
    
    
    
    
    
    
    
    var u = str.charCodeAt(i); 
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  
  heap[outIdx] = 0;
  return outIdx - startIdx;
}


function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}


function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    
    
    
    
    var c = str.charCodeAt(i); 
    if (c <= 0x7F) {
      len++;
    } else if (c <= 0x7FF) {
      len += 2;
    } else if (c >= 0xD800 && c <= 0xDFFF) {
      len += 4; ++i;
    } else {
      len += 3;
    }
  }
  return len;
}




var HEAP,

  HEAP8,

  HEAPU8,

  HEAP16,

  HEAPU16,

  HEAP32,

  HEAPU32,

  HEAPF32,

  HEAP64,

  HEAPU64,

  HEAPF64;

function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
  Module['HEAP64'] = HEAP64 = new BigInt64Array(b);
  Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);
}

var STACK_SIZE = 524288;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;







  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      
      
      
      
      
      'maximum': 2147483648 / 65536
    });
  }

updateMemoryViews();



INITIAL_MEMORY = wasmMemory.buffer.byteLength;







var wasmTable;










var __ATPRERUN__  = []; 
var __ATINIT__    = []; 
var __ATEXIT__    = []; 
var __ATPOSTRUN__ = []; 

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}




















var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; 

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); 
    }
  }
}


function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what = 'Aborted(' + what + ')';
  
  
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what += '. Build with -sASSERTIONS for more info.';

  
  
  
  
  
  
  
  

  
  
  
  
  
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  
  
  
  throw e;
}











var dataURIPrefix = 'data:application/octet-stream;base64,';


function isDataURI(filename) {
  
  return filename.startsWith(dataURIPrefix);
}


function isFileURI(filename) {
  return filename.startsWith('file://');
}


var wasmBinaryFile;
  wasmBinaryFile = 'sqlite3.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  
  
  
  
  
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
  }

  
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}



function createWasm() {
  
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  
  
  
  
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  
  addRunDependency('wasm-instantiate');

  
  function receiveInstantiationResult(result) {
    
    
    
    
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        
        
        
        
        
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            
            
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  
  
  
  
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
        
        readyPromiseReject(e);
    }
  }

  
  instantiateAsync().catch(readyPromiseReject);
  return {}; 
}


var tempDouble;
var tempI64;



var ASM_CONSTS = {
  
};





  
  function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = 'Program terminated with exit(' + status + ')';
      this.status = status;
    }

  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        
        callbacks.shift()(Module);
      }
    }

  
    
  function getValue(ptr, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP64[((ptr)>>3)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return HEAPF64[((ptr)>>3)];
        case '*': return HEAPU32[((ptr)>>2)];
        default: abort('invalid type for getValue: ' + type);
      }
      return null;
    }

  
    
  function setValue(ptr, value, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': HEAP8[((ptr)>>0)] = value; break;
        case 'i8': HEAP8[((ptr)>>0)] = value; break;
        case 'i16': HEAP16[((ptr)>>1)] = value; break;
        case 'i32': HEAP32[((ptr)>>2)] = value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)] = value; break;
        case 'double': HEAPF64[((ptr)>>3)] = value; break;
        case '*': HEAPU32[((ptr)>>2)] = value; break;
        default: abort('invalid type for setValue: ' + type);
      }
    }

  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:(parts, allowAboveRoot) => {
        
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          
          return '.';
        }
        if (dir) {
          
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:(path) => {
        
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },join:function() {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join('/'));
      },join2:(l, r) => {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        
        var randomBuffer = new Uint8Array(1);
        return () => { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      
      return () => abort("randomDevice");
    }
  
  
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; 
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        
        
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  
  
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }
  var TTY = {ttys:[],init:function () {
        
        
        
        
        
        
        
        
      },shutdown:function() {
        
        
        
        
        
        
        
        
        
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          
          stream.tty.ops.fsync(stream.tty);
        },fsync:function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },read:function(stream, buffer, offset, length, pos ) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              
              result = window.prompt('Input: ');  
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); 
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
      return address;
    }
  
  function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
  function mmapAlloc(size) {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      return zeroMemory(ptr, size);
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 , 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; 
          
          
          
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); 
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; 
        
        
        
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); 
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); 
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); 
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; 
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); 
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); 
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          
          
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511  | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { 
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          
          
          
          
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { 
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { 
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { 
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; 
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          
          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            
            
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          
          return 0;
        }}};
  
  
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, (arrayBuffer) => {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, (event) => {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  
          throw new FS.ErrnoError(32);
        }
  
        
        var parts = path.split('/').filter((p) => !!p);
  
        
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          
          
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || 
              (flags & 512)) { 
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream =  function() {
            this.shared = { };
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              
              get: function() { return this.node; },
              
              set: function(val) { this.node = val; }
            },
            isRead: {
              
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              
              get: function() { return (this.flags & 1024); }
            },
            flags: {
              
              get: function() { return this.shared.flags; },
              
              set: function(val) { this.shared.flags = val; },
            },
            position : {
              
              get: function() { return this.shared.position; },
              
              set: function(val) { this.shared.position = val; },
            },
          });
        }
        
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          
          stream.stream_ops = device.stream_ops;
          
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          
          node.mounted = mount;
  
          
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        
        node.mounted = null;
  
        
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 ;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 ;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 ;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        
        var lookup, old_dir, new_dir;
  
        
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        
        var old_node = FS.lookupNode(old_dir, old_name);
        
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          
        }
        
        if (old_node === new_node) {
          return;
        }
        
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        
        
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        
        FS.hashRemoveNode(old_node);
        
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          
          
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          
          
          
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438  : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            
          }
        }
        
        var created = false;
        if ((flags & 64)) {
          if (node) {
            
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        
        
        
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        
        flags &= ~(128 | 512 | 131072);
  
        
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          
          ungotten: [],
          error: false
        });
        
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; 
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, length, position, prot, flags) => {
        
        
        
        
        
        
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        
        FS.mkdir('/dev');
        
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        
        
        
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        
        
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        
        
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 , 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; 
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        
        
        
  
        
        
        
        
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError =  function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno =  function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        
        
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },analyzePath:(path, dontResolveLastLink) => {
        
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        
        
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos ) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          
          try {
            
            
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        
        
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; 
        }
        LazyUint8Array.prototype.get =  function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; 
  
          if (!hasByteServing) chunkSize = datalength;
  
          
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array((xhr.response || []));
            }
            return intArrayFromString(xhr.responseText || '', true);
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; 
            end = Math.min(end, datalength-1); 
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            
            chunkSize = datalength = 1; 
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get:  function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get:  function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        
        
        
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        
        Object.defineProperties(node, {
          usedBytes: {
            get:  function() { return this.contents.length; }
          }
        });
        
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { 
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { 
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr: ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        
        
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); 
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; 
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAPU32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        (tempI64 = [Math.floor(atime / 1000)>>>0,(tempDouble=Math.floor(atime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(64))>>2)] = (atime % 1000) * 1000;
        (tempI64 = [Math.floor(mtime / 1000)>>>0,(tempDouble=Math.floor(mtime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(80))>>2)] = (mtime % 1000) * 1000;
        (tempI64 = [Math.floor(ctime / 1000)>>>0,(tempDouble=Math.floor(ctime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(96))>>2)] = (ctime % 1000) * 1000;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(104))>>2)] = tempI64[0],HEAP32[(((buf)+(108))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      }};
  function ___syscall_chmod(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        
        return -28;
      }
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node) {
        return -44;
      }
      var perms = '';
      if (amode & 4) perms += 'r';
      if (amode & 2) perms += 'w';
      if (amode & 1) perms += 'x';
      if (perms  && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchmod(fd, mode) {
  try {
  
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchown32(fd, owner, group) {
  try {
  
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  
  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5:
         {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 6:
        case 7:
        
        
          
          
          return 0; 
        case 16:
        case 8:
          return -28; 
        case 9:
          
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var MAX_INT53 = 9007199254740992;
  
  var MIN_INT53 = -9007199254740992;
  function bigintToI53Checked(num) {
      return (num < MIN_INT53 || num > MAX_INT53) ? NaN : Number(num);
    }
  
  
  
  
  function ___syscall_ftruncate64(fd,  length) {
  try {
  
      length = bigintToI53Checked(length); if (isNaN(length)) return -61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes) return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; 
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; 
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          
          
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          
          
          
          if (!stream.tty) return -59;
          return 0;
        }
        default: return -28; 
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdirat(dirfd, path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      
      
      path = PATH.normalize(path);
      if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~6400);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0) return -28;
      var ret = FS.readlink(path);
  
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf+len];
      stringToUTF8(ret, buf, bufsize+1);
      
      
      HEAP8[buf+len] = endChar;
      return len;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function readI53FromI64(ptr) {
      return HEAPU32[ptr>>2] + HEAP32[ptr+4>>2] * 4294967296;
    }
  
  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[(((times)+(8))>>2)];
        atime = (seconds*1000) + (nanoseconds/(1000*1000));
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[(((times)+(8))>>2)];
        mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var nowIsMonotonic = true;;
  function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

  
  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  var __MONTH_DAYS_LEAP_CUMULATIVE = [0,31,60,91,121,152,182,213,244,274,305,335];
  
  var __MONTH_DAYS_REGULAR_CUMULATIVE = [0,31,59,90,120,151,181,212,243,273,304,334];
  function __yday_from_date(date) {
      var isLeapYear = __isLeapYear(date.getFullYear());
      var monthDaysCumulative = (isLeapYear ? __MONTH_DAYS_LEAP_CUMULATIVE : __MONTH_DAYS_REGULAR_CUMULATIVE);
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; 
  
      return yday;
    }
  function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time)*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var yday = __yday_from_date(date)|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    }

  
  
  function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, off, prot, flags);
      var ptr = res.ptr;
      HEAP32[((allocated)>>2)] = res.allocated;
      HEAPU32[((addr)>>2)] = ptr;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  
  
  function __munmap_js(addr, len, prot, flags, fd, offset) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
      
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }
  function __tzset_js(timezone, daylight, tzname) {
      
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      
      
      
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      
      
      
      
      
      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        
        HEAPU32[((tzname)>>2)] = winterNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = summerNamePtr;
      } else {
        HEAPU32[((tzname)>>2)] = summerNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = winterNamePtr;
      }
    }

  function _emscripten_date_now() {
      return Date.now();
    }

  var _emscripten_get_now;_emscripten_get_now = () => performance.now();
  ;

  function getHeapMax() {
      
      
      
      
      return 2147483648;
    }
  
  function emscripten_realloc_buffer(size) {
      var b = wasmMemory.buffer;
      try {
        
        wasmMemory.grow((size - b.byteLength + 65535) >>> 16); 
        updateMemoryViews();
        return 1 ;
      } catch(e) {
      }
      
      
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      
      
  
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
  
      
      
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
  
      
      
      
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); 
        
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    }

  var ENV = {};
  
  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        
        
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        
        for (var x in ENV) {
          
          
          
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  
  
  function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
      }
      
      if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
    }
  
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  
  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      
      
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)] = type;
      
      
      
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; 
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }
  
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  
  
  
  function _fd_seek(fd,  offset, whence, newOffset) {
  try {
  
      offset = bigintToI53Checked(offset); if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; 
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_sync(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (stream.stream_ops && stream.stream_ops.fsync) {
        return stream.stream_ops.fsync(stream);
      }
      return 0; 
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }
  
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  var FSNode =  function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: function() {
     return (this.mode & readMode) === readMode;
    },
    set: function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
var ASSERTIONS = false;

var asmLibraryArg = {
  "__syscall_chmod": ___syscall_chmod,
  "__syscall_faccessat": ___syscall_faccessat,
  "__syscall_fchmod": ___syscall_fchmod,
  "__syscall_fchown32": ___syscall_fchown32,
  "__syscall_fcntl64": ___syscall_fcntl64,
  "__syscall_fstat64": ___syscall_fstat64,
  "__syscall_ftruncate64": ___syscall_ftruncate64,
  "__syscall_getcwd": ___syscall_getcwd,
  "__syscall_ioctl": ___syscall_ioctl,
  "__syscall_lstat64": ___syscall_lstat64,
  "__syscall_mkdirat": ___syscall_mkdirat,
  "__syscall_newfstatat": ___syscall_newfstatat,
  "__syscall_openat": ___syscall_openat,
  "__syscall_readlinkat": ___syscall_readlinkat,
  "__syscall_rmdir": ___syscall_rmdir,
  "__syscall_stat64": ___syscall_stat64,
  "__syscall_unlinkat": ___syscall_unlinkat,
  "__syscall_utimensat": ___syscall_utimensat,
  "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
  "_localtime_js": __localtime_js,
  "_mmap_js": __mmap_js,
  "_munmap_js": __munmap_js,
  "_tzset_js": __tzset_js,
  "emscripten_date_now": _emscripten_date_now,
  "emscripten_get_now": _emscripten_get_now,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "fd_close": _fd_close,
  "fd_fdstat_get": _fd_fdstat_get,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_sync": _fd_sync,
  "fd_write": _fd_write,
  "memory": wasmMemory
};
var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};


var _sqlite3_status64 = Module["_sqlite3_status64"] = function() {
  return (_sqlite3_status64 = Module["_sqlite3_status64"] = Module["asm"]["sqlite3_status64"]).apply(null, arguments);
};


var _sqlite3_status = Module["_sqlite3_status"] = function() {
  return (_sqlite3_status = Module["_sqlite3_status"] = Module["asm"]["sqlite3_status"]).apply(null, arguments);
};


var _sqlite3_db_status = Module["_sqlite3_db_status"] = function() {
  return (_sqlite3_db_status = Module["_sqlite3_db_status"] = Module["asm"]["sqlite3_db_status"]).apply(null, arguments);
};


var _sqlite3_msize = Module["_sqlite3_msize"] = function() {
  return (_sqlite3_msize = Module["_sqlite3_msize"] = Module["asm"]["sqlite3_msize"]).apply(null, arguments);
};


var _sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = function() {
  return (_sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = Module["asm"]["sqlite3_vfs_find"]).apply(null, arguments);
};


var _sqlite3_initialize = Module["_sqlite3_initialize"] = function() {
  return (_sqlite3_initialize = Module["_sqlite3_initialize"] = Module["asm"]["sqlite3_initialize"]).apply(null, arguments);
};


var _sqlite3_malloc = Module["_sqlite3_malloc"] = function() {
  return (_sqlite3_malloc = Module["_sqlite3_malloc"] = Module["asm"]["sqlite3_malloc"]).apply(null, arguments);
};


var _sqlite3_free = Module["_sqlite3_free"] = function() {
  return (_sqlite3_free = Module["_sqlite3_free"] = Module["asm"]["sqlite3_free"]).apply(null, arguments);
};


var _sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = function() {
  return (_sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = Module["asm"]["sqlite3_vfs_register"]).apply(null, arguments);
};


var _sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = function() {
  return (_sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = Module["asm"]["sqlite3_vfs_unregister"]).apply(null, arguments);
};


var _sqlite3_malloc64 = Module["_sqlite3_malloc64"] = function() {
  return (_sqlite3_malloc64 = Module["_sqlite3_malloc64"] = Module["asm"]["sqlite3_malloc64"]).apply(null, arguments);
};


var _sqlite3_realloc = Module["_sqlite3_realloc"] = function() {
  return (_sqlite3_realloc = Module["_sqlite3_realloc"] = Module["asm"]["sqlite3_realloc"]).apply(null, arguments);
};


var _sqlite3_realloc64 = Module["_sqlite3_realloc64"] = function() {
  return (_sqlite3_realloc64 = Module["_sqlite3_realloc64"] = Module["asm"]["sqlite3_realloc64"]).apply(null, arguments);
};


var _sqlite3_value_text = Module["_sqlite3_value_text"] = function() {
  return (_sqlite3_value_text = Module["_sqlite3_value_text"] = Module["asm"]["sqlite3_value_text"]).apply(null, arguments);
};


var _sqlite3_randomness = Module["_sqlite3_randomness"] = function() {
  return (_sqlite3_randomness = Module["_sqlite3_randomness"] = Module["asm"]["sqlite3_randomness"]).apply(null, arguments);
};


var _sqlite3_stricmp = Module["_sqlite3_stricmp"] = function() {
  return (_sqlite3_stricmp = Module["_sqlite3_stricmp"] = Module["asm"]["sqlite3_stricmp"]).apply(null, arguments);
};


var _sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = function() {
  return (_sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = Module["asm"]["sqlite3_strnicmp"]).apply(null, arguments);
};


var _sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = function() {
  return (_sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = Module["asm"]["sqlite3_uri_parameter"]).apply(null, arguments);
};


var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};


var _sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = function() {
  return (_sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = Module["asm"]["sqlite3_uri_boolean"]).apply(null, arguments);
};


var _sqlite3_serialize = Module["_sqlite3_serialize"] = function() {
  return (_sqlite3_serialize = Module["_sqlite3_serialize"] = Module["asm"]["sqlite3_serialize"]).apply(null, arguments);
};


var _sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = function() {
  return (_sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = Module["asm"]["sqlite3_prepare_v2"]).apply(null, arguments);
};


var _sqlite3_step = Module["_sqlite3_step"] = function() {
  return (_sqlite3_step = Module["_sqlite3_step"] = Module["asm"]["sqlite3_step"]).apply(null, arguments);
};


var _sqlite3_column_int64 = Module["_sqlite3_column_int64"] = function() {
  return (_sqlite3_column_int64 = Module["_sqlite3_column_int64"] = Module["asm"]["sqlite3_column_int64"]).apply(null, arguments);
};


var _sqlite3_reset = Module["_sqlite3_reset"] = function() {
  return (_sqlite3_reset = Module["_sqlite3_reset"] = Module["asm"]["sqlite3_reset"]).apply(null, arguments);
};


var _sqlite3_exec = Module["_sqlite3_exec"] = function() {
  return (_sqlite3_exec = Module["_sqlite3_exec"] = Module["asm"]["sqlite3_exec"]).apply(null, arguments);
};


var _sqlite3_column_int = Module["_sqlite3_column_int"] = function() {
  return (_sqlite3_column_int = Module["_sqlite3_column_int"] = Module["asm"]["sqlite3_column_int"]).apply(null, arguments);
};


var _sqlite3_finalize = Module["_sqlite3_finalize"] = function() {
  return (_sqlite3_finalize = Module["_sqlite3_finalize"] = Module["asm"]["sqlite3_finalize"]).apply(null, arguments);
};


var _sqlite3_file_control = Module["_sqlite3_file_control"] = function() {
  return (_sqlite3_file_control = Module["_sqlite3_file_control"] = Module["asm"]["sqlite3_file_control"]).apply(null, arguments);
};


var _sqlite3_column_name = Module["_sqlite3_column_name"] = function() {
  return (_sqlite3_column_name = Module["_sqlite3_column_name"] = Module["asm"]["sqlite3_column_name"]).apply(null, arguments);
};


var _sqlite3_column_text = Module["_sqlite3_column_text"] = function() {
  return (_sqlite3_column_text = Module["_sqlite3_column_text"] = Module["asm"]["sqlite3_column_text"]).apply(null, arguments);
};


var _sqlite3_column_type = Module["_sqlite3_column_type"] = function() {
  return (_sqlite3_column_type = Module["_sqlite3_column_type"] = Module["asm"]["sqlite3_column_type"]).apply(null, arguments);
};


var _sqlite3_errmsg = Module["_sqlite3_errmsg"] = function() {
  return (_sqlite3_errmsg = Module["_sqlite3_errmsg"] = Module["asm"]["sqlite3_errmsg"]).apply(null, arguments);
};


var _sqlite3_deserialize = Module["_sqlite3_deserialize"] = function() {
  return (_sqlite3_deserialize = Module["_sqlite3_deserialize"] = Module["asm"]["sqlite3_deserialize"]).apply(null, arguments);
};


var _sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = function() {
  return (_sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = Module["asm"]["sqlite3_clear_bindings"]).apply(null, arguments);
};


var _sqlite3_value_blob = Module["_sqlite3_value_blob"] = function() {
  return (_sqlite3_value_blob = Module["_sqlite3_value_blob"] = Module["asm"]["sqlite3_value_blob"]).apply(null, arguments);
};


var _sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = function() {
  return (_sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = Module["asm"]["sqlite3_value_bytes"]).apply(null, arguments);
};


var _sqlite3_value_double = Module["_sqlite3_value_double"] = function() {
  return (_sqlite3_value_double = Module["_sqlite3_value_double"] = Module["asm"]["sqlite3_value_double"]).apply(null, arguments);
};


var _sqlite3_value_int = Module["_sqlite3_value_int"] = function() {
  return (_sqlite3_value_int = Module["_sqlite3_value_int"] = Module["asm"]["sqlite3_value_int"]).apply(null, arguments);
};


var _sqlite3_value_int64 = Module["_sqlite3_value_int64"] = function() {
  return (_sqlite3_value_int64 = Module["_sqlite3_value_int64"] = Module["asm"]["sqlite3_value_int64"]).apply(null, arguments);
};


var _sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = function() {
  return (_sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = Module["asm"]["sqlite3_value_subtype"]).apply(null, arguments);
};


var _sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = function() {
  return (_sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = Module["asm"]["sqlite3_value_pointer"]).apply(null, arguments);
};


var _sqlite3_value_type = Module["_sqlite3_value_type"] = function() {
  return (_sqlite3_value_type = Module["_sqlite3_value_type"] = Module["asm"]["sqlite3_value_type"]).apply(null, arguments);
};


var _sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = function() {
  return (_sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = Module["asm"]["sqlite3_value_nochange"]).apply(null, arguments);
};


var _sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = function() {
  return (_sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = Module["asm"]["sqlite3_value_frombind"]).apply(null, arguments);
};


var _sqlite3_value_dup = Module["_sqlite3_value_dup"] = function() {
  return (_sqlite3_value_dup = Module["_sqlite3_value_dup"] = Module["asm"]["sqlite3_value_dup"]).apply(null, arguments);
};


var _sqlite3_value_free = Module["_sqlite3_value_free"] = function() {
  return (_sqlite3_value_free = Module["_sqlite3_value_free"] = Module["asm"]["sqlite3_value_free"]).apply(null, arguments);
};


var _sqlite3_result_blob = Module["_sqlite3_result_blob"] = function() {
  return (_sqlite3_result_blob = Module["_sqlite3_result_blob"] = Module["asm"]["sqlite3_result_blob"]).apply(null, arguments);
};


var _sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = function() {
  return (_sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = Module["asm"]["sqlite3_result_error_toobig"]).apply(null, arguments);
};


var _sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = function() {
  return (_sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = Module["asm"]["sqlite3_result_error_nomem"]).apply(null, arguments);
};


var _sqlite3_result_double = Module["_sqlite3_result_double"] = function() {
  return (_sqlite3_result_double = Module["_sqlite3_result_double"] = Module["asm"]["sqlite3_result_double"]).apply(null, arguments);
};


var _sqlite3_result_error = Module["_sqlite3_result_error"] = function() {
  return (_sqlite3_result_error = Module["_sqlite3_result_error"] = Module["asm"]["sqlite3_result_error"]).apply(null, arguments);
};


var _sqlite3_result_int = Module["_sqlite3_result_int"] = function() {
  return (_sqlite3_result_int = Module["_sqlite3_result_int"] = Module["asm"]["sqlite3_result_int"]).apply(null, arguments);
};


var _sqlite3_result_int64 = Module["_sqlite3_result_int64"] = function() {
  return (_sqlite3_result_int64 = Module["_sqlite3_result_int64"] = Module["asm"]["sqlite3_result_int64"]).apply(null, arguments);
};


var _sqlite3_result_null = Module["_sqlite3_result_null"] = function() {
  return (_sqlite3_result_null = Module["_sqlite3_result_null"] = Module["asm"]["sqlite3_result_null"]).apply(null, arguments);
};


var _sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = function() {
  return (_sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = Module["asm"]["sqlite3_result_pointer"]).apply(null, arguments);
};


var _sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = function() {
  return (_sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = Module["asm"]["sqlite3_result_subtype"]).apply(null, arguments);
};


var _sqlite3_result_text = Module["_sqlite3_result_text"] = function() {
  return (_sqlite3_result_text = Module["_sqlite3_result_text"] = Module["asm"]["sqlite3_result_text"]).apply(null, arguments);
};


var _sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = function() {
  return (_sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = Module["asm"]["sqlite3_result_zeroblob"]).apply(null, arguments);
};


var _sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = function() {
  return (_sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = Module["asm"]["sqlite3_result_zeroblob64"]).apply(null, arguments);
};


var _sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = function() {
  return (_sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = Module["asm"]["sqlite3_result_error_code"]).apply(null, arguments);
};


var _sqlite3_user_data = Module["_sqlite3_user_data"] = function() {
  return (_sqlite3_user_data = Module["_sqlite3_user_data"] = Module["asm"]["sqlite3_user_data"]).apply(null, arguments);
};


var _sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = function() {
  return (_sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = Module["asm"]["sqlite3_context_db_handle"]).apply(null, arguments);
};


var _sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = function() {
  return (_sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = Module["asm"]["sqlite3_vtab_nochange"]).apply(null, arguments);
};


var _sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = function() {
  return (_sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = Module["asm"]["sqlite3_vtab_in_first"]).apply(null, arguments);
};


var _sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = function() {
  return (_sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = Module["asm"]["sqlite3_vtab_in_next"]).apply(null, arguments);
};


var _sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = function() {
  return (_sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = Module["asm"]["sqlite3_aggregate_context"]).apply(null, arguments);
};


var _sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = function() {
  return (_sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = Module["asm"]["sqlite3_get_auxdata"]).apply(null, arguments);
};


var _sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = function() {
  return (_sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = Module["asm"]["sqlite3_set_auxdata"]).apply(null, arguments);
};


var _sqlite3_column_count = Module["_sqlite3_column_count"] = function() {
  return (_sqlite3_column_count = Module["_sqlite3_column_count"] = Module["asm"]["sqlite3_column_count"]).apply(null, arguments);
};


var _sqlite3_data_count = Module["_sqlite3_data_count"] = function() {
  return (_sqlite3_data_count = Module["_sqlite3_data_count"] = Module["asm"]["sqlite3_data_count"]).apply(null, arguments);
};


var _sqlite3_column_blob = Module["_sqlite3_column_blob"] = function() {
  return (_sqlite3_column_blob = Module["_sqlite3_column_blob"] = Module["asm"]["sqlite3_column_blob"]).apply(null, arguments);
};


var _sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = function() {
  return (_sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = Module["asm"]["sqlite3_column_bytes"]).apply(null, arguments);
};


var _sqlite3_column_double = Module["_sqlite3_column_double"] = function() {
  return (_sqlite3_column_double = Module["_sqlite3_column_double"] = Module["asm"]["sqlite3_column_double"]).apply(null, arguments);
};


var _sqlite3_column_value = Module["_sqlite3_column_value"] = function() {
  return (_sqlite3_column_value = Module["_sqlite3_column_value"] = Module["asm"]["sqlite3_column_value"]).apply(null, arguments);
};


var _sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = function() {
  return (_sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = Module["asm"]["sqlite3_bind_blob"]).apply(null, arguments);
};


var _sqlite3_bind_double = Module["_sqlite3_bind_double"] = function() {
  return (_sqlite3_bind_double = Module["_sqlite3_bind_double"] = Module["asm"]["sqlite3_bind_double"]).apply(null, arguments);
};


var _sqlite3_bind_int = Module["_sqlite3_bind_int"] = function() {
  return (_sqlite3_bind_int = Module["_sqlite3_bind_int"] = Module["asm"]["sqlite3_bind_int"]).apply(null, arguments);
};


var _sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = function() {
  return (_sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = Module["asm"]["sqlite3_bind_int64"]).apply(null, arguments);
};


var _sqlite3_bind_null = Module["_sqlite3_bind_null"] = function() {
  return (_sqlite3_bind_null = Module["_sqlite3_bind_null"] = Module["asm"]["sqlite3_bind_null"]).apply(null, arguments);
};


var _sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = function() {
  return (_sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = Module["asm"]["sqlite3_bind_pointer"]).apply(null, arguments);
};


var _sqlite3_bind_text = Module["_sqlite3_bind_text"] = function() {
  return (_sqlite3_bind_text = Module["_sqlite3_bind_text"] = Module["asm"]["sqlite3_bind_text"]).apply(null, arguments);
};


var _sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = function() {
  return (_sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = Module["asm"]["sqlite3_bind_parameter_count"]).apply(null, arguments);
};


var _sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = function() {
  return (_sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = Module["asm"]["sqlite3_bind_parameter_index"]).apply(null, arguments);
};


var _sqlite3_db_handle = Module["_sqlite3_db_handle"] = function() {
  return (_sqlite3_db_handle = Module["_sqlite3_db_handle"] = Module["asm"]["sqlite3_db_handle"]).apply(null, arguments);
};


var _sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = function() {
  return (_sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = Module["asm"]["sqlite3_stmt_readonly"]).apply(null, arguments);
};


var _sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = function() {
  return (_sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = Module["asm"]["sqlite3_stmt_isexplain"]).apply(null, arguments);
};


var _sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = function() {
  return (_sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = Module["asm"]["sqlite3_stmt_status"]).apply(null, arguments);
};


var _sqlite3_sql = Module["_sqlite3_sql"] = function() {
  return (_sqlite3_sql = Module["_sqlite3_sql"] = Module["asm"]["sqlite3_sql"]).apply(null, arguments);
};


var _sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = function() {
  return (_sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = Module["asm"]["sqlite3_expanded_sql"]).apply(null, arguments);
};


var _sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = function() {
  return (_sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = Module["asm"]["sqlite3_preupdate_old"]).apply(null, arguments);
};


var _sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = function() {
  return (_sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = Module["asm"]["sqlite3_preupdate_count"]).apply(null, arguments);
};


var _sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = function() {
  return (_sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = Module["asm"]["sqlite3_preupdate_depth"]).apply(null, arguments);
};


var _sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = function() {
  return (_sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = Module["asm"]["sqlite3_preupdate_blobwrite"]).apply(null, arguments);
};


var _sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = function() {
  return (_sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = Module["asm"]["sqlite3_preupdate_new"]).apply(null, arguments);
};


var _sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = function() {
  return (_sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = Module["asm"]["sqlite3_value_numeric_type"]).apply(null, arguments);
};


var _sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = function() {
  return (_sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = Module["asm"]["sqlite3_set_authorizer"]).apply(null, arguments);
};


var _sqlite3_strglob = Module["_sqlite3_strglob"] = function() {
  return (_sqlite3_strglob = Module["_sqlite3_strglob"] = Module["asm"]["sqlite3_strglob"]).apply(null, arguments);
};


var _sqlite3_strlike = Module["_sqlite3_strlike"] = function() {
  return (_sqlite3_strlike = Module["_sqlite3_strlike"] = Module["asm"]["sqlite3_strlike"]).apply(null, arguments);
};


var _sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = function() {
  return (_sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = Module["asm"]["sqlite3_auto_extension"]).apply(null, arguments);
};


var _sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = function() {
  return (_sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = Module["asm"]["sqlite3_cancel_auto_extension"]).apply(null, arguments);
};


var _sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = function() {
  return (_sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = Module["asm"]["sqlite3_reset_auto_extension"]).apply(null, arguments);
};


var _sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = function() {
  return (_sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = Module["asm"]["sqlite3_prepare_v3"]).apply(null, arguments);
};


var _sqlite3_create_module = Module["_sqlite3_create_module"] = function() {
  return (_sqlite3_create_module = Module["_sqlite3_create_module"] = Module["asm"]["sqlite3_create_module"]).apply(null, arguments);
};


var _sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = function() {
  return (_sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = Module["asm"]["sqlite3_create_module_v2"]).apply(null, arguments);
};


var _sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = function() {
  return (_sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = Module["asm"]["sqlite3_drop_modules"]).apply(null, arguments);
};


var _sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = function() {
  return (_sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = Module["asm"]["sqlite3_declare_vtab"]).apply(null, arguments);
};


var _sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = function() {
  return (_sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = Module["asm"]["sqlite3_vtab_on_conflict"]).apply(null, arguments);
};


var _sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = function() {
  return (_sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = Module["asm"]["sqlite3_vtab_collation"]).apply(null, arguments);
};


var _sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = function() {
  return (_sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = Module["asm"]["sqlite3_vtab_in"]).apply(null, arguments);
};


var _sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = function() {
  return (_sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = Module["asm"]["sqlite3_vtab_rhs_value"]).apply(null, arguments);
};


var _sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = function() {
  return (_sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = Module["asm"]["sqlite3_vtab_distinct"]).apply(null, arguments);
};


var _sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = function() {
  return (_sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = Module["asm"]["sqlite3_keyword_name"]).apply(null, arguments);
};


var _sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = function() {
  return (_sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = Module["asm"]["sqlite3_keyword_count"]).apply(null, arguments);
};


var _sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = function() {
  return (_sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = Module["asm"]["sqlite3_keyword_check"]).apply(null, arguments);
};


var _sqlite3_complete = Module["_sqlite3_complete"] = function() {
  return (_sqlite3_complete = Module["_sqlite3_complete"] = Module["asm"]["sqlite3_complete"]).apply(null, arguments);
};


var _sqlite3_libversion = Module["_sqlite3_libversion"] = function() {
  return (_sqlite3_libversion = Module["_sqlite3_libversion"] = Module["asm"]["sqlite3_libversion"]).apply(null, arguments);
};


var _sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = function() {
  return (_sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = Module["asm"]["sqlite3_libversion_number"]).apply(null, arguments);
};


var _sqlite3_shutdown = Module["_sqlite3_shutdown"] = function() {
  return (_sqlite3_shutdown = Module["_sqlite3_shutdown"] = Module["asm"]["sqlite3_shutdown"]).apply(null, arguments);
};


var _sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = function() {
  return (_sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = Module["asm"]["sqlite3_last_insert_rowid"]).apply(null, arguments);
};


var _sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = function() {
  return (_sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = Module["asm"]["sqlite3_set_last_insert_rowid"]).apply(null, arguments);
};


var _sqlite3_changes64 = Module["_sqlite3_changes64"] = function() {
  return (_sqlite3_changes64 = Module["_sqlite3_changes64"] = Module["asm"]["sqlite3_changes64"]).apply(null, arguments);
};


var _sqlite3_changes = Module["_sqlite3_changes"] = function() {
  return (_sqlite3_changes = Module["_sqlite3_changes"] = Module["asm"]["sqlite3_changes"]).apply(null, arguments);
};


var _sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = function() {
  return (_sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = Module["asm"]["sqlite3_total_changes64"]).apply(null, arguments);
};


var _sqlite3_total_changes = Module["_sqlite3_total_changes"] = function() {
  return (_sqlite3_total_changes = Module["_sqlite3_total_changes"] = Module["asm"]["sqlite3_total_changes"]).apply(null, arguments);
};


var _sqlite3_txn_state = Module["_sqlite3_txn_state"] = function() {
  return (_sqlite3_txn_state = Module["_sqlite3_txn_state"] = Module["asm"]["sqlite3_txn_state"]).apply(null, arguments);
};


var _sqlite3_close_v2 = Module["_sqlite3_close_v2"] = function() {
  return (_sqlite3_close_v2 = Module["_sqlite3_close_v2"] = Module["asm"]["sqlite3_close_v2"]).apply(null, arguments);
};


var _sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = function() {
  return (_sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = Module["asm"]["sqlite3_busy_handler"]).apply(null, arguments);
};


var _sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = function() {
  return (_sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = Module["asm"]["sqlite3_progress_handler"]).apply(null, arguments);
};


var _sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = function() {
  return (_sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = Module["asm"]["sqlite3_busy_timeout"]).apply(null, arguments);
};


var _sqlite3_create_function = Module["_sqlite3_create_function"] = function() {
  return (_sqlite3_create_function = Module["_sqlite3_create_function"] = Module["asm"]["sqlite3_create_function"]).apply(null, arguments);
};


var _sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = function() {
  return (_sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = Module["asm"]["sqlite3_create_function_v2"]).apply(null, arguments);
};


var _sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = function() {
  return (_sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = Module["asm"]["sqlite3_create_window_function"]).apply(null, arguments);
};


var _sqlite3_overload_function = Module["_sqlite3_overload_function"] = function() {
  return (_sqlite3_overload_function = Module["_sqlite3_overload_function"] = Module["asm"]["sqlite3_overload_function"]).apply(null, arguments);
};


var _sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = function() {
  return (_sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = Module["asm"]["sqlite3_trace_v2"]).apply(null, arguments);
};


var _sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = function() {
  return (_sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = Module["asm"]["sqlite3_commit_hook"]).apply(null, arguments);
};


var _sqlite3_update_hook = Module["_sqlite3_update_hook"] = function() {
  return (_sqlite3_update_hook = Module["_sqlite3_update_hook"] = Module["asm"]["sqlite3_update_hook"]).apply(null, arguments);
};


var _sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = function() {
  return (_sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = Module["asm"]["sqlite3_rollback_hook"]).apply(null, arguments);
};


var _sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = function() {
  return (_sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = Module["asm"]["sqlite3_preupdate_hook"]).apply(null, arguments);
};


var _sqlite3_error_offset = Module["_sqlite3_error_offset"] = function() {
  return (_sqlite3_error_offset = Module["_sqlite3_error_offset"] = Module["asm"]["sqlite3_error_offset"]).apply(null, arguments);
};


var _sqlite3_errcode = Module["_sqlite3_errcode"] = function() {
  return (_sqlite3_errcode = Module["_sqlite3_errcode"] = Module["asm"]["sqlite3_errcode"]).apply(null, arguments);
};


var _sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = function() {
  return (_sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = Module["asm"]["sqlite3_extended_errcode"]).apply(null, arguments);
};


var _sqlite3_errstr = Module["_sqlite3_errstr"] = function() {
  return (_sqlite3_errstr = Module["_sqlite3_errstr"] = Module["asm"]["sqlite3_errstr"]).apply(null, arguments);
};


var _sqlite3_limit = Module["_sqlite3_limit"] = function() {
  return (_sqlite3_limit = Module["_sqlite3_limit"] = Module["asm"]["sqlite3_limit"]).apply(null, arguments);
};


var _sqlite3_open = Module["_sqlite3_open"] = function() {
  return (_sqlite3_open = Module["_sqlite3_open"] = Module["asm"]["sqlite3_open"]).apply(null, arguments);
};


var _sqlite3_open_v2 = Module["_sqlite3_open_v2"] = function() {
  return (_sqlite3_open_v2 = Module["_sqlite3_open_v2"] = Module["asm"]["sqlite3_open_v2"]).apply(null, arguments);
};


var _sqlite3_create_collation = Module["_sqlite3_create_collation"] = function() {
  return (_sqlite3_create_collation = Module["_sqlite3_create_collation"] = Module["asm"]["sqlite3_create_collation"]).apply(null, arguments);
};


var _sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = function() {
  return (_sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = Module["asm"]["sqlite3_create_collation_v2"]).apply(null, arguments);
};


var _sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = function() {
  return (_sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = Module["asm"]["sqlite3_collation_needed"]).apply(null, arguments);
};


var _sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = function() {
  return (_sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = Module["asm"]["sqlite3_get_autocommit"]).apply(null, arguments);
};


var _sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = function() {
  return (_sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = Module["asm"]["sqlite3_table_column_metadata"]).apply(null, arguments);
};


var _sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = function() {
  return (_sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = Module["asm"]["sqlite3_extended_result_codes"]).apply(null, arguments);
};


var _sqlite3_uri_key = Module["_sqlite3_uri_key"] = function() {
  return (_sqlite3_uri_key = Module["_sqlite3_uri_key"] = Module["asm"]["sqlite3_uri_key"]).apply(null, arguments);
};


var _sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = function() {
  return (_sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = Module["asm"]["sqlite3_uri_int64"]).apply(null, arguments);
};


var _sqlite3_db_name = Module["_sqlite3_db_name"] = function() {
  return (_sqlite3_db_name = Module["_sqlite3_db_name"] = Module["asm"]["sqlite3_db_name"]).apply(null, arguments);
};


var _sqlite3_db_filename = Module["_sqlite3_db_filename"] = function() {
  return (_sqlite3_db_filename = Module["_sqlite3_db_filename"] = Module["asm"]["sqlite3_db_filename"]).apply(null, arguments);
};


var _sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = function() {
  return (_sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = Module["asm"]["sqlite3_compileoption_used"]).apply(null, arguments);
};


var _sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = function() {
  return (_sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = Module["asm"]["sqlite3_compileoption_get"]).apply(null, arguments);
};


var _sqlite3session_diff = Module["_sqlite3session_diff"] = function() {
  return (_sqlite3session_diff = Module["_sqlite3session_diff"] = Module["asm"]["sqlite3session_diff"]).apply(null, arguments);
};


var _sqlite3session_attach = Module["_sqlite3session_attach"] = function() {
  return (_sqlite3session_attach = Module["_sqlite3session_attach"] = Module["asm"]["sqlite3session_attach"]).apply(null, arguments);
};


var _sqlite3session_create = Module["_sqlite3session_create"] = function() {
  return (_sqlite3session_create = Module["_sqlite3session_create"] = Module["asm"]["sqlite3session_create"]).apply(null, arguments);
};


var _sqlite3session_delete = Module["_sqlite3session_delete"] = function() {
  return (_sqlite3session_delete = Module["_sqlite3session_delete"] = Module["asm"]["sqlite3session_delete"]).apply(null, arguments);
};


var _sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = function() {
  return (_sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = Module["asm"]["sqlite3session_table_filter"]).apply(null, arguments);
};


var _sqlite3session_changeset = Module["_sqlite3session_changeset"] = function() {
  return (_sqlite3session_changeset = Module["_sqlite3session_changeset"] = Module["asm"]["sqlite3session_changeset"]).apply(null, arguments);
};


var _sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = function() {
  return (_sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = Module["asm"]["sqlite3session_changeset_strm"]).apply(null, arguments);
};


var _sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = function() {
  return (_sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = Module["asm"]["sqlite3session_patchset_strm"]).apply(null, arguments);
};


var _sqlite3session_patchset = Module["_sqlite3session_patchset"] = function() {
  return (_sqlite3session_patchset = Module["_sqlite3session_patchset"] = Module["asm"]["sqlite3session_patchset"]).apply(null, arguments);
};


var _sqlite3session_enable = Module["_sqlite3session_enable"] = function() {
  return (_sqlite3session_enable = Module["_sqlite3session_enable"] = Module["asm"]["sqlite3session_enable"]).apply(null, arguments);
};


var _sqlite3session_indirect = Module["_sqlite3session_indirect"] = function() {
  return (_sqlite3session_indirect = Module["_sqlite3session_indirect"] = Module["asm"]["sqlite3session_indirect"]).apply(null, arguments);
};


var _sqlite3session_isempty = Module["_sqlite3session_isempty"] = function() {
  return (_sqlite3session_isempty = Module["_sqlite3session_isempty"] = Module["asm"]["sqlite3session_isempty"]).apply(null, arguments);
};


var _sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = function() {
  return (_sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = Module["asm"]["sqlite3session_memory_used"]).apply(null, arguments);
};


var _sqlite3session_object_config = Module["_sqlite3session_object_config"] = function() {
  return (_sqlite3session_object_config = Module["_sqlite3session_object_config"] = Module["asm"]["sqlite3session_object_config"]).apply(null, arguments);
};


var _sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = function() {
  return (_sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = Module["asm"]["sqlite3session_changeset_size"]).apply(null, arguments);
};


var _sqlite3changeset_start = Module["_sqlite3changeset_start"] = function() {
  return (_sqlite3changeset_start = Module["_sqlite3changeset_start"] = Module["asm"]["sqlite3changeset_start"]).apply(null, arguments);
};


var _sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = function() {
  return (_sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = Module["asm"]["sqlite3changeset_start_v2"]).apply(null, arguments);
};


var _sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = function() {
  return (_sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = Module["asm"]["sqlite3changeset_start_strm"]).apply(null, arguments);
};


var _sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = function() {
  return (_sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = Module["asm"]["sqlite3changeset_start_v2_strm"]).apply(null, arguments);
};


var _sqlite3changeset_next = Module["_sqlite3changeset_next"] = function() {
  return (_sqlite3changeset_next = Module["_sqlite3changeset_next"] = Module["asm"]["sqlite3changeset_next"]).apply(null, arguments);
};


var _sqlite3changeset_op = Module["_sqlite3changeset_op"] = function() {
  return (_sqlite3changeset_op = Module["_sqlite3changeset_op"] = Module["asm"]["sqlite3changeset_op"]).apply(null, arguments);
};


var _sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = function() {
  return (_sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = Module["asm"]["sqlite3changeset_pk"]).apply(null, arguments);
};


var _sqlite3changeset_old = Module["_sqlite3changeset_old"] = function() {
  return (_sqlite3changeset_old = Module["_sqlite3changeset_old"] = Module["asm"]["sqlite3changeset_old"]).apply(null, arguments);
};


var _sqlite3changeset_new = Module["_sqlite3changeset_new"] = function() {
  return (_sqlite3changeset_new = Module["_sqlite3changeset_new"] = Module["asm"]["sqlite3changeset_new"]).apply(null, arguments);
};


var _sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = function() {
  return (_sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = Module["asm"]["sqlite3changeset_conflict"]).apply(null, arguments);
};


var _sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = function() {
  return (_sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = Module["asm"]["sqlite3changeset_fk_conflicts"]).apply(null, arguments);
};


var _sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = function() {
  return (_sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = Module["asm"]["sqlite3changeset_finalize"]).apply(null, arguments);
};


var _sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = function() {
  return (_sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = Module["asm"]["sqlite3changeset_invert"]).apply(null, arguments);
};


var _sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = function() {
  return (_sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = Module["asm"]["sqlite3changeset_invert_strm"]).apply(null, arguments);
};


var _sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = function() {
  return (_sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = Module["asm"]["sqlite3changeset_apply_v2"]).apply(null, arguments);
};


var _sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = function() {
  return (_sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = Module["asm"]["sqlite3changeset_apply"]).apply(null, arguments);
};


var _sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = function() {
  return (_sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = Module["asm"]["sqlite3changeset_apply_v2_strm"]).apply(null, arguments);
};


var _sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = function() {
  return (_sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = Module["asm"]["sqlite3changeset_apply_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = function() {
  return (_sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = Module["asm"]["sqlite3changegroup_new"]).apply(null, arguments);
};


var _sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = function() {
  return (_sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = Module["asm"]["sqlite3changegroup_add"]).apply(null, arguments);
};


var _sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = function() {
  return (_sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = Module["asm"]["sqlite3changegroup_output"]).apply(null, arguments);
};


var _sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = function() {
  return (_sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = Module["asm"]["sqlite3changegroup_add_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = function() {
  return (_sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = Module["asm"]["sqlite3changegroup_output_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = function() {
  return (_sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = Module["asm"]["sqlite3changegroup_delete"]).apply(null, arguments);
};


var _sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = function() {
  return (_sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = Module["asm"]["sqlite3changeset_concat"]).apply(null, arguments);
};


var _sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = function() {
  return (_sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = Module["asm"]["sqlite3changeset_concat_strm"]).apply(null, arguments);
};


var _sqlite3session_config = Module["_sqlite3session_config"] = function() {
  return (_sqlite3session_config = Module["_sqlite3session_config"] = Module["asm"]["sqlite3session_config"]).apply(null, arguments);
};


var _sqlite3_sourceid = Module["_sqlite3_sourceid"] = function() {
  return (_sqlite3_sourceid = Module["_sqlite3_sourceid"] = Module["asm"]["sqlite3_sourceid"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_ptr = Module["_sqlite3_wasm_pstack_ptr"] = function() {
  return (_sqlite3_wasm_pstack_ptr = Module["_sqlite3_wasm_pstack_ptr"] = Module["asm"]["sqlite3_wasm_pstack_ptr"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_restore = Module["_sqlite3_wasm_pstack_restore"] = function() {
  return (_sqlite3_wasm_pstack_restore = Module["_sqlite3_wasm_pstack_restore"] = Module["asm"]["sqlite3_wasm_pstack_restore"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_alloc = Module["_sqlite3_wasm_pstack_alloc"] = function() {
  return (_sqlite3_wasm_pstack_alloc = Module["_sqlite3_wasm_pstack_alloc"] = Module["asm"]["sqlite3_wasm_pstack_alloc"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_remaining = Module["_sqlite3_wasm_pstack_remaining"] = function() {
  return (_sqlite3_wasm_pstack_remaining = Module["_sqlite3_wasm_pstack_remaining"] = Module["asm"]["sqlite3_wasm_pstack_remaining"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_quota = Module["_sqlite3_wasm_pstack_quota"] = function() {
  return (_sqlite3_wasm_pstack_quota = Module["_sqlite3_wasm_pstack_quota"] = Module["asm"]["sqlite3_wasm_pstack_quota"]).apply(null, arguments);
};


var _sqlite3_wasm_db_error = Module["_sqlite3_wasm_db_error"] = function() {
  return (_sqlite3_wasm_db_error = Module["_sqlite3_wasm_db_error"] = Module["asm"]["sqlite3_wasm_db_error"]).apply(null, arguments);
};


var _sqlite3_wasm_test_struct = Module["_sqlite3_wasm_test_struct"] = function() {
  return (_sqlite3_wasm_test_struct = Module["_sqlite3_wasm_test_struct"] = Module["asm"]["sqlite3_wasm_test_struct"]).apply(null, arguments);
};


var _sqlite3_wasm_enum_json = Module["_sqlite3_wasm_enum_json"] = function() {
  return (_sqlite3_wasm_enum_json = Module["_sqlite3_wasm_enum_json"] = Module["asm"]["sqlite3_wasm_enum_json"]).apply(null, arguments);
};


var _sqlite3_wasm_vfs_unlink = Module["_sqlite3_wasm_vfs_unlink"] = function() {
  return (_sqlite3_wasm_vfs_unlink = Module["_sqlite3_wasm_vfs_unlink"] = Module["asm"]["sqlite3_wasm_vfs_unlink"]).apply(null, arguments);
};


var _sqlite3_wasm_db_vfs = Module["_sqlite3_wasm_db_vfs"] = function() {
  return (_sqlite3_wasm_db_vfs = Module["_sqlite3_wasm_db_vfs"] = Module["asm"]["sqlite3_wasm_db_vfs"]).apply(null, arguments);
};


var _sqlite3_wasm_db_reset = Module["_sqlite3_wasm_db_reset"] = function() {
  return (_sqlite3_wasm_db_reset = Module["_sqlite3_wasm_db_reset"] = Module["asm"]["sqlite3_wasm_db_reset"]).apply(null, arguments);
};


var _sqlite3_wasm_db_export_chunked = Module["_sqlite3_wasm_db_export_chunked"] = function() {
  return (_sqlite3_wasm_db_export_chunked = Module["_sqlite3_wasm_db_export_chunked"] = Module["asm"]["sqlite3_wasm_db_export_chunked"]).apply(null, arguments);
};


var _sqlite3_wasm_db_serialize = Module["_sqlite3_wasm_db_serialize"] = function() {
  return (_sqlite3_wasm_db_serialize = Module["_sqlite3_wasm_db_serialize"] = Module["asm"]["sqlite3_wasm_db_serialize"]).apply(null, arguments);
};


var _sqlite3_wasm_vfs_create_file = Module["_sqlite3_wasm_vfs_create_file"] = function() {
  return (_sqlite3_wasm_vfs_create_file = Module["_sqlite3_wasm_vfs_create_file"] = Module["asm"]["sqlite3_wasm_vfs_create_file"]).apply(null, arguments);
};


var _sqlite3_wasm_posix_create_file = Module["_sqlite3_wasm_posix_create_file"] = function() {
  return (_sqlite3_wasm_posix_create_file = Module["_sqlite3_wasm_posix_create_file"] = Module["asm"]["sqlite3_wasm_posix_create_file"]).apply(null, arguments);
};


var _sqlite3_wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3_wasm_kvvfsMakeKeyOnPstack"] = function() {
  return (_sqlite3_wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3_wasm_kvvfsMakeKeyOnPstack"] = Module["asm"]["sqlite3_wasm_kvvfsMakeKeyOnPstack"]).apply(null, arguments);
};


var _sqlite3_wasm_kvvfs_methods = Module["_sqlite3_wasm_kvvfs_methods"] = function() {
  return (_sqlite3_wasm_kvvfs_methods = Module["_sqlite3_wasm_kvvfs_methods"] = Module["asm"]["sqlite3_wasm_kvvfs_methods"]).apply(null, arguments);
};


var _sqlite3_wasm_vtab_config = Module["_sqlite3_wasm_vtab_config"] = function() {
  return (_sqlite3_wasm_vtab_config = Module["_sqlite3_wasm_vtab_config"] = Module["asm"]["sqlite3_wasm_vtab_config"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_ip = Module["_sqlite3_wasm_db_config_ip"] = function() {
  return (_sqlite3_wasm_db_config_ip = Module["_sqlite3_wasm_db_config_ip"] = Module["asm"]["sqlite3_wasm_db_config_ip"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_pii = Module["_sqlite3_wasm_db_config_pii"] = function() {
  return (_sqlite3_wasm_db_config_pii = Module["_sqlite3_wasm_db_config_pii"] = Module["asm"]["sqlite3_wasm_db_config_pii"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_s = Module["_sqlite3_wasm_db_config_s"] = function() {
  return (_sqlite3_wasm_db_config_s = Module["_sqlite3_wasm_db_config_s"] = Module["asm"]["sqlite3_wasm_db_config_s"]).apply(null, arguments);
};


var _sqlite3_wasm_config_i = Module["_sqlite3_wasm_config_i"] = function() {
  return (_sqlite3_wasm_config_i = Module["_sqlite3_wasm_config_i"] = Module["asm"]["sqlite3_wasm_config_i"]).apply(null, arguments);
};


var _sqlite3_wasm_config_ii = Module["_sqlite3_wasm_config_ii"] = function() {
  return (_sqlite3_wasm_config_ii = Module["_sqlite3_wasm_config_ii"] = Module["asm"]["sqlite3_wasm_config_ii"]).apply(null, arguments);
};


var _sqlite3_wasm_config_j = Module["_sqlite3_wasm_config_j"] = function() {
  return (_sqlite3_wasm_config_j = Module["_sqlite3_wasm_config_j"] = Module["asm"]["sqlite3_wasm_config_j"]).apply(null, arguments);
};


var _sqlite3_wasm_init_wasmfs = Module["_sqlite3_wasm_init_wasmfs"] = function() {
  return (_sqlite3_wasm_init_wasmfs = Module["_sqlite3_wasm_init_wasmfs"] = Module["asm"]["sqlite3_wasm_init_wasmfs"]).apply(null, arguments);
};


var _sqlite3_wasm_test_intptr = Module["_sqlite3_wasm_test_intptr"] = function() {
  return (_sqlite3_wasm_test_intptr = Module["_sqlite3_wasm_test_intptr"] = Module["asm"]["sqlite3_wasm_test_intptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_voidptr = Module["_sqlite3_wasm_test_voidptr"] = function() {
  return (_sqlite3_wasm_test_voidptr = Module["_sqlite3_wasm_test_voidptr"] = Module["asm"]["sqlite3_wasm_test_voidptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_max = Module["_sqlite3_wasm_test_int64_max"] = function() {
  return (_sqlite3_wasm_test_int64_max = Module["_sqlite3_wasm_test_int64_max"] = Module["asm"]["sqlite3_wasm_test_int64_max"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_min = Module["_sqlite3_wasm_test_int64_min"] = function() {
  return (_sqlite3_wasm_test_int64_min = Module["_sqlite3_wasm_test_int64_min"] = Module["asm"]["sqlite3_wasm_test_int64_min"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_times2 = Module["_sqlite3_wasm_test_int64_times2"] = function() {
  return (_sqlite3_wasm_test_int64_times2 = Module["_sqlite3_wasm_test_int64_times2"] = Module["asm"]["sqlite3_wasm_test_int64_times2"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_minmax = Module["_sqlite3_wasm_test_int64_minmax"] = function() {
  return (_sqlite3_wasm_test_int64_minmax = Module["_sqlite3_wasm_test_int64_minmax"] = Module["asm"]["sqlite3_wasm_test_int64_minmax"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64ptr = Module["_sqlite3_wasm_test_int64ptr"] = function() {
  return (_sqlite3_wasm_test_int64ptr = Module["_sqlite3_wasm_test_int64ptr"] = Module["asm"]["sqlite3_wasm_test_int64ptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_stack_overflow = Module["_sqlite3_wasm_test_stack_overflow"] = function() {
  return (_sqlite3_wasm_test_stack_overflow = Module["_sqlite3_wasm_test_stack_overflow"] = Module["asm"]["sqlite3_wasm_test_stack_overflow"]).apply(null, arguments);
};


var _sqlite3_wasm_test_str_hello = Module["_sqlite3_wasm_test_str_hello"] = function() {
  return (_sqlite3_wasm_test_str_hello = Module["_sqlite3_wasm_test_str_hello"] = Module["asm"]["sqlite3_wasm_test_str_hello"]).apply(null, arguments);
};


var _sqlite3_wasm_SQLTester_strglob = Module["_sqlite3_wasm_SQLTester_strglob"] = function() {
  return (_sqlite3_wasm_SQLTester_strglob = Module["_sqlite3_wasm_SQLTester_strglob"] = Module["asm"]["sqlite3_wasm_SQLTester_strglob"]).apply(null, arguments);
};


var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};


var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};


var _realloc = Module["_realloc"] = function() {
  return (_realloc = Module["_realloc"] = Module["asm"]["realloc"]).apply(null, arguments);
};


var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
  return (_emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = Module["asm"]["emscripten_builtin_memalign"]).apply(null, arguments);
};


var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};


var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};


var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};







Module["wasmMemory"] = wasmMemory;


var calledRun;

dependenciesFulfilled = function runCaller() {
  
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; 
};


function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    
    
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();





if(!Module.postRun) Module.postRun = [];
Module.postRun.push(function(Module){
  'use strict';
  










'use strict';
globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(
  apiConfig = (globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig)
){
  if(sqlite3ApiBootstrap.sqlite3){ 
    console.warn("sqlite3ApiBootstrap() called multiple times.",
                 "Config and external initializers are ignored on calls after the first.");
    return sqlite3ApiBootstrap.sqlite3;
  }
  const config = Object.assign(Object.create(null),{
    exports: undefined,
    memory: undefined,
    bigIntEnabled: (()=>{
      if('undefined'!==typeof Module){
        
        return !!Module.HEAPU64;
      }
      return !!globalThis.BigInt64Array;
    })(),
    debug: console.debug.bind(console),
    warn: console.warn.bind(console),
    error: console.error.bind(console),
    log: console.log.bind(console),
    wasmfsOpfsDir: '/opfs',
    
    useStdAlloc: false
  }, apiConfig || {});

  Object.assign(config, {
    allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',
    deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',
    reallocExportName: config.useStdAlloc ? 'realloc' : 'sqlite3_realloc'
  }, config);

  [
    
    
    'exports', 'memory', 'wasmfsOpfsDir'
  ].forEach((k)=>{
    if('function' === typeof config[k]){
      config[k] = config[k]();
    }
  });
  
  const capi = Object.create(null);
  
  const wasm = Object.create(null);

  
  const __rcStr = (rc)=>{
    return (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc))
           || ("Unknown result code #"+rc);
  };

  
  const __isInt = (n)=>'number'===typeof n && n===(n | 0);

  
  class SQLite3Error extends Error {
    
    constructor(...args){
      let rc;
      if(args.length){
        if(__isInt(args[0])){
          rc = args[0];
          if(1===args.length){
            super(__rcStr(args[0]));
          }else{
            const rcStr = __rcStr(rc);
            if('object'===typeof args[1]){
              super(rcStr,args[1]);
            }else{
              args[0] = rcStr+':';
              super(args.join(' '));
            }
          }
        }else{
          if(2===args.length && 'object'===typeof args[1]){
            super(...args);
          }else{
            super(args.join(' '));
          }
        }
      }
      this.resultCode = rc || capi.SQLITE_ERROR;
      this.name = 'SQLite3Error';
    }
  };

  
  SQLite3Error.toss = (...args)=>{
    throw new SQLite3Error(...args);
  };
  const toss3 = SQLite3Error.toss;

  if(config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)){
    toss3("config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.");
  }

  
  const isInt32 = (n)=>{
    return ('bigint'!==typeof n )
      && !!(n===(n|0) && n<=2147483647 && n>=-2147483648);
  };
  
  const bigIntFits64 = function f(b){
    if(!f._max){
      f._max = BigInt("0x7fffffffffffffff");
      f._min = ~f._max;
    }
    return b >= f._min && b <= f._max;
  };

  
  const bigIntFits32 = (b)=>(b >= (-0x7fffffffn - 1n) && b <= 0x7fffffffn);

  
  const bigIntFitsDouble = function f(b){
    if(!f._min){
      f._min = Number.MIN_SAFE_INTEGER;
      f._max = Number.MAX_SAFE_INTEGER;
    }
    return b >= f._min && b <= f._max;
  };

  
  const isTypedArray = (v)=>{
    return (v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)) ? v : false;
  };


  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  
  const isSharedTypedArray = (aTypedArray)=>(aTypedArray.buffer instanceof __SAB);

  
  const typedArrayPart = (aTypedArray, begin, end)=>{
    return isSharedTypedArray(aTypedArray)
      ? aTypedArray.slice(begin, end)
      : aTypedArray.subarray(begin, end);
  };

  
  const isBindableTypedArray = (v)=>{
    return v && (v instanceof Uint8Array
                 || v instanceof Int8Array
                 || v instanceof ArrayBuffer);
  };

  
  const isSQLableTypedArray = (v)=>{
    return v && (v instanceof Uint8Array
                 || v instanceof Int8Array
                 || v instanceof ArrayBuffer);
  };

  
  const affirmBindableTypedArray = (v)=>{
    return isBindableTypedArray(v)
      || toss3("Value is not of a supported TypedArray type.");
  };

  const utf8Decoder = new TextDecoder('utf-8');

  
  const typedArrayToString = function(typedArray, begin, end){
    return utf8Decoder.decode(typedArrayPart(typedArray, begin,end));
  };

  
  const flexibleString = function(v){
    if(isSQLableTypedArray(v)){
      return typedArrayToString(
        (v instanceof ArrayBuffer) ? new Uint8Array(v) : v
      );
    }
    else if(Array.isArray(v)) return v.join("");
    else if(wasm.isPtr(v)) v = wasm.cstrToJs(v);
    return v;
  };

  
  class WasmAllocError extends Error {
    
    constructor(...args){
      if(2===args.length && 'object'===typeof args[1]){
        super(...args);
      }else if(args.length){
        super(args.join(' '));
      }else{
        super("Allocation failed.");
      }
      this.resultCode = capi.SQLITE_NOMEM;
      this.name = 'WasmAllocError';
    }
  };
  
  WasmAllocError.toss = (...args)=>{
    throw new WasmAllocError(...args);
  };

  Object.assign(capi, {
    
    sqlite3_bind_blob: undefined,

    
    sqlite3_bind_text: undefined,

    
    sqlite3_create_function_v2: (
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal, xDestroy
    )=>{},
    
    sqlite3_create_function: (
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal
    )=>{},
    
    sqlite3_create_window_function: (
      pDb, funcName, nArg, eTextRep, pApp,
      xStep, xFinal, xValue, xInverse, xDestroy
    )=>{},
    
    sqlite3_prepare_v3: (dbPtr, sql, sqlByteLen, prepFlags,
                         stmtPtrPtr, strPtrPtr)=>{},

    
    sqlite3_prepare_v2: (dbPtr, sql, sqlByteLen,
                         stmtPtrPtr,strPtrPtr)=>{},

    
    sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg)=>{},

    
    sqlite3_randomness: (n, outPtr)=>{},
  });

  
  const util = {
    affirmBindableTypedArray, flexibleString,
    bigIntFits32, bigIntFits64, bigIntFitsDouble,
    isBindableTypedArray,
    isInt32, isSQLableTypedArray, isTypedArray,
    typedArrayToString,
    isUIThread: ()=>(globalThis.window===globalThis && !!globalThis.document),
    
    isSharedTypedArray,
    toss: function(...args){throw new Error(args.join(' '))},
    toss3,
    typedArrayPart,
    
    affirmDbHeader: function(bytes){
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      const header = "SQLite format 3";
      if( header.length > bytes.byteLength ){
        toss3("Input does not contain an SQLite3 database header.");
      }
      for(let i = 0; i < header.length; ++i){
        if( header.charCodeAt(i) !== bytes[i] ){
          toss3("Input does not contain an SQLite3 database header.");
        }
      }
    },
    
    affirmIsDb: function(bytes){
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      const n = bytes.byteLength;
      if(n<512 || n%512!==0) {
        toss3("Byte array size",n,"is invalid for an SQLite3 db.");
      }
      util.affirmDbHeader(bytes);
    }
  };

  Object.assign(wasm, {
    
    ptrSizeof: config.wasmPtrSizeof || 4,
    
    ptrIR: config.wasmPtrIR || "i32",
    
    bigIntEnabled: !!config.bigIntEnabled,
    
    exports: config.exports
      || toss3("Missing API config.exports (WASM module exports)."),

    
    memory: config.memory || config.exports['memory']
      || toss3("API config object requires a WebAssembly.Memory object",
              "in either config.exports.memory (exported)",
              "or config.memory (imported)."),

    
    alloc: undefined,

    
    realloc: undefined,

    
    dealloc: undefined

    
  });

  
  wasm.allocFromTypedArray = function(srcTypedArray){
    if(srcTypedArray instanceof ArrayBuffer){
      srcTypedArray = new Uint8Array(srcTypedArray);
    }
    affirmBindableTypedArray(srcTypedArray);
    const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
    wasm.heapForSize(srcTypedArray.constructor).set(
      srcTypedArray.byteLength ? srcTypedArray : [0], pRet
    );
    return pRet;
  };

  {
    
    const keyAlloc = config.allocExportName,
          keyDealloc = config.deallocExportName,
          keyRealloc = config.reallocExportName;
    for(const key of [keyAlloc, keyDealloc, keyRealloc]){
      const f = wasm.exports[key];
      if(!(f instanceof Function)) toss3("Missing required exports[",key,"] function.");
    }

    wasm.alloc = function f(n){
      return f.impl(n) || WasmAllocError.toss("Failed to allocate",n," bytes.");
    };
    wasm.alloc.impl = wasm.exports[keyAlloc];
    wasm.realloc = function f(m,n){
      const m2 = f.impl(m,n);
      return n ? (m2 || WasmAllocError.toss("Failed to reallocate",n," bytes.")) : 0;
    };
    wasm.realloc.impl = wasm.exports[keyRealloc];
    wasm.dealloc = wasm.exports[keyDealloc];
  }

  
  wasm.compileOptionUsed = function f(optName){
    if(!arguments.length){
      if(f._result) return f._result;
      else if(!f._opt){
        f._rx = /^([^=]+)=(.+)/;
        f._rxInt = /^-?\d+$/;
        f._opt = function(opt, rv){
          const m = f._rx.exec(opt);
          rv[0] = (m ? m[1] : opt);
          rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;
        };
      }
      const rc = {}, ov = [0,0];
      let i = 0, k;
      while((k = capi.sqlite3_compileoption_get(i++))){
        f._opt(k,ov);
        rc[ov[0]] = ov[1];
      }
      return f._result = rc;
    }else if(Array.isArray(optName)){
      const rc = {};
      optName.forEach((v)=>{
        rc[v] = capi.sqlite3_compileoption_used(v);
      });
      return rc;
    }else if('object' === typeof optName){
      Object.keys(optName).forEach((k)=> {
        optName[k] = capi.sqlite3_compileoption_used(k);
      });
      return optName;
    }
    return (
      'string'===typeof optName
    ) ? !!capi.sqlite3_compileoption_used(optName) : false;
  };

  
  wasm.pstack = Object.assign(Object.create(null),{
    
    restore: wasm.exports.sqlite3_wasm_pstack_restore,
    
    alloc: function(n){
      if('string'===typeof n && !(n = wasm.sizeofIR(n))){
        WasmAllocError.toss("Invalid value for pstack.alloc(",arguments[0],")");
      }
      return wasm.exports.sqlite3_wasm_pstack_alloc(n)
        || WasmAllocError.toss("Could not allocate",n,
                               "bytes from the pstack.");
    },
    
    allocChunks: function(n,sz){
      if('string'===typeof sz && !(sz = wasm.sizeofIR(sz))){
        WasmAllocError.toss("Invalid size value for allocChunks(",arguments[1],")");
      }
      const mem = wasm.pstack.alloc(n * sz);
      const rc = [];
      let i = 0, offset = 0;
      for(; i < n; ++i, offset += sz) rc.push(mem + offset);
      return rc;
    },
    
    allocPtr: (n=1,safePtrSize=true)=>{
      return 1===n
        ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)
        : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);
    },

    
    call: function(f){
      const stackPos = wasm.pstack.pointer;
      try{ return f(sqlite3) } finally{
        wasm.pstack.restore(stackPos);
      }
    }

  });
  Object.defineProperties(wasm.pstack, {
    
    pointer: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_ptr
      
      
      
    },
    
    quota: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_quota
    },
    
    remaining: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_remaining
    }
  });

  capi.sqlite3_randomness = (...args)=>{
    if(1===args.length && util.isTypedArray(args[0])
      && 1===args[0].BYTES_PER_ELEMENT){
      const ta = args[0];
      if(0===ta.byteLength){
        wasm.exports.sqlite3_randomness(0,0);
        return ta;
      }
      const stack = wasm.pstack.pointer;
      try {
        let n = ta.byteLength, offset = 0;
        const r = wasm.exports.sqlite3_randomness;
        const heap = wasm.heap8u();
        const nAlloc = n < 512 ? n : 512;
        const ptr = wasm.pstack.alloc(nAlloc);
        do{
          const j = (n>nAlloc ? nAlloc : n);
          r(j, ptr);
          ta.set(typedArrayPart(heap, ptr, ptr+j), offset);
          n -= j;
          offset += j;
        } while(n > 0);
      }catch(e){
        console.error("Highly unexpected (and ignored!) "+
                      "exception in sqlite3_randomness():",e);
      }finally{
        wasm.pstack.restore(stack);
      }
      return ta;
    }
    wasm.exports.sqlite3_randomness(...args);
  };

  
  let __wasmfsOpfsDir = undefined;
  
  capi.sqlite3_wasmfs_opfs_dir = function(){
    if(undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;
    
    const pdir = config.wasmfsOpfsDir;
    if(!pdir
       || !globalThis.FileSystemHandle
       || !globalThis.FileSystemDirectoryHandle
       || !globalThis.FileSystemFileHandle){
      return __wasmfsOpfsDir = "";
    }
    try{
      if(pdir && 0===wasm.xCallWrapped(
        'sqlite3_wasm_init_wasmfs', 'i32', ['string'], pdir
      )){
        return __wasmfsOpfsDir = pdir;
      }else{
        return __wasmfsOpfsDir = "";
      }
    }catch(e){
      
      return __wasmfsOpfsDir = "";
    }
  };

  
  capi.sqlite3_wasmfs_filename_is_persistent = function(name){
    const p = capi.sqlite3_wasmfs_opfs_dir();
    return (p && name) ? name.startsWith(p+'/') : false;
  };

  
  capi.sqlite3_js_db_uses_vfs = function(pDb,vfsName,dbName=0){
    try{
      const pK = capi.sqlite3_vfs_find(vfsName);
      if(!pK) return false;
      else if(!pDb){
        return pK===capi.sqlite3_vfs_find(0) ? pK : false;
      }else{
        return pK===capi.sqlite3_js_db_vfs(pDb,dbName) ? pK : false;
      }
    }catch(e){
      
      return false;
    }
  };

  
  capi.sqlite3_js_vfs_list = function(){
    const rc = [];
    let pVfs = capi.sqlite3_vfs_find(0);
    while(pVfs){
      const oVfs = new capi.sqlite3_vfs(pVfs);
      rc.push(wasm.cstrToJs(oVfs.$zName));
      pVfs = oVfs.$pNext;
      oVfs.dispose();
    }
    return rc;
  };

  
  capi.sqlite3_js_db_export = function(pDb, schema=0){
    pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);
    if(!pDb) toss3('Invalid sqlite3* argument.');
    if(!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');
    const scope = wasm.scopedAllocPush();
    let pOut;
    try{
      const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
      const ppOut = pSize + 8;
      
      const zSchema = schema
            ? (wasm.isPtr(schema) ? schema : wasm.scopedAllocCString(''+schema))
            : 0;
      let rc = wasm.exports.sqlite3_wasm_db_serialize(
        pDb, zSchema, ppOut, pSize, 0
      );
      if(rc){
        toss3("Database serialization failed with code",
             sqlite3.capi.sqlite3_js_rc_str(rc));
      }
      pOut = wasm.peekPtr(ppOut);
      const nOut = wasm.peek(pSize, 'i64');
      rc = nOut
        ? wasm.heap8u().slice(pOut, pOut + Number(nOut))
        : new Uint8Array();
      return rc;
    }finally{
      if(pOut) wasm.exports.sqlite3_free(pOut);
      wasm.scopedAllocPop(scope);
    }
  };

  
  capi.sqlite3_js_db_vfs =
    (dbPointer, dbName=0)=>wasm.sqlite3_wasm_db_vfs(dbPointer, dbName);

  
  capi.sqlite3_js_aggregate_context = (pCtx, n)=>{
    return capi.sqlite3_aggregate_context(pCtx, n)
      || (n ? WasmAllocError.toss("Cannot allocate",n,
                                  "bytes for sqlite3_aggregate_context()")
          : 0);
  };

  
  capi.sqlite3_js_posix_create_file = function(filename, data, dataLen){
    let pData;
    if(data && wasm.isPtr(data)){
      pData = data;
    }else if(data instanceof ArrayBuffer || data instanceof Uint8Array){
      pData = wasm.allocFromTypedArray(data);
      if(arguments.length<3 || !util.isInt32(dataLen) || dataLen<0){
        dataLen = data.byteLength;
      }
    }else{
      SQLite3Error.toss("Invalid 2nd argument for sqlite3_js_posix_create_file().");
    }
    try{
      if(!util.isInt32(dataLen) || dataLen<0){
        SQLite3Error.toss("Invalid 3rd argument for sqlite3_js_posix_create_file().");
      }
      const rc = wasm.sqlite3_wasm_posix_create_file(filename, pData, dataLen);
      if(rc) SQLite3Error.toss("Creation of file failed with sqlite3 result code",
                               capi.sqlite3_js_rc_str(rc));
    }finally{
       wasm.dealloc(pData);
    }
  };

  
  capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen){
    config.warn("sqlite3_js_vfs_create_file() is deprecated and",
                "should be avoided because it can lead to C-level crashes.",
                "See its documentation for alternative options.");
    let pData;
    if(data){
      if(wasm.isPtr(data)){
        pData = data;
      }else if(data instanceof ArrayBuffer){
        data = new Uint8Array(data);
      }
      if(data instanceof Uint8Array){
        pData = wasm.allocFromTypedArray(data);
        if(arguments.length<4 || !util.isInt32(dataLen) || dataLen<0){
          dataLen = data.byteLength;
        }
      }else{
        SQLite3Error.toss("Invalid 3rd argument type for sqlite3_js_vfs_create_file().");
      }
    }else{
       pData = 0;
    }
    if(!util.isInt32(dataLen) || dataLen<0){
      wasm.dealloc(pData);
      SQLite3Error.toss("Invalid 4th argument for sqlite3_js_vfs_create_file().");
    }
    try{
      const rc = wasm.sqlite3_wasm_vfs_create_file(vfs, filename, pData, dataLen);
      if(rc) SQLite3Error.toss("Creation of file failed with sqlite3 result code",
                               capi.sqlite3_js_rc_str(rc));
    }finally{
       wasm.dealloc(pData);
    }
  };

  
  capi.sqlite3_js_sql_to_string = (sql)=>{
    if('string' === typeof sql){
      return sql;
    }
    const x = flexibleString(v);
    return x===v ? undefined : x;
  }

  if( util.isUIThread() ){
    

    
    const __kvvfsInfo = function(which){
      const rc = Object.create(null);
      rc.prefix = 'kvvfs-'+which;
      rc.stores = [];
      if('session'===which || ""===which) rc.stores.push(globalThis.sessionStorage);
      if('local'===which || ""===which) rc.stores.push(globalThis.localStorage);
      return rc;
    };

    
    capi.sqlite3_js_kvvfs_clear = function(which=""){
      let rc = 0;
      const kvinfo = __kvvfsInfo(which);
      kvinfo.stores.forEach((s)=>{
        const toRm = [] ;
        let i;
        for( i = 0; i < s.length; ++i ){
          const k = s.key(i);
          if(k.startsWith(kvinfo.prefix)) toRm.push(k);
        }
        toRm.forEach((kk)=>s.removeItem(kk));
        rc += toRm.length;
      });
      return rc;
    };

    
    capi.sqlite3_js_kvvfs_size = function(which=""){
      let sz = 0;
      const kvinfo = __kvvfsInfo(which);
      kvinfo.stores.forEach((s)=>{
        let i;
        for(i = 0; i < s.length; ++i){
          const k = s.key(i);
          if(k.startsWith(kvinfo.prefix)){
            sz += k.length;
            sz += s.getItem(k).length;
          }
        }
      });
      return sz * 2 ;
    };

  }

  
  capi.sqlite3_db_config = function(pDb, op, ...args){
    if(!this.s){
      this.s = wasm.xWrap('sqlite3_wasm_db_config_s','int',
                          ['sqlite3*', 'int', 'string:static']
                          );
      this.pii = wasm.xWrap('sqlite3_wasm_db_config_pii', 'int',
                            ['sqlite3*', 'int', '*','int', 'int']);
      this.ip = wasm.xWrap('sqlite3_wasm_db_config_ip','int',
                           ['sqlite3*', 'int', 'int','*']);
    }
    switch(op){
        case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
        case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
        case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
        case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
        case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
        case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
        case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
        case capi.SQLITE_DBCONFIG_RESET_DATABASE:
        case capi.SQLITE_DBCONFIG_DEFENSIVE:
        case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
        case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
        case capi.SQLITE_DBCONFIG_DQS_DML:
        case capi.SQLITE_DBCONFIG_DQS_DDL:
        case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
        case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
        case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
        case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
        case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
          return this.ip(pDb, op, args[0], args[1] || 0);
        case capi.SQLITE_DBCONFIG_LOOKASIDE:
          return this.pii(pDb, op, args[0], args[1], args[2]);
        case capi.SQLITE_DBCONFIG_MAINDBNAME:
          return this.s(pDb, op, args[0]);
        default:
          return capi.SQLITE_MISUSE;
    }
  }.bind(Object.create(null));

  
  capi.sqlite3_value_to_js = function(pVal,throwIfCannotConvert=true){
    let arg;
    const valType = capi.sqlite3_value_type(pVal);
    switch(valType){
        case capi.SQLITE_INTEGER:
          if(wasm.bigIntEnabled){
            arg = capi.sqlite3_value_int64(pVal);
            if(util.bigIntFitsDouble(arg)) arg = Number(arg);
          }
          else arg = capi.sqlite3_value_double(pVal);
          break;
        case capi.SQLITE_FLOAT:
          arg = capi.sqlite3_value_double(pVal);
          break;
        case capi.SQLITE_TEXT:
          arg = capi.sqlite3_value_text(pVal);
          break;
        case capi.SQLITE_BLOB:{
          const n = capi.sqlite3_value_bytes(pVal);
          const pBlob = capi.sqlite3_value_blob(pVal);
          if(n && !pBlob) sqlite3.WasmAllocError.toss(
            "Cannot allocate memory for blob argument of",n,"byte(s)"
          );
          arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;
          break;
        }
        case capi.SQLITE_NULL:
          arg = null; break;
        default:
          if(throwIfCannotConvert){
            toss3(capi.SQLITE_MISMATCH,
                  "Unhandled sqlite3_value_type():",valType);
          }
          arg = undefined;
    }
    return arg;
  };

  
  capi.sqlite3_values_to_js = function(argc,pArgv,throwIfCannotConvert=true){
    let i;
    const tgt = [];
    for(i = 0; i < argc; ++i){
      
      tgt.push(capi.sqlite3_value_to_js(
        wasm.peekPtr(pArgv + (wasm.ptrSizeof * i)),
        throwIfCannotConvert
      ));
    }
    return tgt;
  };

  
  capi.sqlite3_result_error_js = function(pCtx,e){
    if(e instanceof WasmAllocError){
      capi.sqlite3_result_error_nomem(pCtx);
    }else{
      ;
      capi.sqlite3_result_error(pCtx, ''+e, -1);
    }
  };

  
  capi.sqlite3_result_js = function(pCtx,val){
    if(val instanceof Error){
      capi.sqlite3_result_error_js(pCtx, val);
      return;
    }
    try{
      switch(typeof val) {
          case 'undefined':
            
            break;
          case 'boolean':
            capi.sqlite3_result_int(pCtx, val ? 1 : 0);
            break;
          case 'bigint':
            if(util.bigIntFits32(val)){
              capi.sqlite3_result_int(pCtx, Number(val));
            }else if(util.bigIntFitsDouble(val)){
              capi.sqlite3_result_double(pCtx, Number(val));
            }else if(wasm.bigIntEnabled){
              if(util.bigIntFits64(val)) capi.sqlite3_result_int64(pCtx, val);
              else toss3("BigInt value",val.toString(),"is too BigInt for int64.");
            }else{
              toss3("BigInt value",val.toString(),"is too BigInt.");
            }
            break;
          case 'number': {
            let f;
            if(util.isInt32(val)){
              f = capi.sqlite3_result_int;
            }else if(wasm.bigIntEnabled
                     && Number.isInteger(val)
                     && util.bigIntFits64(BigInt(val))){
              f = capi.sqlite3_result_int64;
            }else{
              f = capi.sqlite3_result_double;
            }
            f(pCtx, val);
            break;
          }
          case 'string': {
            const [p, n] = wasm.allocCString(val,true);
            capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);
            break;
          }
          case 'object':
            if(null===val) {
              capi.sqlite3_result_null(pCtx);
              break;
            }else if(util.isBindableTypedArray(val)){
              const pBlob = wasm.allocFromTypedArray(val);
              capi.sqlite3_result_blob(
                pCtx, pBlob, val.byteLength,
                capi.SQLITE_WASM_DEALLOC
              );
              break;
            }
            
          default:
            toss3("Don't not how to handle this UDF result value:",(typeof val), val);
      }
    }catch(e){
      capi.sqlite3_result_error_js(pCtx, e);
    }
  };

  
  capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert=true){
    const v = capi.sqlite3_column_value(pStmt, iCol);
    return (0===v) ? undefined : capi.sqlite3_value_to_js(v, throwIfCannotConvert);
  };

  
  const __newOldValue = function(pObj, iCol, impl){
    impl = capi[impl];
    if(!this.ptr) this.ptr = wasm.allocPtr();
    else wasm.pokePtr(this.ptr, 0);
    const rc = impl(pObj, iCol, this.ptr);
    if(rc) return SQLite3Error.toss(rc,arguments[2]+"() failed with code "+rc);
    const pv = wasm.peekPtr(this.ptr);
    return pv ? capi.sqlite3_value_to_js( pv, true ) : undefined;
  }.bind(Object.create(null));

  
  capi.sqlite3_preupdate_new_js =
    (pDb, iCol)=>__newOldValue(pDb, iCol, 'sqlite3_preupdate_new');

  
  capi.sqlite3_preupdate_old_js =
    (pDb, iCol)=>__newOldValue(pDb, iCol, 'sqlite3_preupdate_old');

  
  capi.sqlite3changeset_new_js =
    (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol,
                                            'sqlite3changeset_new');

  
  capi.sqlite3changeset_old_js =
    (pChangesetIter, iCol)=>__newOldValue(pChangesetIter, iCol,
                                          'sqlite3changeset_old');

  
  const sqlite3 = {
    WasmAllocError: WasmAllocError,
    SQLite3Error: SQLite3Error,
    capi,
    util,
    wasm,
    config,
    
    version: Object.create(null),

    
    client: undefined,

    
    asyncPostInit: async function ff(){
      if(ff.isReady instanceof Promise) return ff.isReady;
      let lia = sqlite3ApiBootstrap.initializersAsync;
      delete sqlite3ApiBootstrap.initializersAsync;
      const postInit = async ()=>{
        if(!sqlite3.__isUnderTest){
          
          delete sqlite3.util;
          
          delete sqlite3.StructBinder;
        }
        return sqlite3;
      };
      const catcher = (e)=>{
        config.error("an async sqlite3 initializer failed:",e);
        throw e;
      };
      if(!lia || !lia.length){
        return ff.isReady = postInit().catch(catcher);
      }
      lia = lia.map((f)=>{
        return (f instanceof Function) ? async x=>f(sqlite3) : f;
      });
      lia.push(postInit);
      let p = Promise.resolve(sqlite3);
      while(lia.length) p = p.then(lia.shift());
      return ff.isReady = p.catch(catcher);
    },
    
    scriptInfo: undefined
  };
  try{
    sqlite3ApiBootstrap.initializers.forEach((f)=>{
      f(sqlite3);
    });
  }catch(e){
    
    console.error("sqlite3 bootstrap initializer threw:",e);
    throw e;
  }
  delete sqlite3ApiBootstrap.initializers;
  sqlite3ApiBootstrap.sqlite3 = sqlite3;
  return sqlite3;
};

globalThis.sqlite3ApiBootstrap.initializers = [];

globalThis.sqlite3ApiBootstrap.initializersAsync = [];

globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);

globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;




globalThis.WhWasmUtilInstaller = function(target){
  'use strict';
  if(undefined===target.bigIntEnabled){
    target.bigIntEnabled = !!globalThis['BigInt64Array'];
  }

  
  const toss = (...args)=>{throw new Error(args.join(' '))};

  if(!target.exports){
    Object.defineProperty(target, 'exports', {
      enumerable: true, configurable: true,
      get: ()=>(target.instance && target.instance.exports)
    });
  }

  
  

  
  const ptrIR = target.pointerIR || 'i32';
  const ptrSizeof = target.ptrSizeof =
        ('i32'===ptrIR ? 4
         : ('i64'===ptrIR
            ? 8 : toss("Unhandled ptrSizeof:",ptrIR)));
  
  const cache = Object.create(null);
  
  cache.heapSize = 0;
  
  cache.memory = null;
  
  cache.freeFuncIndexes = [];
  
  cache.scopedAlloc = [];

  cache.utf8Decoder = new TextDecoder();
  cache.utf8Encoder = new TextEncoder('utf-8');

  
  target.sizeofIR = (n)=>{
    switch(n){
        case 'i8': return 1;
        case 'i16': return 2;
        case 'i32': case 'f32': case 'float': return 4;
        case 'i64': case 'f64': case 'double': return 8;
        case '*': return ptrSizeof;
        default:
          return (''+n).endsWith('*') ? ptrSizeof : undefined;
    }
  };

  
  const heapWrappers = function(){
    if(!cache.memory){
      cache.memory = (target.memory instanceof WebAssembly.Memory)
        ? target.memory : target.exports.memory;
    }else if(cache.heapSize === cache.memory.buffer.byteLength){
      return cache;
    }
    
    const b = cache.memory.buffer;
    cache.HEAP8 = new Int8Array(b); cache.HEAP8U = new Uint8Array(b);
    cache.HEAP16 = new Int16Array(b); cache.HEAP16U = new Uint16Array(b);
    cache.HEAP32 = new Int32Array(b); cache.HEAP32U = new Uint32Array(b);
    if(target.bigIntEnabled){
      cache.HEAP64 = new BigInt64Array(b); cache.HEAP64U = new BigUint64Array(b);
    }
    cache.HEAP32F = new Float32Array(b); cache.HEAP64F = new Float64Array(b);
    cache.heapSize = b.byteLength;
    return cache;
  };

  
  target.heap8 = ()=>heapWrappers().HEAP8;

  
  target.heap8u = ()=>heapWrappers().HEAP8U;

  
  target.heap16 = ()=>heapWrappers().HEAP16;

  
  target.heap16u = ()=>heapWrappers().HEAP16U;

  
  target.heap32 = ()=>heapWrappers().HEAP32;

  
  target.heap32u = ()=>heapWrappers().HEAP32U;

  
  target.heapForSize = function(n,unsigned = true){
    let ctor;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    switch(n){
        case Int8Array: return c.HEAP8; case Uint8Array: return c.HEAP8U;
        case Int16Array: return c.HEAP16; case Uint16Array: return c.HEAP16U;
        case Int32Array: return c.HEAP32; case Uint32Array: return c.HEAP32U;
        case 8:  return unsigned ? c.HEAP8U : c.HEAP8;
        case 16: return unsigned ? c.HEAP16U : c.HEAP16;
        case 32: return unsigned ? c.HEAP32U : c.HEAP32;
        case 64:
          if(c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;
          break;
        default:
          if(target.bigIntEnabled){
            if(n===globalThis['BigUint64Array']) return c.HEAP64U;
            else if(n===globalThis['BigInt64Array']) return c.HEAP64;
            break;
          }
    }
    toss("Invalid heapForSize() size: expecting 8, 16, 32,",
         "or (if BigInt is enabled) 64.");
  };

  
  target.functionTable = function(){
    return target.exports.__indirect_function_table;
    
  };

  
  target.functionEntry = function(fptr){
    const ft = target.functionTable();
    return fptr < ft.length ? ft.get(fptr) : undefined;
  };

  
  target.jsFuncToWasm = function f(func, sig){
    
    if(!f._){
      f._ = {
        
        sigTypes: Object.assign(Object.create(null),{
          i: 'i32', p: 'i32', P: 'i32', s: 'i32',
          j: 'i64', f: 'f32', d: 'f64'
        }),
        
        typeCodes: Object.assign(Object.create(null),{
          f64: 0x7c, f32: 0x7d, i64: 0x7e, i32: 0x7f
        }),
        
        uleb128Encode: function(tgt, method, n){
          if(n<128) tgt[method](n);
          else tgt[method]( (n % 128) | 128, n>>7);
        },
        
        rxJSig: /^(\w)\((\w*)\)$/,
        
        sigParams: function(sig){
          const m = f._.rxJSig.exec(sig);
          return m ? m[2] : sig.substr(1);
        },
        
        letterType: (x)=>f._.sigTypes[x] || toss("Invalid signature letter:",x),
        
        
        
        pushSigType: (dest, letter)=>dest.push(f._.typeCodes[f._.letterType(letter)])
      };
    }
    if('string'===typeof func){
      const x = sig;
      sig = func;
      func = x;
    }
    const sigParams = f._.sigParams(sig);
    const wasmCode = [0x01, 0x60];
    f._.uleb128Encode(wasmCode, 'push', sigParams.length);
    for(const x of sigParams) f._.pushSigType(wasmCode, x);
    if('v'===sig[0]) wasmCode.push(0);
    else{
      wasmCode.push(1);
      f._.pushSigType(wasmCode, sig[0]);
    }
    f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);
    wasmCode.unshift(
      0x00, 0x61, 0x73, 0x6d, 
      0x01, 0x00, 0x00, 0x00, 
      0x01 
    );
    wasmCode.push(
       0x02, 0x07,
      
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
       0x07, 0x05,
      
      0x01, 0x01, 0x66, 0x00, 0x00
    );
    return (new WebAssembly.Instance(
      new WebAssembly.Module(new Uint8Array(wasmCode)), {
        e: { f: func }
      })).exports['f'];
  };

  
  const __installFunction = function f(func, sig, scoped){
    if(scoped && !cache.scopedAlloc.length){
      toss("No scopedAllocPush() scope is active.");
    }
    if('string'===typeof func){
      const x = sig;
      sig = func;
      func = x;
    }
    if('string'!==typeof sig || !(func instanceof Function)){
      toss("Invalid arguments: expecting (function,signature) "+
           "or (signature,function).");
    }
    const ft = target.functionTable();
    const oldLen = ft.length;
    let ptr;
    while(cache.freeFuncIndexes.length){
      ptr = cache.freeFuncIndexes.pop();
      if(ft.get(ptr)){ 
        ptr = null;
        continue;
      }else{
        break;
      }
    }
    if(!ptr){
      ptr = oldLen;
      ft.grow(1);
    }
    try{
      
      ft.set(ptr, func);
      if(scoped){
        cache.scopedAlloc[cache.scopedAlloc.length-1].push(ptr);
      }
      return ptr;
    }catch(e){
      if(!(e instanceof TypeError)){
        if(ptr===oldLen) cache.freeFuncIndexes.push(oldLen);
        throw e;
      }
    }
    
    try {
      const fptr = target.jsFuncToWasm(func, sig);
      ft.set(ptr, fptr);
      if(scoped){
        cache.scopedAlloc[cache.scopedAlloc.length-1].push(ptr);
      }
    }catch(e){
      if(ptr===oldLen) cache.freeFuncIndexes.push(oldLen);
      throw e;
    }
    return ptr;
  };

  
  target.installFunction = (func, sig)=>__installFunction(func, sig, false);

  
  target.scopedInstallFunction = (func, sig)=>__installFunction(func, sig, true);

  
  target.uninstallFunction = function(ptr){
    if(!ptr && 0!==ptr) return undefined;
    const fi = cache.freeFuncIndexes;
    const ft = target.functionTable();
    fi.push(ptr);
    const rc = ft.get(ptr);
    ft.set(ptr, null);
    return rc;
  };

  
  target.peek = function f(ptr, type='i8'){
    if(type.endsWith('*')) type = ptrIR;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    const list = Array.isArray(ptr) ? [] : undefined;
    let rc;
    do{
      if(list) ptr = arguments[0].shift();
      switch(type){
          case 'i1':
          case 'i8': rc = c.HEAP8[ptr>>0]; break;
          case 'i16': rc = c.HEAP16[ptr>>1]; break;
          case 'i32': rc = c.HEAP32[ptr>>2]; break;
          case 'float': case 'f32': rc = c.HEAP32F[ptr>>2]; break;
          case 'double': case 'f64': rc = Number(c.HEAP64F[ptr>>3]); break;
          case 'i64':
            if(target.bigIntEnabled){
              rc = BigInt(c.HEAP64[ptr>>3]);
              break;
            }
            
          default:
            toss('Invalid type for peek():',type);
      }
      if(list) list.push(rc);
    }while(list && arguments[0].length);
    return list || rc;
  };

  
  target.poke = function(ptr, value, type='i8'){
    if (type.endsWith('*')) type = ptrIR;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    for(const p of (Array.isArray(ptr) ? ptr : [ptr])){
      switch (type) {
          case 'i1':
          case 'i8': c.HEAP8[p>>0] = value; continue;
          case 'i16': c.HEAP16[p>>1] = value; continue;
          case 'i32': c.HEAP32[p>>2] = value; continue;
          case 'float': case 'f32': c.HEAP32F[p>>2] = value; continue;
          case 'double': case 'f64': c.HEAP64F[p>>3] = value; continue;
          case 'i64':
            if(c.HEAP64){
              c.HEAP64[p>>3] = BigInt(value);
              continue;
            }
            
          default:
            toss('Invalid type for poke(): ' + type);
      }
    }
    return this;
  };

  
  target.peekPtr = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), ptrIR );

  
  target.pokePtr = (ptr, value=0)=>target.poke(ptr, value, ptrIR);

  
  target.peek8 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i8' );
  
  target.poke8 = (ptr, value)=>target.poke(ptr, value, 'i8');
  
  target.peek16 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i16' );
  
  target.poke16 = (ptr, value)=>target.poke(ptr, value, 'i16');
  
  target.peek32 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i32' );
  
  target.poke32 = (ptr, value)=>target.poke(ptr, value, 'i32');
  
  target.peek64 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i64' );
  
  target.poke64 = (ptr, value)=>target.poke(ptr, value, 'i64');
  
  target.peek32f = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'f32' );
  
  target.poke32f = (ptr, value)=>target.poke(ptr, value, 'f32');
  
  target.peek64f = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'f64' );
  
  target.poke64f = (ptr, value)=>target.poke(ptr, value, 'f64');

  
  target.getMemValue = target.peek;
  
  target.getPtrValue = target.peekPtr;
  
  target.setMemValue = target.poke;
  
  target.setPtrValue = target.pokePtr;

  
  target.isPtr32 = (ptr)=>('number'===typeof ptr && (ptr===(ptr|0)) && ptr>=0);

  
  target.isPtr = target.isPtr32;

  
  target.cstrlen = function(ptr){
    if(!ptr || !target.isPtr(ptr)) return null;
    const h = heapWrappers().HEAP8U;
    let pos = ptr;
    for( ; h[pos] !== 0; ++pos ){}
    return pos - ptr;
  };

  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  const __utf8Decode = function(arrayBuffer, begin, end){
    return cache.utf8Decoder.decode(
      (arrayBuffer.buffer instanceof __SAB)
        ? arrayBuffer.slice(begin, end)
        : arrayBuffer.subarray(begin, end)
    );
  };

  
  target.cstrToJs = function(ptr){
    const n = target.cstrlen(ptr);
    return n ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr+n) : (null===n ? n : "");
  };

  
  target.jstrlen = function(str){
    
    if('string'!==typeof str) return null;
    const n = str.length;
    let len = 0;
    for(let i = 0; i < n; ++i){
      let u = str.charCodeAt(i);
      if(u>=0xd800 && u<=0xdfff){
        u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
      }
      if(u<=0x7f) ++len;
      else if(u<=0x7ff) len += 2;
      else if(u<=0xffff) len += 3;
      else len += 4;
    }
    return len;
  };

  
  target.jstrcpy = function(jstr, tgt, offset = 0, maxBytes = -1, addNul = true){
    
    if(!tgt || (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))){
      toss("jstrcpy() target must be an Int8Array or Uint8Array.");
    }
    if(maxBytes<0) maxBytes = tgt.length - offset;
    if(!(maxBytes>0) || !(offset>=0)) return 0;
    let i = 0, max = jstr.length;
    const begin = offset, end = offset + maxBytes - (addNul ? 1 : 0);
    for(; i < max && offset < end; ++i){
      let u = jstr.charCodeAt(i);
      if(u>=0xd800 && u<=0xdfff){
        u = 0x10000 + ((u & 0x3FF) << 10) | (jstr.charCodeAt(++i) & 0x3FF);
      }
      if(u<=0x7f){
        if(offset >= end) break;
        tgt[offset++] = u;
      }else if(u<=0x7ff){
        if(offset + 1 >= end) break;
        tgt[offset++] = 0xC0 | (u >> 6);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }else if(u<=0xffff){
        if(offset + 2 >= end) break;
        tgt[offset++] = 0xe0 | (u >> 12);
        tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }else{
        if(offset + 3 >= end) break;
        tgt[offset++] = 0xf0 | (u >> 18);
        tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);
        tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }
    }
    if(addNul) tgt[offset++] = 0;
    return offset - begin;
  };

  
  target.cstrncpy = function(tgtPtr, srcPtr, n){
    if(!tgtPtr || !srcPtr) toss("cstrncpy() does not accept NULL strings.");
    if(n<0) n = target.cstrlen(strPtr)+1;
    else if(!(n>0)) return 0;
    const heap = target.heap8u();
    let i = 0, ch;
    for(; i < n && (ch = heap[srcPtr+i]); ++i){
      heap[tgtPtr+i] = ch;
    }
    if(i<n) heap[tgtPtr + i++] = 0;
    return i;
  };

  
  target.jstrToUintArray = (str, addNul=false)=>{
    return cache.utf8Encoder.encode(addNul ? (str+"\0") : str);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  };

  const __affirmAlloc = (obj,funcName)=>{
    if(!(obj.alloc instanceof Function) ||
       !(obj.dealloc instanceof Function)){
      toss("Object is missing alloc() and/or dealloc() function(s)",
           "required by",funcName+"().");
    }
  };

  const __allocCStr = function(jstr, returnWithLength, allocator, funcName){
    __affirmAlloc(target, funcName);
    if('string'!==typeof jstr) return null;
    if(false){}else{
      const u = cache.utf8Encoder.encode(jstr),
            ptr = allocator(u.length+1),
            heap = heapWrappers().HEAP8U;
      heap.set(u, ptr);
      heap[ptr + u.length] = 0;
      return returnWithLength ? [ptr, u.length] : ptr;
    }
  };

  
  target.allocCString =
    (jstr, returnWithLength=false)=>__allocCStr(jstr, returnWithLength,
                                                target.alloc, 'allocCString()');

  
  target.scopedAllocPush = function(){
    __affirmAlloc(target, 'scopedAllocPush');
    const a = [];
    cache.scopedAlloc.push(a);
    return a;
  };

  
  target.scopedAllocPop = function(state){
    __affirmAlloc(target, 'scopedAllocPop');
    const n = arguments.length
          ? cache.scopedAlloc.indexOf(state)
          : cache.scopedAlloc.length-1;
    if(n<0) toss("Invalid state object for scopedAllocPop().");
    if(0===arguments.length) state = cache.scopedAlloc[n];
    cache.scopedAlloc.splice(n,1);
    for(let p; (p = state.pop()); ){
      if(target.functionEntry(p)){
        
        target.uninstallFunction(p);
      }
      else target.dealloc(p);
    }
  };

  
  target.scopedAlloc = function(n){
    if(!cache.scopedAlloc.length){
      toss("No scopedAllocPush() scope is active.");
    }
    const p = target.alloc(n);
    cache.scopedAlloc[cache.scopedAlloc.length-1].push(p);
    return p;
  };

  Object.defineProperty(target.scopedAlloc, 'level', {
    configurable: false, enumerable: false,
    get: ()=>cache.scopedAlloc.length,
    set: ()=>toss("The 'active' property is read-only.")
  });

  
  target.scopedAllocCString =
    (jstr, returnWithLength=false)=>__allocCStr(jstr, returnWithLength,
                                                target.scopedAlloc, 'scopedAllocCString()');

  
  const __allocMainArgv = function(isScoped, list){
    const pList = target[
      isScoped ? 'scopedAlloc' : 'alloc'
    ]((list.length + 1) * target.ptrSizeof);
    let i = 0;
    list.forEach((e)=>{
      target.pokePtr(pList + (target.ptrSizeof * i++),
                         target[
                           isScoped ? 'scopedAllocCString' : 'allocCString'
                         ](""+e));
    });
    target.pokePtr(pList + (target.ptrSizeof * i), 0);
    return pList;
  };

  
  target.scopedAllocMainArgv = (list)=>__allocMainArgv(true, list);

  
  target.allocMainArgv = (list)=>__allocMainArgv(false, list);

  
  target.cArgvToJs = (argc, pArgv)=>{
    const list = [];
    for(let i = 0; i < argc; ++i){
      const arg = target.peekPtr(pArgv + (target.ptrSizeof * i));
      list.push( arg ? target.cstrToJs(arg) : null );
    }
    return list;
  };

  
  target.scopedAllocCall = function(func){
    target.scopedAllocPush();
    try{ return func() } finally{ target.scopedAllocPop() }
  };

  
  const __allocPtr = function(howMany, safePtrSize, method){
    __affirmAlloc(target, method);
    const pIr = safePtrSize ? 'i64' : ptrIR;
    let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
    target.poke(m, 0, pIr)
    if(1===howMany){
      return m;
    }
    const a = [m];
    for(let i = 1; i < howMany; ++i){
      m += (safePtrSize ? 8 : ptrSizeof);
      a[i] = m;
      target.poke(m, 0, pIr);
    }
    return a;
  };

  
  target.allocPtr =
    (howMany=1, safePtrSize=true)=>__allocPtr(howMany, safePtrSize, 'alloc');

  
  target.scopedAllocPtr =
    (howMany=1, safePtrSize=true)=>__allocPtr(howMany, safePtrSize, 'scopedAlloc');

  
  target.xGet = function(name){
    return target.exports[name] || toss("Cannot find exported symbol:",name);
  };

  const __argcMismatch =
        (f,n)=>toss(f+"() requires",n,"argument(s).");

  
  target.xCall = function(fname, ...args){
    const f = target.xGet(fname);
    if(!(f instanceof Function)) toss("Exported symbol",fname,"is not a function.");
    if(f.length!==args.length) __argcMismatch(fname,f.length)
    ;
    return (2===arguments.length && Array.isArray(arguments[1]))
      ? f.apply(null, arguments[1])
      : f.apply(null, args);
  };

  
  cache.xWrap = Object.create(null);
  cache.xWrap.convert = Object.create(null);
  
  cache.xWrap.convert.arg = new Map;
  
  cache.xWrap.convert.result = new Map;
  const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;

  if(target.bigIntEnabled){
    xArg.set('i64', (i)=>BigInt(i));
  }
  const __xArgPtr = 'i32' === ptrIR
        ? ((i)=>(i | 0)) : ((i)=>(BigInt(i) | BigInt(0)));
  xArg.set('i32', __xArgPtr )
    .set('i16', (i)=>((i | 0) & 0xFFFF))
    .set('i8', (i)=>((i | 0) & 0xFF))
    .set('f32', (i)=>Number(i).valueOf())
    .set('float', xArg.get('f32'))
    .set('f64', xArg.get('f32'))
    .set('double', xArg.get('f64'))
    .set('int', xArg.get('i32'))
    .set('null', (i)=>i)
    .set(null, xArg.get('null'))
    .set('**', __xArgPtr)
    .set('*', __xArgPtr);
  xResult.set('*', __xArgPtr)
    .set('pointer', __xArgPtr)
    .set('number', (v)=>Number(v))
    .set('void', (v)=>undefined)
    .set('null', (v)=>v)
    .set(null, xResult.get('null'));

  { 
    const copyToResult = ['i8', 'i16', 'i32', 'int',
                          'f32', 'float', 'f64', 'double'];
    if(target.bigIntEnabled) copyToResult.push('i64');
    const adaptPtr = xArg.get(ptrIR);
    for(const t of copyToResult){
      xArg.set(t+'*', adaptPtr);
      xResult.set(t+'*', adaptPtr);
      xResult.set(t, (xArg.get(t) || toss("Missing arg converter:",t)));
    }
  }

  
  const __xArgString = function(v){
    if('string'===typeof v) return target.scopedAllocCString(v);
    return v ? __xArgPtr(v) : null;
  };
  xArg.set('string', __xArgString)
    .set('utf8', __xArgString)
    .set('pointer', __xArgString);
  

  xResult.set('string', (i)=>target.cstrToJs(i))
    .set('utf8', xResult.get('string'))
    .set('string:dealloc', (i)=>{
      try { return i ? target.cstrToJs(i) : null }
      finally{ target.dealloc(i) }
    })
    .set('utf8:dealloc', xResult.get('string:dealloc'))
    .set('json', (i)=>JSON.parse(target.cstrToJs(i)))
    .set('json:dealloc', (i)=>{
      try{ return i ? JSON.parse(target.cstrToJs(i)) : null }
      finally{ target.dealloc(i) }
    });

  
  const AbstractArgAdapter = class {
    constructor(opt){
      this.name = opt.name || 'unnamed adapter';
    }
    
    convertArg(v,argv,argIndex){
      toss("AbstractArgAdapter must be subclassed.");
    }
  };

  
  xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
    constructor(opt) {
      super(opt);
      if(xArg.FuncPtrAdapter.warnOnUse){
        console.warn('xArg.FuncPtrAdapter is an internal-only API',
                     'and is not intended to be invoked from',
                     'client-level code. Invoked with:',opt);
      }
      this.name = opt.name || "unnamed";
      this.signature = opt.signature;
      if(opt.contextKey instanceof Function){
        this.contextKey = opt.contextKey;
        if(!opt.bindScope) opt.bindScope = 'context';
      }
      this.bindScope = opt.bindScope
        || toss("FuncPtrAdapter options requires a bindScope (explicit or implied).");
      if(FuncPtrAdapter.bindScopes.indexOf(opt.bindScope)<0){
        toss("Invalid options.bindScope ("+opt.bindMod+") for FuncPtrAdapter. "+
             "Expecting one of: ("+FuncPtrAdapter.bindScopes.join(', ')+')');
      }
      this.isTransient = 'transient'===this.bindScope;
      this.isContext = 'context'===this.bindScope;
      this.isPermanent = 'permanent'===this.bindScope;
      this.singleton = ('singleton'===this.bindScope) ? [] : undefined;
      
      this.callProxy = (opt.callProxy instanceof Function)
        ? opt.callProxy : undefined;
    }

    

    
    contextKey(argv,argIndex){
      return this;
    }

    
    contextMap(key){
      const cm = (this.__cmap || (this.__cmap = new Map));
      let rc = cm.get(key);
      if(undefined===rc) cm.set(key, (rc = []));
      return rc;
    }

    
    convertArg(v,argv,argIndex){
      
      let pair = this.singleton;
      if(!pair && this.isContext){
        pair = this.contextMap(this.contextKey(argv,argIndex));
        
      }
      if(pair && pair[0]===v) return pair[1];
      if(v instanceof Function){
        
        
        if(this.callProxy) v = this.callProxy(v);
        const fp = __installFunction(v, this.signature, this.isTransient);
        if(FuncPtrAdapter.debugFuncInstall){
          FuncPtrAdapter.debugOut("FuncPtrAdapter installed", this,
                                  this.contextKey(argv,argIndex), '@'+fp, v);
        }
        if(pair){
          
          if(pair[1]){
            if(FuncPtrAdapter.debugFuncInstall){
              FuncPtrAdapter.debugOut("FuncPtrAdapter uninstalling", this,
                                      this.contextKey(argv,argIndex), '@'+pair[1], v);
            }
            try{
              
              cache.scopedAlloc[cache.scopedAlloc.length-1].push(pair[1]);
            }
            catch(e){}
          }
          pair[0] = v;
          pair[1] = fp;
        }
        return fp;
      }else if(target.isPtr(v) || null===v || undefined===v){
        
        if(pair && pair[1] && pair[1]!==v){
          
          if(FuncPtrAdapter.debugFuncInstall){
            FuncPtrAdapter.debugOut("FuncPtrAdapter uninstalling", this,
                                    this.contextKey(argv,argIndex), '@'+pair[1], v);
          }
          try{ cache.scopedAlloc[cache.scopedAlloc.length-1].push(pair[1]) }
          catch(e){}
          pair[0] = pair[1] = (v | 0);
        }
        return v || 0;
      }else{
        throw new TypeError("Invalid FuncPtrAdapter argument type. "+
                            "Expecting a function pointer or a "+
                            (this.name ? this.name+' ' : '')+
                            "function matching signature "+
                            this.signature+".");
      }
    }
  };

  
  xArg.FuncPtrAdapter.warnOnUse = false;

  
  xArg.FuncPtrAdapter.debugFuncInstall = false;

  
  xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);

  xArg.FuncPtrAdapter.bindScopes = [
    'transient', 'context', 'singleton', 'permanent'
  ];

  const __xArgAdapterCheck =
        (t)=>xArg.get(t) || toss("Argument adapter not found:",t);

  const __xResultAdapterCheck =
        (t)=>xResult.get(t) || toss("Result adapter not found:",t);

  cache.xWrap.convertArg = (t,...args)=>__xArgAdapterCheck(t)(...args);
  cache.xWrap.convertArgNoCheck = (t,...args)=>xArg.get(t)(...args);

  cache.xWrap.convertResult =
    (t,v)=>(null===t ? v : (t ? __xResultAdapterCheck(t)(v) : undefined));
  cache.xWrap.convertResultNoCheck =
    (t,v)=>(null===t ? v : (t ? xResult.get(t)(v) : undefined));

  
  target.xWrap = function(fArg, resultType, ...argTypes){
    if(3===arguments.length && Array.isArray(arguments[2])){
      argTypes = arguments[2];
    }
    if(target.isPtr(fArg)){
      fArg = target.functionEntry(fArg)
        || toss("Function pointer not found in WASM function table.");
    }
    const fIsFunc = (fArg instanceof Function);
    const xf = fIsFunc ? fArg : target.xGet(fArg);
    if(fIsFunc) fArg = xf.name || 'unnamed function';
    if(argTypes.length!==xf.length) __argcMismatch(fArg, xf.length);
    if((null===resultType) && 0===xf.length){
      
      return xf;
    }
    ;
    if(undefined!==resultType && null!==resultType) __xResultAdapterCheck(resultType);
    for(const t of argTypes){
      if(t instanceof AbstractArgAdapter) xArg.set(t, (...args)=>t.convertArg(...args));
      else __xArgAdapterCheck(t);
    }
    const cxw = cache.xWrap;
    if(0===xf.length){
      
      return (...args)=>(args.length
                         ? __argcMismatch(fArg, xf.length)
                         : cxw.convertResult(resultType, xf.call(null)));
    }
    return function(...args){
      if(args.length!==xf.length) __argcMismatch(fArg, xf.length);
      const scope = target.scopedAllocPush();
      try{
        
        for(const i in args) args[i] = cxw.convertArgNoCheck(
          argTypes[i], args[i], args, i
        );
        return cxw.convertResultNoCheck(resultType, xf.apply(null,args));
      }finally{
        target.scopedAllocPop(scope);
      }
    };
  };

  
  const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart){
    if('string'===typeof typeName){
      if(1===argc) return xcvPart.get(typeName);
      else if(2===argc){
        if(!adapter){
          delete xcvPart.get(typeName);
          return func;
        }else if(!(adapter instanceof Function)){
          toss(modeName,"requires a function argument.");
        }
        xcvPart.set(typeName, adapter);
        return func;
      }
    }
    toss("Invalid arguments to",modeName);
  };

  
  target.xWrap.resultAdapter = function f(typeName, adapter){
    return __xAdapter(f, arguments.length, typeName, adapter,
                      'resultAdapter()', xResult);
  };

  
  target.xWrap.argAdapter = function f(typeName, adapter){
    return __xAdapter(f, arguments.length, typeName, adapter,
                      'argAdapter()', xArg);
  };

  target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;

  
  target.xCallWrapped = function(fArg, resultType, argTypes, ...args){
    if(Array.isArray(arguments[3])) args = arguments[3];
    return target.xWrap(fArg, resultType, argTypes||[]).apply(null, args||[]);
  };

  
  target.xWrap.testConvertArg = cache.xWrap.convertArg;

  
  target.xWrap.testConvertResult = cache.xWrap.convertResult;

  return target;
};


globalThis.WhWasmUtilInstaller.yawl = function(config){
  const wfetch = ()=>fetch(config.uri, {credentials: 'same-origin'});
  const wui = this;
  const finalThen = function(arg){
    
    if(config.wasmUtilTarget){
      const toss = (...args)=>{throw new Error(args.join(' '))};
      const tgt = config.wasmUtilTarget;
      tgt.module = arg.module;
      tgt.instance = arg.instance;
      
      if(!tgt.instance.exports.memory){
        
        tgt.memory = (config.imports && config.imports.env
                      && config.imports.env.memory)
          || toss("Missing 'memory' object!");
      }
      if(!tgt.alloc && arg.instance.exports.malloc){
        const exports = arg.instance.exports;
        tgt.alloc = function(n){
          return exports.malloc(n) || toss("Allocation of",n,"bytes failed.");
        };
        tgt.dealloc = function(m){exports.free(m)};
      }
      wui(tgt);
    }
    if(config.onload) config.onload(arg,config);
    return arg ;
  };
  const loadWasm = WebAssembly.instantiateStreaming
        ? function loadWasmStreaming(){
          return WebAssembly.instantiateStreaming(wfetch(), config.imports||{})
            .then(finalThen);
        }
        : function loadWasmOldSchool(){ 
          return wfetch()
            .then(response => response.arrayBuffer())
            .then(bytes => WebAssembly.instantiate(bytes, config.imports||{}))
            .then(finalThen);
        };
  return loadWasm;
}.bind(globalThis.WhWasmUtilInstaller);



'use strict';
globalThis.Jaccwabyt = function StructBinderFactory(config){


  
  const toss = (...args)=>{throw new Error(args.join(' '))};

  
  if(!(config.heap instanceof WebAssembly.Memory)
     && !(config.heap instanceof Function)){
    toss("config.heap must be WebAssembly.Memory instance or a function.");
  }
  ['alloc','dealloc'].forEach(function(k){
    (config[k] instanceof Function) ||
      toss("Config option '"+k+"' must be a function.");
  });
  const SBF = StructBinderFactory;
  const heap = (config.heap instanceof Function)
        ? config.heap : (()=>new Uint8Array(config.heap.buffer)),
        alloc = config.alloc,
        dealloc = config.dealloc,
        log = config.log || console.log.bind(console),
        memberPrefix = (config.memberPrefix || ""),
        memberSuffix = (config.memberSuffix || ""),
        bigIntEnabled = (undefined===config.bigIntEnabled
                         ? !!globalThis['BigInt64Array'] : !!config.bigIntEnabled),
        BigInt = globalThis['BigInt'],
        BigInt64Array = globalThis['BigInt64Array'],
        
        ptrSizeof = config.ptrSizeof || 4,
        ptrIR = config.ptrIR || 'i32'
  ;

  if(!SBF.debugFlags){
    SBF.__makeDebugFlags = function(deriveFrom=null){
      
      if(deriveFrom && deriveFrom.__flags) deriveFrom = deriveFrom.__flags;
      const f = function f(flags){
        if(0===arguments.length){
          return f.__flags;
        }
        if(flags<0){
          delete f.__flags.getter; delete f.__flags.setter;
          delete f.__flags.alloc; delete f.__flags.dealloc;
        }else{
          f.__flags.getter  = 0!==(0x01 & flags);
          f.__flags.setter  = 0!==(0x02 & flags);
          f.__flags.alloc   = 0!==(0x04 & flags);
          f.__flags.dealloc = 0!==(0x08 & flags);
        }
        return f._flags;
      };
      Object.defineProperty(f,'__flags', {
        iterable: false, writable: false,
        value: Object.create(deriveFrom)
      });
      if(!deriveFrom) f(0);
      return f;
    };
    SBF.debugFlags = SBF.__makeDebugFlags();
  }

  const isLittleEndian = (function() {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true );
    
    return new Int16Array(buffer)[0] === 256;
  })();
  

  
  const isFuncSig = (s)=>'('===s[1];
  
  const isPtrSig = (s)=>'p'===s || 'P'===s;
  const isAutoPtrSig = (s)=>'P'===s ;
  const sigLetter = (s)=>isFuncSig(s) ? 'p' : s[0];
  
  const sigIR = function(s){
    switch(sigLetter(s)){
        case 'c': case 'C': return 'i8';
        case 'i': return 'i32';
        case 'p': case 'P': case 's': return ptrIR;
        case 'j': return 'i64';
        case 'f': return 'float';
        case 'd': return 'double';
    }
    toss("Unhandled signature IR:",s);
  };

  const affirmBigIntArray = BigInt64Array
        ? ()=>true : ()=>toss('BigInt64Array is not available.');
  
  const sigDVGetter = function(s){
    switch(sigLetter(s)) {
        case 'p': case 'P': case 's': {
          switch(ptrSizeof){
              case 4: return 'getInt32';
              case 8: return affirmBigIntArray() && 'getBigInt64';
          }
          break;
        }
        case 'i': return 'getInt32';
        case 'c': return 'getInt8';
        case 'C': return 'getUint8';
        case 'j': return affirmBigIntArray() && 'getBigInt64';
        case 'f': return 'getFloat32';
        case 'd': return 'getFloat64';
    }
    toss("Unhandled DataView getter for signature:",s);
  };
  
  const sigDVSetter = function(s){
    switch(sigLetter(s)){
        case 'p': case 'P': case 's': {
          switch(ptrSizeof){
              case 4: return 'setInt32';
              case 8: return affirmBigIntArray() && 'setBigInt64';
          }
          break;
        }
        case 'i': return 'setInt32';
        case 'c': return 'setInt8';
        case 'C': return 'setUint8';
        case 'j': return affirmBigIntArray() && 'setBigInt64';
        case 'f': return 'setFloat32';
        case 'd': return 'setFloat64';
    }
    toss("Unhandled DataView setter for signature:",s);
  };
  
  const sigDVSetWrapper = function(s){
    switch(sigLetter(s)) {
        case 'i': case 'f': case 'c': case 'C': case 'd': return Number;
        case 'j': return affirmBigIntArray() && BigInt;
        case 'p': case 'P': case 's':
          switch(ptrSizeof){
              case 4: return Number;
              case 8: return affirmBigIntArray() && BigInt;
          }
          break;
    }
    toss("Unhandled DataView set wrapper for signature:",s);
  };

  
  const sPropName = (s,k)=>s+'::'+k;

  const __propThrowOnSet = function(structName,propName){
    return ()=>toss(sPropName(structName,propName),"is read-only.");
  };

  
  const __instancePointerMap = new WeakMap();

  
  const xPtrPropName = '(pointer-is-external)';

  
  const __freeStruct = function(ctor, obj, m){
    if(!m) m = __instancePointerMap.get(obj);
    if(m) {
      __instancePointerMap.delete(obj);
      if(Array.isArray(obj.ondispose)){
        let x;
        while((x = obj.ondispose.shift())){
          try{
            if(x instanceof Function) x.call(obj);
            else if(x instanceof StructType) x.dispose();
            else if('number' === typeof x) dealloc(x);
            
            
          }catch(e){
            console.warn("ondispose() for",ctor.structName,'@',
                         m,'threw. NOT propagating it.',e);
          }
        }
      }else if(obj.ondispose instanceof Function){
        try{obj.ondispose()}
        catch(e){
          
          console.warn("ondispose() for",ctor.structName,'@',
                       m,'threw. NOT propagating it.',e);
        }
      }
      delete obj.ondispose;
      if(ctor.debugFlags.__flags.dealloc){
        log("debug.dealloc:",(obj[xPtrPropName]?"EXTERNAL":""),
            ctor.structName,"instance:",
            ctor.structInfo.sizeof,"bytes @"+m);
      }
      if(!obj[xPtrPropName]) dealloc(m);
    }
  };

  
  const rop = (v)=>{return {configurable: false, writable: false,
                            iterable: false, value: v}};

  
  const __allocStruct = function(ctor, obj, m){
    let fill = !m;
    if(m) Object.defineProperty(obj, xPtrPropName, rop(m));
    else{
      m = alloc(ctor.structInfo.sizeof);
      if(!m) toss("Allocation of",ctor.structName,"structure failed.");
    }
    try {
      if(ctor.debugFlags.__flags.alloc){
        log("debug.alloc:",(fill?"":"EXTERNAL"),
            ctor.structName,"instance:",
            ctor.structInfo.sizeof,"bytes @"+m);
      }
      if(fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
      __instancePointerMap.set(obj, m);
    }catch(e){
      __freeStruct(ctor, obj, m);
      throw e;
    }
  };
  
  const __memoryDump = function(){
    const p = this.pointer;
    return p
      ? new Uint8Array(heap().slice(p, p+this.structInfo.sizeof))
      : null;
  };

  const __memberKey = (k)=>memberPrefix + k + memberSuffix;
  const __memberKeyProp = rop(__memberKey);

  
  const __lookupMember = function(structInfo, memberName, tossIfNotFound=true){
    let m = structInfo.members[memberName];
    if(!m && (memberPrefix || memberSuffix)){
      
      for(const v of Object.values(structInfo.members)){
        if(v.key===memberName){ m = v; break; }
      }
      if(!m && tossIfNotFound){
        toss(sPropName(structInfo.name,memberName),'is not a mapped struct member.');
      }
    }
    return m;
  };

  
  const __memberSignature = function f(obj,memberName,emscriptenFormat=false){
    if(!f._) f._ = (x)=>x.replace(/[^vipPsjrdcC]/g,"").replace(/[pPscC]/g,'i');
    const m = __lookupMember(obj.structInfo, memberName, true);
    return emscriptenFormat ? f._(m.signature) : m.signature;
  };

  const __ptrPropDescriptor = {
    configurable: false, enumerable: false,
    get: function(){return __instancePointerMap.get(this)},
    set: ()=>toss("Cannot assign the 'pointer' property of a struct.")
    
    
    
  };

  
  const __structMemberKeys = rop(function(){
    const a = [];
    for(const k of Object.keys(this.structInfo.members)){
      a.push(this.memberKey(k));
    }
    return a;
  });

  const __utf8Decoder = new TextDecoder('utf-8');
  const __utf8Encoder = new TextEncoder();
  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  const __utf8Decode = function(arrayBuffer, begin, end){
    return __utf8Decoder.decode(
      (arrayBuffer.buffer instanceof __SAB)
        ? arrayBuffer.slice(begin, end)
        : arrayBuffer.subarray(begin, end)
    );
  };
  
  const __memberIsString = function(obj,memberName, tossIfNotFound=false){
    const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
    return (m && 1===m.signature.length && 's'===m.signature[0]) ? m : false;
  };

  
  const __affirmCStringSignature = function(member){
    if('s'===member.signature) return;
    toss("Invalid member type signature for C-string value:",
         JSON.stringify(member));
  };

  
  const __memberToJsString = function f(obj,memberName){
    const m = __lookupMember(obj.structInfo, memberName, true);
    __affirmCStringSignature(m);
    const addr = obj[m.key];
    
    if(!addr) return null;
    let pos = addr;
    const mem = heap();
    for( ; mem[pos]!==0; ++pos ) {
      
    };
    
    return (addr===pos) ? "" : __utf8Decode(mem, addr, pos);
  };

  
  const __addOnDispose = function(obj, ...v){
    if(obj.ondispose){
      if(!Array.isArray(obj.ondispose)){
        obj.ondispose = [obj.ondispose];
      }
    }else{
      obj.ondispose = [];
    }
    obj.ondispose.push(...v);
  };

  
  const __allocCString = function(str){
    const u = __utf8Encoder.encode(str);
    const mem = alloc(u.length+1);
    if(!mem) toss("Allocation error while duplicating string:",str);
    const h = heap();
    
    
    h.set(u, mem);
    h[mem + u.length] = 0;
    
    return mem;
  };

  
  const __setMemberCString = function(obj, memberName, str){
    const m = __lookupMember(obj.structInfo, memberName, true);
    __affirmCStringSignature(m);
    
    const mem = __allocCString(str);
    obj[m.key] = mem;
    __addOnDispose(obj, mem);
    return obj;
  };

  
  const StructType = function ctor(structName, structInfo){
    if(arguments[2]!==rop){
      toss("Do not call the StructType constructor",
           "from client-level code.");
    }
    Object.defineProperties(this,{
      
      structName: rop(structName),
      structInfo: rop(structInfo)
    });
  };

  
  StructType.prototype = Object.create(null, {
    dispose: rop(function(){__freeStruct(this.constructor, this)}),
    lookupMember: rop(function(memberName, tossIfNotFound=true){
      return __lookupMember(this.structInfo, memberName, tossIfNotFound);
    }),
    memberToJsString: rop(function(memberName){
      return __memberToJsString(this, memberName);
    }),
    memberIsString: rop(function(memberName, tossIfNotFound=true){
      return __memberIsString(this, memberName, tossIfNotFound);
    }),
    memberKey: __memberKeyProp,
    memberKeys: __structMemberKeys,
    memberSignature: rop(function(memberName, emscriptenFormat=false){
      return __memberSignature(this, memberName, emscriptenFormat);
    }),
    memoryDump: rop(__memoryDump),
    pointer: __ptrPropDescriptor,
    setMemberCString: rop(function(memberName, str){
      return __setMemberCString(this, memberName, str);
    })
  });
  
  Object.assign(StructType.prototype,{
    addOnDispose: function(...v){
      __addOnDispose(this,...v);
      return this;
    }
  });

  
  Object.defineProperties(StructType, {
    allocCString: rop(__allocCString),
    isA: rop((v)=>v instanceof StructType),
    hasExternalPointer: rop((v)=>(v instanceof StructType) && !!v[xPtrPropName]),
    memberKey: __memberKeyProp
  });

  const isNumericValue = (v)=>Number.isFinite(v) || (v instanceof (BigInt || Number));

  
  const makeMemberWrapper = function f(ctor,name, descr){
    if(!f._){
      
      f._ = {getters: {}, setters: {}, sw:{}};
      const a = ['i','c','C','p','P','s','f','d','v()'];
      if(bigIntEnabled) a.push('j');
      a.forEach(function(v){
        
        f._.getters[v] = sigDVGetter(v) ;
        f._.setters[v] = sigDVSetter(v) ;
        f._.sw[v] = sigDVSetWrapper(v)  ;
      });
      const rxSig1 = /^[ipPsjfdcC]$/,
            rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
      f.sigCheck = function(obj, name, key,sig){
        if(Object.prototype.hasOwnProperty.call(obj, key)){
          toss(obj.structName,'already has a property named',key+'.');
        }
        rxSig1.test(sig) || rxSig2.test(sig)
          || toss("Malformed signature for",
                  sPropName(obj.structName,name)+":",sig);
      };
    }
    const key = ctor.memberKey(name);
    f.sigCheck(ctor.prototype, name, key, descr.signature);
    descr.key = key;
    descr.name = name;
    const sigGlyph = sigLetter(descr.signature);
    const xPropName = sPropName(ctor.prototype.structName,key);
    const dbg = ctor.prototype.debugFlags.__flags;
    
    const prop = Object.create(null);
    prop.configurable = false;
    prop.enumerable = false;
    prop.get = function(){
      if(dbg.getter){
        log("debug.getter:",f._.getters[sigGlyph],"for", sigIR(sigGlyph),
            xPropName,'@', this.pointer,'+',descr.offset,'sz',descr.sizeof);
      }
      let rc = (
        new DataView(heap().buffer, this.pointer + descr.offset, descr.sizeof)
      )[f._.getters[sigGlyph]](0, isLittleEndian);
      if(dbg.getter) log("debug.getter:",xPropName,"result =",rc);
      return rc;
    };
    if(descr.readOnly){
      prop.set = __propThrowOnSet(ctor.prototype.structName,key);
    }else{
      prop.set = function(v){
        if(dbg.setter){
          log("debug.setter:",f._.setters[sigGlyph],"for", sigIR(sigGlyph),
              xPropName,'@', this.pointer,'+',descr.offset,'sz',descr.sizeof, v);
        }
        if(!this.pointer){
          toss("Cannot set struct property on disposed instance.");
        }
        if(null===v) v = 0;
        else while(!isNumericValue(v)){
          if(isAutoPtrSig(descr.signature) && (v instanceof StructType)){
            
            v = v.pointer || 0;
            if(dbg.setter) log("debug.setter:",xPropName,"resolved to",v);
            break;
          }
          toss("Invalid value for pointer-type",xPropName+'.');
        }
        (
          new DataView(heap().buffer, this.pointer + descr.offset, descr.sizeof)
        )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);
      };
    }
    Object.defineProperty(ctor.prototype, key, prop);
  };
  
  
  const StructBinder = function StructBinder(structName, structInfo){
    if(1===arguments.length){
      structInfo = structName;
      structName = structInfo.name;
    }else if(!structInfo.name){
      structInfo.name = structName;
    }
    if(!structName) toss("Struct name is required.");
    let lastMember = false;
    Object.keys(structInfo.members).forEach((k)=>{
      
      const m = structInfo.members[k];
      if(!m.sizeof) toss(structName,"member",k,"is missing sizeof.");
      else if(m.sizeof===1){
        (m.signature === 'c' || m.signature === 'C') ||
          toss("Unexpected sizeof==1 member",
               sPropName(structInfo.name,k),
               "with signature",m.signature);
      }else{
        
        
        if(0!==(m.sizeof%4)){
          console.warn("Invalid struct member description =",m,"from",structInfo);
          toss(structName,"member",k,"sizeof is not aligned. sizeof="+m.sizeof);
        }
        if(0!==(m.offset%4)){
          console.warn("Invalid struct member description =",m,"from",structInfo);
          toss(structName,"member",k,"offset is not aligned. offset="+m.offset);
        }
      }
      if(!lastMember || lastMember.offset < m.offset) lastMember = m;
    });
    if(!lastMember) toss("No member property descriptions found.");
    else if(structInfo.sizeof < lastMember.offset+lastMember.sizeof){
      toss("Invalid struct config:",structName,
           "max member offset ("+lastMember.offset+") ",
           "extends past end of struct (sizeof="+structInfo.sizeof+").");
    }
    const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));
    
    const StructCtor = function StructCtor(externalMemory){
      if(!(this instanceof StructCtor)){
        toss("The",structName,"constructor may only be called via 'new'.");
      }else if(arguments.length){
        if(externalMemory!==(externalMemory|0) || externalMemory<=0){
          toss("Invalid pointer value for",structName,"constructor.");
        }
        __allocStruct(StructCtor, this, externalMemory);
      }else{
        __allocStruct(StructCtor, this);
      }
    };
    Object.defineProperties(StructCtor,{
      debugFlags: debugFlags,
      isA: rop((v)=>v instanceof StructCtor),
      memberKey: __memberKeyProp,
      memberKeys: __structMemberKeys,
      methodInfoForKey: rop(function(mKey){
      }),
      structInfo: rop(structInfo),
      structName: rop(structName)
    });
    StructCtor.prototype = new StructType(structName, structInfo, rop);
    Object.defineProperties(StructCtor.prototype,{
      debugFlags: debugFlags,
      constructor: rop(StructCtor)
      
    });
    Object.keys(structInfo.members).forEach(
      (name)=>makeMemberWrapper(StructCtor, name, structInfo.members[name])
    );
    return StructCtor;
  };
  StructBinder.StructType = StructType;
  StructBinder.config = config;
  StructBinder.allocCString = __allocCString;
  if(!StructBinder.debugFlags){
    StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
  }
  return StructBinder;
};



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  'use strict';
  const toss = (...args)=>{throw new Error(args.join(' '))};
  const toss3 = sqlite3.SQLite3Error.toss;
  const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
  globalThis.WhWasmUtilInstaller(wasm);
  delete globalThis.WhWasmUtilInstaller;

  if(false){}

  
  wasm.bindingSignatures = [
    
    ["sqlite3_aggregate_context","void*", "sqlite3_context*", "int"],
    
    
    ["sqlite3_bind_double","int", "sqlite3_stmt*", "int", "f64"],
    ["sqlite3_bind_int","int", "sqlite3_stmt*", "int", "int"],
    ["sqlite3_bind_null",undefined, "sqlite3_stmt*", "int"],
    ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
    ["sqlite3_bind_parameter_index","int", "sqlite3_stmt*", "string"],
    ["sqlite3_bind_pointer", "int",
     "sqlite3_stmt*", "int", "*", "string:static", "*"],
    ["sqlite3_busy_handler","int", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        signature: 'i(pi)',
        contextKey: (argv,argIndex)=>argv[0]
      }),
      "*"
    ]],
    ["sqlite3_busy_timeout","int", "sqlite3*", "int"],
    
    
    ["sqlite3_changes", "int", "sqlite3*"],
    ["sqlite3_clear_bindings","int", "sqlite3_stmt*"],
    ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
    ["sqlite3_column_blob","*", "sqlite3_stmt*", "int"],
    ["sqlite3_column_bytes","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_count", "int", "sqlite3_stmt*"],
    ["sqlite3_column_double","f64", "sqlite3_stmt*", "int"],
    ["sqlite3_column_int","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_name","string", "sqlite3_stmt*", "int"],
    ["sqlite3_column_text","string", "sqlite3_stmt*", "int"],
    ["sqlite3_column_type","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_value","sqlite3_value*", "sqlite3_stmt*", "int"],
    ["sqlite3_commit_hook", "void*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_commit_hook',
        signature: 'i(p)',
        contextKey: (argv)=>argv[0]
      }),
      '*'
    ]],
    ["sqlite3_compileoption_get", "string", "int"],
    ["sqlite3_compileoption_used", "int", "string"],
    ["sqlite3_complete", "int", "string:flexible"],
    ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],

    
    
    ["sqlite3_data_count", "int", "sqlite3_stmt*"],
    ["sqlite3_db_filename", "string", "sqlite3*", "string"],
    ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
    ["sqlite3_db_name", "string", "sqlite3*", "int"],
    ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
    ["sqlite3_errcode", "int", "sqlite3*"],
    ["sqlite3_errmsg", "string", "sqlite3*"],
    ["sqlite3_error_offset", "int", "sqlite3*"],
    ["sqlite3_errstr", "string", "int"],
    ["sqlite3_exec", "int", [
      "sqlite3*", "string:flexible",
      new wasm.xWrap.FuncPtrAdapter({
        signature: 'i(pipp)',
        bindScope: 'transient',
        callProxy: (callback)=>{
          let aNames;
          return (pVoid, nCols, pColVals, pColNames)=>{
            try {
              const aVals = wasm.cArgvToJs(nCols, pColVals);
              if(!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);
              return callback(aVals, aNames) | 0;
            }catch(e){
              
              return e.resultCode || capi.SQLITE_ERROR;
            }
          }
        }
      }),
      "*", "**"
    ]],
    ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
    ["sqlite3_extended_errcode", "int", "sqlite3*"],
    ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
    ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
    ["sqlite3_finalize", "int", "sqlite3_stmt*"],
    ["sqlite3_free", undefined,"*"],
    ["sqlite3_get_autocommit", "int", "sqlite3*"],
    ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
    ["sqlite3_initialize", undefined],
    
    ["sqlite3_keyword_count", "int"],
    ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
    ["sqlite3_keyword_check", "int", ["string", "int"]],
    ["sqlite3_libversion", "string"],
    ["sqlite3_libversion_number", "int"],
    ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
    ["sqlite3_malloc", "*","int"],
    ["sqlite3_open", "int", "string", "*"],
    ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
    
    
    ["sqlite3_progress_handler", undefined, [
      "sqlite3*", "int", new wasm.xWrap.FuncPtrAdapter({
        name: 'xProgressHandler',
        signature: 'i(p)',
        bindScope: 'context',
        contextKey: (argv,argIndex)=>argv[0]
      }), "*"
    ]],
    ["sqlite3_realloc", "*","*","int"],
    ["sqlite3_reset", "int", "sqlite3_stmt*"],
    
    ["sqlite3_result_blob", undefined, "sqlite3_context*", "*", "int", "*"],
    ["sqlite3_result_double", undefined, "sqlite3_context*", "f64"],
    ["sqlite3_result_error", undefined, "sqlite3_context*", "string", "int"],
    ["sqlite3_result_error_code", undefined, "sqlite3_context*", "int"],
    ["sqlite3_result_error_nomem", undefined, "sqlite3_context*"],
    ["sqlite3_result_error_toobig", undefined, "sqlite3_context*"],
    ["sqlite3_result_int", undefined, "sqlite3_context*", "int"],
    ["sqlite3_result_null", undefined, "sqlite3_context*"],
    ["sqlite3_result_pointer", undefined,
     "sqlite3_context*", "*", "string:static", "*"],
    ["sqlite3_result_subtype", undefined, "sqlite3_value*", "int"],
    ["sqlite3_result_text", undefined, "sqlite3_context*", "string", "int", "*"],
    ["sqlite3_result_zeroblob", undefined, "sqlite3_context*", "int"],
    ["sqlite3_rollback_hook", "void*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_rollback_hook',
        signature: 'v(p)',
        contextKey: (argv)=>argv[0]
      }),
      '*'
    ]],
    ["sqlite3_set_authorizer", "int", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: "sqlite3_set_authorizer::xAuth",
        signature: "i(pi"+"ssss)",
        contextKey: (argv, argIndex)=>argv[0],
        callProxy: (callback)=>{
          return (pV, iCode, s0, s1, s2, s3)=>{
            try{
              s0 = s0 && wasm.cstrToJs(s0); s1 = s1 && wasm.cstrToJs(s1);
              s2 = s2 && wasm.cstrToJs(s2); s3 = s3 && wasm.cstrToJs(s3);
              return callback(pV, iCode, s0, s1, s2, s3) || 0;
            }catch(e){
              return e.resultCode || capi.SQLITE_ERROR;
            }
          }
        }
      }),
      "*"
    ]],
    ["sqlite3_set_auxdata", undefined, [
      "sqlite3_context*", "int", "*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'xDestroyAuxData',
        signature: 'v(*)',
        contextKey: (argv, argIndex)=>argv[0]
      })
    ]],
    ["sqlite3_shutdown", undefined],
    ["sqlite3_sourceid", "string"],
    ["sqlite3_sql", "string", "sqlite3_stmt*"],
    ["sqlite3_status", "int", "int", "*", "*", "int"],
    ["sqlite3_step", "int", "sqlite3_stmt*"],
    ["sqlite3_stmt_isexplain", "int", ["sqlite3_stmt*"]],
    ["sqlite3_stmt_readonly", "int", ["sqlite3_stmt*"]],
    ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
    ["sqlite3_strglob", "int", "string","string"],
    ["sqlite3_stricmp", "int", "string", "string"],
    ["sqlite3_strlike", "int", "string", "string","int"],
    ["sqlite3_strnicmp", "int", "string", "string", "int"],
    ["sqlite3_table_column_metadata", "int",
     "sqlite3*", "string", "string", "string",
     "**", "**", "*", "*", "*"],
    ["sqlite3_total_changes", "int", "sqlite3*"],
    ["sqlite3_trace_v2", "int", [
      "sqlite3*", "int",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_trace_v2::callback',
        signature: 'i(ippp)',
        contextKey: (argv,argIndex)=>argv[0]
      }),
      "*"
    ]],
    ["sqlite3_txn_state", "int", ["sqlite3*","string"]],
    
    ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
    ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
    ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
    ["sqlite3_user_data","void*", "sqlite3_context*"],
    ["sqlite3_value_blob", "*", "sqlite3_value*"],
    ["sqlite3_value_bytes","int", "sqlite3_value*"],
    ["sqlite3_value_double","f64", "sqlite3_value*"],
    ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
    ["sqlite3_value_free", undefined, "sqlite3_value*"],
    ["sqlite3_value_frombind", "int", "sqlite3_value*"],
    ["sqlite3_value_int","int", "sqlite3_value*"],
    ["sqlite3_value_nochange", "int", "sqlite3_value*"],
    ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
    ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
    ["sqlite3_value_subtype", "int", "sqlite3_value*"],
    ["sqlite3_value_text", "string", "sqlite3_value*"],
    ["sqlite3_value_type", "int", "sqlite3_value*"],
    ["sqlite3_vfs_find", "*", "string"],
    ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
    ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
  ];

  if(false){}

  if(wasm.exports.sqlite3_activate_see instanceof Function){
    wasm.bindingSignatures.push(
      ["sqlite3_key", "int", "sqlite3*", "string", "int"],
      ["sqlite3_key_v2","int","sqlite3*","string","*","int"],
      ["sqlite3_rekey", "int", "sqlite3*", "string", "int"],
      ["sqlite3_rekey_v2", "int", "sqlite3*", "string", "*", "int"],
      ["sqlite3_activate_see", undefined, "string"]
    );
  }
  
  wasm.bindingSignatures.int64 = [
    ["sqlite3_bind_int64","int", ["sqlite3_stmt*", "int", "i64"]],
    ["sqlite3_changes64","i64", ["sqlite3*"]],
    ["sqlite3_column_int64","i64", ["sqlite3_stmt*", "int"]],
    ["sqlite3_create_module", "int",
     ["sqlite3*","string","sqlite3_module*","*"]],
    ["sqlite3_create_module_v2", "int",
     ["sqlite3*","string","sqlite3_module*","*","*"]],
    ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
    ["sqlite3_deserialize", "int", "sqlite3*", "string", "*", "i64", "i64", "int"]
    ,
    ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
    ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
    ["sqlite3_malloc64", "*","i64"],
    ["sqlite3_msize", "i64", "*"],
    ["sqlite3_overload_function", "int", ["sqlite3*","string","int"]],
    ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
    ["sqlite3_preupdate_count", "int", "sqlite3*"],
    ["sqlite3_preupdate_depth", "int", "sqlite3*"],
    ["sqlite3_preupdate_hook", "*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_preupdate_hook',
        signature: "v(ppippjj)",
        contextKey: (argv)=>argv[0],
        callProxy: (callback)=>{
          return (p,db,op,zDb,zTbl,iKey1,iKey2)=>{
            callback(p, db, op, wasm.cstrToJs(zDb), wasm.cstrToJs(zTbl),
                     iKey1, iKey2);
          };
        }
      }),
      "*"
    ]],
    ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
    ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]],
    ["sqlite3_realloc64", "*","*", "i64"],
    ["sqlite3_result_int64", undefined, "*", "i64"],
    ["sqlite3_result_zeroblob64", "int", "*", "i64"],
    ["sqlite3_serialize","*", "sqlite3*", "string", "*", "int"],
    ["sqlite3_set_last_insert_rowid", undefined, ["sqlite3*", "i64"]],
    ["sqlite3_status64", "int", "int", "*", "*", "int"],
    ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
    ["sqlite3_update_hook", "*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_update_hook',
        signature: "v(iippj)",
        contextKey: (argv)=>argv[0],
        callProxy: (callback)=>{
          return (p,op,z0,z1,rowid)=>{
            callback(p, op, wasm.cstrToJs(z0), wasm.cstrToJs(z1), rowid);
          };
        }
      }),
      "*"
    ]],
    ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
    ["sqlite3_value_int64","i64", "sqlite3_value*"],
    ["sqlite3_vtab_collation","string","sqlite3_index_info*","int"],
    ["sqlite3_vtab_distinct","int", "sqlite3_index_info*"],
    ["sqlite3_vtab_in","int", "sqlite3_index_info*", "int", "int"],
    ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
    ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
    
    ["sqlite3_vtab_nochange","int", "sqlite3_context*"],
    ["sqlite3_vtab_on_conflict","int", "sqlite3*"],
    ["sqlite3_vtab_rhs_value","int", "sqlite3_index_info*", "int", "**"]
  ];

  
  if(wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add){
    
    
    const __ipsProxy = {
      signature: 'i(ps)',
      callProxy:(callback)=>{
        return (p,s)=>{
          try{return callback(p, wasm.cstrToJs(s)) | 0}
          catch(e){return e.resultCode || capi.SQLITE_ERROR}
        }
      }
    };

    wasm.bindingSignatures.int64.push(...[
      ['sqlite3changegroup_add', 'int', ['sqlite3_changegroup*', 'int', 'void*']],
      ['sqlite3changegroup_add_strm', 'int', [
        'sqlite3_changegroup*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changegroup_delete', undefined, ['sqlite3_changegroup*']],
      ['sqlite3changegroup_new', 'int', ['**']],
      ['sqlite3changegroup_output', 'int', ['sqlite3_changegroup*', 'int*', '**']],
      ['sqlite3changegroup_output_strm', 'int', [
        'sqlite3_changegroup*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply', 'int', [
        'sqlite3*', 'int', 'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply_strm', 'int', [
        'sqlite3*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply_v2', 'int', [
        'sqlite3*', 'int', 'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*', '**', 'int*', 'int'

      ]],
      ['sqlite3changeset_apply_v2_strm', 'int', [
        'sqlite3*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*', '**', 'int*', 'int'
      ]],
      ['sqlite3changeset_concat', 'int', ['int','void*', 'int', 'void*', 'int*', '**']],
      ['sqlite3changeset_concat_strm', 'int', [
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInputA', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInputB', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_conflict', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],
      ['sqlite3changeset_fk_conflicts', 'int', ['sqlite3_changeset_iter*', 'int*']],
      ['sqlite3changeset_invert', 'int', ['int', 'void*', 'int*', '**']],
      ['sqlite3changeset_invert_strm', 'int', [
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_new', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],
      ['sqlite3changeset_old', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_op', 'int', [
        'sqlite3_changeset_iter*', '**', 'int*', 'int*','int*'
      ]],
      ['sqlite3changeset_pk', 'int', ['sqlite3_changeset_iter*', '**', 'int*']],
      ['sqlite3changeset_start', 'int', ['**', 'int', '*']],
      ['sqlite3changeset_start_strm', 'int', [
        '**',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],
      ['sqlite3changeset_start_v2_strm', 'int', [
        '**',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*', 'int'
      ]],
      ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],
      ['sqlite3session_changeset', 'int', ['sqlite3_session*', 'int*', '**']],
      ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],
      ['sqlite3session_changeset_strm', 'int', [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3session_config', 'int', ['int', 'void*']],
      ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],
      
      ['sqlite3session_diff', 'int', ['sqlite3_session*', 'string', 'string', '**']],
      ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],
      ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],
      ['sqlite3session_isempty', 'int', ['sqlite3_session*']],
      ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],
      ['sqlite3session_object_config', 'int', ['sqlite3_session*', 'int', 'void*']],
      ['sqlite3session_patchset', 'int', ['sqlite3_session*', '*', '**']],
      ['sqlite3session_patchset_strm', 'int', [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3session_table_filter', undefined, [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', ...__ipsProxy,
          contextKey: (argv,argIndex)=>argv[0]
        }),
        '*'
      ]]
    ]);
  }

  
  wasm.bindingSignatures.wasm = [
    ["sqlite3_wasm_db_reset", "int", "sqlite3*"],
    ["sqlite3_wasm_db_vfs", "sqlite3_vfs*", "sqlite3*","string"],
    ["sqlite3_wasm_vfs_create_file", "int",
     "sqlite3_vfs*","string","*", "int"],
    ["sqlite3_wasm_posix_create_file", "int", "string","*", "int"],
    ["sqlite3_wasm_vfs_unlink", "int", "sqlite3_vfs*","string"]
  ];

  
  sqlite3.StructBinder = globalThis.Jaccwabyt({
    heap:  false ? 0 : wasm.heap8u,
    alloc: wasm.alloc,
    dealloc: wasm.dealloc,
    bigIntEnabled: wasm.bigIntEnabled,
    memberPrefix:  '$'
  });
  delete globalThis.Jaccwabyt;

  {

    
    const __xString = wasm.xWrap.argAdapter('string');
    wasm.xWrap.argAdapter(
      'string:flexible', (v)=>__xString(util.flexibleString(v))
    );

    
    wasm.xWrap.argAdapter(
      'string:static',
      function(v){
        if(wasm.isPtr(v)) return v;
        v = ''+v;
        let rc = this[v];
        return rc || (this[v] = wasm.allocCString(v));
      }.bind(Object.create(null))
    );

    
    const __xArgPtr = wasm.xWrap.argAdapter('*');
    const nilType = function(){};
    wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)
    ('sqlite3_context*', __xArgPtr)
    ('sqlite3_value*', __xArgPtr)
    ('void*', __xArgPtr)
    ('sqlite3_changegroup*', __xArgPtr)
    ('sqlite3_changeset_iter*', __xArgPtr)
    
    ('sqlite3_session*', __xArgPtr)
    ('sqlite3_stmt*', (v)=>
      __xArgPtr((v instanceof (sqlite3?.oo1?.Stmt || nilType))
           ? v.pointer : v))
    ('sqlite3*', (v)=>
      __xArgPtr((v instanceof (sqlite3?.oo1?.DB || nilType))
           ? v.pointer : v))
    ('sqlite3_index_info*', (v)=>
      __xArgPtr((v instanceof (capi.sqlite3_index_info || nilType))
           ? v.pointer : v))
    ('sqlite3_module*', (v)=>
      __xArgPtr((v instanceof (capi.sqlite3_module || nilType))
           ? v.pointer : v))
    
    ('sqlite3_vfs*', (v)=>{
      if('string'===typeof v){
        
        return capi.sqlite3_vfs_find(v)
          || sqlite3.SQLite3Error.toss(
            capi.SQLITE_NOTFOUND,
            "Unknown sqlite3_vfs name:", v
          );
      }
      return __xArgPtr((v instanceof (capi.sqlite3_vfs || nilType))
                       ? v.pointer : v);
    });

    const __xRcPtr = wasm.xWrap.resultAdapter('*');
    wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)
    ('sqlite3_context*', __xRcPtr)
    ('sqlite3_stmt*', __xRcPtr)
    ('sqlite3_value*', __xRcPtr)
    ('sqlite3_vfs*', __xRcPtr)
    ('void*', __xRcPtr);

    
    if(0 === wasm.exports.sqlite3_step.length){
      
      wasm.xWrap.doArgcCheck = false;
      sqlite3.config.warn(
        "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
      );
    }
    for(const e of wasm.bindingSignatures){
      capi[e[0]] = wasm.xWrap.apply(null, e);
    }
    for(const e of wasm.bindingSignatures.wasm){
      wasm[e[0]] = wasm.xWrap.apply(null, e);
    }

    
    const fI64Disabled = function(fname){
      return ()=>toss(fname+"() is unavailable due to lack",
                      "of BigInt support in this build.");
    };
    for(const e of wasm.bindingSignatures.int64){
      capi[e[0]] = wasm.bigIntEnabled
        ? wasm.xWrap.apply(null, e)
        : fI64Disabled(e[0]);
    }

    
    delete wasm.bindingSignatures;

    if(wasm.exports.sqlite3_wasm_db_error){
      const __db_err = wasm.xWrap(
        'sqlite3_wasm_db_error', 'int', 'sqlite3*', 'int', 'string'
      );
      
      util.sqlite3_wasm_db_error = function(pDb, resultCode, message){
        if(resultCode instanceof sqlite3.WasmAllocError){
          resultCode = capi.SQLITE_NOMEM;
          message = 0 ;
        }else if(resultCode instanceof Error){
          message = message || ''+resultCode;
          resultCode = (resultCode.resultCode || capi.SQLITE_ERROR);
        }
        return pDb ? __db_err(pDb, resultCode, message) : resultCode;
      };
    }else{
      util.sqlite3_wasm_db_error = function(pDb,errCode,msg){
        console.warn("sqlite3_wasm_db_error() is not exported.",arguments);
        return errCode;
      };
    }
  }

  {
    const cJson = wasm.xCall('sqlite3_wasm_enum_json');
    if(!cJson){
      toss("Maintenance required: increase sqlite3_wasm_enum_json()'s",
           "static buffer size!");
    }
    
    wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));
    
    const defineGroups = ['access', 'authorizer',
                          'blobFinalizers', 'changeset',
                          'config', 'dataTypes',
                          'dbConfig', 'dbStatus',
                          'encodings', 'fcntl', 'flock', 'ioCap',
                          'limits', 'openFlags',
                          'prepareFlags', 'resultCodes',
                          'sqlite3Status',
                          'stmtStatus', 'syncFlags',
                          'trace', 'txnState', 'udfFlags',
                          'version' ];
    if(wasm.bigIntEnabled){
      defineGroups.push('serialize', 'session', 'vtab');
    }
    for(const t of defineGroups){
      for(const e of Object.entries(wasm.ctype[t])){
        
        
        capi[e[0]] = e[1];
      }
    }
    if(!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)){
      toss("Internal error: cannot resolve exported function",
           "entry SQLITE_WASM_DEALLOC (=="+capi.SQLITE_WASM_DEALLOC+").");
    }
    const __rcMap = Object.create(null);
    for(const t of ['resultCodes']){
      for(const e of Object.entries(wasm.ctype[t])){
        __rcMap[e[1]] = e[0];
      }
    }
    
    capi.sqlite3_js_rc_str = (rc)=>__rcMap[rc];
    
    const notThese = Object.assign(Object.create(null),{
      
      WasmTestStruct: true,
      
      sqlite3_kvvfs_methods: !util.isUIThread(),
      
      sqlite3_index_info: !wasm.bigIntEnabled,
      sqlite3_index_constraint: !wasm.bigIntEnabled,
      sqlite3_index_orderby: !wasm.bigIntEnabled,
      sqlite3_index_constraint_usage: !wasm.bigIntEnabled
    });
    for(const s of wasm.ctype.structs){
      if(!notThese[s.name]){
        capi[s.name] = sqlite3.StructBinder(s);
      }
    }
    if(capi.sqlite3_index_info){
      
      for(const k of ['sqlite3_index_constraint',
                      'sqlite3_index_orderby',
                      'sqlite3_index_constraint_usage']){
        capi.sqlite3_index_info[k] = capi[k];
        delete capi[k];
      }
      capi.sqlite3_vtab_config = wasm.xWrap(
        'sqlite3_wasm_vtab_config','int',[
          'sqlite3*', 'int', 'int']
      );
    }
  }

  
  const __dbArgcMismatch = (pDb,f,n)=>{
    return util.sqlite3_wasm_db_error(pDb, capi.SQLITE_MISUSE,
                                      f+"() requires "+n+" argument"+
                                      (1===n?"":'s')+".");
  };

  
  const __errEncoding = (pDb)=>{
    return util.sqlite3_wasm_db_error(
      pDb, capi.SQLITE_FORMAT, "SQLITE_UTF8 is the only supported encoding."
    );
  };

  
  const __argPDb = (pDb)=>wasm.xWrap.argAdapter('sqlite3*')(pDb);
  const __argStr = (str)=>wasm.isPtr(str) ? wasm.cstrToJs(str) : str;
  const __dbCleanupMap = function(
    pDb, mode
  ){
    pDb = __argPDb(pDb);
    let m = this.dbMap.get(pDb);
    if(!mode){
      this.dbMap.delete(pDb);
      return m;
    }else if(!m && mode>0){
      this.dbMap.set(pDb, (m = Object.create(null)));
    }
    return m;
  }.bind(Object.assign(Object.create(null),{
    dbMap: new Map
  }));

  __dbCleanupMap.addCollation = function(pDb, name){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.collation) m.collation = new Set;
    m.collation.add(__argStr(name).toLowerCase());
  };

  __dbCleanupMap._addUDF = function(pDb, name, arity, map){
    
    name = __argStr(name).toLowerCase();
    let u = map.get(name);
    if(!u) map.set(name, (u = new Set));
    u.add((arity<0) ? -1 : arity);
  };

  __dbCleanupMap.addFunction = function(pDb, name, arity){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.udf) m.udf = new Map;
    this._addUDF(pDb, name, arity, m.udf);
  };

  __dbCleanupMap.addWindowFunc = function(pDb, name, arity){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.wudf) m.wudf = new Map;
    this._addUDF(pDb, name, arity, m.wudf);
  };

  
  __dbCleanupMap.cleanup = function(pDb){
    pDb = __argPDb(pDb);
    
    
    const closeArgs = [pDb];
    for(const name of [
      'sqlite3_busy_handler',
      'sqlite3_commit_hook',
      'sqlite3_preupdate_hook',
      'sqlite3_progress_handler',
      'sqlite3_rollback_hook',
      'sqlite3_set_authorizer',
      'sqlite3_trace_v2',
      'sqlite3_update_hook'
    ]) {
      const x = wasm.exports[name];
      closeArgs.length = x.length
      ;
      try{ capi[name](...closeArgs) }
      catch(e){
        console.warn("close-time call of",name+"(",closeArgs,") threw:",e);
      }
    }
    const m = __dbCleanupMap(pDb, 0);
    if(!m) return;
    if(m.collation){
      for(const name of m.collation){
        try{
          capi.sqlite3_create_collation_v2(
            pDb, name, capi.SQLITE_UTF8, 0, 0, 0
          );
        }catch(e){
          
        }
      }
      delete m.collation;
    }
    let i;
    for(i = 0; i < 2; ++i){ 
      const fmap = i ? m.wudf : m.udf;
      if(!fmap) continue;
      const func = i
            ? capi.sqlite3_create_window_function
            : capi.sqlite3_create_function_v2;
      for(const e of fmap){
        const name = e[0], arities = e[1];
        const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
        if(i) fargs.push(0);
        for(const arity of arities){
          try{ fargs[2] = arity; func.apply(null, fargs); }
          catch(e){}
        }
        arities.clear();
      }
      fmap.clear();
    }
    delete m.udf;
    delete m.wudf;
  };

  {
    const __sqlite3CloseV2 = wasm.xWrap("sqlite3_close_v2", "int", "sqlite3*");
    capi.sqlite3_close_v2 = function(pDb){
      if(1!==arguments.length) return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);
      if(pDb){
        try{__dbCleanupMap.cleanup(pDb)} catch(e){}
      }
      return __sqlite3CloseV2(pDb);
    };
  }

  if(capi.sqlite3session_table_filter){
    const __sqlite3SessionDelete = wasm.xWrap(
      'sqlite3session_delete', undefined, ['sqlite3_session*']
    );
    capi.sqlite3session_delete = function(pSession){
      if(1!==arguments.length){
        return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);
        
      }
      else if(pSession){
        
        capi.sqlite3session_table_filter(pSession, 0, 0);
      }
      __sqlite3SessionDelete(pSession);
    };
  }

  {
    
    const contextKey = (argv,argIndex)=>{
      return 'argv['+argIndex+']:'+argv[0]+
        ':'+wasm.cstrToJs(argv[1]).toLowerCase()
    };
    const __sqlite3CreateCollationV2 = wasm.xWrap(
      'sqlite3_create_collation_v2', 'int', [
        'sqlite3*', 'string', 'int', '*',
        new wasm.xWrap.FuncPtrAdapter({
          
          name: 'xCompare', signature: 'i(pipip)', contextKey
        }),
        new wasm.xWrap.FuncPtrAdapter({
          
          name: 'xDestroy', signature: 'v(p)', contextKey
        })
      ]
    );

    
    capi.sqlite3_create_collation_v2 = function(pDb,zName,eTextRep,pArg,xCompare,xDestroy){
      if(6!==arguments.length) return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);
      else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateCollationV2(pDb, zName, eTextRep, pArg, xCompare, xDestroy);
        if(0===rc && xCompare instanceof Function){
          __dbCleanupMap.addCollation(pDb, zName);
        }
        return rc;
      }catch(e){
        return util.sqlite3_wasm_db_error(pDb, e);
      }
    };

    capi.sqlite3_create_collation = (pDb,zName,eTextRep,pArg,xCompare)=>{
      return (5===arguments.length)
        ? capi.sqlite3_create_collation_v2(pDb,zName,eTextRep,pArg,xCompare,0)
        : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);
    };

  }

  {
    
    const contextKey = function(argv,argIndex){
      return (
        argv[0]
          +':'+(argv[2] < 0 ? -1 : argv[2])
          +':'+argIndex
          +':'+wasm.cstrToJs(argv[1]).toLowerCase()
      )
    };

    
    const __cfProxy = Object.assign(Object.create(null), {
      xInverseAndStep: {
        signature:'v(pip)', contextKey,
        callProxy: (callback)=>{
          return (pCtx, argc, pArgv)=>{
            try{ callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)) }
            catch(e){ capi.sqlite3_result_error_js(pCtx, e) }
          };
        }
      },
      xFinalAndValue: {
        signature:'v(p)', contextKey,
        callProxy: (callback)=>{
          return (pCtx)=>{
            try{ capi.sqlite3_result_js(pCtx, callback(pCtx)) }
            catch(e){ capi.sqlite3_result_error_js(pCtx, e) }
          };
        }
      },
      xFunc: {
        signature:'v(pip)', contextKey,
        callProxy: (callback)=>{
          return (pCtx, argc, pArgv)=>{
            try{
              capi.sqlite3_result_js(
                pCtx,
                callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
              );
            }catch(e){
              
              capi.sqlite3_result_error_js(pCtx, e);
            }
          };
        }
      },
      xDestroy: {
        signature:'v(p)', contextKey,
        
        callProxy: (callback)=>{
          return (pVoid)=>{
            try{ callback(pVoid) }
            catch(e){ console.error("UDF xDestroy method threw:",e) }
          };
        }
      }
    });

    const __sqlite3CreateFunction = wasm.xWrap(
      "sqlite3_create_function_v2", "int", [
        "sqlite3*", "string", "int",
        "int", "*",
        new wasm.xWrap.FuncPtrAdapter({name: 'xFunc', ...__cfProxy.xFunc}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xStep', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xFinal', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xDestroy', ...__cfProxy.xDestroy})
      ]
    );

    const __sqlite3CreateWindowFunction = wasm.xWrap(
      "sqlite3_create_window_function", "int", [
        "sqlite3*", "string", "int",
        "int", "*",
        new wasm.xWrap.FuncPtrAdapter({name: 'xStep', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xFinal', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xValue', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xInverse', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xDestroy', ...__cfProxy.xDestroy})
      ]
    );

    
    capi.sqlite3_create_function_v2 = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc,   
      xStep,   
      xFinal,  
      xDestroy 
    ){
      if( f.length!==arguments.length ){
        return __dbArgcMismatch(pDb,"sqlite3_create_function_v2",f.length);
      }else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateFunction(pDb, funcName, nArg, eTextRep,
                                           pApp, xFunc, xStep, xFinal, xDestroy);
        if(0===rc && (xFunc instanceof Function
                      || xStep instanceof Function
                      || xFinal instanceof Function
                      || xDestroy instanceof Function)){
          __dbCleanupMap.addFunction(pDb, funcName, nArg);
        }
        return rc;
      }catch(e){
        console.error("sqlite3_create_function_v2() setup threw:",e);
        return util.sqlite3_wasm_db_error(pDb, e, "Creation of UDF threw: "+e);
      }
    };

    
    capi.sqlite3_create_function = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal
    ){
      return (f.length===arguments.length)
        ? capi.sqlite3_create_function_v2(pDb, funcName, nArg, eTextRep,
                                          pApp, xFunc, xStep, xFinal, 0)
        : __dbArgcMismatch(pDb,"sqlite3_create_function",f.length);
    };

    
    capi.sqlite3_create_window_function = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xStep,   
      xFinal,  
      xValue,  
      xInverse,
      xDestroy 
    ){
      if( f.length!==arguments.length ){
        return __dbArgcMismatch(pDb,"sqlite3_create_window_function",f.length);
      }else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateWindowFunction(pDb, funcName, nArg, eTextRep,
                                                 pApp, xStep, xFinal, xValue,
                                                 xInverse, xDestroy);
        if(0===rc && (xStep instanceof Function
                      || xFinal instanceof Function
                      || xValue instanceof Function
                      || xInverse instanceof Function
                      || xDestroy instanceof Function)){
          __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);
        }
        return rc;
      }catch(e){
        console.error("sqlite3_create_window_function() setup threw:",e);
        return util.sqlite3_wasm_db_error(pDb, e, "Creation of UDF threw: "+e);
      }
    };
    
    capi.sqlite3_create_function_v2.udfSetResult =
      capi.sqlite3_create_function.udfSetResult =
      capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;

    
    capi.sqlite3_create_function_v2.udfConvertArgs =
      capi.sqlite3_create_function.udfConvertArgs =
      capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;

    
    capi.sqlite3_create_function_v2.udfSetError =
      capi.sqlite3_create_function.udfSetError =
      capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;

  };

  {

    
    const __flexiString = (v,n)=>{
      if('string'===typeof v){
        n = -1;
      }else if(util.isSQLableTypedArray(v)){
        n = v.byteLength;
        v = util.typedArrayToString(
          (v instanceof ArrayBuffer) ? new Uint8Array(v) : v
        );
      }else if(Array.isArray(v)){
        v = v.join("");
        n = -1;
      }
      return [v, n];
    };

    
    const __prepare = {
      
      basic: wasm.xWrap('sqlite3_prepare_v3',
                        "int", ["sqlite3*", "string",
                                "int",
                                "int", "**",
                                "**"]),
      
      full: wasm.xWrap('sqlite3_prepare_v3',
                       "int", ["sqlite3*", "*", "int", "int",
                               "**", "**"])
    };

    
    capi.sqlite3_prepare_v3 = function f(pDb, sql, sqlLen, prepFlags, ppStmt, pzTail){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(pDb,"sqlite3_prepare_v3",f.length);
      }
      const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
      switch(typeof xSql){
          case 'string': return __prepare.basic(pDb, xSql, xSqlLen, prepFlags, ppStmt, null);
          case 'number': return __prepare.full(pDb, xSql, xSqlLen, prepFlags, ppStmt, pzTail);
          default:
            return util.sqlite3_wasm_db_error(
              pDb, capi.SQLITE_MISUSE,
              "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
            );
      }
    };

    
    capi.sqlite3_prepare_v2 = function f(pDb, sql, sqlLen, ppStmt, pzTail){
      return (f.length===arguments.length)
        ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)
        : __dbArgcMismatch(pDb,"sqlite3_prepare_v2",f.length);
    };

  }

  {
    const __bindText = wasm.xWrap("sqlite3_bind_text", "int", [
      "sqlite3_stmt*", "int", "string", "int", "*"
    ]);
    const __bindBlob = wasm.xWrap("sqlite3_bind_blob", "int", [
      "sqlite3_stmt*", "int", "*", "int", "*"
    ]);

    
    capi.sqlite3_bind_text = function f(pStmt, iCol, text, nText, xDestroy){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(capi.sqlite3_db_handle(pStmt),
                                "sqlite3_bind_text", f.length);
      }else if(wasm.isPtr(text) || null===text){
        return __bindText(pStmt, iCol, text, nText, xDestroy);
      }else if(text instanceof ArrayBuffer){
        text = new Uint8Array(text);
      }else if(Array.isArray(pMem)){
        text = pMem.join('');
      }
      let p, n;
      try{
        if(util.isSQLableTypedArray(text)){
          p = wasm.allocFromTypedArray(text);
          n = text.byteLength;
        }else if('string'===typeof text){
          [p, n] = wasm.allocCString(text);
        }else{
          return util.sqlite3_wasm_db_error(
            capi.sqlite3_db_handle(pStmt), capi.SQLITE_MISUSE,
            "Invalid 3rd argument type for sqlite3_bind_text()."
          );
        }
        return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
      }catch(e){
        wasm.dealloc(p);
        return util.sqlite3_wasm_db_error(
          capi.sqlite3_db_handle(pStmt), e
        );
      }
    };

    
    capi.sqlite3_bind_blob = function f(pStmt, iCol, pMem, nMem, xDestroy){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(capi.sqlite3_db_handle(pStmt),
                                "sqlite3_bind_blob", f.length);
      }else if(wasm.isPtr(pMem) || null===pMem){
        return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);
      }else if(pMem instanceof ArrayBuffer){
        pMem = new Uint8Array(pMem);
      }else if(Array.isArray(pMem)){
        pMem = pMem.join('');
      }
      let p, n;
      try{
        if(util.isBindableTypedArray(pMem)){
          p = wasm.allocFromTypedArray(pMem);
          n = nMem>=0 ? nMem : pMem.byteLength;
        }else if('string'===typeof pMem){
          [p, n] = wasm.allocCString(pMem);
        }else{
          return util.sqlite3_wasm_db_error(
            capi.sqlite3_db_handle(pStmt), capi.SQLITE_MISUSE,
            "Invalid 3rd argument type for sqlite3_bind_blob()."
          );
        }
        return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
      }catch(e){
        wasm.dealloc(p);
        return util.sqlite3_wasm_db_error(
          capi.sqlite3_db_handle(pStmt), e
        );
      }
    };

  }

  {
    
    capi.sqlite3_config = function(op, ...args){
      if(arguments.length<2) return capi.SQLITE_MISUSE;
      switch(op){
          case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN: 
          case capi.SQLITE_CONFIG_MEMSTATUS:
          case capi.SQLITE_CONFIG_SMALL_MALLOC: 
          case capi.SQLITE_CONFIG_SORTERREF_SIZE: 
          case capi.SQLITE_CONFIG_STMTJRNL_SPILL: 
          case capi.SQLITE_CONFIG_URI:
            return wasm.exports.sqlite3_wasm_config_i(op, args[0]);
          case capi.SQLITE_CONFIG_LOOKASIDE: 
            return wasm.exports.sqlite3_wasm_config_ii(op, args[0], args[1]);
          case capi.SQLITE_CONFIG_MEMDB_MAXSIZE: 
            return wasm.exports.sqlite3_wasm_config_j(op, args[0]);
          case capi.SQLITE_CONFIG_GETMALLOC: 
          case capi.SQLITE_CONFIG_GETMUTEX: 
          case capi.SQLITE_CONFIG_GETPCACHE2: 
          case capi.SQLITE_CONFIG_GETPCACHE: 
          case capi.SQLITE_CONFIG_HEAP: 
          case capi.SQLITE_CONFIG_LOG: 
          case capi.SQLITE_CONFIG_MALLOC:
          case capi.SQLITE_CONFIG_MMAP_SIZE: 
          case capi.SQLITE_CONFIG_MULTITHREAD: 
          case capi.SQLITE_CONFIG_MUTEX: 
          case capi.SQLITE_CONFIG_PAGECACHE: 
          case capi.SQLITE_CONFIG_PCACHE2: 
          case capi.SQLITE_CONFIG_PCACHE: 
          case capi.SQLITE_CONFIG_PCACHE_HDRSZ: 
          case capi.SQLITE_CONFIG_PMASZ: 
          case capi.SQLITE_CONFIG_SERIALIZED: 
          case capi.SQLITE_CONFIG_SINGLETHREAD: 
          case capi.SQLITE_CONFIG_SQLLOG: 
          case capi.SQLITE_CONFIG_WIN32_HEAPSIZE: 
          default:
            return capi.SQLITE_NOTFOUND;
      }
    };
  }

  {
    const __autoExtFptr = new Set;

    capi.sqlite3_auto_extension = function(fPtr){
      if( fPtr instanceof Function ){
        fPtr = wasm.installFunction('i(ppp)', fPtr);
      }else if( 1!==arguments.length || !wasm.isPtr(fPtr) ){
        return capi.SQLITE_MISUSE;
      }
      const rc = wasm.exports.sqlite3_auto_extension(fPtr);
      if( fPtr!==arguments[0] ){
        if(0===rc) __autoExtFptr.add(fPtr);
        else wasm.uninstallFunction(fPtr);
      }
      return rc;
    };

    capi.sqlite3_cancel_auto_extension = function(fPtr){
     ;
      if(!fPtr || 1!==arguments.length || !wasm.isPtr(fPtr)) return 0;
      return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
      
    };

    capi.sqlite3_reset_auto_extension = function(){
      wasm.exports.sqlite3_reset_auto_extension();
      for(const fp of __autoExtFptr) wasm.uninstallFunction(fp);
      __autoExtFptr.clear();
    };
  }

  const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
  if( pKvvfs ){
    if(util.isUIThread()){
      const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
        wasm.exports.sqlite3_wasm_kvvfs_methods()
      );
      delete capi.sqlite3_kvvfs_methods;

      const kvvfsMakeKey = wasm.exports.sqlite3_wasm_kvvfsMakeKeyOnPstack,
            pstack = wasm.pstack;

      const kvvfsStorage = (zClass)=>
            ((115===wasm.peek(zClass))
             ? sessionStorage : localStorage);

      
      const kvvfsImpls = {
        xRead: (zClass, zKey, zBuf, nBuf)=>{
          const stack = pstack.pointer,
                astack = wasm.scopedAllocPush();
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return -3;
            const jKey = wasm.cstrToJs(zXKey);
            const jV = kvvfsStorage(zClass).getItem(jKey);
            if(!jV) return -1;
            const nV = jV.length ;
            if(nBuf<=0) return nV;
            else if(1===nBuf){
              wasm.poke(zBuf, 0);
              return nV;
            }
            const zV = wasm.scopedAllocCString(jV);
            if(nBuf > nV + 1) nBuf = nV + 1;
            wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
            wasm.poke(zBuf + nBuf - 1, 0);
            return nBuf - 1;
          }catch(e){
            console.error("kvstorageRead()",e);
            return -2;
          }finally{
            pstack.restore(stack);
            wasm.scopedAllocPop(astack);
          }
        },
        xWrite: (zClass, zKey, zData)=>{
          const stack = pstack.pointer;
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return 1;
            const jKey = wasm.cstrToJs(zXKey);
            kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
            return 0;
          }catch(e){
            console.error("kvstorageWrite()",e);
            return capi.SQLITE_IOERR;
          }finally{
            pstack.restore(stack);
          }
        },
        xDelete: (zClass, zKey)=>{
          const stack = pstack.pointer;
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return 1;
            kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
            return 0;
          }catch(e){
            console.error("kvstorageDelete()",e);
            return capi.SQLITE_IOERR;
          }finally{
            pstack.restore(stack);
          }
        }
      };
      for(const k of Object.keys(kvvfsImpls)){
        kvvfsMethods[kvvfsMethods.memberKey(k)] =
          wasm.installFunction(
            kvvfsMethods.memberSignature(k),
            kvvfsImpls[k]
          );
      }
    }else{
      
      capi.sqlite3_vfs_unregister(pKvvfs);
    }
  }

  wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
});


globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  sqlite3.version = {"libVersion": "3.45.2", "libVersionNumber": 3045002, "sourceId": "2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77","downloadVersion": 3450200};
});



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  const toss = (...args)=>{throw new Error(args.join(' '))};
  const toss3 = (...args)=>{throw new sqlite3.SQLite3Error(...args)};

  const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
  

  
  const __ptrMap = new WeakMap();
  
  const __stmtMap = new WeakMap();

  
  const getOwnOption = (opts, p, dflt)=>{
    const d = Object.getOwnPropertyDescriptor(opts,p);
    return d ? d.value : dflt;
  };

  
  const checkSqlite3Rc = function(dbPtr, sqliteResultCode){
    if(sqliteResultCode){
      if(dbPtr instanceof DB) dbPtr = dbPtr.pointer;
      toss3(
        sqliteResultCode,
        "sqlite3 result code",sqliteResultCode+":",
        (dbPtr
         ? capi.sqlite3_errmsg(dbPtr)
         : capi.sqlite3_errstr(sqliteResultCode))
      );
    }
    return arguments[0];
  };

  
  const __dbTraceToConsole =
        wasm.installFunction('i(ippp)', function(t,c,p,x){
          if(capi.SQLITE_TRACE_STMT===t){
            
            console.log("SQL TRACE #"+(++this.counter)+' via sqlite3@'+c+':',
                        wasm.cstrToJs(x));
          }
        }.bind({counter: 0}));

  
  const __vfsPostOpenSql = Object.create(null);

  
  const dbCtorHelper = function ctor(...args){
    if(!ctor._name2vfs){
      
      ctor._name2vfs = Object.create(null);
      const isWorkerThread = ('function'===typeof importScripts)
            ? (n)=>toss3("The VFS for",n,"is only available in the main window thread.")
            : false;
      ctor._name2vfs[':localStorage:'] = {
        vfs: 'kvvfs', filename: isWorkerThread || (()=>'local')
      };
      ctor._name2vfs[':sessionStorage:'] = {
        vfs: 'kvvfs', filename: isWorkerThread || (()=>'session')
      };
    }
    const opt = ctor.normalizeArgs(...args);
    let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
    if(('string'!==typeof fn && 'number'!==typeof fn)
       || 'string'!==typeof flagsStr
       || (vfsName && ('string'!==typeof vfsName && 'number'!==typeof vfsName))){
      sqlite3.config.error("Invalid DB ctor args",opt,arguments);
      toss3("Invalid arguments for DB constructor.");
    }
    let fnJs = ('number'===typeof fn) ? wasm.cstrToJs(fn) : fn;
    const vfsCheck = ctor._name2vfs[fnJs];
    if(vfsCheck){
      vfsName = vfsCheck.vfs;
      fn = fnJs = vfsCheck.filename(fnJs);
    }
    let pDb, oflags = 0;
    if( flagsStr.indexOf('c')>=0 ){
      oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
    }
    if( flagsStr.indexOf('w')>=0 ) oflags |= capi.SQLITE_OPEN_READWRITE;
    if( 0===oflags ) oflags |= capi.SQLITE_OPEN_READONLY;
    oflags |= capi.SQLITE_OPEN_EXRESCODE;
    const stack = wasm.pstack.pointer;
    try {
      const pPtr = wasm.pstack.allocPtr() ;
      let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
      pDb = wasm.peekPtr(pPtr);
      checkSqlite3Rc(pDb, rc);
      capi.sqlite3_extended_result_codes(pDb, 1);
      if(flagsStr.indexOf('t')>=0){
        capi.sqlite3_trace_v2(pDb, capi.SQLITE_TRACE_STMT,
                              __dbTraceToConsole, pDb);
      }
    }catch( e ){
      if( pDb ) capi.sqlite3_close_v2(pDb);
      throw e;
    }finally{
      wasm.pstack.restore(stack);
    }
    this.filename = fnJs;
    __ptrMap.set(this, pDb);
    __stmtMap.set(this, Object.create(null));
    try{
      
      const pVfs = capi.sqlite3_js_db_vfs(pDb);
      if(!pVfs) toss3("Internal error: cannot get VFS for new db handle.");
      const postInitSql = __vfsPostOpenSql[pVfs];
      if(postInitSql instanceof Function){
        postInitSql(this, sqlite3);
      }else if(postInitSql){
        checkSqlite3Rc(
          pDb, capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0)
        );
      }
    }catch(e){
      this.close();
      throw e;
    }
  };

  
  dbCtorHelper.setVfsPostOpenSql = function(pVfs, sql){
    __vfsPostOpenSql[pVfs] = sql;
  };

  
  dbCtorHelper.normalizeArgs = function(filename=':memory:',flags = 'c',vfs = null){
    const arg = {};
    if(1===arguments.length && arguments[0] && 'object'===typeof arguments[0]){
      Object.assign(arg, arguments[0]);
      if(undefined===arg.flags) arg.flags = 'c';
      if(undefined===arg.vfs) arg.vfs = null;
      if(undefined===arg.filename) arg.filename = ':memory:';
    }else{
      arg.filename = filename;
      arg.flags = flags;
      arg.vfs = vfs;
    }
    return arg;
  };
  
  const DB = function(...args){
    dbCtorHelper.apply(this, args);
  };
  DB.dbCtorHelper = dbCtorHelper;

  
  const BindTypes = {
    null: 1,
    number: 2,
    string: 3,
    boolean: 4,
    blob: 5
  };
  BindTypes['undefined'] == BindTypes.null;
  if(wasm.bigIntEnabled){
    BindTypes.bigint = BindTypes.number;
  }

  
  const Stmt = function(){
    if(BindTypes!==arguments[2]){
      toss3(capi.SQLITE_MISUSE, "Do not call the Stmt constructor directly. Use DB.prepare().");
    }
    this.db = arguments[0];
    __ptrMap.set(this, arguments[1]);
    this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
  };

  
  const affirmDbOpen = function(db){
    if(!db.pointer) toss3("DB has been closed.");
    return db;
  };

  
  const affirmColIndex = function(stmt,ndx){
    if((ndx !== (ndx|0)) || ndx<0 || ndx>=stmt.columnCount){
      toss3("Column index",ndx,"is out of range.");
    }
    return stmt;
  };

  
  const parseExecArgs = function(db, args){
    const out = Object.create(null);
    out.opt = Object.create(null);
    switch(args.length){
        case 1:
          if('string'===typeof args[0] || util.isSQLableTypedArray(args[0])){
            out.sql = args[0];
          }else if(Array.isArray(args[0])){
            out.sql = args[0];
          }else if(args[0] && 'object'===typeof args[0]){
            out.opt = args[0];
            out.sql = out.opt.sql;
          }
          break;
        case 2:
          out.sql = args[0];
          out.opt = args[1];
          break;
        default: toss3("Invalid argument count for exec().");
    };
    out.sql = util.flexibleString(out.sql);
    if('string'!==typeof out.sql){
      toss3("Missing SQL argument or unsupported SQL value type.");
    }
    const opt = out.opt;
    switch(opt.returnValue){
        case 'resultRows':
          if(!opt.resultRows) opt.resultRows = [];
          out.returnVal = ()=>opt.resultRows;
          break;
        case 'saveSql':
          if(!opt.saveSql) opt.saveSql = [];
          out.returnVal = ()=>opt.saveSql;
          break;
        case undefined:
        case 'this':
          out.returnVal = ()=>db;
          break;
        default:
          toss3("Invalid returnValue value:",opt.returnValue);
    }
    if(!opt.callback && !opt.returnValue && undefined!==opt.rowMode){
      if(!opt.resultRows) opt.resultRows = [];
      out.returnVal = ()=>opt.resultRows;
    }
    if(opt.callback || opt.resultRows){
      switch((undefined===opt.rowMode)
             ? 'array' : opt.rowMode) {
          case 'object': out.cbArg = (stmt)=>stmt.get(Object.create(null)); break;
          case 'array': out.cbArg = (stmt)=>stmt.get([]); break;
          case 'stmt':
            if(Array.isArray(opt.resultRows)){
              toss3("exec(): invalid rowMode for a resultRows array: must",
                    "be one of 'array', 'object',",
                    "a result column number, or column name reference.");
            }
            out.cbArg = (stmt)=>stmt;
            break;
          default:
            if(util.isInt32(opt.rowMode)){
              out.cbArg = (stmt)=>stmt.get(opt.rowMode);
              break;
            }else if('string'===typeof opt.rowMode
                     && opt.rowMode.length>1
                     && '$'===opt.rowMode[0]){
              
              const $colName = opt.rowMode.substr(1);
              out.cbArg = (stmt)=>{
                const rc = stmt.get(Object.create(null))[$colName];
                return (undefined===rc)
                  ? toss3(capi.SQLITE_NOTFOUND,
                          "exec(): unknown result column:",$colName)
                  : rc;
              };
              break;
            }
            toss3("Invalid rowMode:",opt.rowMode);
      }
    }
    return out;
  };

  
  const __selectFirstRow = (db, sql, bind, ...getArgs)=>{
    const stmt = db.prepare(sql);
    try {
      const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : undefined;
      stmt.reset();
      return rc;
    }finally{
      stmt.finalize();
    }
  };

  
  const __selectAll =
        (db, sql, bind, rowMode)=>db.exec({
          sql, bind, rowMode, returnValue: 'resultRows'
        });

  
  DB.checkRc = (db,resultCode)=>checkSqlite3Rc(db,resultCode);

  DB.prototype = {
    
    isOpen: function(){
      return !!this.pointer;
    },
    
    affirmOpen: function(){
      return affirmDbOpen(this);
    },
    
    close: function(){
      if(this.pointer){
        if(this.onclose && (this.onclose.before instanceof Function)){
          try{this.onclose.before(this)}
          catch(e){}
        }
        const pDb = this.pointer;
        Object.keys(__stmtMap.get(this)).forEach((k,s)=>{
          if(s && s.pointer){
            try{s.finalize()}
            catch(e){}
          }
        });
        __ptrMap.delete(this);
        __stmtMap.delete(this);
        capi.sqlite3_close_v2(pDb);
        if(this.onclose && (this.onclose.after instanceof Function)){
          try{this.onclose.after(this)}
          catch(e){}
        }
        delete this.filename;
      }
    },
    
    changes: function(total=false,sixtyFour=false){
      const p = affirmDbOpen(this).pointer;
      if(total){
        return sixtyFour
          ? capi.sqlite3_total_changes64(p)
          : capi.sqlite3_total_changes(p);
      }else{
        return sixtyFour
          ? capi.sqlite3_changes64(p)
          : capi.sqlite3_changes(p);
      }
    },
    
    dbFilename: function(dbName='main'){
      return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
    },
    
    dbName: function(dbNumber=0){
      return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
    },
    
    dbVfsName: function(dbName=0){
      let rc;
      const pVfs = capi.sqlite3_js_db_vfs(
        affirmDbOpen(this).pointer, dbName
      );
      if(pVfs){
        const v = new capi.sqlite3_vfs(pVfs);
        try{ rc = wasm.cstrToJs(v.$zName) }
        finally { v.dispose() }
      }
      return rc;
    },
    
    prepare: function(sql){
      affirmDbOpen(this);
      const stack = wasm.pstack.pointer;
      let ppStmt, pStmt;
      try{
        ppStmt = wasm.pstack.alloc(8);
        DB.checkRc(this, capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null));
        pStmt = wasm.peekPtr(ppStmt);
      }
      finally {
        wasm.pstack.restore(stack);
      }
      if(!pStmt) toss3("Cannot prepare empty SQL.");
      const stmt = new Stmt(this, pStmt, BindTypes);
      __stmtMap.get(this)[pStmt] = stmt;
      return stmt;
    },
    
    exec: function(){
      affirmDbOpen(this);
      const arg = parseExecArgs(this, arguments);
      if(!arg.sql){
        return toss3("exec() requires an SQL string.");
      }
      const opt = arg.opt;
      const callback = opt.callback;
      const resultRows =
            Array.isArray(opt.resultRows) ? opt.resultRows : undefined;
      let stmt;
      let bind = opt.bind;
      let evalFirstResult = !!(
        arg.cbArg || opt.columnNames || resultRows
      ) ;
      const stack = wasm.scopedAllocPush();
      const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : undefined;
      try{
        const isTA = util.isSQLableTypedArray(arg.sql)
        ;
        
        let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);
        const ppStmt  = wasm.scopedAlloc(
          
          (2 * wasm.ptrSizeof) + (sqlByteLen + 1)
        );
        const pzTail = ppStmt + wasm.ptrSizeof ;
        let pSql = pzTail + wasm.ptrSizeof;
        const pSqlEnd = pSql + sqlByteLen;
        if(isTA) wasm.heap8().set(arg.sql, pSql);
        else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
        wasm.poke(pSql + sqlByteLen, 0);
        while(pSql && wasm.peek(pSql, 'i8')
               ){
          wasm.pokePtr([ppStmt, pzTail], 0);
          DB.checkRc(this, capi.sqlite3_prepare_v3(
            this.pointer, pSql, sqlByteLen, 0, ppStmt, pzTail
          ));
          const pStmt = wasm.peekPtr(ppStmt);
          pSql = wasm.peekPtr(pzTail);
          sqlByteLen = pSqlEnd - pSql;
          if(!pStmt) continue;
          if(saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
          stmt = new Stmt(this, pStmt, BindTypes);
          if(bind && stmt.parameterCount){
            stmt.bind(bind);
            bind = null;
          }
          if(evalFirstResult && stmt.columnCount){
            
            let gotColNames = Array.isArray(
              opt.columnNames
              ) ? 0 : 1;
            evalFirstResult = false;
            if(arg.cbArg || resultRows){
              for(; stmt.step(); stmt._lockedByExec = false){
                if(0===gotColNames++) stmt.getColumnNames(opt.columnNames);
                stmt._lockedByExec = true;
                const row = arg.cbArg(stmt);
                if(resultRows) resultRows.push(row);
                if(callback && false === callback.call(opt, row, stmt)){
                  break;
                }
              }
              stmt._lockedByExec = false;
            }
            if(0===gotColNames){
              
              stmt.getColumnNames(opt.columnNames);
            }
          }else{
            stmt.step();
          }
          stmt.reset(
            ).finalize();
          stmt = null;
        }
      }finally{
        wasm.scopedAllocPop(stack);
        if(stmt){
          delete stmt._lockedByExec;
          stmt.finalize();
        }
      }
      return arg.returnVal();
    },

    
    createFunction: function f(name, xFunc, opt){
      const isFunc = (f)=>(f instanceof Function);
      switch(arguments.length){
          case 1: 
            opt = name;
            name = opt.name;
            xFunc = opt.xFunc || 0;
            break;
          case 2: 
            if(!isFunc(xFunc)){
              opt = xFunc;
              xFunc = opt.xFunc || 0;
            }
            break;
          case 3: 
            break;
          default: break;
      }
      if(!opt) opt = {};
      if('string' !== typeof name){
        toss3("Invalid arguments: missing function name.");
      }
      let xStep = opt.xStep || 0;
      let xFinal = opt.xFinal || 0;
      const xValue = opt.xValue || 0;
      const xInverse = opt.xInverse || 0;
      let isWindow = undefined;
      if(isFunc(xFunc)){
        isWindow = false;
        if(isFunc(xStep) || isFunc(xFinal)){
          toss3("Ambiguous arguments: scalar or aggregate?");
        }
        xStep = xFinal = null;
      }else if(isFunc(xStep)){
        if(!isFunc(xFinal)){
          toss3("Missing xFinal() callback for aggregate or window UDF.");
        }
        xFunc = null;
      }else if(isFunc(xFinal)){
        toss3("Missing xStep() callback for aggregate or window UDF.");
      }else{
        toss3("Missing function-type properties.");
      }
      if(false === isWindow){
        if(isFunc(xValue) || isFunc(xInverse)){
          toss3("xValue and xInverse are not permitted for non-window UDFs.");
        }
      }else if(isFunc(xValue)){
        if(!isFunc(xInverse)){
          toss3("xInverse must be provided if xValue is.");
        }
        isWindow = true;
      }else if(isFunc(xInverse)){
        toss3("xValue must be provided if xInverse is.");
      }
      const pApp = opt.pApp;
      if(undefined!==pApp &&
         null!==pApp &&
         (('number'!==typeof pApp) || !util.isInt32(pApp))){
        toss3("Invalid value for pApp property. Must be a legal WASM pointer value.");
      }
      const xDestroy = opt.xDestroy || 0;
      if(xDestroy && !isFunc(xDestroy)){
        toss3("xDestroy property must be a function.");
      }
      let fFlags = 0 ;
      if(getOwnOption(opt, 'deterministic')) fFlags |= capi.SQLITE_DETERMINISTIC;
      if(getOwnOption(opt, 'directOnly')) fFlags |= capi.SQLITE_DIRECTONLY;
      if(getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;
      name = name.toLowerCase();
      const xArity = xFunc || xStep;
      const arity = getOwnOption(opt, 'arity');
      const arityArg = ('number'===typeof arity
                        ? arity
                        : (xArity.length ? xArity.length-1 : 0));
      let rc;
      if( isWindow ){
        rc = capi.sqlite3_create_window_function(
          this.pointer, name, arityArg,
          capi.SQLITE_UTF8 | fFlags, pApp || 0,
          xStep, xFinal, xValue, xInverse, xDestroy);
      }else{
        rc = capi.sqlite3_create_function_v2(
          this.pointer, name, arityArg,
          capi.SQLITE_UTF8 | fFlags, pApp || 0,
          xFunc, xStep, xFinal, xDestroy);
      }
      DB.checkRc(this, rc);
      return this;
    },
    
    selectValue: function(sql,bind,asType){
      return __selectFirstRow(this, sql, bind, 0, asType);
    },

    
    selectValues: function(sql,bind,asType){
      const stmt = this.prepare(sql), rc = [];
      try {
        stmt.bind(bind);
        while(stmt.step()) rc.push(stmt.get(0,asType));
        stmt.reset();
      }finally{
        stmt.finalize();
      }
      return rc;
    },

    
    selectArray: function(sql,bind){
      return __selectFirstRow(this, sql, bind, []);
    },

    
    selectObject: function(sql,bind){
      return __selectFirstRow(this, sql, bind, {});
    },

    
    selectArrays: function(sql,bind){
      return __selectAll(this, sql, bind, 'array');
    },

    
    selectObjects: function(sql,bind){
      return __selectAll(this, sql, bind, 'object');
    },

    
    openStatementCount: function(){
      return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
    },

    
    transaction: function(callback){
      let opener = 'BEGIN';
      if(arguments.length>1){
        if(/[^a-zA-Z]/.test(arguments[0])){
          toss3(capi.SQLITE_MISUSE, "Invalid argument for BEGIN qualifier.");
        }
        opener += ' '+arguments[0];
        callback = arguments[1];
      }
      affirmDbOpen(this).exec(opener);
      try {
        const rc = callback(this);
        this.exec("COMMIT");
        return rc;
      }catch(e){
        this.exec("ROLLBACK");
        throw e;
      }
    },

    
    savepoint: function(callback){
      affirmDbOpen(this).exec("SAVEPOINT oo1");
      try {
        const rc = callback(this);
        this.exec("RELEASE oo1");
        return rc;
      }catch(e){
        this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
        throw e;
      }
    },

    
    checkRc: function(resultCode){
      return checkSqlite3Rc(this, resultCode);
    }
  };


  
  const affirmStmtOpen = function(stmt){
    if(!stmt.pointer) toss3("Stmt has been closed.");
    return stmt;
  };

  
  const isSupportedBindType = function(v){
    let t = BindTypes[(null===v||undefined===v) ? 'null' : typeof v];
    switch(t){
        case BindTypes.boolean:
        case BindTypes.null:
        case BindTypes.number:
        case BindTypes.string:
          return t;
        case BindTypes.bigint:
          if(wasm.bigIntEnabled) return t;
          
        default:
          return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;
    }
  };

  
  const affirmSupportedBindType = function(v){
    
    return isSupportedBindType(v) || toss3("Unsupported bind() argument type:",typeof v);
  };

  
  const affirmParamIndex = function(stmt,key){
    const n = ('number'===typeof key)
          ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
    if(0===n || !util.isInt32(n)){
      toss3("Invalid bind() parameter name: "+key);
    }
    else if(n<1 || n>stmt.parameterCount) toss3("Bind index",key,"is out of range.");
    return n;
  };

  
  const affirmNotLockedByExec = function(stmt,currentOpName){
    if(stmt._lockedByExec){
      toss3("Operation is illegal when statement is locked:",currentOpName);
    }
    return stmt;
  };

  
  const bindOne = function f(stmt,ndx,bindType,val){
    affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');
    if(!f._){
      f._tooBigInt = (v)=>toss3(
        "BigInt value is too big to store without precision loss:", v
      );
      f._ = {
        string: function(stmt, ndx, val, asBlob){
          const [pStr, n] = wasm.allocCString(val, true);
          const f = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
          return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);
        }
      };
    }
    affirmSupportedBindType(val);
    ndx = affirmParamIndex(stmt,ndx);
    let rc = 0;
    switch((null===val || undefined===val) ? BindTypes.null : bindType){
        case BindTypes.null:
          rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
          break;
        case BindTypes.string:
          rc = f._.string(stmt, ndx, val, false);
          break;
        case BindTypes.number: {
          let m;
          if(util.isInt32(val)) m = capi.sqlite3_bind_int;
          else if('bigint'===typeof val){
            if(!util.bigIntFits64(val)){
              f._tooBigInt(val);
            }else if(wasm.bigIntEnabled){
              m = capi.sqlite3_bind_int64;
            }else if(util.bigIntFitsDouble(val)){
              val = Number(val);
              m = capi.sqlite3_bind_double;
            }else{
              f._tooBigInt(val);
            }
          }else{ 
            val = Number(val);
            if(wasm.bigIntEnabled && Number.isInteger(val)){
              m = capi.sqlite3_bind_int64;
            }else{
              m = capi.sqlite3_bind_double;
            }
          }
          rc = m(stmt.pointer, ndx, val);
          break;
        }
        case BindTypes.boolean:
          rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
          break;
        case BindTypes.blob: {
          if('string'===typeof val){
            rc = f._.string(stmt, ndx, val, true);
            break;
          }else if(val instanceof ArrayBuffer){
            val = new Uint8Array(val);
          }else if(!util.isBindableTypedArray(val)){
            toss3("Binding a value as a blob requires",
                  "that it be a string, Uint8Array, Int8Array, or ArrayBuffer.");
          }
          const pBlob = wasm.alloc(val.byteLength || 1);
          wasm.heap8().set(val.byteLength ? val : [0], pBlob)
          rc = capi.sqlite3_bind_blob(stmt.pointer, ndx, pBlob, val.byteLength,
                                      capi.SQLITE_WASM_DEALLOC);
          break;
        }
        default:
          sqlite3.config.warn("Unsupported bind() argument type:",val);
          toss3("Unsupported bind() argument type: "+(typeof val));
    }
    if(rc) DB.checkRc(stmt.db.pointer, rc);
    stmt._mayGet = false;
    return stmt;
  };

  Stmt.prototype = {
    
    finalize: function(){
      if(this.pointer){
        affirmNotLockedByExec(this,'finalize()');
        const rc = capi.sqlite3_finalize(this.pointer);
        delete __stmtMap.get(this.db)[this.pointer];
        __ptrMap.delete(this);
        delete this._mayGet;
        delete this.parameterCount;
        delete this._lockedByExec;
        delete this.db;
        return rc;
      }
    },
    
    clearBindings: function(){
      affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()')
      capi.sqlite3_clear_bindings(this.pointer);
      this._mayGet = false;
      return this;
    },
    
    reset: function(alsoClearBinds){
      affirmNotLockedByExec(this,'reset()');
      if(alsoClearBinds) this.clearBindings();
      const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
      this._mayGet = false;
      checkSqlite3Rc(this.db, rc);
      return this;
    },
    
    bind: function(){
      affirmStmtOpen(this);
      let ndx, arg;
      switch(arguments.length){
          case 1: ndx = 1; arg = arguments[0]; break;
          case 2: ndx = arguments[0]; arg = arguments[1]; break;
          default: toss3("Invalid bind() arguments.");
      }
      if(undefined===arg){
        
        return this;
      }else if(!this.parameterCount){
        toss3("This statement has no bindable parameters.");
      }
      this._mayGet = false;
      if(null===arg){
        
        return bindOne(this, ndx, BindTypes.null, arg);
      }
      else if(Array.isArray(arg)){
        
        if(1!==arguments.length){
          toss3("When binding an array, an index argument is not permitted.");
        }
        arg.forEach((v,i)=>bindOne(this, i+1, affirmSupportedBindType(v), v));
        return this;
      }else if(arg instanceof ArrayBuffer){
        arg = new Uint8Array(arg);
      }
      if('object'===typeof arg
              && !util.isBindableTypedArray(arg)){
        
        if(1!==arguments.length){
          toss3("When binding an object, an index argument is not permitted.");
        }
        Object.keys(arg)
          .forEach(k=>bindOne(this, k,
                              affirmSupportedBindType(arg[k]),
                              arg[k]));
        return this;
      }else{
        return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
      }
      toss3("Should not reach this point.");
    },
    
    bindAsBlob: function(ndx,arg){
      affirmStmtOpen(this);
      if(1===arguments.length){
        arg = ndx;
        ndx = 1;
      }
      const t = affirmSupportedBindType(arg);
      if(BindTypes.string !== t && BindTypes.blob !== t
         && BindTypes.null !== t){
        toss3("Invalid value type for bindAsBlob()");
      }
      return bindOne(this, ndx, BindTypes.blob, arg);
    },
    
    step: function(){
      affirmNotLockedByExec(this, 'step()');
      const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
      switch(rc){
          case capi.SQLITE_DONE: return this._mayGet = false;
          case capi.SQLITE_ROW: return this._mayGet = true;
          default:
            this._mayGet = false;
            sqlite3.config.warn("sqlite3_step() rc=",rc,
                         capi.sqlite3_js_rc_str(rc),
                         "SQL =", capi.sqlite3_sql(this.pointer));
            DB.checkRc(this.db.pointer, rc);
      }
    },
    
    stepReset: function(){
      this.step();
      return this.reset();
    },
    
    stepFinalize: function(){
      try{
        const rc = this.step();
        this.reset();
        return rc;
      }finally{
        try{this.finalize()}
        catch(e){}
      }
    },
    
    get: function(ndx,asType){
      if(!affirmStmtOpen(this)._mayGet){
        toss3("Stmt.step() has not (recently) returned true.");
      }
      if(Array.isArray(ndx)){
        let i = 0;
        const n = this.columnCount;
        while(i<n){
          ndx[i] = this.get(i++);
        }
        return ndx;
      }else if(ndx && 'object'===typeof ndx){
        let i = 0;
        const n = this.columnCount;
        while(i<n){
          ndx[capi.sqlite3_column_name(this.pointer,i)] = this.get(i++);
        }
        return ndx;
      }
      affirmColIndex(this, ndx);
      switch(undefined===asType
             ? capi.sqlite3_column_type(this.pointer, ndx)
             : asType){
          case capi.SQLITE_NULL: return null;
          case capi.SQLITE_INTEGER:{
            if(wasm.bigIntEnabled){
              const rc = capi.sqlite3_column_int64(this.pointer, ndx);
              if(rc>=Number.MIN_SAFE_INTEGER && rc<=Number.MAX_SAFE_INTEGER){
                
                return Number(rc).valueOf();
              }
              return rc;
            }else{
              const rc = capi.sqlite3_column_double(this.pointer, ndx);
              if(rc>Number.MAX_SAFE_INTEGER || rc<Number.MIN_SAFE_INTEGER){
                
                toss3("Integer is out of range for JS integer range: "+rc);
              }
              
              return util.isInt32(rc) ? (rc | 0) : rc;
            }
          }
          case capi.SQLITE_FLOAT:
            return capi.sqlite3_column_double(this.pointer, ndx);
          case capi.SQLITE_TEXT:
            return capi.sqlite3_column_text(this.pointer, ndx);
          case capi.SQLITE_BLOB: {
            const n = capi.sqlite3_column_bytes(this.pointer, ndx),
                  ptr = capi.sqlite3_column_blob(this.pointer, ndx),
                  rc = new Uint8Array(n);
            
            if(n) rc.set(wasm.heap8u().slice(ptr, ptr+n), 0);
            
            if(n && this.db._blobXfer instanceof Array){
              
              this.db._blobXfer.push(rc.buffer);
            }
            return rc;
          }
          default: toss3("Don't know how to translate",
                         "type of result column #"+ndx+".");
      }
      toss3("Not reached.");
    },
    
    getInt: function(ndx){return this.get(ndx,capi.SQLITE_INTEGER)},
    
    getFloat: function(ndx){return this.get(ndx,capi.SQLITE_FLOAT)},
    
    getString: function(ndx){return this.get(ndx,capi.SQLITE_TEXT)},
    
    getBlob: function(ndx){return this.get(ndx,capi.SQLITE_BLOB)},
    
    getJSON: function(ndx){
      const s = this.get(ndx, capi.SQLITE_STRING);
      return null===s ? s : JSON.parse(s);
    },
    
    
    
    
    
    getColumnName: function(ndx){
      return capi.sqlite3_column_name(
        affirmColIndex(affirmStmtOpen(this),ndx).pointer, ndx
      );
    },
    
    getColumnNames: function(tgt=[]){
      affirmColIndex(affirmStmtOpen(this),0);
      const n = this.columnCount;
      for(let i = 0; i < n; ++i){
        tgt.push(capi.sqlite3_column_name(this.pointer, i));
      }
      return tgt;
    },
    
    getParamIndex: function(name){
      return (affirmStmtOpen(this).parameterCount
              ? capi.sqlite3_bind_parameter_index(this.pointer, name)
              : undefined);
    }
  };

  {
    const prop = {
      enumerable: true,
      get: function(){return __ptrMap.get(this)},
      set: ()=>toss3("The pointer property is read-only.")
    }
    Object.defineProperty(Stmt.prototype, 'pointer', prop);
    Object.defineProperty(DB.prototype, 'pointer', prop);
  }
  
  Object.defineProperty(Stmt.prototype, 'columnCount', {
    enumerable: false,
    get: function(){return capi.sqlite3_column_count(this.pointer)},
    set: ()=>toss3("The columnCount property is read-only.")
  });

  
  sqlite3.oo1 = {
    DB,
    Stmt
  };

  if(util.isUIThread()){
    
    sqlite3.oo1.JsStorageDb = function(storageName='session'){
      if('session'!==storageName && 'local'!==storageName){
        toss3("JsStorageDb db name must be one of 'session' or 'local'.");
      }
      dbCtorHelper.call(this, {
        filename: storageName,
        flags: 'c',
        vfs: "kvvfs"
      });
    };
    const jdb = sqlite3.oo1.JsStorageDb;
    jdb.prototype = Object.create(DB.prototype);
    
    jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
    
    jdb.prototype.clearStorage = function(){
      return jdb.clearStorage(affirmDbOpen(this).filename);
    };
    
    jdb.storageSize = capi.sqlite3_js_kvvfs_size;
    
    jdb.prototype.storageSize = function(){
      return jdb.storageSize(affirmDbOpen(this).filename);
    };
  }

});





globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
sqlite3.initWorker1API = function(){
  'use strict';
  const toss = (...args)=>{throw new Error(args.join(' '))};
  if(!(globalThis.WorkerGlobalScope instanceof Function)){
    toss("initWorker1API() must be run from a Worker thread.");
  }
  const sqlite3 = this.sqlite3 || toss("Missing this.sqlite3 object.");
  const DB = sqlite3.oo1.DB;

  
  const getDbId = function(db){
    let id = wState.idMap.get(db);
    if(id) return id;
    id = 'db#'+(++wState.idSeq)+'@'+db.pointer;
    
    wState.idMap.set(db, id);
    return id;
  };

  
  const wState = {
    
    dbList: [],
    
    idSeq: 0,
    
    idMap: new WeakMap,
    
    xfer: [],
    open: function(opt){
      const db = new DB(opt);
      this.dbs[getDbId(db)] = db;
      if(this.dbList.indexOf(db)<0) this.dbList.push(db);
      return db;
    },
    close: function(db,alsoUnlink){
      if(db){
        delete this.dbs[getDbId(db)];
        const filename = db.filename;
        const pVfs = sqlite3.wasm.sqlite3_wasm_db_vfs(db.pointer, 0);
        db.close();
        const ddNdx = this.dbList.indexOf(db);
        if(ddNdx>=0) this.dbList.splice(ddNdx, 1);
        if(alsoUnlink && filename && pVfs){
          sqlite3.wasm.sqlite3_wasm_vfs_unlink(pVfs, filename);
        }
      }
    },
    
    post: function(msg,xferList){
      if(xferList && xferList.length){
        globalThis.postMessage( msg, Array.from(xferList) );
        xferList.length = 0;
      }else{
        globalThis.postMessage(msg);
      }
    },
    
    dbs: Object.create(null),
    
    getDb: function(id,require=true){
      return this.dbs[id]
        || (require ? toss("Unknown (or closed) DB ID:",id) : undefined);
    }
  };

  
  const affirmDbOpen = function(db = wState.dbList[0]){
    return (db && db.pointer) ? db : toss("DB is not opened.");
  };

  
  const getMsgDb = function(msgData,affirmExists=true){
    const db = wState.getDb(msgData.dbId,false) || wState.dbList[0];
    return affirmExists ? affirmDbOpen(db) : db;
  };

  const getDefaultDbId = function(){
    return wState.dbList[0] && getDbId(wState.dbList[0]);
  };

  const guessVfs = function(filename){
    const m = /^file:.+(vfs=(\w+))/.exec(filename);
    return sqlite3.capi.sqlite3_vfs_find(m ? m[2] : 0);
  };

  const isSpecialDbFilename = (n)=>{
    return ""===n || ':'===n[0];
  };

  
  const wMsgHandler = {
    open: function(ev){
      const oargs = Object.create(null), args = (ev.args || Object.create(null));
      if(args.simulateError){ 
        toss("Throwing because of simulateError flag.");
      }
      const rc = Object.create(null);
      let byteArray, pVfs;
      oargs.vfs = args.vfs;
      if(isSpecialDbFilename(args.filename)){
        oargs.filename = args.filename || "";
      }else{
        oargs.filename = args.filename;
        byteArray = args.byteArray;
        if(byteArray) pVfs = guessVfs(args.filename);
      }
      if(pVfs){
        
        let pMem;
        try{
          pMem = sqlite3.wasm.allocFromTypedArray(byteArray);
          const rc = sqlite3.wasm.sqlite3_wasm_vfs_create_file(
            pVfs, oargs.filename, pMem, byteArray.byteLength
          );
          if(rc) sqlite3.SQLite3Error.toss(rc);
        }catch(e){
          throw new sqlite3.SQLite3Error(
            e.name+' creating '+args.filename+": "+e.message, {
              cause: e
            }
          );
        }finally{
          if(pMem) sqlite3.wasm.dealloc(pMem);
        }
      }
      const db = wState.open(oargs);
      rc.filename = db.filename;
      rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(db.pointer, "opfs");
      rc.dbId = getDbId(db);
      rc.vfs = db.dbVfsName();
      return rc;
    },

    close: function(ev){
      const db = getMsgDb(ev,false);
      const response = {
        filename: db && db.filename
      };
      if(db){
        const doUnlink = ((ev.args && 'object'===typeof ev.args)
                         ? !!ev.args.unlink : false);
        wState.close(db, doUnlink);
      }
      return response;
    },

    exec: function(ev){
      const rc = (
        'string'===typeof ev.args
      ) ? {sql: ev.args} : (ev.args || Object.create(null));
      if('stmt'===rc.rowMode){
        toss("Invalid rowMode for 'exec': stmt mode",
             "does not work in the Worker API.");
      }else if(!rc.sql){
        toss("'exec' requires input SQL.");
      }
      const db = getMsgDb(ev);
      if(rc.callback || Array.isArray(rc.resultRows)){
        
        db._blobXfer = wState.xfer;
      }
      const theCallback = rc.callback;
      let rowNumber = 0;
      const hadColNames = !!rc.columnNames;
      if('string' === typeof theCallback){
        if(!hadColNames) rc.columnNames = [];
        
        rc.callback = function(row,stmt){
          wState.post({
            type: theCallback,
            columnNames: rc.columnNames,
            rowNumber: ++rowNumber,
            row: row
          }, wState.xfer);
        }
      }
      try {
        const changeCount = !!rc.countChanges
              ? db.changes(true,(64===rc.countChanges))
              : undefined;
        db.exec(rc);
        if(undefined !== changeCount){
          rc.changeCount = db.changes(true,64===rc.countChanges) - changeCount;
        }
        if(rc.callback instanceof Function){
          rc.callback = theCallback;
          
          wState.post({
            type: theCallback,
            columnNames: rc.columnNames,
            rowNumber: null ,
            row: undefined 
          });
        }
      }finally{
        delete db._blobXfer;
        if(rc.callback) rc.callback = theCallback;
      }
      return rc;
    },

    'config-get': function(){
      const rc = Object.create(null), src = sqlite3.config;
      [
        'bigIntEnabled'
      ].forEach(function(k){
        if(Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
      });
      rc.version = sqlite3.version;
      rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();
      rc.opfsEnabled = !!sqlite3.opfs;
      return rc;
    },

    
    export: function(ev){
      const db = getMsgDb(ev);
      const response = {
        byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),
        filename: db.filename,
        mimetype: 'application/x-sqlite3'
      };
      wState.xfer.push(response.byteArray.buffer);
      return response;
    },

    toss: function(ev){
      toss("Testing worker exception");
    },

    'opfs-tree': async function(ev){
      if(!sqlite3.opfs) toss("OPFS support is unavailable.");
      const response = await sqlite3.opfs.treeList();
      return response;
    }
  };

  globalThis.onmessage = async function(ev){
    ev = ev.data;
    let result, dbId = ev.dbId, evType = ev.type;
    const arrivalTime = performance.now();
    try {
      if(wMsgHandler.hasOwnProperty(evType) &&
         wMsgHandler[evType] instanceof Function){
        result = await wMsgHandler[evType](ev);
      }else{
        toss("Unknown db worker message type:",ev.type);
      }
    }catch(err){
      evType = 'error';
      result = {
        operation: ev.type,
        message: err.message,
        errorClass: err.name,
        input: ev
      };
      if(err.stack){
        result.stack = ('string'===typeof err.stack)
          ? err.stack.split(/\n\s*/) : err.stack;
      }
      if(false) {}
    }
    if(!dbId){
      dbId = result.dbId
        || getDefaultDbId();
    }
    
    
    wState.post({
      type: evType,
      dbId: dbId,
      messageId: ev.messageId,
      workerReceivedTime: arrivalTime,
      workerRespondTime: performance.now(),
      departureTime: ev.departureTime,
      
      
      
      
      
      
      result: result
    }, wState.xfer);
  };
  globalThis.postMessage({type:'sqlite3-api',result:'worker1-ready'});
}.bind({sqlite3});
});





'use strict';
globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  const wasm = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
  const vfs = Object.create(null), vtab = Object.create(null);

  const StructBinder = sqlite3.StructBinder
  ;
  sqlite3.vfs = vfs;
  sqlite3.vtab = vtab;

  const sii = capi.sqlite3_index_info;
  
  sii.prototype.nthConstraint = function(n, asPtr=false){
    if(n<0 || n>=this.$nConstraint) return false;
    const ptr = this.$aConstraint + (
      sii.sqlite3_index_constraint.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
  };

  
  sii.prototype.nthConstraintUsage = function(n, asPtr=false){
    if(n<0 || n>=this.$nConstraint) return false;
    const ptr = this.$aConstraintUsage + (
      sii.sqlite3_index_constraint_usage.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
  };

  
  sii.prototype.nthOrderBy = function(n, asPtr=false){
    if(n<0 || n>=this.$nOrderBy) return false;
    const ptr = this.$aOrderBy + (
      sii.sqlite3_index_orderby.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
  };

  
  const installMethod = function callee(
    tgt, name, func, applyArgcCheck = callee.installMethodArgcCheck
  ){
    if(!(tgt instanceof StructBinder.StructType)){
      toss("Usage error: target object is-not-a StructType.");
    }else if(!(func instanceof Function) && !wasm.isPtr(func)){
      toss("Usage errror: expecting a Function or WASM pointer to one.");
    }
    if(1===arguments.length){
      return (n,f)=>callee(tgt, n, f, applyArgcCheck);
    }
    if(!callee.argcProxy){
      callee.argcProxy = function(tgt, funcName, func,sig){
        return function(...args){
          if(func.length!==arguments.length){
            toss("Argument mismatch for",
                 tgt.structInfo.name+"::"+funcName
                 +": Native signature is:",sig);
          }
          return func.apply(this, args);
        }
      };
      
      callee.removeFuncList = function(){
        if(this.ondispose.__removeFuncList){
          this.ondispose.__removeFuncList.forEach(
            (v,ndx)=>{
              if('number'===typeof v){
                try{wasm.uninstallFunction(v)}
                catch(e){}
              }
              
            }
          );
          delete this.ondispose.__removeFuncList;
        }
      };
    }
    const sigN = tgt.memberSignature(name);
    if(sigN.length<2){
      toss("Member",name,"does not have a function pointer signature:",sigN);
    }
    const memKey = tgt.memberKey(name);
    const fProxy = (applyArgcCheck && !wasm.isPtr(func))
    
          ? callee.argcProxy(tgt, memKey, func, sigN)
          : func;
    if(wasm.isPtr(fProxy)){
      if(fProxy && !wasm.functionEntry(fProxy)){
        toss("Pointer",fProxy,"is not a WASM function table entry.");
      }
      tgt[memKey] = fProxy;
    }else{
      const pFunc = wasm.installFunction(fProxy, tgt.memberSignature(name, true));
      tgt[memKey] = pFunc;
      if(!tgt.ondispose || !tgt.ondispose.__removeFuncList){
        tgt.addOnDispose('ondispose.__removeFuncList handler',
                         callee.removeFuncList);
        tgt.ondispose.__removeFuncList = [];
      }
      tgt.ondispose.__removeFuncList.push(memKey, pFunc);
    }
    return (n,f)=>callee(tgt, n, f, applyArgcCheck);
  };
  installMethod.installMethodArgcCheck = false;

  
  const installMethods = function(
    structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    const seen = new Map ;
    for(const k of Object.keys(methods)){
      const m = methods[k];
      const prior = seen.get(m);
      if(prior){
        const mkey = structInstance.memberKey(k);
        structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
      }else{
        installMethod(structInstance, k, m, applyArgcCheck);
        seen.set(m, k);
      }
    }
    return structInstance;
  };

  
  StructBinder.StructType.prototype.installMethod = function callee(
    name, func, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    return (arguments.length < 3 && name && 'object'===typeof name)
      ? installMethods(this, ...arguments)
      : installMethod(this, ...arguments);
  };

  
  StructBinder.StructType.prototype.installMethods = function(
    methods, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    return installMethods(this, methods, applyArgcCheck);
  };

  
  capi.sqlite3_vfs.prototype.registerVfs = function(asDefault=false){
    if(!(this instanceof sqlite3.capi.sqlite3_vfs)){
      toss("Expecting a sqlite3_vfs-type argument.");
    }
    const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
    if(rc){
      toss("sqlite3_vfs_register(",this,") failed with rc",rc);
    }
    if(this.pointer !== capi.sqlite3_vfs_find(this.$zName)){
      toss("BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
           this);
    }
    return this;
  };

  
  vfs.installVfs = function(opt){
    let count = 0;
    const propList = ['io','vfs'];
    for(const key of propList){
      const o = opt[key];
      if(o){
        ++count;
        installMethods(o.struct, o.methods, !!o.applyArgcCheck);
        if('vfs'===key){
          if(!o.struct.$zName && 'string'===typeof o.name){
            o.struct.addOnDispose(
              o.struct.$zName = wasm.allocCString(o.name)
            );
          }
          o.struct.registerVfs(!!o.asDefault);
        }
      }
    }
    if(!count) toss("Misuse: installVfs() options object requires at least",
                    "one of:", propList);
    return this;
  };

  
  const __xWrapFactory = function(methodName,StructType){
    return function(ptr,removeMapping=false){
      if(0===arguments.length) ptr = new StructType;
      if(ptr instanceof StructType){
        
        this.set(ptr.pointer, ptr);
        return ptr;
      }else if(!wasm.isPtr(ptr)){
        sqlite3.SQLite3Error.toss("Invalid argument to",methodName+"()");
      }
      let rc = this.get(ptr);
      if(removeMapping) this.delete(ptr);
      return rc;
    }.bind(new Map);
  };

  
  const StructPtrMapper = function(name, StructType){
    const __xWrap = __xWrapFactory(name,StructType);
    
    return Object.assign(Object.create(null),{
      
      StructType,
      
      create: (ppOut)=>{
        const rc = __xWrap();
        wasm.pokePtr(ppOut, rc.pointer);
        return rc;
      },
      
      get: (pCObj)=>__xWrap(pCObj),
      
      unget: (pCObj)=>__xWrap(pCObj,true),
      
      dispose: (pCObj)=>{
        const o = __xWrap(pCObj,true);
        if(o) o.dispose();
      }
    });
  };

  
  vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);

  
  vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);

  
  vtab.xIndexInfo = (pIdxInfo)=>new capi.sqlite3_index_info(pIdxInfo);

  
  

  
  vtab.xError = function f(methodName, err, defaultRc){
    if(f.errorReporter instanceof Function){
      try{f.errorReporter("sqlite3_module::"+methodName+"(): "+err.message);}
      catch(e){}
    }
    let rc;
    if(err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;
    else if(arguments.length>2) rc = defaultRc;
    else if(err instanceof sqlite3.SQLite3Error) rc = err.resultCode;
    return rc || capi.SQLITE_ERROR;
  };
  vtab.xError.errorReporter =  true ? console.error.bind(console) : 0;

  
  

  
  vtab.xRowid = (ppRowid64, value)=>wasm.poke(ppRowid64, value, 'i64');

  
  vtab.setupModule = function(opt){
    let createdMod = false;
    const mod = (this instanceof capi.sqlite3_module)
          ? this : (opt.struct || (createdMod = new capi.sqlite3_module()));
    try{
      const methods = opt.methods || toss("Missing 'methods' object.");
      for(const e of Object.entries({
        
        
        xConnect: 'xCreate', xDisconnect: 'xDestroy'
      })){
        
        const k = e[0], v = e[1];
        if(true === methods[k]) methods[k] = methods[v];
        else if(true === methods[v]) methods[v] = methods[k];
      }
      if(opt.catchExceptions){
        const fwrap = function(methodName, func){
          if(['xConnect','xCreate'].indexOf(methodName) >= 0){
            return function(pDb, pAux, argc, argv, ppVtab, pzErr){
              try{return func(...arguments) || 0}
              catch(e){
                if(!(e instanceof sqlite3.WasmAllocError)){
                  wasm.dealloc(wasm.peekPtr(pzErr));
                  wasm.pokePtr(pzErr, wasm.allocCString(e.message));
                }
                return vtab.xError(methodName, e);
              }
            };
          }else{
            return function(...args){
              try{return func(...args) || 0}
              catch(e){
                return vtab.xError(methodName, e);
              }
            };
          }
        };
        const mnames = [
          'xCreate', 'xConnect', 'xBestIndex', 'xDisconnect',
          'xDestroy', 'xOpen', 'xClose', 'xFilter', 'xNext',
          'xEof', 'xColumn', 'xRowid', 'xUpdate',
          'xBegin', 'xSync', 'xCommit', 'xRollback',
          'xFindFunction', 'xRename', 'xSavepoint', 'xRelease',
          'xRollbackTo', 'xShadowName'
        ];
        const remethods = Object.create(null);
        for(const k of mnames){
          const m = methods[k];
          if(!(m instanceof Function)) continue;
          else if('xConnect'===k && methods.xCreate===m){
            remethods[k] = methods.xCreate;
          }else if('xCreate'===k && methods.xConnect===m){
            remethods[k] = methods.xConnect;
          }else{
            remethods[k] = fwrap(k, m);
          }
        }
        installMethods(mod, remethods, false);
      }else{
        
        
        installMethods(
          mod, methods, !!opt.applyArgcCheck
        );
      }
      if(0===mod.$iVersion){
        let v;
        if('number'===typeof opt.iVersion) v = opt.iVersion;
        else if(mod.$xShadowName) v = 3;
        else if(mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo) v = 2;
        else v = 1;
        mod.$iVersion = v;
      }
    }catch(e){
      if(createdMod) createdMod.dispose();
      throw e;
    }
    return mod;
  };

  
  capi.sqlite3_module.prototype.setupModule = function(opt){
    return vtab.setupModule.call(this, opt);
  };
});



'use strict';
globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){

const installOpfsVfs = function callee(options){
  if(!globalThis.SharedArrayBuffer
    || !globalThis.Atomics){
    return Promise.reject(
      new Error("Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. "+
                "The server must emit the COOP/COEP response headers to enable those. "+
                "See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep")
    );
  }else if('undefined'===typeof WorkerGlobalScope){
    return Promise.reject(
      new Error("The OPFS sqlite3_vfs cannot run in the main thread "+
                "because it requires Atomics.wait().")
    );
  }else if(!globalThis.FileSystemHandle ||
           !globalThis.FileSystemDirectoryHandle ||
           !globalThis.FileSystemFileHandle ||
           !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
           !navigator?.storage?.getDirectory){
    return Promise.reject(
      new Error("Missing required OPFS APIs.")
    );
  }
  if(!options || 'object'!==typeof options){
    options = Object.create(null);
  }
  const urlParams = new URL(globalThis.location.href).searchParams;
  if(urlParams.has('opfs-disable')){
    
    return Promise.resolve(sqlite3);
  }
  if(undefined===options.verbose){
    options.verbose = urlParams.has('opfs-verbose')
      ? (+urlParams.get('opfs-verbose') || 2) : 1;
  }
  if(undefined===options.sanityChecks){
    options.sanityChecks = urlParams.has('opfs-sanity-check');
  }
  if(undefined===options.proxyUri){
    options.proxyUri = callee.defaultProxyUri;
  }

  

  if('function' === typeof options.proxyUri){
    options.proxyUri = options.proxyUri();
  }
  const thePromise = new Promise(function(promiseResolve_, promiseReject_){
    const loggers = [
      sqlite3.config.error,
      sqlite3.config.warn,
      sqlite3.config.log
    ];
    const logImpl = (level,...args)=>{
      if(options.verbose>level) loggers[level]("OPFS syncer:",...args);
    };
    const log =    (...args)=>logImpl(2, ...args);
    const warn =   (...args)=>logImpl(1, ...args);
    const error =  (...args)=>logImpl(0, ...args);
    const toss = sqlite3.util.toss;
    const capi = sqlite3.capi;
    const util = sqlite3.util;
    const wasm = sqlite3.wasm;
    const sqlite3_vfs = capi.sqlite3_vfs;
    const sqlite3_file = capi.sqlite3_file;
    const sqlite3_io_methods = capi.sqlite3_io_methods;
    
    const opfsUtil = Object.create(null);

    
    const thisThreadHasOPFS = ()=>{
      return globalThis.FileSystemHandle &&
        globalThis.FileSystemDirectoryHandle &&
        globalThis.FileSystemFileHandle &&
        globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle &&
        navigator?.storage?.getDirectory;
    };

    
    opfsUtil.metrics = {
      dump: function(){
        let k, n = 0, t = 0, w = 0;
        for(k in state.opIds){
          const m = metrics[k];
          n += m.count;
          t += m.time;
          w += m.wait;
          m.avgTime = (m.count && m.time) ? (m.time / m.count) : 0;
          m.avgWait = (m.count && m.wait) ? (m.wait / m.count) : 0;
        }
        sqlite3.config.log(globalThis.location.href,
                    "metrics for",globalThis.location.href,":",metrics,
                    "\nTotal of",n,"op(s) for",t,
                    "ms (incl. "+w+" ms of waiting on the async side)");
        sqlite3.config.log("Serialization metrics:",metrics.s11n);
        W.postMessage({type:'opfs-async-metrics'});
      },
      reset: function(){
        let k;
        const r = (m)=>(m.count = m.time = m.wait = 0);
        for(k in state.opIds){
          r(metrics[k] = Object.create(null));
        }
        let s = metrics.s11n = Object.create(null);
        s = s.serialize = Object.create(null);
        s.count = s.time = 0;
        s = metrics.s11n.deserialize = Object.create(null);
        s.count = s.time = 0;
      }
    };
    const opfsIoMethods = new sqlite3_io_methods();
    const opfsVfs = new sqlite3_vfs()
          .addOnDispose( ()=>opfsIoMethods.dispose());
    let promiseWasRejected = undefined;
    const promiseReject = (err)=>{
      promiseWasRejected = true;
      opfsVfs.dispose();
      return promiseReject_(err);
    };
    const promiseResolve = ()=>{
      promiseWasRejected = false;
      return promiseResolve_(sqlite3);
    };
    const W =
    new Worker(options.proxyUri);
    setTimeout(()=>{
      
      if(undefined===promiseWasRejected){
        promiseReject(
          new Error("Timeout while waiting for OPFS async proxy worker.")
        );
      }
    }, 4000);
    W._originalOnError = W.onerror ;
    W.onerror = function(err){
      
      
      error("Error initializing OPFS asyncer:",err);
      promiseReject(new Error("Loading OPFS async Worker failed for unknown reasons."));
    };
    const pDVfs = capi.sqlite3_vfs_find(null);
    const dVfs = pDVfs
          ? new sqlite3_vfs(pDVfs)
          : null ;
    opfsIoMethods.$iVersion = 1;
    opfsVfs.$iVersion = 2;
    opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
    opfsVfs.$mxPathname = 1024;
    opfsVfs.$zName = wasm.allocCString("opfs");
    
    opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
    opfsVfs.addOnDispose(
      '$zName', opfsVfs.$zName,
      'cleanup default VFS wrapper', ()=>(dVfs ? dVfs.dispose() : null)
    );
    
    
    const state = Object.create(null);
    state.verbose = options.verbose;
    state.littleEndian = (()=>{
      const buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true );
      
      return new Int16Array(buffer)[0] === 256;
    })();
    
    state.asyncIdleWaitTime = 150;

    
    state.asyncS11nExceptions = 1;
    
    state.fileBufferSize = 1024 * 64;
    state.sabS11nOffset = state.fileBufferSize;
    
    state.sabS11nSize = opfsVfs.$mxPathname * 2;
    
    state.sabIO = new SharedArrayBuffer(
      state.fileBufferSize
      + state.sabS11nSize
    );
    state.opIds = Object.create(null);
    const metrics = Object.create(null);
    {
      
      let i = 0;
      
      state.opIds.whichOp = i++;
      
      state.opIds.rc = i++;
      
      state.opIds.xAccess = i++;
      state.opIds.xClose = i++;
      state.opIds.xDelete = i++;
      state.opIds.xDeleteNoWait = i++;
      state.opIds.xFileSize = i++;
      state.opIds.xLock = i++;
      state.opIds.xOpen = i++;
      state.opIds.xRead = i++;
      state.opIds.xSleep = i++;
      state.opIds.xSync = i++;
      state.opIds.xTruncate = i++;
      state.opIds.xUnlock = i++;
      state.opIds.xWrite = i++;
      state.opIds.mkdir = i++;
      state.opIds['opfs-async-metrics'] = i++;
      state.opIds['opfs-async-shutdown'] = i++;
      
      state.opIds.retry = i++;
      state.sabOP = new SharedArrayBuffer(
        i * 4);
      opfsUtil.metrics.reset();
    }
    
    state.sq3Codes = Object.create(null);
    [
      'SQLITE_ACCESS_EXISTS',
      'SQLITE_ACCESS_READWRITE',
      'SQLITE_BUSY',
      'SQLITE_ERROR',
      'SQLITE_IOERR',
      'SQLITE_IOERR_ACCESS',
      'SQLITE_IOERR_CLOSE',
      'SQLITE_IOERR_DELETE',
      'SQLITE_IOERR_FSYNC',
      'SQLITE_IOERR_LOCK',
      'SQLITE_IOERR_READ',
      'SQLITE_IOERR_SHORT_READ',
      'SQLITE_IOERR_TRUNCATE',
      'SQLITE_IOERR_UNLOCK',
      'SQLITE_IOERR_WRITE',
      'SQLITE_LOCK_EXCLUSIVE',
      'SQLITE_LOCK_NONE',
      'SQLITE_LOCK_PENDING',
      'SQLITE_LOCK_RESERVED',
      'SQLITE_LOCK_SHARED',
      'SQLITE_LOCKED',
      'SQLITE_MISUSE',
      'SQLITE_NOTFOUND',
      'SQLITE_OPEN_CREATE',
      'SQLITE_OPEN_DELETEONCLOSE',
      'SQLITE_OPEN_MAIN_DB',
      'SQLITE_OPEN_READONLY'
    ].forEach((k)=>{
      if(undefined === (state.sq3Codes[k] = capi[k])){
        toss("Maintenance required: not found:",k);
      }
    });
    state.opfsFlags = Object.assign(Object.create(null),{
      
      OPFS_UNLOCK_ASAP: 0x01,
      
      defaultUnlockAsap: false
    });

    
    const opRun = (op,...args)=>{
      const opNdx = state.opIds[op] || toss("Invalid op ID:",op);
      state.s11n.serialize(...args);
      Atomics.store(state.sabOPView, state.opIds.rc, -1);
      Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
      Atomics.notify(state.sabOPView, state.opIds.whichOp)
      ;
      const t = performance.now();
      Atomics.wait(state.sabOPView, state.opIds.rc, -1)
      ;
      const rc = Atomics.load(state.sabOPView, state.opIds.rc);
      metrics[op].wait += performance.now() - t;
      if(rc && state.asyncS11nExceptions){
        const err = state.s11n.deserialize();
        if(err) error(op+"() async error:",...err);
      }
      return rc;
    };

    
    opfsUtil.debug = {
      asyncShutdown: ()=>{
        warn("Shutting down OPFS async listener. The OPFS VFS will no longer work.");
        opRun('opfs-async-shutdown');
      },
      asyncRestart: ()=>{
        warn("Attempting to restart OPFS VFS async listener. Might work, might not.");
        W.postMessage({type: 'opfs-async-restart'});
      }
    };

    const initS11n = ()=>{
      
      if(state.s11n) return state.s11n;
      const textDecoder = new TextDecoder(),
            textEncoder = new TextEncoder('utf-8'),
            viewU8 = new Uint8Array(state.sabIO, state.sabS11nOffset, state.sabS11nSize),
            viewDV = new DataView(state.sabIO, state.sabS11nOffset, state.sabS11nSize);
      state.s11n = Object.create(null);
      
      const TypeIds = Object.create(null);
      TypeIds.number  = { id: 1, size: 8, getter: 'getFloat64', setter: 'setFloat64' };
      TypeIds.bigint  = { id: 2, size: 8, getter: 'getBigInt64', setter: 'setBigInt64' };
      TypeIds.boolean = { id: 3, size: 4, getter: 'getInt32', setter: 'setInt32' };
      TypeIds.string =  { id: 4 };

      const getTypeId = (v)=>(
        TypeIds[typeof v]
          || toss("Maintenance required: this value type cannot be serialized.",v)
      );
      const getTypeIdById = (tid)=>{
        switch(tid){
            case TypeIds.number.id: return TypeIds.number;
            case TypeIds.bigint.id: return TypeIds.bigint;
            case TypeIds.boolean.id: return TypeIds.boolean;
            case TypeIds.string.id: return TypeIds.string;
            default: toss("Invalid type ID:",tid);
        }
      };

      
      state.s11n.deserialize = function(clear=false){
        ++metrics.s11n.deserialize.count;
        const t = performance.now();
        const argc = viewU8[0];
        const rc = argc ? [] : null;
        if(argc){
          const typeIds = [];
          let offset = 1, i, n, v;
          for(i = 0; i < argc; ++i, ++offset){
            typeIds.push(getTypeIdById(viewU8[offset]));
          }
          for(i = 0; i < argc; ++i){
            const t = typeIds[i];
            if(t.getter){
              v = viewDV[t.getter](offset, state.littleEndian);
              offset += t.size;
            }else{
              n = viewDV.getInt32(offset, state.littleEndian);
              offset += 4;
              v = textDecoder.decode(viewU8.slice(offset, offset+n));
              offset += n;
            }
            rc.push(v);
          }
        }
        if(clear) viewU8[0] = 0;
        
        metrics.s11n.deserialize.time += performance.now() - t;
        return rc;
      };

      
      state.s11n.serialize = function(...args){
        const t = performance.now();
        ++metrics.s11n.serialize.count;
        if(args.length){
          
          const typeIds = [];
          let i = 0, offset = 1;
          viewU8[0] = args.length & 0xff ;
          for(; i < args.length; ++i, ++offset){
            
            typeIds.push(getTypeId(args[i]));
            viewU8[offset] = typeIds[i].id;
          }
          for(i = 0; i < args.length; ++i) {
            
            const t = typeIds[i];
            if(t.setter){
              viewDV[t.setter](offset, args[i], state.littleEndian);
              offset += t.size;
            }else{
              const s = textEncoder.encode(args[i]);
              viewDV.setInt32(offset, s.byteLength, state.littleEndian);
              offset += 4;
              viewU8.set(s, offset);
              offset += s.byteLength;
            }
          }
          
        }else{
          viewU8[0] = 0;
        }
        metrics.s11n.serialize.time += performance.now() - t;
      };
      return state.s11n;
    };

    
    const randomFilename = function f(len=16){
      if(!f._chars){
        f._chars = "abcdefghijklmnopqrstuvwxyz"+
          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"+
          "012346789";
        f._n = f._chars.length;
      }
      const a = [];
      let i = 0;
      for( ; i < len; ++i){
        const ndx = Math.random() * (f._n * 64) % f._n | 0;
        a[i] = f._chars[ndx];
      }
      return a.join("");
      
    };

    
    const __openFiles = Object.create(null);

    const opTimer = Object.create(null);
    opTimer.op = undefined;
    opTimer.start = undefined;
    const mTimeStart = (op)=>{
      opTimer.start = performance.now();
      opTimer.op = op;
      ++metrics[op].count;
    };
    const mTimeEnd = ()=>(
      metrics[opTimer.op].time += performance.now() - opTimer.start
    );

    
    const ioSyncWrappers = {
      xCheckReservedLock: function(pFile,pOut){
        
        const f = __openFiles[pFile];
        wasm.poke(pOut, f.lockType ? 1 : 0, 'i32');
        return 0;
      },
      xClose: function(pFile){
        mTimeStart('xClose');
        let rc = 0;
        const f = __openFiles[pFile];
        if(f){
          delete __openFiles[pFile];
          rc = opRun('xClose', pFile);
          if(f.sq3File) f.sq3File.dispose();
        }
        mTimeEnd();
        return rc;
      },
      xDeviceCharacteristics: function(pFile){
        
        return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
      },
      xFileControl: function(pFile, opId, pArg){
        
        return capi.SQLITE_NOTFOUND;
      },
      xFileSize: function(pFile,pSz64){
        mTimeStart('xFileSize');
        let rc = opRun('xFileSize', pFile);
        if(0==rc){
          try {
            const sz = state.s11n.deserialize()[0];
            wasm.poke(pSz64, sz, 'i64');
          }catch(e){
            error("Unexpected error reading xFileSize() result:",e);
            rc = state.sq3Codes.SQLITE_IOERR;
          }
        }
        mTimeEnd();
        return rc;
      },
      xLock: function(pFile,lockType){
        mTimeStart('xLock');
        const f = __openFiles[pFile];
        let rc = 0;
        
        if( !f.lockType ) {
          rc = opRun('xLock', pFile, lockType);
          if( 0===rc ) f.lockType = lockType;
        }else{
          f.lockType = lockType;
        }
        mTimeEnd();
        return rc;
      },
      xRead: function(pFile,pDest,n,offset64){
        mTimeStart('xRead');
        const f = __openFiles[pFile];
        let rc;
        try {
          rc = opRun('xRead',pFile, n, Number(offset64));
          if(0===rc || capi.SQLITE_IOERR_SHORT_READ===rc){
            
            wasm.heap8u().set(f.sabView.subarray(0, n), pDest);
          }
        }catch(e){
          error("xRead(",arguments,") failed:",e,f);
          rc = capi.SQLITE_IOERR_READ;
        }
        mTimeEnd();
        return rc;
      },
      xSync: function(pFile,flags){
        mTimeStart('xSync');
        ++metrics.xSync.count;
        const rc = opRun('xSync', pFile, flags);
        mTimeEnd();
        return rc;
      },
      xTruncate: function(pFile,sz64){
        mTimeStart('xTruncate');
        const rc = opRun('xTruncate', pFile, Number(sz64));
        mTimeEnd();
        return rc;
      },
      xUnlock: function(pFile,lockType){
        mTimeStart('xUnlock');
        const f = __openFiles[pFile];
        let rc = 0;
        if( capi.SQLITE_LOCK_NONE === lockType
          && f.lockType ){
          rc = opRun('xUnlock', pFile, lockType);
        }
        if( 0===rc ) f.lockType = lockType;
        mTimeEnd();
        return rc;
      },
      xWrite: function(pFile,pSrc,n,offset64){
        mTimeStart('xWrite');
        const f = __openFiles[pFile];
        let rc;
        try {
          f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc+n));
          rc = opRun('xWrite', pFile, n, Number(offset64));
        }catch(e){
          error("xWrite(",arguments,") failed:",e,f);
          rc = capi.SQLITE_IOERR_WRITE;
        }
        mTimeEnd();
        return rc;
      }
    };

    
    const vfsSyncWrappers = {
      xAccess: function(pVfs,zName,flags,pOut){
        mTimeStart('xAccess');
        const rc = opRun('xAccess', wasm.cstrToJs(zName));
        wasm.poke( pOut, (rc ? 0 : 1), 'i32' );
        mTimeEnd();
        return 0;
      },
      xCurrentTime: function(pVfs,pOut){
        
        wasm.poke(pOut, 2440587.5 + (new Date().getTime()/86400000),
                  'double');
        return 0;
      },
      xCurrentTimeInt64: function(pVfs,pOut){
        wasm.poke(pOut, (2440587.5 * 86400000) + new Date().getTime(),
                  'i64');
        return 0;
      },
      xDelete: function(pVfs, zName, doSyncDir){
        mTimeStart('xDelete');
        const rc = opRun('xDelete', wasm.cstrToJs(zName), doSyncDir, false);
        mTimeEnd();
        return rc;
      },
      xFullPathname: function(pVfs,zName,nOut,pOut){
        
        const i = wasm.cstrncpy(pOut, zName, nOut);
        return i<nOut ? 0 : capi.SQLITE_CANTOPEN
        ;
      },
      xGetLastError: function(pVfs,nOut,pOut){
        
        warn("OPFS xGetLastError() has nothing sensible to return.");
        return 0;
      },
      
      xOpen: function f(pVfs, zName, pFile, flags, pOutFlags){
        mTimeStart('xOpen');
        let opfsFlags = 0;
        if(0===zName){
          zName = randomFilename();
        }else if('number'===typeof zName){
          if(capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)){
            
            opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
          }
          zName = wasm.cstrToJs(zName);
        }
        const fh = Object.create(null);
        fh.fid = pFile;
        fh.filename = zName;
        fh.sab = new SharedArrayBuffer(state.fileBufferSize);
        fh.flags = flags;
        const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);
        if(!rc){
          
          if(fh.readOnly){
            wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');
          }
          __openFiles[pFile] = fh;
          fh.sabView = state.sabFileBufView;
          fh.sq3File = new sqlite3_file(pFile);
          fh.sq3File.$pMethods = opfsIoMethods.pointer;
          fh.lockType = capi.SQLITE_LOCK_NONE;
        }
        mTimeEnd();
        return rc;
      }
    };

    if(dVfs){
      opfsVfs.$xRandomness = dVfs.$xRandomness;
      opfsVfs.$xSleep = dVfs.$xSleep;
    }
    if(!opfsVfs.$xRandomness){
      
      vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut){
        const heap = wasm.heap8u();
        let i = 0;
        for(; i < nOut; ++i) heap[pOut + i] = (Math.random()*255000) & 0xFF;
        return i;
      };
    }
    if(!opfsVfs.$xSleep){
      
      vfsSyncWrappers.xSleep = function(pVfs,ms){
        Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
        return 0;
      };
    }

    
    opfsUtil.getResolvedPath = function(filename,splitIt){
      const p = new URL(filename, "file://irrelevant").pathname;
      return splitIt ? p.split('/').filter((v)=>!!v) : p;
    };

    
    opfsUtil.getDirForFilename = async function f(absFilename, createDirs = false){
      const path = opfsUtil.getResolvedPath(absFilename, true);
      const filename = path.pop();
      let dh = opfsUtil.rootDirectory;
      for(const dirName of path){
        if(dirName){
          dh = await dh.getDirectoryHandle(dirName, {create: !!createDirs});
        }
      }
      return [dh, filename];
    };

    
    opfsUtil.mkdir = async function(absDirName){
      try {
        await opfsUtil.getDirForFilename(absDirName+"/filepart", true);
        return true;
      }catch(e){
        
        return false;
      }
    };
    
    opfsUtil.entryExists = async function(fsEntryName){
      try {
        const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
        await dh.getFileHandle(fn);
        return true;
      }catch(e){
        return false;
      }
    };

    
    opfsUtil.randomFilename = randomFilename;

    
    opfsUtil.registerVfs = (asDefault=false)=>{
      return wasm.exports.sqlite3_vfs_register(
        opfsVfs.pointer, asDefault ? 1 : 0
      );
    };

    
    opfsUtil.treeList = async function(){
      const doDir = async function callee(dirHandle,tgt){
        tgt.name = dirHandle.name;
        tgt.dirs = [];
        tgt.files = [];
        for await (const handle of dirHandle.values()){
          if('directory' === handle.kind){
            const subDir = Object.create(null);
            tgt.dirs.push(subDir);
            await callee(handle, subDir);
          }else{
            tgt.files.push(handle.name);
          }
        }
      };
      const root = Object.create(null);
      await doDir(opfsUtil.rootDirectory, root);
      return root;
    };

    
    opfsUtil.rmfr = async function(){
      const dir = opfsUtil.rootDirectory, opt = {recurse: true};
      for await (const handle of dir.values()){
        dir.removeEntry(handle.name, opt);
      }
    };

    
    opfsUtil.unlink = async function(fsEntryName, recursive = false,
                                     throwOnError = false){
      try {
        const [hDir, filenamePart] =
              await opfsUtil.getDirForFilename(fsEntryName, false);
        await hDir.removeEntry(filenamePart, {recursive});
        return true;
      }catch(e){
        if(throwOnError){
          throw new Error("unlink(",arguments[0],") failed: "+e.message,{
            cause: e
          });
        }
        return false;
      }
    };

    
    opfsUtil.traverse = async function(opt){
      const defaultOpt = {
        recursive: true,
        directory: opfsUtil.rootDirectory
      };
      if('function'===typeof opt){
        opt = {callback:opt};
      }
      opt = Object.assign(defaultOpt, opt||{});
      const doDir = async function callee(dirHandle, depth){
        for await (const handle of dirHandle.values()){
          if(false === opt.callback(handle, dirHandle, depth)) return false;
          else if(opt.recursive && 'directory' === handle.kind){
            if(false === await callee(handle, depth + 1)) break;
          }
        }
      };
      doDir(opt.directory, 0);
    };

    
    const importDbChunked = async function(filename, callback){
      const [hDir, fnamePart] = await opfsUtil.getDirForFilename(filename, true);
      const hFile = await hDir.getFileHandle(fnamePart, {create:true});
      let sah = await hFile.createSyncAccessHandle();
      let nWrote = 0, chunk, checkedHeader = false, err = false;
      try{
        sah.truncate(0);
        while( undefined !== (chunk = await callback()) ){
          if(chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
          if( 0===nWrote && chunk.byteLength>=15 ){
            util.affirmDbHeader(chunk);
            checkedHeader = true;
          }
          sah.write(chunk, {at: nWrote});
          nWrote += chunk.byteLength;
        }
        if( nWrote < 512 || 0!==nWrote % 512 ){
          toss("Input size",nWrote,"is not correct for an SQLite database.");
        }
        if( !checkedHeader ){
          const header = new Uint8Array(20);
          sah.read( header, {at: 0} );
          util.affirmDbHeader( header );
        }
        sah.write(new Uint8Array([1,1]), {at: 18});
        return nWrote;
      }catch(e){
        await sah.close();
        sah = undefined;
        await hDir.removeEntry( fnamePart ).catch(()=>{});
        throw e;
      }finally {
        if( sah ) await sah.close();
      }
    };

    
    opfsUtil.importDb = async function(filename, bytes){
      if( bytes instanceof Function ){
        return importDbChunked(filename, bytes);
      }
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      util.affirmIsDb(bytes);
      const n = bytes.byteLength;
      const [hDir, fnamePart] = await opfsUtil.getDirForFilename(filename, true);
      let sah, err, nWrote = 0;
      try {
        const hFile = await hDir.getFileHandle(fnamePart, {create:true});
        sah = await hFile.createSyncAccessHandle();
        sah.truncate(0);
        nWrote = sah.write(bytes, {at: 0});
        if(nWrote != n){
          toss("Expected to write "+n+" bytes but wrote "+nWrote+".");
        }
        sah.write(new Uint8Array([1,1]), {at: 18}) ;
        return nWrote;
      }catch(e){
        if( sah ){ await sah.close(); sah = undefined; }
        await hDir.removeEntry( fnamePart ).catch(()=>{});
        throw e;
      }finally{
        if( sah ) await sah.close();
      }
    };

    if(sqlite3.oo1){
      const OpfsDb = function(...args){
        const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
        opt.vfs = opfsVfs.$zName;
        sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
      };
      OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
      sqlite3.oo1.OpfsDb = OpfsDb;
      OpfsDb.importDb = opfsUtil.importDb;
      sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
        opfsVfs.pointer,
        function(oo1Db, sqlite3){
          
          sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);
          sqlite3.capi.sqlite3_exec(oo1Db, [
            
            "pragma journal_mode=DELETE;",
            
            "pragma cache_size=-16384;"
          ], 0, 0, 0);
        }
      );
    }

    const sanityCheck = function(){
      const scope = wasm.scopedAllocPush();
      const sq3File = new sqlite3_file();
      try{
        const fid = sq3File.pointer;
        const openFlags = capi.SQLITE_OPEN_CREATE
              | capi.SQLITE_OPEN_READWRITE
        
              | capi.SQLITE_OPEN_MAIN_DB;
        const pOut = wasm.scopedAlloc(8);
        const dbFile = "/sanity/check/file"+randomFilename(8);
        const zDbFile = wasm.scopedAllocCString(dbFile);
        let rc;
        state.s11n.serialize("This is ä string.");
        rc = state.s11n.deserialize();
        log("deserialize() says:",rc);
        if("This is ä string."!==rc[0]) toss("String d13n error.");
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        log("xAccess(",dbFile,") exists ?=",rc);
        rc = vfsSyncWrappers.xOpen(opfsVfs.pointer, zDbFile,
                                   fid, openFlags, pOut);
        log("open rc =",rc,"state.sabOPView[xOpen] =",
            state.sabOPView[state.opIds.xOpen]);
        if(0!==rc){
          error("open failed with code",rc);
          return;
        }
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        if(!rc) toss("xAccess() failed to detect file.");
        rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
        if(rc) toss('sync failed w/ rc',rc);
        rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
        if(rc) toss('truncate failed w/ rc',rc);
        wasm.poke(pOut,0,'i64');
        rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
        if(rc) toss('xFileSize failed w/ rc',rc);
        log("xFileSize says:",wasm.peek(pOut, 'i64'));
        rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
        if(rc) toss("xWrite() failed!");
        const readBuf = wasm.scopedAlloc(16);
        rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
        wasm.poke(readBuf+6,0);
        let jRead = wasm.cstrToJs(readBuf);
        log("xRead() got:",jRead);
        if("sanity"!==jRead) toss("Unexpected xRead() value.");
        if(vfsSyncWrappers.xSleep){
          log("xSleep()ing before close()ing...");
          vfsSyncWrappers.xSleep(opfsVfs.pointer,2000);
          log("waking up from xSleep()");
        }
        rc = ioSyncWrappers.xClose(fid);
        log("xClose rc =",rc,"sabOPView =",state.sabOPView);
        log("Deleting file:",dbFile);
        vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        if(rc) toss("Expecting 0 from xAccess(",dbFile,") after xDelete().");
        warn("End of OPFS sanity checks.");
      }finally{
        sq3File.dispose();
        wasm.scopedAllocPop(scope);
      }
    };

    W.onmessage = function({data}){
      
      switch(data.type){
          case 'opfs-unavailable':
            
            promiseReject(new Error(data.payload.join(' ')));
            break;
          case 'opfs-async-loaded':
            
            W.postMessage({type: 'opfs-async-init',args: state});
            break;
          case 'opfs-async-inited': {
            
            if(true===promiseWasRejected){
              break ;
            }
            try {
              sqlite3.vfs.installVfs({
                io: {struct: opfsIoMethods, methods: ioSyncWrappers},
                vfs: {struct: opfsVfs, methods: vfsSyncWrappers}
              });
              state.sabOPView = new Int32Array(state.sabOP);
              state.sabFileBufView = new Uint8Array(state.sabIO, 0, state.fileBufferSize);
              state.sabS11nView = new Uint8Array(state.sabIO, state.sabS11nOffset, state.sabS11nSize);
              initS11n();
              if(options.sanityChecks){
                warn("Running sanity checks because of opfs-sanity-check URL arg...");
                sanityCheck();
              }
              if(thisThreadHasOPFS()){
                navigator.storage.getDirectory().then((d)=>{
                  W.onerror = W._originalOnError;
                  delete W._originalOnError;
                  sqlite3.opfs = opfsUtil;
                  opfsUtil.rootDirectory = d;
                  log("End of OPFS sqlite3_vfs setup.", opfsVfs);
                  promiseResolve();
                }).catch(promiseReject);
              }else{
                promiseResolve();
              }
            }catch(e){
              error(e);
              promiseReject(e);
            }
            break;
          }
          default: {
            const errMsg = (
              "Unexpected message from the OPFS async worker: " +
              JSON.stringify(data)
            );
            error(errMsg);
            promiseReject(new Error(errMsg));
            break;
          }
      }
    };
  });
  return thePromise;
};
installOpfsVfs.defaultProxyUri =
  "sqlite3-opfs-async-proxy.js";
globalThis.sqlite3ApiBootstrap.initializersAsync.push(async (sqlite3)=>{
  try{
    let proxyJs = installOpfsVfs.defaultProxyUri;
    if(sqlite3.scriptInfo.sqlite3Dir){
      installOpfsVfs.defaultProxyUri =
        sqlite3.scriptInfo.sqlite3Dir + proxyJs;
      
    }
    return installOpfsVfs().catch((e)=>{
      sqlite3.config.warn("Ignoring inability to install OPFS sqlite3_vfs:",e.message);
    });
  }catch(e){
    sqlite3.config.error("installOpfsVfs() exception:",e);
    return Promise.reject(e);
  }
});
});



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  'use strict';
  const toss = sqlite3.util.toss;
  const toss3 = sqlite3.util.toss3;
  const initPromises = Object.create(null);
  const capi = sqlite3.capi;
  const util = sqlite3.util;
  const wasm = sqlite3.wasm;
  
  const SECTOR_SIZE = 4096;
  const HEADER_MAX_PATH_SIZE = 512;
  const HEADER_FLAGS_SIZE = 4;
  const HEADER_DIGEST_SIZE = 8;
  const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
  const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
  const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
  const HEADER_OFFSET_DATA = SECTOR_SIZE;
  
  const PERSISTENT_FILE_TYPES =
        capi.SQLITE_OPEN_MAIN_DB |
        capi.SQLITE_OPEN_MAIN_JOURNAL |
        capi.SQLITE_OPEN_SUPER_JOURNAL |
        capi.SQLITE_OPEN_WAL ;

  
  const OPAQUE_DIR_NAME = ".opaque";

  
  const getRandomName = ()=>Math.random().toString(36).slice(2);

  const textDecoder = new TextDecoder();
  const textEncoder = new TextEncoder();

  const optionDefaults = Object.assign(Object.create(null),{
    name: 'opfs-sahpool',
    directory: undefined ,
    initialCapacity: 6,
    clearOnInit: false,
    
    verbosity: 2
  });

  
  const loggers = [
    sqlite3.config.error,
    sqlite3.config.warn,
    sqlite3.config.log
  ];
  const log = sqlite3.config.log;
  const warn = sqlite3.config.warn;
  const error = sqlite3.config.error;

  
  const __mapVfsToPool = new Map();
  const getPoolForVfs = (pVfs)=>__mapVfsToPool.get(pVfs);
  const setPoolForVfs = (pVfs,pool)=>{
    if(pool) __mapVfsToPool.set(pVfs, pool);
    else __mapVfsToPool.delete(pVfs);
  };
  
  const __mapSqlite3File = new Map();
  const getPoolForPFile = (pFile)=>__mapSqlite3File.get(pFile);
  const setPoolForPFile = (pFile,pool)=>{
    if(pool) __mapSqlite3File.set(pFile, pool);
    else __mapSqlite3File.delete(pFile);
  };

  
  const ioMethods = {
    xCheckReservedLock: function(pFile,pOut){
      const pool = getPoolForPFile(pFile);
      pool.log('xCheckReservedLock');
      pool.storeErr();
      wasm.poke32(pOut, 1);
      return 0;
    },
    xClose: function(pFile){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      if(file) {
        try{
          pool.log(`xClose ${file.path}`);
          pool.mapS3FileToOFile(pFile, false);
          file.sah.flush();
          if(file.flags & capi.SQLITE_OPEN_DELETEONCLOSE){
            pool.deletePath(file.path);
          }
        }catch(e){
          return pool.storeErr(e, capi.SQLITE_IOERR);
        }
      }
      return 0;
    },
    xDeviceCharacteristics: function(pFile){
      return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
    },
    xFileControl: function(pFile, opId, pArg){
      return capi.SQLITE_NOTFOUND;
    },
    xFileSize: function(pFile,pSz64){
      const pool = getPoolForPFile(pFile);
      pool.log(`xFileSize`);
      const file = pool.getOFileForS3File(pFile);
      const size = file.sah.getSize() - HEADER_OFFSET_DATA;
      
      wasm.poke64(pSz64, BigInt(size));
      return 0;
    },
    xLock: function(pFile,lockType){
      const pool = getPoolForPFile(pFile);
      pool.log(`xLock ${lockType}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      file.lockType = lockType;
      return 0;
    },
    xRead: function(pFile,pDest,n,offset64){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      pool.log(`xRead ${file.path} ${n} @ ${offset64}`);
      try {
        const nRead = file.sah.read(
          wasm.heap8u().subarray(pDest, pDest+n),
          {at: HEADER_OFFSET_DATA + Number(offset64)}
        );
        if(nRead < n){
          wasm.heap8u().fill(0, pDest + nRead, pDest + n);
          return capi.SQLITE_IOERR_SHORT_READ;
        }
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xSectorSize: function(pFile){
      return SECTOR_SIZE;
    },
    xSync: function(pFile,flags){
      const pool = getPoolForPFile(pFile);
      pool.log(`xSync ${flags}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      
      try{
        file.sah.flush();
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xTruncate: function(pFile,sz64){
      const pool = getPoolForPFile(pFile);
      pool.log(`xTruncate ${sz64}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      
      try{
        file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xUnlock: function(pFile,lockType){
      const pool = getPoolForPFile(pFile);
      pool.log('xUnlock');
      const file = pool.getOFileForS3File(pFile);
      file.lockType = lockType;
      return 0;
    },
    xWrite: function(pFile,pSrc,n,offset64){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      pool.log(`xWrite ${file.path} ${n} ${offset64}`);
      try{
        const nBytes = file.sah.write(
          wasm.heap8u().subarray(pSrc, pSrc+n),
          { at: HEADER_OFFSET_DATA + Number(offset64) }
        );
        return n===nBytes ? 0 : toss("Unknown write() failure.");
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    }
  };

  const opfsIoMethods = new capi.sqlite3_io_methods();
  opfsIoMethods.$iVersion = 1;
  sqlite3.vfs.installVfs({
    io: {struct: opfsIoMethods, methods: ioMethods}
  });

  
  const vfsMethods = {
    xAccess: function(pVfs,zName,flags,pOut){
      
      const pool = getPoolForVfs(pVfs);
      pool.storeErr();
      try{
        const name = pool.getPath(zName);
        wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
      }catch(e){
        
        wasm.poke32(pOut, 0);
      }
      return 0;
    },
    xCurrentTime: function(pVfs,pOut){
      wasm.poke(pOut, 2440587.5 + (new Date().getTime()/86400000),
                'double');
      return 0;
    },
    xCurrentTimeInt64: function(pVfs,pOut){
      wasm.poke(pOut, (2440587.5 * 86400000) + new Date().getTime(),
                'i64');
      return 0;
    },
    xDelete: function(pVfs, zName, doSyncDir){
      const pool = getPoolForVfs(pVfs);
      pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
      pool.storeErr();
      try{
        pool.deletePath(pool.getPath(zName));
        return 0;
      }catch(e){
        pool.storeErr(e);
        return capi.SQLITE_IOERR_DELETE;
      }
    },
    xFullPathname: function(pVfs,zName,nOut,pOut){
      
      
      const i = wasm.cstrncpy(pOut, zName, nOut);
      return i<nOut ? 0 : capi.SQLITE_CANTOPEN;
    },
    xGetLastError: function(pVfs,nOut,pOut){
      const pool = getPoolForVfs(pVfs);
      const e = pool.popErr();
      pool.log(`xGetLastError ${nOut} e =`,e);
      if(e){
        const scope = wasm.scopedAllocPush();
        try{
          const [cMsg, n] = wasm.scopedAllocCString(e.message, true);
          wasm.cstrncpy(pOut, cMsg, nOut);
          if(n > nOut) wasm.poke8(pOut + nOut - 1, 0);
        }catch(e){
          return capi.SQLITE_NOMEM;
        }finally{
          wasm.scopedAllocPop(scope);
        }
      }
      return e ? (e.sqlite3Rc || capi.SQLITE_IOERR) : 0;
    },
    
    xOpen: function f(pVfs, zName, pFile, flags, pOutFlags){
      const pool = getPoolForVfs(pVfs);
      try{
        pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);
        
        const path = (zName && wasm.peek8(zName))
              ? pool.getPath(zName)
              : getRandomName();
        let sah = pool.getSAHForPath(path);
        if(!sah && (flags & capi.SQLITE_OPEN_CREATE)) {
          
          if(pool.getFileCount() < pool.getCapacity()) {
            
            sah = pool.nextAvailableSAH();
            pool.setAssociatedPath(sah, path, flags);
          }else{
            
            toss('SAH pool is full. Cannot create file',path);
          }
        }
        if(!sah){
          toss('file not found:',path);
        }
        
        
        const file = {path, flags, sah};
        pool.mapS3FileToOFile(pFile, file);
        file.lockType = capi.SQLITE_LOCK_NONE;
        const sq3File = new capi.sqlite3_file(pFile);
        sq3File.$pMethods = opfsIoMethods.pointer;
        sq3File.dispose();
        wasm.poke32(pOutFlags, flags);
        return 0;
      }catch(e){
        pool.storeErr(e);
        return capi.SQLITE_CANTOPEN;
      }
    }
  };

  
  const createOpfsVfs = function(vfsName){
    if( sqlite3.capi.sqlite3_vfs_find(vfsName)){
      toss3("VFS name is already registered:", vfsName);
    }
    const opfsVfs = new capi.sqlite3_vfs();
    
    const pDVfs = capi.sqlite3_vfs_find(null);
    const dVfs = pDVfs
          ? new capi.sqlite3_vfs(pDVfs)
          : null ;
    opfsVfs.$iVersion = 2;
    opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
    opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
    opfsVfs.addOnDispose(
      opfsVfs.$zName = wasm.allocCString(vfsName),
      ()=>setPoolForVfs(opfsVfs.pointer, 0)
    );

    if(dVfs){
      
      opfsVfs.$xRandomness = dVfs.$xRandomness;
      opfsVfs.$xSleep = dVfs.$xSleep;
      dVfs.dispose();
    }
    if(!opfsVfs.$xRandomness && !vfsMethods.xRandomness){
      
      vfsMethods.xRandomness = function(pVfs, nOut, pOut){
        const heap = wasm.heap8u();
        let i = 0;
        for(; i < nOut; ++i) heap[pOut + i] = (Math.random()*255000) & 0xFF;
        return i;
      };
    }
    if(!opfsVfs.$xSleep && !vfsMethods.xSleep){
      vfsMethods.xSleep = (pVfs,ms)=>0;
    }
    sqlite3.vfs.installVfs({
      vfs: {struct: opfsVfs, methods: vfsMethods}
    });
    return opfsVfs;
  };

  
  class OpfsSAHPool {
    
    vfsDir;
    
    #dhVfsRoot;
    
    #dhOpaque;
    
    #dhVfsParent;
    
    #mapSAHToName = new Map();
    
    #mapFilenameToSAH = new Map();
    
    #availableSAH = new Set();
    
    #mapS3FileToOFile_ = new Map();

    
    

    
    #apBody = new Uint8Array(HEADER_CORPUS_SIZE);
    
    #dvBody;

    
    #cVfs;

    
    #verbosity;

    constructor(options = Object.create(null)){
      this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
      this.vfsName = options.name || optionDefaults.name;
      this.#cVfs = createOpfsVfs(this.vfsName);
      setPoolForVfs(this.#cVfs.pointer, this);
      this.vfsDir = options.directory || ("."+this.vfsName);
      this.#dvBody =
        new DataView(this.#apBody.buffer, this.#apBody.byteOffset);
      this.isReady = this
        .reset(!!(options.clearOnInit ?? optionDefaults.clearOnInit))
        .then(()=>{
          if(this.$error) throw this.$error;
          return this.getCapacity()
            ? Promise.resolve(undefined)
            : this.addCapacity(options.initialCapacity
                               || optionDefaults.initialCapacity);
        });
    }

    #logImpl(level,...args){
      if(this.#verbosity>level) loggers[level](this.vfsName+":",...args);
    };
    log(...args){this.#logImpl(2, ...args)};
    warn(...args){this.#logImpl(1, ...args)};
    error(...args){this.#logImpl(0, ...args)};

    getVfs(){return this.#cVfs}

    
    getCapacity(){return this.#mapSAHToName.size}

    
    getFileCount(){return this.#mapFilenameToSAH.size}

    
    getFileNames(){
      const rc = [];
      const iter = this.#mapFilenameToSAH.keys();
      for(const n of iter) rc.push(n);
      return rc;
    }












    
    async addCapacity(n){
      for(let i = 0; i < n; ++i){
        const name = getRandomName();
        const h = await this.#dhOpaque.getFileHandle(name, {create:true});
        const ah = await h.createSyncAccessHandle();
        this.#mapSAHToName.set(ah,name);
        this.setAssociatedPath(ah, '', 0);
        
      }
      return this.getCapacity();
    }

    
    async reduceCapacity(n){
      let nRm = 0;
      for(const ah of Array.from(this.#availableSAH)){
        if(nRm === n || this.getFileCount() === this.getCapacity()){
          break;
        }
        const name = this.#mapSAHToName.get(ah);
        
        ah.close();
        await this.#dhOpaque.removeEntry(name);
        this.#mapSAHToName.delete(ah);
        this.#availableSAH.delete(ah);
        ++nRm;
      }
      return nRm;
    }

    
    releaseAccessHandles(){
      for(const ah of this.#mapSAHToName.keys()) ah.close();
      this.#mapSAHToName.clear();
      this.#mapFilenameToSAH.clear();
      this.#availableSAH.clear();
    }

    
    async acquireAccessHandles(clearFiles){
      const files = [];
      for await (const [name,h] of this.#dhOpaque){
        if('file'===h.kind){
          files.push([name,h]);
        }
      }
      return Promise.all(files.map(async([name,h])=>{
        try{
          const ah = await h.createSyncAccessHandle()
          this.#mapSAHToName.set(ah, name);
          if(clearFiles){
            ah.truncate(HEADER_OFFSET_DATA);
            this.setAssociatedPath(ah, '', 0);
          }else{
            const path = this.getAssociatedPath(ah);
            if(path){
              this.#mapFilenameToSAH.set(path, ah);
            }else{
              this.#availableSAH.add(ah);
            }
          }
        }catch(e){
          this.storeErr(e);
          this.releaseAccessHandles();
          throw e;
        }
      }));
    }

    
    getAssociatedPath(sah){
      sah.read(this.#apBody, {at: 0});
      
      
      const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
      if(this.#apBody[0] &&
         ((flags & capi.SQLITE_OPEN_DELETEONCLOSE) ||
          (flags & PERSISTENT_FILE_TYPES)===0)){
        warn(`Removing file with unexpected flags ${flags.toString(16)}`,
             this.#apBody);
        this.setAssociatedPath(sah, '', 0);
        return '';
      }

      const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
      sah.read(fileDigest, {at: HEADER_OFFSET_DIGEST});
      const compDigest = this.computeDigest(this.#apBody);
      if(fileDigest.every((v,i) => v===compDigest[i])){
        
        const pathBytes = this.#apBody.findIndex((v)=>0===v);
        if(0===pathBytes){
          
          
          sah.truncate(HEADER_OFFSET_DATA);
        }
        return pathBytes
          ? textDecoder.decode(this.#apBody.subarray(0,pathBytes))
          : '';
      }else{
        
        warn('Disassociating file with bad digest.');
        this.setAssociatedPath(sah, '', 0);
        return '';
      }
    }

    
    setAssociatedPath(sah, path, flags){
      const enc = textEncoder.encodeInto(path, this.#apBody);
      if(HEADER_MAX_PATH_SIZE <= enc.written + 1){
        toss("Path too long:",path);
      }
      this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
      this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);

      const digest = this.computeDigest(this.#apBody);
      sah.write(this.#apBody, {at: 0});
      sah.write(digest, {at: HEADER_OFFSET_DIGEST});
      sah.flush();

      if(path){
        this.#mapFilenameToSAH.set(path, sah);
        this.#availableSAH.delete(sah);
      }else{
        
        sah.truncate(HEADER_OFFSET_DATA);
        this.#availableSAH.add(sah);
      }
    }

    
    computeDigest(byteArray){
      let h1 = 0xdeadbeef;
      let h2 = 0x41c6ce57;
      for(const v of byteArray){
        h1 = 31 * h1 + (v * 307);
        h2 = 31 * h2 + (v * 307);
      }
      return new Uint32Array([h1>>>0, h2>>>0]);
    }

    
    async reset(clearFiles){
      await this.isReady;
      let h = await navigator.storage.getDirectory();
      let prev, prevName;
      for(const d of this.vfsDir.split('/')){
        if(d){
          prev = h;
          h = await h.getDirectoryHandle(d,{create:true});
        }
      }
      this.#dhVfsRoot = h;
      this.#dhVfsParent = prev;
      this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
        OPAQUE_DIR_NAME,{create:true}
      );
      this.releaseAccessHandles();
      return this.acquireAccessHandles(clearFiles);
    }

    
    getPath(arg) {
      if(wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);
      return ((arg instanceof URL)
              ? arg
              : new URL(arg, 'file://localhost/')).pathname;
    }

    
    deletePath(path) {
      const sah = this.#mapFilenameToSAH.get(path);
      if(sah) {
        
        this.#mapFilenameToSAH.delete(path);
        this.setAssociatedPath(sah, '', 0);
      }
      return !!sah;
    }

    
    storeErr(e,code){
      if(e){
        e.sqlite3Rc = code || capi.SQLITE_IOERR;
        this.error(e);
      }
      this.$error = e;
      return code;
    }
    
    popErr(){
      const rc = this.$error;
      this.$error = undefined;
      return rc;
    }

    
    nextAvailableSAH(){
      const [rc] = this.#availableSAH.keys();
      return rc;
    }

    
    getOFileForS3File(pFile){
      return this.#mapS3FileToOFile_.get(pFile);
    }
    
    mapS3FileToOFile(pFile,file){
      if(file){
        this.#mapS3FileToOFile_.set(pFile, file);
        setPoolForPFile(pFile, this);
      }else{
        this.#mapS3FileToOFile_.delete(pFile);
        setPoolForPFile(pFile, false);
      }
    }

    
    hasFilename(name){
      return this.#mapFilenameToSAH.has(name)
    }

    
    getSAHForPath(path){
      return this.#mapFilenameToSAH.get(path);
    }

    
    async removeVfs(){
      if(!this.#cVfs.pointer || !this.#dhOpaque) return false;
      capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
      this.#cVfs.dispose();
      try{
        this.releaseAccessHandles();
        await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {recursive: true});
        this.#dhOpaque = undefined;
        await this.#dhVfsParent.removeEntry(
          this.#dhVfsRoot.name, {recursive: true}
        );
        this.#dhVfsRoot = this.#dhVfsParent = undefined;
      }catch(e){
        sqlite3.config.error(this.vfsName,"removeVfs() failed:",e);
        
      }
      return true;
    }


    
    exportFile(name){
      const sah = this.#mapFilenameToSAH.get(name) || toss("File not found:",name);
      const n = sah.getSize() - HEADER_OFFSET_DATA;
      const b = new Uint8Array(n>0 ? n : 0);
      if(n>0){
        const nRead = sah.read(b, {at: HEADER_OFFSET_DATA});
        if(nRead != n){
          toss("Expected to read "+n+" bytes but read "+nRead+".");
        }
      }
      return b;
    }

    
    async importDbChunked(name, callback){
      const sah = this.#mapFilenameToSAH.get(name)
            || this.nextAvailableSAH()
            || toss("No available handles to import to.");
      sah.truncate(0);
      let nWrote = 0, chunk, checkedHeader = false, err = false;
      try{
        while( undefined !== (chunk = await callback()) ){
          if(chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
          if( 0===nWrote && chunk.byteLength>=15 ){
            util.affirmDbHeader(chunk);
            checkedHeader = true;
          }
          sah.write(chunk, {at:  HEADER_OFFSET_DATA + nWrote});
          nWrote += chunk.byteLength;
        }
        if( nWrote < 512 || 0!==nWrote % 512 ){
          toss("Input size",nWrote,"is not correct for an SQLite database.");
        }
        if( !checkedHeader ){
          const header = new Uint8Array(20);
          sah.read( header, {at: 0} );
          util.affirmDbHeader( header );
        }
        sah.write(new Uint8Array([1,1]), {
          at: HEADER_OFFSET_DATA + 18
        });
      }catch(e){
        this.setAssociatedPath(sah, '', 0);
        throw e;
      }
      this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
      return nWrote;
    }

    
    importDb(name, bytes){
      if( bytes instanceof ArrayBuffer ) bytes = new Uint8Array(bytes);
      else if( bytes instanceof Function ) return this.importDbChunked(name, bytes);
      const sah = this.#mapFilenameToSAH.get(name)
            || this.nextAvailableSAH()
            || toss("No available handles to import to.");
      const n = bytes.byteLength;
      if(n<512 || n%512!=0){
        toss("Byte array size is invalid for an SQLite db.");
      }
      const header = "SQLite format 3";
      for(let i = 0; i < header.length; ++i){
        if( header.charCodeAt(i) !== bytes[i] ){
          toss("Input does not contain an SQLite database header.");
        }
      }
      const nWrote = sah.write(bytes, {at: HEADER_OFFSET_DATA});
      if(nWrote != n){
        this.setAssociatedPath(sah, '', 0);
        toss("Expected to write "+n+" bytes but wrote "+nWrote+".");
      }else{
        sah.write(new Uint8Array([1,1]), {at: HEADER_OFFSET_DATA+18}
                   );
        this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
      }
      return nWrote;
    }

  };


  
  class OpfsSAHPoolUtil {
    
    #p;

    constructor(sahPool){
      this.#p = sahPool;
      this.vfsName = sahPool.vfsName;
    }

    async addCapacity(n){ return this.#p.addCapacity(n) }

    async reduceCapacity(n){ return this.#p.reduceCapacity(n) }

    getCapacity(){ return this.#p.getCapacity(this.#p) }

    getFileCount(){ return this.#p.getFileCount() }
    getFileNames(){ return this.#p.getFileNames() }

    async reserveMinimumCapacity(min){
      const c = this.#p.getCapacity();
      return (c < min) ? this.#p.addCapacity(min - c) : c;
    }

    exportFile(name){ return this.#p.exportFile(name) }

    importDb(name, bytes){ return this.#p.importDb(name,bytes) }

    async wipeFiles(){ return this.#p.reset(true) }

    unlink(filename){ return this.#p.deletePath(filename) }

    async removeVfs(){ return this.#p.removeVfs() }

  };

  
  const apiVersionCheck = async ()=>{
    const dh = await navigator.storage.getDirectory();
    const fn = '.opfs-sahpool-sync-check-'+getRandomName();
    const fh = await dh.getFileHandle(fn, { create: true });
    const ah = await fh.createSyncAccessHandle();
    const close = ah.close();
    await close;
    await dh.removeEntry(fn);
    if(close?.then){
      toss("The local OPFS API is too old for opfs-sahpool:",
           "it has an async FileSystemSyncAccessHandle.close() method.");
    }
    return true;
  };

  
  let instanceCounter = 0;

  
  sqlite3.installOpfsSAHPoolVfs = async function(options=Object.create(null)){
    const vfsName = options.name || optionDefaults.name;
    if(false){}
    if(initPromises[vfsName]){
      
      return initPromises[vfsName];
    }
    if(!globalThis.FileSystemHandle ||
       !globalThis.FileSystemDirectoryHandle ||
       !globalThis.FileSystemFileHandle ||
       !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
       !navigator?.storage?.getDirectory){
      return (initPromises[vfsName] = Promise.reject(new Error("Missing required OPFS APIs.")));
    }

    
    return initPromises[vfsName] = apiVersionCheck().then(async function(){
      if(options.$testThrowInInit){
        throw options.$testThrowInInit;
      }
      const thePool = new OpfsSAHPool(options);
      return thePool.isReady.then(async()=>{
        
        const poolUtil = new OpfsSAHPoolUtil(thePool);
        if(sqlite3.oo1){
          const oo1 = sqlite3.oo1;
          const theVfs = thePool.getVfs();
          const OpfsSAHPoolDb = function(...args){
            const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
            opt.vfs = theVfs.$zName;
            oo1.DB.dbCtorHelper.call(this, opt);
          };
          OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
          
          poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
          oo1.DB.dbCtorHelper.setVfsPostOpenSql(
            theVfs.pointer,
            function(oo1Db, sqlite3){
              sqlite3.capi.sqlite3_exec(oo1Db, [
                
                "pragma journal_mode=DELETE;",
                "pragma cache_size=-16384;"
              ], 0, 0, 0);
            }
          );
        }
        thePool.log("VFS initialized.");
        return poolUtil;
      }).catch(async (e)=>{
        await thePool.removeVfs().catch(()=>{});
        return e;
      });
    }).catch((err)=>{
      
      return initPromises[vfsName] = Promise.reject(err);
    });
  };
});



'use strict';
if('undefined' !== typeof Module){ 
  
  const SABC = Object.assign(
    Object.create(null), {
      exports: ('undefined'===typeof wasmExports)
        ? Module['asm']
        : wasmExports  ,
      memory: Module.wasmMemory 
    },
    globalThis.sqlite3ApiConfig || {}
  );

  
  
  globalThis.sqlite3ApiConfig = SABC;
  let sqlite3;
  try{
    sqlite3 = globalThis.sqlite3ApiBootstrap();
  }catch(e){
    console.error("sqlite3ApiBootstrap() error:",e);
    throw e;
  }finally{
    delete globalThis.sqlite3ApiBootstrap;
    delete globalThis.sqlite3ApiConfig;
  }

  Module.sqlite3 = sqlite3 ;
}else{
  console.warn("This is not running in an Emscripten module context, so",
               "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
               "of config info for the WASM environment.",
               "It must be called manually.");
}




});



  return sqlite3InitModule.ready
}
);
})();
if (true)
  module.exports = sqlite3InitModule;
else {}



(function(){
  
  const originalInit = sqlite3InitModule;
  if(!originalInit){
    throw new Error("Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.");
  }
  
  const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(Object.create(null),{
    moduleScript: globalThis?.document?.currentScript,
    isWorker: ('undefined' !== typeof WorkerGlobalScope),
    location: globalThis.location,
    urlParams:  globalThis?.location?.href
      ? new URL(globalThis.location.href).searchParams
      : new URLSearchParams()
  });
  initModuleState.debugModule =
    initModuleState.urlParams.has('sqlite3.debugModule')
    ? (...args)=>console.warn('sqlite3.debugModule:',...args)
    : ()=>{};

  if(initModuleState.urlParams.has('sqlite3.dir')){
    initModuleState.sqlite3Dir = initModuleState.urlParams.get('sqlite3.dir') +'/';
  }else if(initModuleState.moduleScript){
    const li = initModuleState.moduleScript.src.split('/');
    li.pop();
    initModuleState.sqlite3Dir = li.join('/') + '/';
  }

  globalThis.sqlite3InitModule = function ff(...args){
    
    return originalInit(...args).then((EmscriptenModule)=>{
      
      const s = EmscriptenModule.sqlite3;
      s.scriptInfo = initModuleState;
      
      if(ff.__isUnderTest) s.__isUnderTest = true;
      const f = s.asyncPostInit;
      delete s.asyncPostInit;
      return f();
    }).catch((e)=>{
      console.error("Exception loading sqlite3 module:",e);
      throw e;
    });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;

  if(globalThis.sqlite3InitModuleState.moduleScript){
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split('/');
    src.pop();
    sim.scriptDir = src.join('/') + '/';
  }
  initModuleState.debugModule('sqlite3InitModuleState =',initModuleState);
  if(false){}



  
  if (true){
    module.exports = sqlite3InitModule;
  }else {}
  
  return globalThis.sqlite3InitModule ;
})();


/***/ }),

/***/ "./src/pages/R1-02/CM/sqlite3.wasm":
/*!*****************************************!*\
  !*** ./src/pages/R1-02/CM/sqlite3.wasm ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "pages/R1-02/CM/sqlite3.wasm";

/***/ }),

/***/ "https://raw.githack.com/denis-migdal/LISS/main/index.js":
/*!**************************************************************************!*\
  !*** external "https://raw.githack.com/denis-migdal/LISS/main/index.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_https_raw_githack_com_denis_migdal_LISS_main_index_js_bb6a3cae__;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/async module */
/******/ (() => {
/******/ 	var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 	var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 	var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 	var resolveQueue = (queue) => {
/******/ 		if(queue && queue.d < 1) {
/******/ 			queue.d = 1;
/******/ 			queue.forEach((fn) => (fn.r--));
/******/ 			queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 		}
/******/ 	}
/******/ 	var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 		if(dep !== null && typeof dep === "object") {
/******/ 			if(dep[webpackQueues]) return dep;
/******/ 			if(dep.then) {
/******/ 				var queue = [];
/******/ 				queue.d = 0;
/******/ 				dep.then((r) => {
/******/ 					obj[webpackExports] = r;
/******/ 					resolveQueue(queue);
/******/ 				}, (e) => {
/******/ 					obj[webpackError] = e;
/******/ 					resolveQueue(queue);
/******/ 				});
/******/ 				var obj = {};
/******/ 				obj[webpackQueues] = (fn) => (fn(queue));
/******/ 				return obj;
/******/ 			}
/******/ 		}
/******/ 		var ret = {};
/******/ 		ret[webpackQueues] = x => {};
/******/ 		ret[webpackExports] = dep;
/******/ 		return ret;
/******/ 	}));
/******/ 	__webpack_require__.a = (module, body, hasAwait) => {
/******/ 		var queue;
/******/ 		hasAwait && ((queue = []).d = -1);
/******/ 		var depQueues = new Set();
/******/ 		var exports = module.exports;
/******/ 		var currentDeps;
/******/ 		var outerResolve;
/******/ 		var reject;
/******/ 		var promise = new Promise((resolve, rej) => {
/******/ 			reject = rej;
/******/ 			outerResolve = resolve;
/******/ 		});
/******/ 		promise[webpackExports] = exports;
/******/ 		promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 		module.exports = promise;
/******/ 		body((deps) => {
/******/ 			currentDeps = wrapDeps(deps);
/******/ 			var fn;
/******/ 			var getResult = () => (currentDeps.map((d) => {
/******/ 				if(d[webpackError]) throw d[webpackError];
/******/ 				return d[webpackExports];
/******/ 			}))
/******/ 			var promise = new Promise((resolve) => {
/******/ 				fn = () => (resolve(getResult));
/******/ 				fn.r = 0;
/******/ 				var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 				currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 			});
/******/ 			return fn.r ? promise : getResult();
/******/ 		}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 		queue && queue.d < 0 && (queue.d = 0);
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	__webpack_require__.p = "";
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module used 'module' so it can't be inlined
/******/ __webpack_require__("./src/pages/R1-02/CM/index.ts");
/******/ __webpack_require__("./src/pages/R1-02/CM/index.css");
/******/ var __webpack_exports__ = __webpack_require__("./src/pages/R1-02/CM/index.md");
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVILDZCQUE2QixnREFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtB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QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQ0FBaUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQyw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDZCQUE2QjtBQUM3QixVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0EsWUFBWTtBQUNaLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRCx5Q0FBeUMsUUFBUTtBQUNqRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUJBQWlCOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBLHVDQUF1QztBQUN2QyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNERBQTREO0FBQzVELHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw2REFBNkQ7QUFDN0QsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUMsQ0FBQyxFQUtKO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCLFNBQVM7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsZUFBZTtBQUNmLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBOzs7QUFHQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLEtBQUMsQ0FBQyxFQWdCSjs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxLQUEwRCxDQUFDLEVBRzdEOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFDLEdBQUcsQ0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFLHVDQUF1Qyw0Q0FBNEM7QUFDbkYsdUNBQXVDLDRDQUE0QztBQUNuRix1Q0FBdUMsd0NBQXdDO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNENBQTRDO0FBQ25GLHVDQUF1Qyw0Q0FBNEM7QUFDbkYsdUNBQXVDLDRDQUE0QztBQUNuRix1Q0FBdUMsK0NBQStDO0FBQ3RGLHVDQUF1Qyx3Q0FBd0M7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLHFCQUFxQjtBQUNyQixDQUFDOzs7O0FBSUQ7QUFDQSwyQkFBMkI7QUFDM0IsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPLFdBQVc7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFDLEVBQUUsRUFDMkU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLDBDQUEwQztBQUNwRSxDQUFDLE9BQU8sUUFBUTtBQUNoQixDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUMsaUNBQWlDLENBQUs7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFD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QTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBOztTQUVBO1NBQ0E7O1NBRUE7U0FDQTtTQUNBOzs7OztVQ3RCQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLElBQUk7VUFDSjtVQUNBO1VBQ0EsSUFBSTtVQUNKO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLENBQUM7VUFDRDtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsRUFBRTtVQUNGO1VBQ0Esc0dBQXNHO1VBQ3RHO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsR0FBRztVQUNIO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQSxHQUFHO1VBQ0g7VUFDQSxFQUFFO1VBQ0Y7VUFDQTs7Ozs7VUNoRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLGlDQUFpQyxXQUFXO1VBQzVDO1VBQ0E7Ozs7O1VDUEE7VUFDQTtVQUNBO1VBQ0E7VUFDQSx5Q0FBeUMsd0NBQXdDO1VBQ2pGO1VBQ0E7VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7O1VDTkE7Ozs7O1NFQUE7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvcGFnZXMvUjEtMDIvQ00vaW5kZXguY3NzPzQ0YjIiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvcGFnZXMvUjEtMDIvQ00vaW5kZXgubWQiLCJ3ZWJwYWNrOi8vQ291cnMvLi9saWJzL0xJU1MvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvcGFnZXMvUjEtMDIvQ00vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvc3RydWN0L1NRTGl0ZS50cyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3QvY29udGVudC50cyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3QvbWVudS50cyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3Qvc3RydWN0LnRzIiwid2VicGFjazovL0NvdXJzLy4vc3JjL3N0cnVjdC9hbmltLXBsYXllci5qcyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3Qvc3FsLWR5bS10YWJsZS5qcyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3Qvc3FsLWludGVyYWN0aXZlLmpzIiwid2VicGFjazovL0NvdXJzLy4vc3JjL3N0cnVjdC9zcWxpdGUvc3FsaXRlMy5qcyIsIndlYnBhY2s6Ly9Db3Vycy9leHRlcm5hbCBtb2R1bGUgXCJodHRwczovL3Jhdy5naXRoYWNrLmNvbS9kZW5pcy1taWdkYWwvTElTUy9tYWluL2luZGV4LmpzXCIiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ydW50aW1lL2FzeW5jIG1vZHVsZSIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwicGFnZXMvUjEtMDIvQ00vaW5kZXguaHRtbFwiOyIsIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgZXhwb3J0ZWQgdHlwZXMgPT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLypcbnR5cGUgUzxBLEI+ID0ge1xuXHRBOiBBLFxuXHRCOiBCXG59O1xudHlwZSBMSCA9IFM8dW5rbm93bix1bmtub3duPjtcblxudHlwZSBpbmZlckE8VD4gPSBUIGV4dGVuZHMgUzxpbmZlciBBLCBhbnk+ID8gQSA6IG5ldmVyO1xuXG5mdW5jdGlvbiBmb288VCBleHRlbmRzIExIPih0OiBUKTogaW5mZXJBPFQ+IHtcblx0cmV0dXJuIHQuQSBhcyBpbmZlckE8VD47XG59XG5cbmxldCBYID0ge1xuXHRBOiAzMixcblx0QjogXCJzdHJcIlxufTtcblxubGV0IGMgPSBmb28oWCk7XG4qL1xuXG5leHBvcnQgdHlwZSBDU1NfUmVzb3VyY2UgPSBzdHJpbmd8UmVzcG9uc2V8SFRNTFN0eWxlRWxlbWVudHxDU1NTdHlsZVNoZWV0O1xuZXhwb3J0IHR5cGUgQ1NTX1NvdXJjZSAgID0gQ1NTX1Jlc291cmNlIHwgUHJvbWlzZTxDU1NfUmVzb3VyY2U+O1xuXG5leHBvcnQgdHlwZSBIVE1MX1Jlc291cmNlID0gc3RyaW5nfFJlc3BvbnNlfEhUTUxUZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnQgdHlwZSBIVE1MX1NvdXJjZSAgID0gSFRNTF9SZXNvdXJjZSB8IFByb21pc2U8SFRNTF9SZXNvdXJjZT47XG5cbmV4cG9ydCB0eXBlIExJU1NPcHRpb25zPEV4dGVuZHMgICAgZXh0ZW5kcyBDbGFzcyxcblx0XHRcdFx0XHRcdEhvc3QgICAgICAgZXh0ZW5kcyBIVE1MRWxlbWVudCxcblx0XHRcdFx0XHRcdEF0dHJzICAgICAgZXh0ZW5kcyBzdHJpbmcsXG5cdFx0XHRcdFx0XHRQYXJhbWV0ZXJzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4gPSB7XG5cblx0ZXh0ZW5kcz86IENvbnN0cnVjdG9yPEV4dGVuZHM+LFxuXHRob3N0ICAgPzogQ29uc3RydWN0b3I8SG9zdD4sXG5cblx0ZGVwZW5kZW5jaWVzPzogcmVhZG9ubHkgUHJvbWlzZTxhbnk+W10sXG5cdGF0dHJpYnV0ZXMgID86IHJlYWRvbmx5IEF0dHJzW10sXG5cdHBhcmFtcyAgICAgID86IFJlYWRvbmx5PFBhcmFtZXRlcnM+LFxuXG5cdGNvbnRlbnQ/OiBIVE1MX1NvdXJjZSxcblx0Y3NzICAgID86ICBDU1NfU291cmNlIHwgcmVhZG9ubHkgQ1NTX1NvdXJjZVtdLFxuXHRzaGFkb3cgPzogIFNoYWRvd0NmZyxcbn07XG5cbmV4cG9ydCBlbnVtIFNoYWRvd0NmZyB7XG5cdE5PTkUgPSAnbm9uZScsXG5cdE9QRU4gPSAnb3BlbicsIFxuXHRDTE9TRT0gJ2Nsb3NlZCdcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgQ2xhc3MgPT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxubGV0IF9fY3N0cl9ob3N0ICA6IGFueSA9IG51bGw7XG5cbnR5cGUgQ29uc3RydWN0b3I8VD4gPSBuZXcgKCkgPT4gVDtcbmludGVyZmFjZSBDbGFzcyB7fVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9hdHRhY2hTaGFkb3dcbmNvbnN0IENBTl9IQVZFX1NIQURPVyA9IFtcblx0bnVsbCwgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2RpdicsXG5cdCdmb290ZXInLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ21haW4nLFxuXHQnbmF2JywgJ3AnLCAnc2VjdGlvbicsICdzcGFuJ1xuXHRcbl07XG5mdW5jdGlvbiBfY2FuSGFzU2hhZG93KHRhZzogdHlwZW9mIEhUTUxFbGVtZW50KSB7XG5cdHJldHVybiBDQU5fSEFWRV9TSEFET1cuaW5jbHVkZXMoIF9lbGVtZW50MnRhZ25hbWUodGFnKSApO1xufVxuXG50eXBlIFJlc291cmNlID0gVVJMfFJlc3BvbnNlO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExJU1M8RXh0ZW5kcyAgICBleHRlbmRzIENsYXNzICAgICAgICAgICAgICA9IENsYXNzLFxuXHRcdFx0XHRcdFx0XHQgSG9zdCAgICAgICBleHRlbmRzIEhUTUxFbGVtZW50ICAgICAgICA9IEhUTUxFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHQgQXR0cnMgICAgICBleHRlbmRzIHN0cmluZyAgICAgICAgICAgICA9IG5ldmVyLFxuXHRcdFx0XHRcdFx0XHQgUGFyYW1ldGVycyBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55PiA9IHt9Pih7XG5cdFx0XHRcdFx0XHRcdFx0ZXh0ZW5kcyAgICAgOiBwX2V4dGVuZHMsXG5cdFx0XHRcdFx0XHRcdFx0aG9zdCAgICAgICAgOiBwX2hvc3QsXG5cdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzOiBwX2RlcHMsXG5cdFx0XHRcdFx0XHRcdCAgICBhdHRyaWJ1dGVzICA6IHBfYXR0cnMsXG5cdFx0XHRcdFx0XHRcdCAgICBwYXJhbXMsXG5cdFx0XHRcdFx0XHRcdFx0Y29udGVudCxcblx0XHRcdFx0XHRcdFx0XHRjc3MsXG5cdFx0XHRcdFx0XHRcdFx0c2hhZG93ICAgICAgOiBwX3NoYWRvdyxcblx0XHRcdFx0XHRcdFx0fTogTElTU09wdGlvbnM8RXh0ZW5kcywgSG9zdCwgQXR0cnMsIFBhcmFtZXRlcnM+ID0ge30pIHtcblxuXHQvL1RPRE8gbWVyZ2UgcHJvcCBpZiBleHRlbmRzIExJU1MuLi5cblxuXHRjb25zdCBob3N0ICAgICAgICA9IHBfaG9zdCAgICA/PyBIVE1MRWxlbWVudCBhcyBDb25zdHJ1Y3RvcjxIb3N0Pjtcblx0Y29uc3QgX2V4dGVuZHMgICAgPSBwX2V4dGVuZHMgPz8gT2JqZWN0ICAgICAgYXMgdW5rbm93biBhcyBDb25zdHJ1Y3RvcjxFeHRlbmRzPjtcblx0Y29uc3QgYXR0cmlidXRlcyAgPSBwX2F0dHJzICAgPz8gW107XG5cdGNvbnN0IGRlcGVuZGVuY2llcz0gcF9kZXBzICAgID8gWy4uLnBfZGVwc10gOiBbXTtcblx0Y29uc3QgY2FuSGFzU2hhZG93PSBfY2FuSGFzU2hhZG93KGhvc3QpO1xuXHRjb25zdCBzaGFkb3cgICAgICA9IHBfc2hhZG93ICA/PyAoY2FuSGFzU2hhZG93ID8gU2hhZG93Q2ZnLkNMT1NFIDogU2hhZG93Q2ZnLk5PTkUpO1xuXG5cdGlmKCAhIGNhbkhhc1NoYWRvdyAmJiBzaGFkb3cgIT09IFNoYWRvd0NmZy5OT05FKVxuXHRcdHRocm93IG5ldyBFcnJvcihgSG9zdCBlbGVtZW50ICR7X2VsZW1lbnQydGFnbmFtZShob3N0KX0gZG9lcyBub3Qgc3VwcG9ydCBTaGFkb3dSb290YCk7XG5cblx0Ly8gQ09OVEVOVCBwcm9jZXNzaW5nXG5cdGlmKCBjb250ZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRkZXBlbmRlbmNpZXMucHVzaCggKCBhc3luYyAoKSA9PiB7XG5cblx0XHRcdGNvbnRlbnQgPSBhd2FpdCBjb250ZW50O1xuXG5cdFx0XHRpZihjb250ZW50IGluc3RhbmNlb2YgSFRNTFRlbXBsYXRlRWxlbWVudClcblx0XHRcdGNvbnRlbnQgPSBjb250ZW50LmlubmVySFRNTDtcblxuXHRcdFx0aWYoIHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG5cblx0XHRcdFx0Y29udGVudCA9IGNvbnRlbnQudHJpbSgpOyAvLyBOZXZlciByZXR1cm4gYSB0ZXh0IG5vZGUgb2Ygd2hpdGVzcGFjZSBhcyB0aGUgcmVzdWx0XG5cdFx0XHRcdGlmKGNvbnRlbnQgPT09ICcnKVxuXHRcdFx0XHRcdGNvbnRlbnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdH1cblx0XHRcdGlmKCBjb250ZW50IGluc3RhbmNlb2YgUmVzcG9uc2UgKVxuXHRcdFx0XHRjb250ZW50ID0gYXdhaXQgY29udGVudC50ZXh0KCk7XG5cblx0XHRcdHJldHVybiBMSVNTQmFzZS5QYXJhbWV0ZXJzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdH0pKCkgKTtcblx0fVxuXG5cdC8vIENTUyBwcm9jZXNzaW5nXG5cdGxldCBzdHlsZXNoZWV0czogcmVhZG9ubHkgQ1NTU3R5bGVTaGVldFtdID0gW107XG5cdGlmKCBjc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmKCAhIEFycmF5LmlzQXJyYXkoY3NzKSApXG5cdFx0XHRjc3MgPSBbY3NzIGFzIENTU19Tb3VyY2VdO1xuXG5cdFx0c3R5bGVzaGVldHMgPSBuZXcgQXJyYXk8Q1NTU3R5bGVTaGVldD4oY3NzLmxlbmd0aCk7XG5cblx0XHRjb25zdCBmZXRjaF9jc3MgPSAoYXN5bmMgKGNzczogQ1NTX1NvdXJjZSkgPT4ge1xuXHRcdFx0Y3NzID0gYXdhaXQgY3NzO1xuXHRcdFx0aWYoY3NzIGluc3RhbmNlb2YgQ1NTU3R5bGVTaGVldClcblx0XHRcdFx0cmV0dXJuIGNzcztcblx0XHRcdGlmKCBjc3MgaW5zdGFuY2VvZiBIVE1MU3R5bGVFbGVtZW50KVxuXHRcdFx0XHRyZXR1cm4gY3NzLnNoZWV0ITtcblxuXHRcdFx0bGV0IHN0eWxlID0gbmV3IENTU1N0eWxlU2hlZXQoKTtcblx0XHRcdGlmKCB0eXBlb2YgY3NzID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRhd2FpdCBzdHlsZS5yZXBsYWNlKGNzcyk7XG5cdFx0XHRcdHJldHVybiBzdHlsZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9pZiggY3NzIGluc3RhbmNlb2YgUmVzcG9uc2UgKVxuXHRcdFx0YXdhaXQgc3R5bGUucmVwbGFjZShhd2FpdCBjc3MudGV4dCgpKTtcblx0XHRcdHJldHVybiBzdHlsZTtcblx0XHR9KTtcblxuXHRcdGRlcGVuZGVuY2llcy5wdXNoKCAuLi5jc3MubWFwKCBhc3luYyAoY3NzLCBpZHgpID0+ICAoc3R5bGVzaGVldHMgYXMgYW55KVtpZHhdID0gYXdhaXQgZmV0Y2hfY3NzKGNzcykgKSApO1xuXHR9XG5cblx0dHlwZSBMSG9zdCA9IExJU1NIb3N0PExJU1NCYXNlPjtcblxuXHQvLyBAdHMtaWdub3JlXG5cdGNsYXNzIExJU1NCYXNlIGV4dGVuZHMgX2V4dGVuZHMge1xuXG5cdFx0cmVhZG9ubHkgI2hvc3Q6IGFueTsgLy8gcHJldmVudHMgaXNzdWUgIzEuLi5cblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXG5cdFx0XHQvLyBoNGNrLCBva2F5IGJlY2F1c2UgSlMgaXMgbW9ub3RocmVhZGVkLlxuXHRcdFx0aWYoIF9fY3N0cl9ob3N0ID09PSBudWxsIClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIGRvIG5vdCBkaXJlY3RseSBjYWxsIHRoaXMgY29uc3RydWN0b3JcIik7XG5cdFx0XHR0aGlzLiNob3N0ID0gX19jc3RyX2hvc3Q7XG5cdFx0XHRfX2NzdHJfaG9zdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cHVibGljIGdldCBob3N0KCk6IEhvc3Qge1xuXHRcdFx0cmV0dXJuIHRoaXMuI2hvc3Q7XG5cdFx0fVxuXHRcdHByb3RlY3RlZCBnZXQgYXR0cnMoKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuI2hvc3QgYXMgTEhvc3QpLmF0dHJzO1xuXHRcdH1cblx0XHRwcm90ZWN0ZWQgc2V0QXR0ckRlZmF1bHQoIGF0dHI6IEF0dHJzLCB2YWx1ZTogc3RyaW5nfG51bGwpIHtcblx0XHRcdHJldHVybiAodGhpcy4jaG9zdCBhcyBMSG9zdCkuc2V0QXR0ckRlZmF1bHQoYXR0ciwgdmFsdWUpO1xuXG5cdFx0fVxuXHRcdHB1YmxpYyBnZXQgcGFyYW1zKCk6IFJlYWRvbmx5PFBhcmFtZXRlcnM+IHtcblx0XHRcdHJldHVybiAodGhpcy4jaG9zdCBhcyBMSG9zdCkucGFyYW1zO1xuXHRcdH1cblx0XHRwdWJsaWMgc2V0UGFyYW08VCBleHRlbmRzIGtleW9mIFBhcmFtZXRlcnM+KG5hbWU6IFQsIHZhbHVlOiBQYXJhbWV0ZXJzW1RdKSB7XG5cdFx0XHQodGhpcy4jaG9zdCBhcyBMSG9zdCkucGFyYW1zW25hbWVdID0gdmFsdWU7XG5cdFx0fVxuXHRcdHByb3RlY3RlZCBnZXQgY29udGVudCgpIHtcblx0XHRcdHJldHVybiAodGhpcy4jaG9zdCBhcyBMSG9zdCkuY29udGVudCE7XG5cdFx0fVxuXG5cdFx0c3RhdGljIHJlYWRvbmx5IFBhcmFtZXRlcnMgPSB7XG5cdFx0XHRob3N0LFxuXHRcdFx0ZGVwZW5kZW5jaWVzLFxuXHRcdFx0YXR0cmlidXRlcyxcblx0XHRcdHBhcmFtcyxcblx0XHRcdGNvbnRlbnQsXG5cdFx0XHRzdHlsZXNoZWV0cyxcblx0XHRcdHNoYWRvdyxcblx0XHR9O1xuXG5cdFx0cHJvdGVjdGVkIG9uQXR0ckNoYW5nZWQoX25hbWU6IHN0cmluZyxcblx0XHRcdFx0XHRcdFx0XHRfb2xkVmFsdWU6IHN0cmluZyxcblx0XHRcdFx0XHRcdFx0XHRfbmV3VmFsdWU6IHN0cmluZyk6IHZvaWR8ZmFsc2Uge31cblxuXHRcdHB1YmxpYyBnZXQgaXNJbkRPTSgpIHtcblx0XHRcdHJldHVybiAodGhpcy4jaG9zdCBhcyBMSG9zdCkuaXNJbkRPTTtcblx0XHR9XG5cdFx0cHJvdGVjdGVkIG9uRE9NQ29ubmVjdGVkKCkge31cblx0XHRwcm90ZWN0ZWQgb25ET01EaXNjb25uZWN0ZWQoKSB7fVxuXHR9XG5cblx0cmV0dXJuIExJU1NCYXNlO1xufVxuXG4vL1RPRE86IG90aGVyIG9wdGlvbnMuLi5cbmZ1bmN0aW9uIGV4dGVuZHNMSVNTPEV4dGVuZHMgZXh0ZW5kcyBDbGFzcyxcblx0SG9zdCAgICBleHRlbmRzIEhUTUxFbGVtZW50LFxuXHRBdHRyczEgICBleHRlbmRzIHN0cmluZyxcblx0QXR0cnMyICAgZXh0ZW5kcyBzdHJpbmcsXG5cdFBhcmFtcyAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLGFueT4sXG5cdFQgZXh0ZW5kcyBMSVNTUmV0dXJuVHlwZTxFeHRlbmRzLCBIb3N0LCBBdHRyczEsIFBhcmFtcz4+KExpc3M6IFQsXG5cdFx0cGFyYW1ldGVyczoge1xuXHRcdFx0c2hhZG93ICAgICAgPzogU2hhZG93Q2ZnLFxuXHRcdFx0YXR0cmlidXRlcyAgPzogcmVhZG9ubHkgQXR0cnMyW10sXG5cdFx0XHRkZXBlbmRlbmNpZXM/OiByZWFkb25seSBQcm9taXNlPGFueT5bXVxuXHRcdH0pIHtcblxuXHRjb25zdCBhdHRyaWJ1dGVzICAgPSBbLi4uTGlzcy5QYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgICwgLi4ucGFyYW1ldGVycy5hdHRyaWJ1dGVzICA/P1tdXTtcblx0Y29uc3QgZGVwZW5kZW5jaWVzID0gWy4uLkxpc3MuUGFyYW1ldGVycy5kZXBlbmRlbmNpZXMsIC4uLnBhcmFtZXRlcnMuZGVwZW5kZW5jaWVzPz9bXV07XG5cblx0Y29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgTGlzcy5QYXJhbWV0ZXJzLCB7XG5cdFx0YXR0cmlidXRlcyxcblx0XHRkZXBlbmRlbmNpZXNcblx0fSk7XG5cdGlmKCBwYXJhbWV0ZXJzLnNoYWRvdyAhPT0gdW5kZWZpbmVkKVxuXHRcdHBhcmFtcy5zaGFkb3cgPSBwYXJhbWV0ZXJzLnNoYWRvdztcblxuXHQvLyBAdHMtaWdub3JlIDogYmVjYXVzZSBUUyBzdHVwaWRcblx0Y2xhc3MgRXh0ZW5kZWRMSVNTIGV4dGVuZHMgTGlzcyB7XG5cdFx0Y29uc3RydWN0b3IoLi4udDogYW55W10pIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgOiBiZWNhdXNlIFRTIHN0dXBpZFxuXHRcdFx0c3VwZXIoLi4udCk7XG5cdFx0fVxuXG5cdFx0cHJvdGVjdGVkIG92ZXJyaWRlIGdldCBhdHRycygpIHtcblx0XHRcdHJldHVybiBzdXBlci5hdHRycyBhcyBSZWNvcmQ8QXR0cnMyfEF0dHJzMSwgc3RyaW5nfG51bGw+O1xuXHRcdH1cblxuXHRcdHN0YXRpYyBvdmVycmlkZSBQYXJhbWV0ZXJzID0gcGFyYW1zO1xuXHR9XG5cblx0cmV0dXJuIEV4dGVuZGVkTElTUztcbn1cbkxJU1MuZXh0ZW5kc0xJU1MgPSBleHRlbmRzTElTUztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT0gTElTUyB0eXBlIGhlbHBlcnMgPT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50eXBlIGJ1aWxkTElTU0hvc3RSZXR1cm5UeXBlPFQ+ICA9IFQgZXh0ZW5kcyBMSVNTUmV0dXJuVHlwZTxpbmZlciBFeHRlbmRzIGV4dGVuZHMgQ2xhc3MsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmZlciBIb3N0ICAgIGV4dGVuZHMgSFRNTEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmZlciBBdHRycyAgIGV4dGVuZHMgc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5mZXIgUGFyYW1zICBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55Pj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdD8gUmV0dXJuVHlwZTx0eXBlb2YgYnVpbGRMSVNTSG9zdDxFeHRlbmRzLCBIb3N0LCBBdHRycywgUGFyYW1zLCBUPj4gOiBuZXZlcjtcblxuZXhwb3J0IHR5cGUgTElTU1JldHVyblR5cGU8XG5cdEV4dGVuZHMgZXh0ZW5kcyBDbGFzcyxcblx0SG9zdCAgICBleHRlbmRzIEhUTUxFbGVtZW50LFxuXHRBdHRycyAgIGV4dGVuZHMgc3RyaW5nLFxuXHRQYXJhbXMgIGV4dGVuZHMgUmVjb3JkPHN0cmluZyxhbnk+PiA9IFJldHVyblR5cGU8dHlwZW9mIExJU1M8RXh0ZW5kcywgSG9zdCwgQXR0cnMsIFBhcmFtcz4+O1xuZXhwb3J0IHR5cGUgTElTU0Jhc2U8RXh0ZW5kcyBleHRlbmRzIENsYXNzLFxuXHRcdFx0XHRcdCBIb3N0ICAgIGV4dGVuZHMgSFRNTEVsZW1lbnQsXG5cdFx0XHRcdFx0IEF0dHJzICAgZXh0ZW5kcyBzdHJpbmcsXG5cdFx0XHRcdFx0IFBhcmFtcyAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLGFueT4+ID0gSW5zdGFuY2VUeXBlPExJU1NSZXR1cm5UeXBlPEV4dGVuZHMsIEhvc3QsIEF0dHJzLCBQYXJhbXM+PjtcbmV4cG9ydCB0eXBlIExJU1NIb3N0PExJU1MgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+ID4gPSBJbnN0YW5jZVR5cGU8YnVpbGRMSVNTSG9zdFJldHVyblR5cGU8Q29uc3RydWN0b3I8TElTUz4gJiB7UGFyYW1ldGVyczogYW55fT4+O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTSG9zdCBjbGFzcyA9PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmxldCBpZCA9IDA7XG5cbmZ1bmN0aW9uIGJ1aWxkTElTU0hvc3Q8RXh0ZW5kcyBleHRlbmRzIENsYXNzLFxuXHRcdFx0XHRcdCAgIEhvc3QgICAgZXh0ZW5kcyBIVE1MRWxlbWVudCxcblx0XHRcdFx0XHQgICBBdHRycyAgIGV4dGVuZHMgc3RyaW5nLFxuXHRcdFx0XHRcdCAgIFBhcmFtcyAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLGFueT4sXG5cdFx0XHRcdFx0ICAgVCBleHRlbmRzIExJU1NSZXR1cm5UeXBlPEV4dGVuZHMsIEhvc3QsIEF0dHJzLCBQYXJhbXM+PihMaXNzOiBULCBfcGFyYW1zOiBQYXJ0aWFsPFBhcmFtcz4gPSB7fSkge1xuXHRjb25zdCB7XG5cdFx0aG9zdCxcblx0XHRhdHRyaWJ1dGVzLFxuXHRcdGNvbnRlbnQsXG5cdFx0c3R5bGVzaGVldHMsXG5cdFx0c2hhZG93LFxuXHR9ID0gTGlzcy5QYXJhbWV0ZXJzO1xuXG5cdGNvbnN0IGFscmVhZHlEZWNsYXJlZENTUyA9IG5ldyBTZXQoKTtcblxuXHRjb25zdCBHRVQgPSBTeW1ib2woJ2dldCcpO1xuXHRjb25zdCBTRVQgPSBTeW1ib2woJ3NldCcpO1xuXG5cdGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoIGF0dHJpYnV0ZXMubWFwKG4gPT4gW24sIHtcblxuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbigpOiBzdHJpbmd8bnVsbCAgICAgIHsgcmV0dXJuICh0aGlzIGFzIHVua25vd24gYXMgQXR0cmlidXRlcylbR0VUXShuKTsgfSxcblx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlOiBzdHJpbmd8bnVsbCkgeyByZXR1cm4gKHRoaXMgYXMgdW5rbm93biBhcyBBdHRyaWJ1dGVzKVtTRVRdKG4sIHZhbHVlKTsgfVxuXHR9XSkgKTtcblxuXHRjbGFzcyBBdHRyaWJ1dGVzIHtcbiAgICAgICAgW3g6IHN0cmluZ106IHN0cmluZ3xudWxsO1xuXG4gICAgICAgICNkYXRhICAgICA6IFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+O1xuICAgICAgICAjZGVmYXVsdHMgOiBSZWNvcmQ8QXR0cnMsIHN0cmluZ3xudWxsPjtcbiAgICAgICAgI3NldHRlciAgIDogKG5hbWU6IEF0dHJzLCB2YWx1ZTogc3RyaW5nfG51bGwpID0+IHZvaWQ7XG5cbiAgICAgICAgW0dFVF0obmFtZTogQXR0cnMpIHtcbiAgICAgICAgXHRyZXR1cm4gdGhpcy4jZGF0YVtuYW1lXSA/PyB0aGlzLiNkZWZhdWx0c1tuYW1lXSA/PyBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBbU0VUXShuYW1lOiBBdHRycywgdmFsdWU6IHN0cmluZ3xudWxsKXtcbiAgICAgICAgXHRyZXR1cm4gdGhpcy4jc2V0dGVyKG5hbWUsIHZhbHVlKTsgLy8gcmVxdWlyZWQgdG8gZ2V0IGEgY2xlYW4gb2JqZWN0IHdoZW4gZG9pbmcgey4uLmF0dHJzfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3RydWN0b3IoZGF0YSAgICA6IFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+LFxuXHRcdFx0XHRcdGRlZmF1bHRzOiBSZWNvcmQ8QXR0cnMsIHN0cmluZ3xudWxsPixcbiAgICAgICAgXHRcdFx0c2V0dGVyICA6IChuYW1lOiBBdHRycywgdmFsdWU6IHN0cmluZ3xudWxsKSA9PiB2b2lkKSB7XG5cbiAgICAgICAgXHR0aGlzLiNkYXRhICAgICA9IGRhdGE7XG5cdFx0XHR0aGlzLiNkZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICBcdHRoaXMuI3NldHRlciA9IHNldHRlcjtcblxuICAgICAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cdH1cblxuXHQvLyBAdHMtaWdub3JlIDogYmVjYXVzZSBUUyBpcyBzdHVwaWQuXG5cdGNsYXNzIExJU1NIb3N0QmFzZSBleHRlbmRzIGhvc3Qge1xuXG5cdFx0cmVhZG9ubHkgI3BhcmFtczogUGFyYW1zO1xuXG5cdFx0cmVhZG9ubHkgI2lkID0gKytpZDsgLy8gZm9yIGRlYnVnXG5cblx0XHRjb25zdHJ1Y3RvcihwYXJhbXM6IFBhcnRpYWw8UGFyYW1zPiA9IHt9KSB7XG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy4jcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgTGlzcy5QYXJhbWV0ZXJzLnBhcmFtcywgX3BhcmFtcywgcGFyYW1zKTtcblxuXHRcdFx0dGhpcy4jd2FpdEluaXQgPSBuZXcgUHJvbWlzZSggKHJlc29sdmUpID0+IHtcblx0XHRcdFx0aWYodGhpcy5pc0luaXQpXG5cdFx0XHRcdFx0cmV0dXJuIHJlc29sdmUodGhpcy4jQVBJISk7XG5cdFx0XHRcdHRoaXMuI3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqKiogcHVibGljIEFQSSAqKioqKioqKioqKioqL1xuXG5cdFx0Z2V0IGlzSW5pdCgpIHtcblx0XHRcdHJldHVybiB0aGlzLiNBUEkgIT09IG51bGw7XG5cdFx0fVxuXHRcdGluaXRpYWxpemUocGFyYW1zOiBQYXJ0aWFsPFBhcmFtcz4gPSB7fSkge1xuXG5cdFx0XHRpZiggdGhpcy5pc0luaXQgKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgYWxyZWFkeSBpbml0aWFsaXplZCEnKTtcblxuXHRcdFx0T2JqZWN0LmFzc2lnbih0aGlzLiNwYXJhbXMsIHBhcmFtcyk7XG5cblx0XHRcdGNvbnN0IGFwaSA9IHRoaXMuaW5pdCgpO1xuXG5cdFx0XHRpZiggdGhpcy4jaXNJbkRPTSApXG5cdFx0XHRcdChhcGkgYXMgYW55KS5vbkRPTUNvbm5lY3RlZCgpO1xuXG5cdFx0XHRyZXR1cm4gYXBpO1xuXHRcdH1cblxuXHRcdGdldCBMSVNTU3luYygpIHtcblx0XHRcdGlmKCAhIHRoaXMuaXNJbml0IClcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBY2Nlc3NpbmcgQVBJIGJlZm9yZSBXZWJDb21wb25lbnQgaW5pdGlhbGl6YXRpb24hJyk7XG5cdFx0XHRyZXR1cm4gdGhpcy4jQVBJITtcblx0XHR9XG5cdFx0Z2V0IExJU1MoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jd2FpdEluaXQ7XG5cdFx0fVxuXG5cdFx0LyoqKiBpbml0ICoqKi9cblx0XHQjd2FpdEluaXQ6IFByb21pc2U8SW5zdGFuY2VUeXBlPFQ+Pjtcblx0XHQjcmVzb2x2ZTogKCh1OiBJbnN0YW5jZVR5cGU8VD4pID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG5cdFx0I0FQSTogSW5zdGFuY2VUeXBlPFQ+IHwgbnVsbCA9IG51bGw7XG5cblx0XHQjaXNJbkRPTSA9IGZhbHNlO1xuXHRcdGdldCBpc0luRE9NKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI2lzSW5ET007XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiNpc0luRE9NID0gZmFsc2U7XG5cdFx0XHQodGhpcy4jQVBJISBhcyBhbnkpLm9uRE9NRGlzY29ubmVjdGVkKCk7XG5cdFx0fVxuXG5cdFx0Y29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cblx0XHRcdHRoaXMuI2lzSW5ET00gPSB0cnVlO1xuXHRcblx0XHRcdGlmKCAhIHRoaXMuaXNJbml0IClcblx0XHRcdFx0dGhpcy5pbml0KCk7XG5cblx0XHRcdCh0aGlzLiNBUEkhIGFzIGFueSkub25ET01Db25uZWN0ZWQoKTtcblx0XHR9XG5cblx0XHRwcml2YXRlIGluaXQoKSB7XG5cdFx0XHRcblx0XHRcdGN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUodGhpcyk7XG5cdFx0XHRcblx0XHRcdC8vIHNoYWRvd1xuXHRcdFx0dGhpcy4jY29udGVudCA9IHRoaXMgYXMgdW5rbm93biBhcyBIb3N0O1xuXHRcdFx0aWYoIHNoYWRvdyAhPT0gJ25vbmUnKSB7XG5cdFx0XHRcdHRoaXMuI2NvbnRlbnQgPSB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogc2hhZG93fSk7XG5cblx0XHRcdFx0Ly9AdHMtaWdub3JlXG5cdFx0XHRcdHRoaXMuI2NvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrRXZlbnQpO1xuXHRcdFx0XHQvL0B0cy1pZ25vcmVcblx0XHRcdFx0dGhpcy4jY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIG9uQ2xpY2tFdmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGF0dHJzXG5cdFx0XHRmb3IobGV0IG9icyBvZiBhdHRyaWJ1dGVzISlcblx0XHRcdFx0dGhpcy4jYXR0cmlidXRlc1tvYnNdID0gdGhpcy5nZXRBdHRyaWJ1dGUob2JzKTtcblxuXHRcdFx0Ly8gY3NzXG5cdFx0XHRpZiggc2hhZG93ICE9PSAnbm9uZScpXG5cdFx0XHRcdCh0aGlzLiNjb250ZW50IGFzIFNoYWRvd1Jvb3QpLmFkb3B0ZWRTdHlsZVNoZWV0cy5wdXNoKHNoYXJlZENTUyk7XG5cdFx0XHRpZiggc3R5bGVzaGVldHMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGlmKCBzaGFkb3cgIT09ICdub25lJylcblx0XHRcdFx0XHQodGhpcy4jY29udGVudCBhcyBTaGFkb3dSb290KS5hZG9wdGVkU3R5bGVTaGVldHMucHVzaCguLi5zdHlsZXNoZWV0cyk7XG5cdFx0XHRcdGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc3QgY3Nzc2VsZWN0b3IgPSB0aGlzLkNTU1NlbGVjdG9yO1xuXG5cdFx0XHRcdFx0Ly8gaWYgbm90IHlldCBpbnNlcnRlZCA6XG5cdFx0XHRcdFx0aWYoICEgYWxyZWFkeURlY2xhcmVkQ1NTLmhhcyhjc3NzZWxlY3RvcikgKSB7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cblx0XHRcdFx0XHRcdHN0eWxlLnNldEF0dHJpYnV0ZSgnZm9yJywgY3Nzc2VsZWN0b3IpO1xuXG5cdFx0XHRcdFx0XHRsZXQgaHRtbF9zdHlsZXNoZWV0cyA9IFwiXCI7XG5cblx0XHRcdFx0XHRcdGZvcihsZXQgc3R5bGUgb2Ygc3R5bGVzaGVldHMpXG5cdFx0XHRcdFx0XHRcdGZvcihsZXQgcnVsZSBvZiBzdHlsZS5jc3NSdWxlcylcblx0XHRcdFx0XHRcdFx0XHRodG1sX3N0eWxlc2hlZXRzICs9IHJ1bGUuY3NzVGV4dCArICdcXG4nO1xuXG5cdFx0XHRcdFx0XHRzdHlsZS5pbm5lckhUTUwgPSBodG1sX3N0eWxlc2hlZXRzLnJlcGxhY2UoJzpob3N0JywgYDppcygke2Nzc3NlbGVjdG9yfSlgKTtcblxuXHRcdFx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmQoc3R5bGUpO1xuXG5cdFx0XHRcdFx0XHRhbHJlYWR5RGVjbGFyZWRDU1MuYWRkKGNzc3NlbGVjdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29udGVudFxuXHRcdFx0aWYoIGNvbnRlbnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0bGV0IHRlbXBsYXRlX2VsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRcdFx0XHRsZXQgc3RyID0gKGNvbnRlbnQgYXMgc3RyaW5nKS5yZXBsYWNlKC9cXCRcXHsoLis/KVxcfS9nLCAoXywgbWF0Y2gpID0+IHRoaXMuZ2V0QXR0cmlidXRlKG1hdGNoKT8/JycpXG5cdCAgICBcdFx0dGVtcGxhdGVfZWxlbS5pbm5lckhUTUwgPSBzdHI7XG5cdCAgICBcdFx0dGhpcy4jY29udGVudC5hcHBlbmQoLi4udGVtcGxhdGVfZWxlbS5jb250ZW50LmNoaWxkTm9kZXMpO1xuXHQgICAgXHR9XG5cblx0ICAgIFx0Ly8gYnVpbGRcblxuXHQgICAgXHQvLyBoNGNrLCBva2F5IGJlY2F1c2UgSlMgaXMgbW9ub3RocmVhZGVkLlxuXHRcdFx0X19jc3RyX2hvc3QgICA9IHRoaXM7XG5cblx0ICAgIFx0bGV0IG9iaiA9IG5ldyBMaXNzKCk7XG5cblx0ICAgIFx0LyppZiggb2JqIGluc3RhbmNlb2YgUHJvbWlzZSlcblx0ICAgIFx0XHRvYmogPSBhd2FpdCBvYmo7Ki9cblxuXHRcdFx0dGhpcy4jQVBJID0gb2JqIGFzIEluc3RhbmNlVHlwZTxUPjtcblxuXHRcdFx0Ly8gZGVmYXVsdCBzbG90XG5cdFx0XHRpZiggdGhpcy5oYXNTaGFkb3cgJiYgdGhpcy4jY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCApXG5cdFx0XHRcdHRoaXMuI2NvbnRlbnQuYXBwZW5kKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzbG90JykgKTtcblxuXHRcdFx0aWYoIHRoaXMuI3Jlc29sdmUgIT09IG51bGwpXG5cdFx0XHRcdHRoaXMuI3Jlc29sdmUodGhpcy4jQVBJKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuI0FQSTtcblx0XHR9XG5cblx0XHRnZXQgcGFyYW1zKCk6IFBhcmFtcyB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jcGFyYW1zO1xuXHRcdH1cblx0XHRwdWJsaWMgc2V0UGFyYW08VCBleHRlbmRzIGtleW9mIFBhcmFtcz4obmFtZTogVCwgdmFsdWU6IFBhcmFtc1tUXSkge1xuXHRcdFx0aWYoIHRoaXMuaXNJbml0IClcblx0XHRcdFx0cmV0dXJuIHRoaXMuI0FQSSEuc2V0UGFyYW0obmFtZSwgdmFsdWUpO1xuXG5cdFx0XHR0aGlzLiNwYXJhbXNbbmFtZV0gPSB2YWx1ZTsgLy8gd2lsbCBiZSBnaXZlbiB0byBjb25zdHJ1Y3Rvci5cblx0XHR9XG5cblxuXHRcdC8qKiogY29udGVudCAqKiovXG5cdFx0I2NvbnRlbnQ6IEhvc3R8U2hhZG93Um9vdHxudWxsID0gbnVsbDtcblxuXHRcdGdldCBjb250ZW50KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI2NvbnRlbnQ7XG5cdFx0fVxuXG5cdFx0Z2V0UGFydChuYW1lOiBzdHJpbmcpIHtcblx0XHRcdHJldHVybiB0aGlzLmhhc1NoYWRvd1xuXHRcdFx0XHRcdD8gdGhpcy4jY29udGVudD8ucXVlcnlTZWxlY3RvcihgOjpwYXJ0KCR7bmFtZX0pYClcblx0XHRcdFx0XHQ6IHRoaXMuI2NvbnRlbnQ/LnF1ZXJ5U2VsZWN0b3IoYFtwYXJ0PVwiJHtuYW1lfVwiXWApO1xuXHRcdH1cblx0XHRnZXRQYXJ0cyhuYW1lOiBzdHJpbmcpIHtcblx0XHRcdHJldHVybiB0aGlzLmhhc1NoYWRvd1xuXHRcdFx0XHRcdD8gdGhpcy4jY29udGVudD8ucXVlcnlTZWxlY3RvckFsbChgOjpwYXJ0KCR7bmFtZX0pYClcblx0XHRcdFx0XHQ6IHRoaXMuI2NvbnRlbnQ/LnF1ZXJ5U2VsZWN0b3JBbGwoYFtwYXJ0PVwiJHtuYW1lfVwiXWApO1xuXHRcdH1cblxuXHRcdHByb3RlY3RlZCBnZXQgaGFzU2hhZG93KCk6IGJvb2xlYW4ge1xuXHRcdFx0cmV0dXJuIHNoYWRvdyAhPT0gJ25vbmUnO1xuXHRcdH1cblxuXHRcdC8qKiogQ1NTICoqKi9cblxuXHRcdGdldCBDU1NTZWxlY3RvcigpIHtcblxuXHRcdFx0aWYodGhpcy5oYXNTaGFkb3cgfHwgISB0aGlzLmhhc0F0dHJpYnV0ZShcImlzXCIpIClcblx0XHRcdFx0cmV0dXJuIHRoaXMudGFnTmFtZTtcblxuXHRcdFx0cmV0dXJuIGAke3RoaXMudGFnTmFtZX1baXM9XCIke3RoaXMuZ2V0QXR0cmlidXRlKFwiaXNcIil9XCJdYDtcblx0XHR9XG5cblx0XHQvKioqIGF0dHJzICoqKi9cblx0XHQjYXR0cnNfZmxhZyA9IGZhbHNlO1xuXG5cdFx0I2F0dHJpYnV0ZXMgICAgICAgICA9IHt9IGFzIFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+O1xuXHRcdCNhdHRyaWJ1dGVzRGVmYXVsdHMgPSB7fSBhcyBSZWNvcmQ8QXR0cnMsIHN0cmluZ3xudWxsPjtcblx0XHQjYXR0cnMgPSBuZXcgQXR0cmlidXRlcyhcblx0XHRcdHRoaXMuI2F0dHJpYnV0ZXMsXG5cdFx0XHR0aGlzLiNhdHRyaWJ1dGVzRGVmYXVsdHMsXG5cdFx0XHQobmFtZTogQXR0cnMsIHZhbHVlOnN0cmluZ3xudWxsKSA9PiB7XG5cblx0XHRcdFx0dGhpcy4jYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuI2F0dHJzX2ZsYWcgPSB0cnVlOyAvLyBkbyBub3QgdHJpZ2dlciBvbkF0dHJzQ2hhbmdlZC5cblx0XHRcdFx0aWYoIHZhbHVlID09PSBudWxsKVxuXHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdCkgYXMgdW5rbm93biBhcyBSZWNvcmQ8QXR0cnMsIHN0cmluZ3xudWxsPjtcblxuXHRcdHNldEF0dHJEZWZhdWx0KG5hbWU6IEF0dHJzLCB2YWx1ZTogc3RyaW5nfG51bGwpIHtcblx0XHRcdGlmKCB2YWx1ZSA9PT0gbnVsbClcblx0XHRcdFx0ZGVsZXRlIHRoaXMuI2F0dHJpYnV0ZXNEZWZhdWx0c1tuYW1lXTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy4jYXR0cmlidXRlc0RlZmF1bHRzW25hbWVdID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Z2V0IGF0dHJzKCk6IFJlYWRvbmx5PFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+PiB7XG5cblx0XHRcdHJldHVybiB0aGlzLiNhdHRycztcblx0XHR9XG5cblx0XHRzdGF0aWMgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblx0XHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSAgICA6IEF0dHJzLFxuXHRcdFx0XHRcdFx0XHRcdCBvbGRWYWx1ZTogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRcdCBuZXdWYWx1ZTogc3RyaW5nKSB7XG5cblx0XHRcdGlmKHRoaXMuI2F0dHJzX2ZsYWcpIHtcblx0XHRcdFx0dGhpcy4jYXR0cnNfZmxhZyA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuI2F0dHJpYnV0ZXNbbmFtZV0gPSBuZXdWYWx1ZTtcblx0XHRcdGlmKCAhIHRoaXMuaXNJbml0IClcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRpZiggKHRoaXMuI0FQSSEgYXMgYW55KS5vbkF0dHJDaGFuZ2VkKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuI2F0dHJzW25hbWVdID0gb2xkVmFsdWU7IC8vIHJldmVydCB0aGUgY2hhbmdlLlxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gTElTU0hvc3RCYXNlO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTIGRlZmluZSA9PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IF9ET01Db250ZW50TG9hZGVkID0gbmV3IFByb21pc2U8dm9pZD4oIChyZXNvbHZlKSA9PiB7XG5cblx0aWYoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJpbnRlcmFjdGl2ZVwiIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIilcblx0XHRyZXR1cm4gcmVzb2x2ZSgpO1xuXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG5cdFx0cmVzb2x2ZSgpO1xuXHR9LCB0cnVlKTtcbn0pO1xuXG5MSVNTLmRlZmluZSA9IGFzeW5jIGZ1bmN0aW9uPEV4dGVuZHMgZXh0ZW5kcyBDbGFzcyxcblx0XHRcdFx0XHRcdFx0IEhvc3QgICAgZXh0ZW5kcyBIVE1MRWxlbWVudCxcblx0XHRcdFx0XHRcdCAgICAgQXR0cnMgICBleHRlbmRzIHN0cmluZyxcblx0XHRcdFx0XHRcdCAgICAgUGFyYW1zICBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55Pixcblx0XHRcdFx0XHRcdCAgIFx0IFQgZXh0ZW5kcyBMSVNTUmV0dXJuVHlwZTxFeHRlbmRzLCBIb3N0LCBBdHRycywgUGFyYW1zPj4oXG5cdFx0XHRcdFx0XHQgICBcdHRhZ25hbWU6IHN0cmluZyxcblx0XHRcdFx0XHRcdFx0Q29tcG9uZW50Q2xhc3M6IFQsXG5cdFx0XHRcdFx0XHRcdHtkZXBlbmRlbmNpZXMsIHBhcmFtc306IHtwYXJhbXM/OiBQYXJ0aWFsPFBhcmFtcz4sIGRlcGVuZGVuY2llcz86IHJlYWRvbmx5IFByb21pc2U8c3RyaW5nPltdfSA9IHt9KSB7XG5cblx0ZGVwZW5kZW5jaWVzPz89W107XG5cdHBhcmFtcyAgICAgID8/PSB7fTtcblxuXHRjb25zdCBDbGFzcyA9IENvbXBvbmVudENsYXNzLlBhcmFtZXRlcnMuaG9zdDtcblx0bGV0IExJU1NCYXNlOiBhbnkgPSBDb21wb25lbnRDbGFzcztcblx0bGV0IGh0bWx0YWcgPSBfZWxlbWVudDJ0YWduYW1lKENsYXNzKT8/dW5kZWZpbmVkO1xuXG5cdGF3YWl0IFByb21pc2UuYWxsKFtfRE9NQ29udGVudExvYWRlZCwgLi4uZGVwZW5kZW5jaWVzLCAuLi5MSVNTQmFzZS5QYXJhbWV0ZXJzLmRlcGVuZGVuY2llc10pO1xuXG5cdGNvbnN0IExJU1NjbGFzcyA9IGJ1aWxkTElTU0hvc3Q8RXh0ZW5kcywgSG9zdCwgQXR0cnMsIFBhcmFtcywgVD4oQ29tcG9uZW50Q2xhc3MsIHBhcmFtcyk7XG5cdFxuXHRjb25zdCBvcHRzID0gaHRtbHRhZyA9PT0gdW5kZWZpbmVkID8ge31cblx0XHRcdFx0XHRcdFx0XHRcdCAgIDoge2V4dGVuZHM6IGh0bWx0YWd9O1xuXHRcblx0Y3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ25hbWUsIExJU1NjbGFzcywgb3B0cyk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTIFNoYWRvd1Jvb3QgdG9vbHMgPT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IHNoYXJlZENTUyA9IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG5kb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMucHVzaChzaGFyZWRDU1MpO1xuXG5MSVNTLmluc2VydEdsb2JhbENTU1J1bGVzID0gZnVuY3Rpb24oY3NzOiBzdHJpbmd8SFRNTFN0eWxlRWxlbWVudCkge1xuXG5cdGxldCBjc3Nfc3R5bGUhOiBDU1NTdHlsZVNoZWV0O1xuXG5cdGlmKCBjc3MgaW5zdGFuY2VvZiBIVE1MU3R5bGVFbGVtZW50IClcblx0XHRjc3Nfc3R5bGUgPSBjc3Muc2hlZXQhO1xuXHRpZiggdHlwZW9mIGNzcyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdGNzc19zdHlsZSA9IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG5cdFx0Y3NzX3N0eWxlLnJlcGxhY2VTeW5jKGNzcyk7XG5cdH1cblxuXHRmb3IobGV0IHJ1bGUgb2YgY3NzX3N0eWxlLmNzc1J1bGVzKVxuXHRcdHNoYXJlZENTUy5pbnNlcnRSdWxlKHJ1bGUuY3NzVGV4dCk7XG59XG5cbnR5cGUgRGVsZWdhdGVkSGFuZGxlciA9IFtzdHJpbmcsIChldjogTW91c2VFdmVudCkgPT4gdm9pZF07XG5jb25zdCBERUxFR0FURURfRVZFTlRTID0ge1xuXHRcImNsaWNrXCI6IFtdIGFzIERlbGVnYXRlZEhhbmRsZXJbXSxcblx0XCJkYmxjbGlja1wiOiBbXSBhcyBEZWxlZ2F0ZWRIYW5kbGVyW11cbn07XG5cbmNvbnN0IEFMUkVBRFlfUFJPQ0VTU0VEID0gU3ltYm9sKCk7XG5cbmZ1bmN0aW9uIG9uQ2xpY2tFdmVudChldjogTW91c2VFdmVudCkge1xuXG5cdGlmKCAoZXYgYXMgYW55KVtBTFJFQURZX1BST0NFU1NFRF0gPT09IHRydWUgKVxuXHRcdHJldHVybjtcblx0KGV2IGFzIGFueSlbQUxSRUFEWV9QUk9DRVNTRURdID0gdHJ1ZTtcblxuXHRjb25zdCBoYW5kbGVycyA9IERFTEVHQVRFRF9FVkVOVFNbZXYudHlwZSBhcyBrZXlvZiB0eXBlb2YgREVMRUdBVEVEX0VWRU5UU107XG5cblx0Zm9yKGxldCBlbGVtIG9mIGV2LmNvbXBvc2VkUGF0aCgpICkge1xuXHRcblx0XHRpZiggZWxlbSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgZWxlbSA9PT0gZG9jdW1lbnQgfHwgZWxlbSA9PT0gd2luZG93IClcblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0dmFyIHRhcmdldCA9IGVsZW0gYXMgRWxlbWVudDtcblxuXHRcdGZvcihsZXQgW3NlbGVjdG9yLCBoYW5kbGVyXSBvZiBoYW5kbGVycykge1xuXHRcdFx0aWYoIHRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSApXG5cdFx0XHRcdGhhbmRsZXIoZXYpO1xuXHRcdH1cblx0fVxufVxuXG5MSVNTLmluc2VydEdsb2JhbERlbGVnYXRlZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRfbmFtZToga2V5b2YgdHlwZW9mIERFTEVHQVRFRF9FVkVOVFMsIHNlbGVjdG9yOiBzdHJpbmcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdm9pZCApIHtcblx0REVMRUdBVEVEX0VWRU5UU1tldmVudF9uYW1lXS5wdXNoKFtzZWxlY3RvciwgaGFuZGxlcl0pXG59XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGlja0V2ZW50KTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgb25DbGlja0V2ZW50KTtcblxuTElTUy5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdDxFIGV4dGVuZHMgRWxlbWVudD4oc2VsZWN0b3I6IHN0cmluZywgZWxlbWVudDogRWxlbWVudCkge1xuXG5cdHdoaWxlKHRydWUpIHtcblx0XHR2YXIgcmVzdWx0ID0gZWxlbWVudC5jbG9zZXN0PEU+KHNlbGVjdG9yKTtcblxuXHRcdGlmKCByZXN1bHQgIT09IG51bGwpXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0Y29uc3Qgcm9vdCA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcblx0XHRpZiggISAoXCJob3N0XCIgaW4gcm9vdCkgKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRlbGVtZW50ID0gKHJvb3QgYXMgU2hhZG93Um9vdCkuaG9zdDtcblx0fVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTIGhlbHBlcnMgPT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnR5cGUgaW5mZXJQYXJhbXM8VD4gPSBUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksIGluZmVyIFAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLGFueT4+ID8gUCA6IG5ldmVyO1xuXG50eXBlIEJVSUxEX09QVElPTlM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+ID0gUGFydGlhbDx7XG5cdFx0XHRcdFx0ICBcdHBhcmFtcyAgICA6IFBhcnRpYWw8aW5mZXJQYXJhbXM8VD4+LFxuXHRcdFx0XHRcdCAgXHRjb250ZW50XHQgIDogc3RyaW5nfE5vZGV8cmVhZG9ubHkgTm9kZVtdLFxuXHRcdFx0XHRcdFx0aWQgXHRcdCAgOiBzdHJpbmcsXG5cdFx0XHRcdFx0ICBcdGNsYXNzZXNcdCAgOiByZWFkb25seSBzdHJpbmdbXSxcblx0XHRcdFx0XHQgIFx0Y3NzdmFycyAgIDogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4sXG5cdFx0XHRcdFx0ICBcdGF0dHJzIFx0ICA6IFJlYWRvbmx5PFJlY29yZDxzdHJpbmcsIHN0cmluZ3xib29sZWFuPj4sXG5cdFx0XHRcdFx0ICBcdGRhdGEgXHQgIDogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+Pixcblx0XHRcdFx0XHQgIFx0bGlzdGVuZXJzIDogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgKGV2OiBFdmVudCkgPT4gdm9pZD4+XG5cdFx0XHRcdFx0fT4gJiAoe1xuXHRcdFx0XHRcdFx0aW5pdGlhbGl6ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRwYXJlbnQ6IEVsZW1lbnRcblx0XHRcdFx0XHR9fHtcblx0XHRcdFx0XHRcdGluaXRpYWxpemU/OiB0cnVlLFxuXHRcdFx0XHRcdFx0cGFyZW50PzogRWxlbWVudFxuXHRcdFx0XHRcdH0pO1xuXG5hc3luYyBmdW5jdGlvbiBidWlsZDxUIGV4dGVuZHMga2V5b2YgQ29tcG9uZW50cz4odGFnbmFtZTogVCwgb3B0aW9ucz86IEJVSUxEX09QVElPTlM8Q29tcG9uZW50c1tUXT4pOiBQcm9taXNlPENvbXBvbmVudHNbVF0+O1xuYXN5bmMgZnVuY3Rpb24gYnVpbGQ8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHRhZ25hbWU6IHN0cmluZywgb3B0aW9ucz86IEJVSUxEX09QVElPTlM8VD4pOiBQcm9taXNlPFQ+O1xuYXN5bmMgZnVuY3Rpb24gYnVpbGQ8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHRhZ25hbWU6IHN0cmluZywge1xuXHRcdHBhcmFtcyAgICA9IHt9LFxuXHRcdGluaXRpYWxpemU9IHRydWUsXG5cdFx0Y29udGVudCAgID0gW10sXG5cdFx0cGFyZW50ICAgID0gdW5kZWZpbmVkLFxuXHRcdGlkIFx0XHQgID0gdW5kZWZpbmVkLFxuXHRcdGNsYXNzZXMgICA9IFtdLFxuXHRcdGNzc3ZhcnMgICA9IHt9LFxuXHRcdGF0dHJzICAgICA9IHt9LFxuXHRcdGRhdGEgXHQgID0ge30sXG5cdFx0bGlzdGVuZXJzID0ge31cblx0fTogQlVJTERfT1BUSU9OUzxUPiA9IHt9KTogUHJvbWlzZTxUPiB7XG5cblx0aWYoICEgaW5pdGlhbGl6ZSAmJiBwYXJlbnQgPT09IG51bGwpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQSBwYXJlbnQgbXVzdCBiZSBnaXZlbiBpZiBpbml0aWFsaXplIGlzIGZhbHNlXCIpO1xuXG5cdGxldCBDdXN0b21DbGFzcyA9IGF3YWl0IGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKHRhZ25hbWUpO1xuXHRsZXQgZWxlbSA9IG5ldyBDdXN0b21DbGFzcyhwYXJhbXMpIGFzIExJU1NIb3N0PFQ+O1xuXG5cdC8vIEZpeCBpc3N1ZSAjMlxuXHRpZiggZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRhZ25hbWUgKVxuXHRcdGVsZW0uc2V0QXR0cmlidXRlKFwiaXNcIiwgdGFnbmFtZSk7XG5cblx0aWYoIGlkICE9PSB1bmRlZmluZWQgKVxuXHRcdGVsZW0uaWQgPSBpZDtcblxuXHRpZiggY2xhc3Nlcy5sZW5ndGggPiAwKVxuXHRcdGVsZW0uY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcblxuXHRmb3IobGV0IG5hbWUgaW4gY3NzdmFycylcblx0XHRlbGVtLnN0eWxlLnNldFByb3BlcnR5KGAtLSR7bmFtZX1gLCBjc3N2YXJzW25hbWVdKTtcblxuXHRmb3IobGV0IG5hbWUgaW4gYXR0cnMpIHtcblxuXHRcdGxldCB2YWx1ZSA9IGF0dHJzW25hbWVdO1xuXHRcdGlmKCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKVxuXHRcdFx0ZWxlbS50b2dnbGVBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdGVsc2Vcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0fVxuXG5cdGZvcihsZXQgbmFtZSBpbiBkYXRhKSB7XG5cblx0XHRsZXQgdmFsdWUgPSBkYXRhW25hbWVdO1xuXHRcdGlmKCB2YWx1ZSA9PT0gZmFsc2UpXG5cdFx0XHRkZWxldGUgZWxlbS5kYXRhc2V0W25hbWVdO1xuXHRcdGVsc2UgaWYodmFsdWUgPT09IHRydWUpXG5cdFx0XHRlbGVtLmRhdGFzZXRbbmFtZV0gPSBcIlwiO1xuXHRcdGVsc2Vcblx0XHRcdGVsZW0uZGF0YXNldFtuYW1lXSA9IHZhbHVlO1xuXHR9XG5cblx0aWYoICEgQXJyYXkuaXNBcnJheShjb250ZW50KSApXG5cdFx0Y29udGVudCA9IFtjb250ZW50IGFzIGFueV07XG5cdGVsZW0ucmVwbGFjZUNoaWxkcmVuKC4uLmNvbnRlbnQpO1xuXG5cdGZvcihsZXQgbmFtZSBpbiBsaXN0ZW5lcnMpXG5cdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyc1tuYW1lXSk7XG5cblx0aWYoIHBhcmVudCAhPT0gdW5kZWZpbmVkIClcblx0XHRwYXJlbnQuYXBwZW5kKGVsZW0pO1xuXG5cdGlmKCAhIGVsZW0uaXNJbml0ICYmIGluaXRpYWxpemUgKVxuXHRcdHJldHVybiBhd2FpdCBMSVNTLmluaXRpYWxpemUoZWxlbSk7XG5cblx0cmV0dXJuIGF3YWl0IExJU1MuZ2V0TElTUyhlbGVtKTtcbn1cbkxJU1MuYnVpbGQgPSBidWlsZDtcblxuXG5mdW5jdGlvbiBidWlsZFN5bmM8VCBleHRlbmRzIGtleW9mIENvbXBvbmVudHM+KHRhZ25hbWU6IFQsIG9wdGlvbnM/OiBCVUlMRF9PUFRJT05TPENvbXBvbmVudHNbVF0+KTogQ29tcG9uZW50c1tUXTtcbmZ1bmN0aW9uIGJ1aWxkU3luYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4odGFnbmFtZTogc3RyaW5nLCBvcHRpb25zPzogQlVJTERfT1BUSU9OUzxUPik6IFQ7XG5mdW5jdGlvbiBidWlsZFN5bmM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHRhZ25hbWU6IHN0cmluZywge1xuXHRcdHBhcmFtcyAgICA9IHt9LFxuXHRcdGluaXRpYWxpemU9IHRydWUsXG5cdFx0Y29udGVudCAgID0gW10sXG5cdFx0cGFyZW50ICAgID0gdW5kZWZpbmVkLFxuXHRcdGlkIFx0XHQgID0gdW5kZWZpbmVkLFxuXHRcdGNsYXNzZXMgICA9IFtdLFxuXHRcdGNzc3ZhcnMgICA9IHt9LFxuXHRcdGF0dHJzICAgICA9IHt9LFxuXHRcdGRhdGEgXHQgID0ge30sXG5cdFx0bGlzdGVuZXJzID0ge31cblx0fTogQlVJTERfT1BUSU9OUzxUPiA9IHt9KTogVCB7XG5cblx0aWYoICEgaW5pdGlhbGl6ZSAmJiBwYXJlbnQgPT09IG51bGwpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQSBwYXJlbnQgbXVzdCBiZSBnaXZlbiBpZiBpbml0aWFsaXplIGlzIGZhbHNlXCIpO1xuXG5cdGxldCBDdXN0b21DbGFzcyA9IGN1c3RvbUVsZW1lbnRzLmdldCh0YWduYW1lKTtcblx0aWYoQ3VzdG9tQ2xhc3MgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dGFnbmFtZX0gbm90IGRlZmluZWRgKTtcblx0bGV0IGVsZW0gPSBuZXcgQ3VzdG9tQ2xhc3MocGFyYW1zKSBhcyBMSVNTSG9zdDxUPjtcblxuXHQvL1RPRE86IGZhY3Rvcml6ZS4uLlxuXG5cdC8vIEZpeCBpc3N1ZSAjMlxuXHRpZiggZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRhZ25hbWUgKVxuXHRcdGVsZW0uc2V0QXR0cmlidXRlKFwiaXNcIiwgdGFnbmFtZSk7XG5cblx0aWYoIGlkICE9PSB1bmRlZmluZWQgKVxuXHRcdGVsZW0uaWQgPSBpZDtcblxuXHRpZiggY2xhc3Nlcy5sZW5ndGggPiAwKVxuXHRcdGVsZW0uY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcblxuXHRmb3IobGV0IG5hbWUgaW4gY3NzdmFycylcblx0XHRlbGVtLnN0eWxlLnNldFByb3BlcnR5KGAtLSR7bmFtZX1gLCBjc3N2YXJzW25hbWVdKTtcblxuXHRmb3IobGV0IG5hbWUgaW4gYXR0cnMpIHtcblxuXHRcdGxldCB2YWx1ZSA9IGF0dHJzW25hbWVdO1xuXHRcdGlmKCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKVxuXHRcdFx0ZWxlbS50b2dnbGVBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdGVsc2Vcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0fVxuXG5cdGZvcihsZXQgbmFtZSBpbiBkYXRhKSB7XG5cblx0XHRsZXQgdmFsdWUgPSBkYXRhW25hbWVdO1xuXHRcdGlmKCB2YWx1ZSA9PT0gZmFsc2UpXG5cdFx0XHRkZWxldGUgZWxlbS5kYXRhc2V0W25hbWVdO1xuXHRcdGVsc2UgaWYodmFsdWUgPT09IHRydWUpXG5cdFx0XHRlbGVtLmRhdGFzZXRbbmFtZV0gPSBcIlwiO1xuXHRcdGVsc2Vcblx0XHRcdGVsZW0uZGF0YXNldFtuYW1lXSA9IHZhbHVlO1xuXHR9XG5cblx0aWYoICEgQXJyYXkuaXNBcnJheShjb250ZW50KSApXG5cdFx0Y29udGVudCA9IFtjb250ZW50IGFzIGFueV07XG5cdGVsZW0ucmVwbGFjZUNoaWxkcmVuKC4uLmNvbnRlbnQpO1xuXG5cdGZvcihsZXQgbmFtZSBpbiBsaXN0ZW5lcnMpXG5cdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyc1tuYW1lXSk7XG5cblx0aWYoIHBhcmVudCAhPT0gdW5kZWZpbmVkIClcblx0XHRwYXJlbnQuYXBwZW5kKGVsZW0pO1xuXG5cdGlmKCAhIGVsZW0uaXNJbml0ICYmIGluaXRpYWxpemUgKVxuXHRcdExJU1MuaW5pdGlhbGl6ZVN5bmMoZWxlbSk7XG5cblx0cmV0dXJuIExJU1MuZ2V0TElTU1N5bmMoZWxlbSk7XG59XG5MSVNTLmJ1aWxkU3luYyA9IGJ1aWxkU3luYztcblxuTElTUy53aGVuRGVmaW5lZCAgICA9IGFzeW5jIGZ1bmN0aW9uKHRhZ25hbWU6IHN0cmluZywgY2FsbGJhY2s/OiAoKSA9PiB2b2lkICkgOiBQcm9taXNlPHZvaWQ+IHtcblxuXHRhd2FpdCBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCh0YWduYW1lKTtcblxuXHRpZiggY2FsbGJhY2sgIT09IHVuZGVmaW5lZClcblx0XHRjYWxsYmFjaygpO1xuXG5cdHJldHVybjtcbn1cbkxJU1Mud2hlbkFsbERlZmluZWQgPSBhc3luYyBmdW5jdGlvbih0YWduYW1lczogcmVhZG9ubHkgc3RyaW5nW10sIGNhbGxiYWNrPzogKCkgPT4gdm9pZCApIDogUHJvbWlzZTx2b2lkPiB7XG5cblx0YXdhaXQgUHJvbWlzZS5hbGwoIHRhZ25hbWVzLm1hcCggdCA9PiBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZCh0KSApIClcblxuXHRpZiggY2FsbGJhY2sgIT09IHVuZGVmaW5lZClcblx0XHRjYWxsYmFjaygpO1xuXG59XG5cbkxJU1MuaXNEZWZpbmVkID0gZnVuY3Rpb24obmFtZTogc3RyaW5nKSB7XG5cdHJldHVybiBjdXN0b21FbGVtZW50cy5nZXQobmFtZSk7XG59XG5cbkxJU1Muc2VsZWN0b3IgPSBmdW5jdGlvbihuYW1lPzogc3RyaW5nKSB7XG5cdGlmKG5hbWUgPT09IHVuZGVmaW5lZCkgLy8ganVzdCBhbiBoNGNrXG5cdFx0cmV0dXJuIFwiXCI7XG5cdHJldHVybiBgOmlzKCR7bmFtZX0sIFtpcz1cIiR7bmFtZX1cIl0pYDtcbn1cblxuTElTUy5nZXRMSVNTICAgID0gYXN5bmMgZnVuY3Rpb248VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KCBlbGVtZW50OiBFbGVtZW50ICkge1xuXG5cdGF3YWl0IExJU1Mud2hlbkRlZmluZWQoIExJU1MuZ2V0TmFtZShlbGVtZW50KSApO1xuXG5cdHJldHVybiAoZWxlbWVudCBhcyBMSVNTSG9zdDxUPikuTElTUzsgLy8gZW5zdXJlIGluaXRpYWxpemVkLlxufVxuTElTUy5nZXRMSVNTU3luYz0gZnVuY3Rpb248VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KCBlbGVtZW50OiBFbGVtZW50ICkge1xuXG5cdGNvbnN0IG5hbWUgPSBMSVNTLmdldE5hbWUoZWxlbWVudCk7XG5cdGlmKCAhIExJU1MuaXNEZWZpbmVkKCBuYW1lICkgKVxuXHRcdHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBoYXNuJ3QgYmVlbiBkZWZpbmVkIHlldC5gKTtcblxuXHRsZXQgaG9zdCA9IGVsZW1lbnQgYXMgTElTU0hvc3Q8VD47XG5cblx0aWYoICEgaG9zdC5pc0luaXQgKVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkluc3RhbmNlIGhhc24ndCBiZWVuIGluaXRpYWxpemVkIHlldC5cIik7XG5cblx0cmV0dXJuIGhvc3QuTElTU1N5bmM7XG59XG5MSVNTLmluaXRpYWxpemUgPSBhc3luYyBmdW5jdGlvbjxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oIGVsZW1lbnQ6IEVsZW1lbnQpIHtcblxuXHRhd2FpdCBMSVNTLndoZW5EZWZpbmVkKCBMSVNTLmdldE5hbWUoZWxlbWVudCkgKTtcblxuXHRyZXR1cm4gYXdhaXQgKGVsZW1lbnQgYXMgTElTU0hvc3Q8VD4pLmluaXRpYWxpemUoKTsgLy8gZW5zdXJlIGluaXRpYWxpemF0aW9uLlxufVxuXG5MSVNTLmluaXRpYWxpemVTeW5jID0gZnVuY3Rpb248VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KCBlbGVtZW50OiBFbGVtZW50KSB7XG5cblx0Y29uc3QgbmFtZSA9IExJU1MuZ2V0TmFtZShlbGVtZW50KTtcblx0aWYoICEgTElTUy5pc0RlZmluZWQobmFtZSkgKVxuXHRcdHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBub3QgZGVmaW5lZGApO1xuXG5cdHJldHVybiAoZWxlbWVudCBhcyBMSVNTSG9zdDxUPikuaW5pdGlhbGl6ZSgpOyAvLyBlbnN1cmUgaW5pdGlhbGl6YXRpb24uXG59XG5cbkxJU1MuZ2V0TmFtZSA9IGZ1bmN0aW9uKCBlbGVtZW50OiBFbGVtZW50ICk6IHN0cmluZyB7XG5cblx0Y29uc3QgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpcycpID8/IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcblx0aWYoICEgbmFtZS5pbmNsdWRlcygnLScpIClcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnQgJHtuYW1lfSBpcyBub3QgYSBXZWJDb21wb25lbnRgKTtcblxuXHRyZXR1cm4gbmFtZTtcbn1cblxuZnVuY3Rpb24gX2J1aWxkUVMoc2VsZWN0b3I6IHN0cmluZywgdGFnbmFtZV9vcl9wYXJlbnQ/OiBzdHJpbmcgfCBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQsIHBhcmVudDogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50ID0gZG9jdW1lbnQpIHtcblx0XG5cdGlmKCB0YWduYW1lX29yX3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0YWduYW1lX29yX3BhcmVudCAhPT0gJ3N0cmluZycpIHtcblx0XHRwYXJlbnQgPSB0YWduYW1lX29yX3BhcmVudDtcblx0XHR0YWduYW1lX29yX3BhcmVudCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdHJldHVybiBbYCR7c2VsZWN0b3J9JHtMSVNTLnNlbGVjdG9yKHRhZ25hbWVfb3JfcGFyZW50IGFzIHN0cmluZ3x1bmRlZmluZWQpfWAsIHBhcmVudF0gYXMgY29uc3Q7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgUXVlcnlTZWxlY3RvcnMgPT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuYXN5bmMgZnVuY3Rpb24gcXM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRwYXJlbnQgID86IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCk6IFByb21pc2U8VD47XG5hc3luYyBmdW5jdGlvbiBxczxOIGV4dGVuZHMga2V5b2YgQ29tcG9uZW50cz4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWUgIDogTixcblx0XHRcdFx0XHRcdHBhcmVudCAgPzogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50KTogUHJvbWlzZTwgQ29tcG9uZW50c1tOXSA+O1xuYXN5bmMgZnVuY3Rpb24gcXM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KFx0c2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWVfb3JfcGFyZW50Pzoga2V5b2YgQ29tcG9uZW50cyB8IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCxcblx0XHRcdFx0XHRcdHBhcmVudCAgOiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQgPSBkb2N1bWVudCkge1xuXG5cdFtzZWxlY3RvciwgcGFyZW50XSA9IF9idWlsZFFTKHNlbGVjdG9yLCB0YWduYW1lX29yX3BhcmVudCwgcGFyZW50KTtcblxuXHRsZXQgcmVzdWx0ID0gYXdhaXQgTElTUy5xc288VD4oc2VsZWN0b3IsIHBhcmVudCk7XG5cdGlmKHJlc3VsdCA9PT0gbnVsbClcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnQgJHtzZWxlY3Rvcn0gbm90IGZvdW5kYCk7XG5cblx0cmV0dXJuIHJlc3VsdCFcbn1cbkxJU1MucXMgID0gcXNcblxuYXN5bmMgZnVuY3Rpb24gcXNvPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0cGFyZW50ICA/OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQpOiBQcm9taXNlPFQ+O1xuYXN5bmMgZnVuY3Rpb24gcXNvPE4gZXh0ZW5kcyBrZXlvZiBDb21wb25lbnRzPihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZSAgOiBOLFxuXHRcdFx0XHRcdFx0cGFyZW50ICA/OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQpOiBQcm9taXNlPCBDb21wb25lbnRzW05dID47XG5hc3luYyBmdW5jdGlvbiBxc288VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KFx0c2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWVfb3JfcGFyZW50Pzoga2V5b2YgQ29tcG9uZW50cyB8IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCxcblx0XHRcdFx0XHRcdHBhcmVudCAgOiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQgPSBkb2N1bWVudCkge1xuXG5cdFtzZWxlY3RvciwgcGFyZW50XSA9IF9idWlsZFFTKHNlbGVjdG9yLCB0YWduYW1lX29yX3BhcmVudCwgcGFyZW50KTtcblxuXHRjb25zdCBlbGVtZW50ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3I8TElTU0hvc3Q8VD4+KHNlbGVjdG9yKTtcblx0aWYoIGVsZW1lbnQgPT09IG51bGwgKVxuXHRcdHJldHVybiBudWxsO1xuXG5cdHJldHVybiBhd2FpdCBMSVNTLmdldExJU1MoIGVsZW1lbnQgKTtcbn1cbkxJU1MucXNvID0gcXNvXG5cbmFzeW5jIGZ1bmN0aW9uIHFzYTxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHBhcmVudCAgPzogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50KTogUHJvbWlzZTxUW10+O1xuYXN5bmMgZnVuY3Rpb24gcXNhPE4gZXh0ZW5kcyBrZXlvZiBDb21wb25lbnRzPihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZSAgOiBOLFxuXHRcdFx0XHRcdFx0cGFyZW50ICA/OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQpOiBQcm9taXNlPCBDb21wb25lbnRzW05dW10gPjtcbmFzeW5jIGZ1bmN0aW9uIHFzYTxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oXHRzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZV9vcl9wYXJlbnQ/OiBrZXlvZiBDb21wb25lbnRzIHwgRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50LFxuXHRcdFx0XHRcdFx0cGFyZW50ICA6IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCA9IGRvY3VtZW50KSB7XG5cblx0W3NlbGVjdG9yLCBwYXJlbnRdID0gX2J1aWxkUVMoc2VsZWN0b3IsIHRhZ25hbWVfb3JfcGFyZW50LCBwYXJlbnQpO1xuXG5cdGNvbnN0IGVsZW1lbnRzID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGw8TElTU0hvc3Q8VD4+KHNlbGVjdG9yKTtcblxuXHRsZXQgaWR4ID0gMDtcblx0Y29uc3QgcHJvbWlzZXMgPSBuZXcgQXJyYXk8UHJvbWlzZTxUPj4oIGVsZW1lbnRzLmxlbmd0aCApO1xuXHRmb3IobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpXG5cdFx0cHJvbWlzZXNbaWR4KytdID0gTElTUy5nZXRMSVNTKCBlbGVtZW50ICk7XG5cblx0cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbn1cbkxJU1MucXNhID0gcXNhO1xuXG5hc3luYyBmdW5jdGlvbiBxc2M8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRlbGVtZW50ICA6IEVsZW1lbnQpOiBQcm9taXNlPFQ+O1xuYXN5bmMgZnVuY3Rpb24gcXNjPE4gZXh0ZW5kcyBrZXlvZiBDb21wb25lbnRzPihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZSAgOiBOLFxuXHRcdFx0XHRcdFx0ZWxlbWVudCAgOiBFbGVtZW50KTogUHJvbWlzZTwgQ29tcG9uZW50c1tOXSA+O1xuYXN5bmMgZnVuY3Rpb24gcXNjPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PihcdHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lX29yX3BhcmVudD86IGtleW9mIENvbXBvbmVudHMgfCBFbGVtZW50LFxuXHRcdFx0XHRcdFx0ZWxlbWVudCAgPzogRWxlbWVudCkge1xuXG5cdGNvbnN0IHJlcyA9IF9idWlsZFFTKHNlbGVjdG9yLCB0YWduYW1lX29yX3BhcmVudCwgZWxlbWVudCk7XG5cdFxuXHRjb25zdCByZXN1bHQgPSAocmVzWzFdIGFzIHVua25vd24gYXMgRWxlbWVudCkuY2xvc2VzdDxMSVNTSG9zdDxUPj4ocmVzWzBdKTtcblx0aWYocmVzdWx0ID09PSBudWxsKVxuXHRcdHJldHVybiBudWxsO1xuXG5cdHJldHVybiBhd2FpdCBMSVNTLmdldExJU1MocmVzdWx0KTtcbn1cbkxJU1MucXNjID0gcXNjO1xuXG5mdW5jdGlvbiBxc1N5bmM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRwYXJlbnQgID86IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCk6IFQ7XG5mdW5jdGlvbiBxc1N5bmM8TiBleHRlbmRzIGtleW9mIENvbXBvbmVudHM+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lICA6IE4sXG5cdFx0XHRcdFx0XHRwYXJlbnQgID86IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCk6IENvbXBvbmVudHNbTl07XG5mdW5jdGlvbiBxc1N5bmM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KFx0c2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWVfb3JfcGFyZW50Pzoga2V5b2YgQ29tcG9uZW50cyB8IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCxcblx0XHRcdFx0XHRcdHBhcmVudCAgOiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQgPSBkb2N1bWVudCkge1xuXG5cdFtzZWxlY3RvciwgcGFyZW50XSA9IF9idWlsZFFTKHNlbGVjdG9yLCB0YWduYW1lX29yX3BhcmVudCwgcGFyZW50KTtcblxuXHRjb25zdCBlbGVtZW50ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3I8TElTU0hvc3Q8VD4+KHNlbGVjdG9yKTtcblxuXHRpZiggZWxlbWVudCA9PT0gbnVsbCApXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFbGVtZW50ICR7c2VsZWN0b3J9IG5vdCBmb3VuZGApO1xuXG5cdHJldHVybiBMSVNTLmdldExJU1NTeW5jKCBlbGVtZW50ICk7XG59XG5MSVNTLnFzU3luYyA9IHFzU3luYztcblxuZnVuY3Rpb24gcXNhU3luYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHBhcmVudCAgPzogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50KTogVFtdO1xuZnVuY3Rpb24gcXNhU3luYzxOIGV4dGVuZHMga2V5b2YgQ29tcG9uZW50cz4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWUgIDogTixcblx0XHRcdFx0XHRcdHBhcmVudCAgPzogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50KTogQ29tcG9uZW50c1tOXVtdO1xuZnVuY3Rpb24gcXNhU3luYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oXHRzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZV9vcl9wYXJlbnQ/OiBrZXlvZiBDb21wb25lbnRzIHwgRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50LFxuXHRcdFx0XHRcdFx0cGFyZW50ICA6IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCA9IGRvY3VtZW50KSB7XG5cblx0W3NlbGVjdG9yLCBwYXJlbnRdID0gX2J1aWxkUVMoc2VsZWN0b3IsIHRhZ25hbWVfb3JfcGFyZW50LCBwYXJlbnQpO1xuXG5cdGNvbnN0IGVsZW1lbnRzID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGw8TElTU0hvc3Q8VD4+KHNlbGVjdG9yKTtcblxuXHRsZXQgaWR4ID0gMDtcblx0Y29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PFQ+KCBlbGVtZW50cy5sZW5ndGggKTtcblx0Zm9yKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKVxuXHRcdHJlc3VsdFtpZHgrK10gPSBMSVNTLmdldExJU1NTeW5jKCBlbGVtZW50ICk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cbkxJU1MucXNhU3luYyA9IHFzYVN5bmM7XG5cbmZ1bmN0aW9uIHFzY1N5bmM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRlbGVtZW50ICA6IEVsZW1lbnQpOiBUO1xuZnVuY3Rpb24gcXNjU3luYzxOIGV4dGVuZHMga2V5b2YgQ29tcG9uZW50cz4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWUgIDogTixcblx0XHRcdFx0XHRcdGVsZW1lbnQgIDogRWxlbWVudCk6IENvbXBvbmVudHNbTl07XG5mdW5jdGlvbiBxc2NTeW5jPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PihcdHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lX29yX3BhcmVudD86IGtleW9mIENvbXBvbmVudHMgfCBFbGVtZW50LFxuXHRcdFx0XHRcdFx0ZWxlbWVudCAgPzogRWxlbWVudCkge1xuXG5cdGNvbnN0IHJlcyA9IF9idWlsZFFTKHNlbGVjdG9yLCB0YWduYW1lX29yX3BhcmVudCwgZWxlbWVudCk7XG5cdFxuXHRjb25zdCByZXN1bHQgPSAocmVzWzFdIGFzIHVua25vd24gYXMgRWxlbWVudCkuY2xvc2VzdDxMSVNTSG9zdDxUPj4ocmVzWzBdKTtcblx0aWYocmVzdWx0ID09PSBudWxsKVxuXHRcdHJldHVybiBudWxsO1xuXG5cdHJldHVybiBMSVNTLmdldExJU1NTeW5jKHJlc3VsdCk7XG59XG5MSVNTLnFzY1N5bmMgPSBxc2NTeW5jO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTIEF1dG8gPT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjbGFzcyBMSVNTX0F1dG8gZXh0ZW5kcyBMSVNTKHthdHRyaWJ1dGVzOiBbXCJzcmNcIl19KSB7XG5cblx0cmVhZG9ubHkgI2tub3duX3RhZyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRyZWFkb25seSAjZGlyZWN0b3J5OiBzdHJpbmc7XG5cdHJlYWRvbmx5ICNzdzogUHJvbWlzZTx2b2lkPjtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLiNzdyA9IG5ldyBQcm9taXNlKCBhc3luYyAocmVzb2x2ZSkgPT4ge1xuXHRcdFx0XG5cdFx0XHRhd2FpdCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcihgLi9zdy5qc2ApO1xuXG5cdFx0XHRpZiggbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlciApXG5cdFx0XHRcdHJlc29sdmUoKTtcblxuXHRcdFx0bmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udHJvbGxlcmNoYW5nZScsICgpID0+IHtcblx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblxuXHRcdGNvbnN0IHNyYyA9IHRoaXMuYXR0cnMuc3JjO1xuXHRcdGlmKHNyYyA9PT0gbnVsbClcblx0XHRcdHRocm93IG5ldyBFcnJvcihcInNyYyBhdHRyaWJ1dGUgaXMgbWlzc2luZy5cIik7XG5cdFx0dGhpcy4jZGlyZWN0b3J5ID0gc3JjWzBdID09PSAnLidcblx0XHRcdFx0XHRcdFx0XHQ/IGAke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX0vJHtzcmN9YFxuXHRcdFx0XHRcdFx0XHRcdDogc3JjO1xuXG5cdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoIChtdXRhdGlvbnMpID0+IHtcblxuXHRcdFx0Zm9yKGxldCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpXG5cdFx0XHRcdGZvcihsZXQgYWRkaXRpb24gb2YgbXV0YXRpb24uYWRkZWROb2Rlcylcblx0XHRcdFx0XHRpZihhZGRpdGlvbiBpbnN0YW5jZW9mIEVsZW1lbnQpXG5cdFx0XHRcdFx0XHR0aGlzLiNhZGRUYWcoYWRkaXRpb24udGFnTmFtZSlcblxuXHRcdH0pLm9ic2VydmUoIGRvY3VtZW50LCB7IGNoaWxkTGlzdDp0cnVlLCBzdWJ0cmVlOnRydWUgfSk7XG5cblxuXHRcdGZvciggbGV0IGVsZW0gb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIipcIikgKVxuXHRcdFx0dGhpcy4jYWRkVGFnKGVsZW0udGFnTmFtZSk7XG5cdH1cblxuXG4gICAgcHJvdGVjdGVkIHJlc291cmNlcygpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0XCJpbmRleC5qc1wiLFxuXHRcdFx0XCJpbmRleC5odG1sXCIsXG5cdFx0XHRcImluZGV4LmNzc1wiXG5cdFx0XTtcbiAgICB9XG5cblx0cHJvdGVjdGVkIGRlZmluZVdlYkNvbXBvbmVudCh0YWduYW1lOiBzdHJpbmcsIGZpbGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRzOiBQYXJ0aWFsPHtjb250ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nfT4pIHtcblxuXHRcdGNvbnN0IGpzID0gZmlsZXNbXCJpbmRleC5qc1wiXTtcblx0XHRjb25zdCBjb250ZW50ID0gZmlsZXNbXCJpbmRleC5odG1sXCJdO1xuXG5cdFx0bGV0IGtsYXNzOiBudWxsfCBSZXR1cm5UeXBlPHR5cGVvZiBMSVNTPiA9IG51bGw7XG5cdFx0aWYoIGpzICE9PSB1bmRlZmluZWQgKVxuXHRcdFx0a2xhc3MgPSBqcyhvcHRzKTtcblx0XHRlbHNlIGlmKCBjb250ZW50ICE9PSB1bmRlZmluZWQgKVxuXHRcdFx0a2xhc3MgPSBjbGFzcyBXZWJDb21wb25lbnQgZXh0ZW5kcyBMSVNTKG9wdHMpIHt9O1xuXG5cdFx0aWYoa2xhc3MgPT09IG51bGwpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZmlsZXMgZm9yIFdlYkNvbXBvbmVudCAke3RhZ25hbWV9LmApO1xuXG5cdFx0cmV0dXJuIExJU1MuZGVmaW5lKHRhZ25hbWUsIGtsYXNzKTtcblx0fVxuXG5cdGFzeW5jICNhZGRUYWcodGFnbmFtZTogc3RyaW5nKSB7XG5cblx0XHR0YWduYW1lID0gdGFnbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYoIHRhZ25hbWUgPT09ICdsaXNzLWF1dG8nIHx8IHRhZ25hbWUgPT09ICdibGlzcy1hdXRvJyB8fCAhIHRhZ25hbWUuaW5jbHVkZXMoJy0nKSB8fCB0aGlzLiNrbm93bl90YWcuaGFzKCB0YWduYW1lICkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy4ja25vd25fdGFnLmFkZCh0YWduYW1lKTtcblxuXHRcdGF3YWl0IHRoaXMuI3N3OyAvLyBlbnN1cmUgU1cgaXMgaW5zdGFsbGVkLlxuXG5cdFx0Y29uc3QgZmlsZW5hbWVzID0gdGhpcy5yZXNvdXJjZXMoKTtcblx0XHRjb25zdCByZXNvdXJjZXMgPSBhd2FpdCBQcm9taXNlLmFsbCggZmlsZW5hbWVzLm1hcCggZmlsZSA9PiBmaWxlLmVuZHNXaXRoKCcuanMnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ/IF9pbXBvcnQgICAoYCR7dGhpcy4jZGlyZWN0b3J5fS8ke3RhZ25hbWV9LyR7ZmlsZX1gLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ6IF9mZXRjaFRleHQoYCR7dGhpcy4jZGlyZWN0b3J5fS8ke3RhZ25hbWV9LyR7ZmlsZX1gLCB0cnVlKSApICk7XG5cblx0XHRjb25zdCBmaWxlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCBmaWxlbmFtZXMubGVuZ3RoOyArK2kpXG5cdFx0XHRpZiggcmVzb3VyY2VzW2ldICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdGZpbGVzW2ZpbGVuYW1lc1tpXV0gPSByZXNvdXJjZXNbaV07XG5cblx0XHRjb25zdCBjb250ZW50ID0gZmlsZXNbXCJpbmRleC5odG1sXCJdO1xuXHRcdGNvbnN0IGNzcyAgICAgPSBmaWxlc1tcImluZGV4LmNzc1wiXTtcblxuXHRcdGNvbnN0IG9wdHM6IFBhcnRpYWw8e2NvbnRlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmd9PiA9IHtcblx0XHRcdC4uLmNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiB7Y29udGVudH0sXG5cdFx0XHQuLi5jc3MgICAgICE9PSB1bmRlZmluZWQgJiYge2Nzc30sXG5cdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLmRlZmluZVdlYkNvbXBvbmVudCh0YWduYW1lLCBmaWxlcywgb3B0cyk7XG5cdFx0XG5cdH1cbn1cbkxJU1MuZGVmaW5lKFwibGlzcy1hdXRvXCIsIExJU1NfQXV0byk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50cyB7XG5cdFwibGlzcy1hdXRvXCI6IExJU1NfQXV0b1xufTtcbi8qXG4gKiBkZWNsYXJlIG1vZHVsZSAnJExJU1MnIHtcbiAqIFx0XHRpbnRlcmZhY2UgQ29tcG9uZW50cyB7XG4gKiBcdFx0XHRcIm5hbWVcIjogY2xhc3NcbiAqIFx0XHR9XG4gKiB9XG4gKi9cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT0gTElTUyBFdmVudHNUYXJnZXQgPT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50eXBlIENzdEV2ZW50PEV2ZW50IGV4dGVuZHMgc3RyaW5nLCBBcmdzPiA9IEN1c3RvbUV2ZW50PEFyZ3M+ICYge3R5cGU6IEV2ZW50fTtcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudHNUYXJnZXQ8RXZlbnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj57XG5cblx0YWRkRXZlbnRMaXN0ZW5lcjxFdmVudCBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgRXZlbnRzLCBzeW1ib2x8bnVtYmVyPj4odHlwZTogRXZlbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgbGlzdGVuZXI6IG51bGx8ICgoZXY6IENzdEV2ZW50PEV2ZW50LCBFdmVudHNbRXZlbnRdPikgPT4gdm9pZCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgb3B0aW9ucz86IGJvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkO1xuXG5cdGRpc3BhdGNoRXZlbnQ8RXZlbnQgZXh0ZW5kcyBFeGNsdWRlPGtleW9mIEV2ZW50cywgc3ltYm9sfG51bWJlcj4+KGV2ZW50OiBDc3RFdmVudDxFdmVudCwgRXZlbnRzW0V2ZW50XT4pOiBib29sZWFuO1xuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI8RXZlbnQgZXh0ZW5kcyBFeGNsdWRlPGtleW9mIEV2ZW50cywgc3ltYm9sfG51bWJlcj4+KHR5cGU6IEV2ZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsaXN0ZW5lcjogbnVsbHwgKChldjogQ3N0RXZlbnQ8RXZlbnQsIEV2ZW50c1tFdmVudF0+KSA9PiB2b2lkKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucz86IGJvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgQ3N0bUV2ZW50PEV2ZW50IGV4dGVuZHMgc3RyaW5nLCBBcmdzPiBleHRlbmRzIEN1c3RvbUV2ZW50PEFyZ3M+IHtcblxuXHRvdmVycmlkZSBnZXQgdHlwZSgpOiBFdmVudCB7IHJldHVybiBzdXBlci50eXBlIGFzIEV2ZW50OyB9XG5cblx0Y29uc3RydWN0b3IodHlwZTogRXZlbnQsIGFyZ3M6IEFyZ3MpIHtcblx0XHRzdXBlcih0eXBlLCB7ZGV0YWlsOiBhcmdzfSk7XG5cdH1cbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRzVGFyZ2V0Q3N0cjxFdmVudHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLGFueT4+ID0gQ29uc3RydWN0b3I8RXZlbnRzVGFyZ2V0PEV2ZW50cz4+O1xuXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgaW50ZXJuYWwgdG9vbHMgPT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXNvdXJjZShyZXNvdXJjZTogUmVzb3VyY2V8UHJvbWlzZTxSZXNvdXJjZT4pIHtcblxuXHRyZXNvdXJjZSA9IGF3YWl0IHJlc291cmNlO1xuXG5cdGlmKCAhIChyZXNvdXJjZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSApXG5cdFx0cmVzb3VyY2UgPSBhd2FpdCBmZXRjaChyZXNvdXJjZSk7XG5cblx0cmV0dXJuIGF3YWl0IHJlc291cmNlLnRleHQoKTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBfZmV0Y2hUZXh0KHVyaTogc3RyaW5nfFVSTCwgaXNMaXNzQXV0bzogYm9vbGVhbiA9IGZhbHNlKSB7XG5cblx0Y29uc3Qgb3B0aW9ucyA9IGlzTGlzc0F1dG9cblx0XHRcdFx0XHRcdD8ge2hlYWRlcnM6e1wibGlzcy1hdXRvXCI6IFwidHJ1ZVwifX1cblx0XHRcdFx0XHRcdDoge307XG5cblxuXHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVyaSwgb3B0aW9ucyk7XG5cdGlmKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwIClcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdGlmKCBpc0xpc3NBdXRvICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwic3RhdHVzXCIpISA9PT0gXCI0MDRcIiApXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gX2ltcG9ydCh1cmk6IHN0cmluZywgaXNMaXNzQXV0bzogYm9vbGVhbiA9IGZhbHNlKSB7XG5cblx0Ly8gdGVzdCBmb3IgdGhlIG1vZHVsZSBleGlzdGFuY2UuXG5cdGlmKGlzTGlzc0F1dG8gJiYgYXdhaXQgX2ZldGNoVGV4dCh1cmksIGlzTGlzc0F1dG8pID09PSB1bmRlZmluZWQgKVxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gKGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIHVyaSkpLmRlZmF1bHQ7XG5cdH0gY2F0Y2goZSkge1xuXHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cbn1cblxuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MTAwMDQ2MS9odG1sLWVsZW1lbnQtdGFnLW5hbWUtZnJvbS1jb25zdHJ1Y3RvclxuY29uc3QgSFRNTENMQVNTX1JFR0VYID0gIC9IVE1MKFxcdyspRWxlbWVudC87XG5jb25zdCBlbGVtZW50TmFtZUxvb2t1cFRhYmxlID0ge1xuICAgICdVTGlzdCc6ICd1bCcsXG4gICAgJ1RhYmxlQ2FwdGlvbic6ICdjYXB0aW9uJyxcbiAgICAnVGFibGVDZWxsJzogJ3RkJywgLy8gdGhcbiAgICAnVGFibGVDb2wnOiAnY29sJywgIC8vJ2NvbGdyb3VwJyxcbiAgICAnVGFibGVSb3cnOiAndHInLFxuICAgICdUYWJsZVNlY3Rpb24nOiAndGJvZHknLCAvL1sndGhlYWQnLCAndGJvZHknLCAndGZvb3QnXSxcbiAgICAnUXVvdGUnOiAncScsXG4gICAgJ1BhcmFncmFwaCc6ICdwJyxcbiAgICAnT0xpc3QnOiAnb2wnLFxuICAgICdNb2QnOiAnaW5zJywgLy8sICdkZWwnXSxcbiAgICAnTWVkaWEnOiAndmlkZW8nLC8vICdhdWRpbyddLFxuICAgICdJbWFnZSc6ICdpbWcnLFxuICAgICdIZWFkaW5nJzogJ2gxJywgLy8sICdoMicsICdoMycsICdoNCcsICdoNScsICdoNiddLFxuICAgICdEaXJlY3RvcnknOiAnZGlyJyxcbiAgICAnRExpc3QnOiAnZGwnLFxuICAgICdBbmNob3InOiAnYSdcbiAgfTtcbmZ1bmN0aW9uIF9lbGVtZW50MnRhZ25hbWUoQ2xhc3M6IHR5cGVvZiBIVE1MRWxlbWVudCk6IHN0cmluZ3xudWxsIHtcblxuXHRpZiggQ2xhc3MgPT09IEhUTUxFbGVtZW50IClcblx0XHRyZXR1cm4gbnVsbDtcblx0XG5cdGxldCBodG1sdGFnID0gSFRNTENMQVNTX1JFR0VYLmV4ZWMoQ2xhc3MubmFtZSkhWzFdO1xuXHRyZXR1cm4gZWxlbWVudE5hbWVMb29rdXBUYWJsZVtodG1sdGFnIGFzIGtleW9mIHR5cGVvZiBlbGVtZW50TmFtZUxvb2t1cFRhYmxlXSA/PyBodG1sdGFnLnRvTG93ZXJDYXNlKClcbn0iLCJpbXBvcnQgXCIuLi8uLi8uLi9zdHJ1Y3Qvc3FsLWludGVyYWN0aXZlLmpzXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9zdHJ1Y3Qvc3FsLWR5bS10YWJsZS5qc1wiO1xuaW1wb3J0IFwiLi4vLi4vLi4vc3RydWN0L2FuaW0tcGxheWVyLmpzXCI7XG5cbmltcG9ydCBcIi4uLy4uLy4uL3N0cnVjdC9tZW51LnRzXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9zdHJ1Y3Qvc3RydWN0LnRzXCI7IiwiLy9UT0RPOiBiZXR0ZXIgKGFzc2V0cylcbmltcG9ydCBcIi4vc3FsaXRlL3NxbGl0ZTMuanNcIjtcbnJlcXVpcmUoXCIuLi9wYWdlcy9SMS0wMi9DTS9zcWxpdGUzLndhc21cIik7XG4vL3JlcXVpcmUoXCIuLi8uLi8uLi9zdHJ1Y3Qvc3FsaXRlL3NxbGl0ZTMud2FzbVwiKTtcblxuaW1wb3J0ICogYXMgcyBmcm9tIFwiLi9zcWxpdGUvc3FsaXRlMy5qc1wiO1xuY29uc3Qgc3FsaXRlMyA9IChhd2FpdCBzKCkpLnNxbGl0ZTMub28xO1xuXG4vLyBAdHMtaWdub3JlXG4vLyBjb25zdCBzcWxpdGUzID0gKGF3YWl0IHNxbGl0ZTNJbml0TW9kdWxlISgpKS5vbzE7XG50eXBlIFRBQkxFX0RFU0MgPSB7XG4gICAgc2NoZW1hICAgICAgOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGNvbnN0cmFpbnRzPzogc3RyaW5nLFxuICAgIGVudHJpZXMgICAgIDogKG51bGx8c3RyaW5nfG51bWJlcilbXVtdXG59O1xudHlwZSBEQl9ERVNDID0gUmVjb3JkPHN0cmluZywgVEFCTEVfREVTQz47XG5cbmZ1bmN0aW9uIGpzMnNxbCh2YWx1ZTogbnVsbHxzdHJpbmd8bnVtYmVyKSB7XG4gICAgaWYodmFsdWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBcIk5VTExcIjtcbiAgICBpZiggdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgICBpZiggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSdgO1xuICAgIHRocm93IG5ldyBFcnJvcignPz8/Jyk7XG59XG5cbi8vVE9ETyBtZXJnZSBxdWVyaWVzLi4uXG5jbGFzcyBEQiB7XG5cbiAgICByZWFkb25seSAjZGVzYzogREJfREVTQztcbiAgICByZWFkb25seSAjZGIgIDogYW55O1xuXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBkZXNjOiBEQl9ERVNDKSB7XG5cbiAgICAgICAgdGhpcy4jZGVzYyA9IGRlc2M7XG5cbiAgICAgICAgLy8gYWRkIHQgZm9yIHRyYWNpbmcuXG4gICAgICAgIHRoaXMuI2RiID0gbmV3IHNxbGl0ZTMuREIobmFtZSwnYycpOyBcbiAgICAgICAgdGhpcy4jZGIuZXhlYygnUFJBR01BIGZvcmVpZ25fa2V5cz1PTjsnKTtcblxuICAgICAgICB0aGlzLmZ1bGxSZXNldCgpO1xuICAgIH1cblxuICAgICNkcm9wVGFibGUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuI2RiLmV4ZWMoYGRyb3AgdGFibGUgaWYgZXhpc3RzICR7bmFtZX1gKTtcbiAgICB9XG4gICAgI2NyZWF0ZVRhYmxlKG5hbWU6IHN0cmluZykge1xuXG4gICAgICAgIGNvbnN0IGRlc2MgPSB0aGlzLiNkZXNjW25hbWVdO1xuXG4gICAgICAgIGNvbnN0IGNvbHMgPSBPYmplY3QuZW50cmllcyhkZXNjLnNjaGVtYSkubWFwKCAoW25hbWUsIHR5cGVdKSA9PiBgJHtuYW1lfSAke3R5cGV9YCkuam9pbihcIiwgXCIpO1xuICAgICAgICBsZXQgY29uc3RyYWludHMgPSBcIlwiO1xuICAgICAgICBpZiggXCJjb25zdHJhaW50c1wiIGluIGRlc2MpXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGAsICR7ZGVzYy5jb25zdHJhaW50c31gOyBcbiAgICAgICAgdGhpcy4jZGIuZXhlYyhgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJHtuYW1lfSgke2NvbHN9JHtjb25zdHJhaW50c30pIFNUUklDVDtgKTtcblxuICAgICAgICAvLyBQb3B1bGF0ZS4uLlxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXNjLmVudHJpZXMubWFwKCBlID0+IGAoJHsgZS5tYXAoYyA9PiBqczJzcWwoYykpLmpvaW4oJywgJykgfSlgKS5qb2luKFwiLCBcIik7XG4gICAgICAgIHRoaXMuI2RiLmV4ZWMoYElOU0VSVCBJTlRPICR7bmFtZX0gVkFMVUVTICR7dmFsdWVzfTtgKTtcbiAgICB9XG5cbiAgICByZXNldFRhYmxlKG5hbWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLiNkcm9wVGFibGUobmFtZSk7XG4gICAgICAgIHRoaXMuI2NyZWF0ZVRhYmxlKG5hbWUpO1xuICAgIH1cblxuICAgICNjcmVhdGVkX3RhYmxlID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgI3VwZGF0ZWRfdGFibGUgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIGZvciggbGV0IG5hbWUgb2YgWy4uLnRoaXMuI2NyZWF0ZWRfdGFibGUudmFsdWVzKCldLnJldmVyc2UoKSApXG4gICAgICAgICAgICB0aGlzLiNkYi5leGVjKGBkcm9wIHRhYmxlIGlmIGV4aXN0cyAke25hbWV9O2ApO1xuXG4gICAgICAgIGZvcihsZXQgbmFtZSBpbiB0aGlzLiNkZXNjKVxuICAgICAgICAgICAgaWYoIHRoaXMuI3VwZGF0ZWRfdGFibGUuaGFzKG5hbWUpIClcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VGFibGUobmFtZSk7XG5cbiAgICAgICAgdGhpcy4jY3JlYXRlZF90YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLiN1cGRhdGVkX3RhYmxlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZnVsbFJlc2V0KCkge1xuICAgICAgICBmb3IoIGxldCBuYW1lIG9mIFsuLi50aGlzLiNjcmVhdGVkX3RhYmxlLnZhbHVlcygpXS5yZXZlcnNlKCkgKVxuICAgICAgICAgICAgdGhpcy4jZGIuZXhlYyhgZHJvcCB0YWJsZSBpZiBleGlzdHMgJHtuYW1lfWApO1xuXG4gICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXModGhpcy4jZGVzYyk7XG5cbiAgICAgICAgLy8gcmVxdWlyZWQgZHVlIHRvIEZLLi4uXG4gICAgICAgIGZvcihsZXQgdGFibGUgb2YgbmFtZXMucmV2ZXJzZSgpIClcbiAgICAgICAgICAgIHRoaXMuI2Ryb3BUYWJsZSh0YWJsZSlcbiAgICAgICAgZm9yKGxldCB0YWJsZSBvZiBuYW1lcy5yZXZlcnNlKCkgKVxuICAgICAgICAgICAgdGhpcy4jY3JlYXRlVGFibGUodGFibGUpXG5cbiAgICAgICAgdGhpcy4jY3JlYXRlZF90YWJsZS5jbGVhcigpO1xuICAgICAgICB0aGlzLiN1cGRhdGVkX3RhYmxlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgI2lzVGFibGVOYW1lKGM6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gYyAhPT0gXCIgXCIgJiYgYyAhPT0gXCI7XCIgJiYgYyAhPT0gXCJcXG5cIjtcbiAgICB9XG5cbiAgICAjZXh0cmFjdFRhYmxlTmFtZUZyb21TUUwoc3FsOiBzdHJpbmcpIHtcblxuICAgICAgICBjb25zdCB0eXBlcyA9IFtcbiAgICAgICAgICAgIFwiQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgXCIsXG4gICAgICAgICAgICBcIkNSRUFURSBUQUJMRSBcIixcbiAgICAgICAgICAgIFwiQUxURVIgVEFCTEUgXCIsXG4gICAgICAgICAgICBcIkRST1AgVEFCTEUgXCIsXG4gICAgICAgICAgICBcIlVQREFURSBcIixcbiAgICAgICAgICAgIFwiSU5TRVJUIElOVE8gXCIsXG4gICAgICAgICAgICBcIkRFTEVURSBGUk9NIFwiXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3Qgc3FsX3R5cGUgPSB0eXBlcy5maW5kKCB2ID0+IHNxbC5zdGFydHNXaXRoKHYpICkhO1xuXG4gICAgICAgIGxldCBzdGFydF9wb3MgID0gc3FsX3R5cGUubGVuZ3RoO1xuICAgICAgICB3aGlsZSggISB0aGlzLiNpc1RhYmxlTmFtZSggc3FsW3N0YXJ0X3Bvc10gKSApXG4gICAgICAgICAgICArK3N0YXJ0X3BvcztcblxuICAgICAgICBsZXQgZW5kX3BvcyA9IHN0YXJ0X3BvcztcbiAgICAgICAgd2hpbGUoIHRoaXMuI2lzVGFibGVOYW1lKCBzcWxbZW5kX3Bvc10gKSApXG4gICAgICAgICAgICArK2VuZF9wb3M7XG4gICAgXG4gICAgICAgIGNvbnN0IHRhYmxlX25hbWUgPSBzcWwuc2xpY2Uoc3RhcnRfcG9zLCBlbmRfcG9zICk7XG4gICAgICAgIHJldHVybiBbIHNxbF90eXBlLCB0YWJsZV9uYW1lXTtcbiAgICB9XG5cbiAgICBleGVjX29uZShzcWw6IHN0cmluZykge1xuXG4gICAgICAgIGlmKCBzcWwuc3RhcnRzV2l0aChcIlZBTFVFUyBcIikgfHwgc3FsLnN0YXJ0c1dpdGgoXCJTRUxFQ1QgXCIpIClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNkYi5zZWxlY3RPYmplY3RzKHNxbCk7XG5cbiAgICAgICAgdGhpcy4jZGIuZXhlYyhzcWwpO1xuXG4gICAgICAgIGNvbnN0IFt0eXBlLCBuYW1lXSA9IHRoaXMuI2V4dHJhY3RUYWJsZU5hbWVGcm9tU1FMKHNxbCk7XG5cbiAgICAgICAgaWYoIG5hbWUgaW4gdGhpcy4jZGVzYyApXG4gICAgICAgICAgICB0aGlzLiN1cGRhdGVkX3RhYmxlLmFkZChuYW1lKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy4jY3JlYXRlZF90YWJsZS5hZGQobmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZXhlY19tYW55KHNxbDogc3RyaW5nW10pIHtcblxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzcWwubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggdGhpcy5leGVjX29uZShzcWxbaV0pICk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJFcnJvcjpcIiArIChlIGFzIEVycm9yKS5tZXNzYWdlLnNwbGl0KCc6Jykuc2xpY2UoMikuam9pbignOicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59XG5cbmNvbnN0IGRiMiA9IG5ldyBEQihcIkJEUjFfQ01cIixcbiAgICB7XG4gICAgICAgIFVzZXJzOiB7XG4gICAgICAgICAgICBzY2hlbWEgOiB7XG4gICAgICAgICAgICAgICAgSUQgICAgOiBcIklOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVFwiLFxuICAgICAgICAgICAgICAgIE5vbSAgIDogXCJURVhUXCIsXG4gICAgICAgICAgICAgICAgUHJlbm9tOiBcIlRFWFRcIixcbiAgICAgICAgICAgICAgICBBZ2UgICA6IFwiSU5UXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAgW251bGwsICdEb2UnLCAgICAnSm9obicsICAgNDNdLFxuICAgICAgICAgICAgICAgIFtudWxsLCAnRHVyYW50JywgJ1BhdWwnLCAgICA5XSxcbiAgICAgICAgICAgICAgICBbbnVsbCwgJ05lc2NpbycsICdOb21lbicsICA0M11cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgUHJvZHVpdHM6IHtcbiAgICAgICAgICAgIHNjaGVtYSA6IHtcbiAgICAgICAgICAgICAgICBEYXRlOiBcIlRFWFRcIixcbiAgICAgICAgICAgICAgICBSZWYgOiBcIlRFWFRcIixcbiAgICAgICAgICAgICAgICBRICAgOiBcIklOVFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIFsnMjAyMy0wMS0wMScsICdHb21tZScgLCAxMF0sXG4gICAgICAgICAgICAgICAgWycyMDIzLTAyLTIzJywgJ0dvbW1lJyAsICA5XSxcbiAgICAgICAgICAgICAgICBbJzIwMjMtMDYtMTMnLCAnR29tbWUnICwgMjRdLFxuICAgICAgICAgICAgICAgIFsnMjAyMy0wMS0wMScsICdDcmF5b24nLCAyMF0sXG4gICAgICAgICAgICAgICAgWycyMDIzLTAyLTIzJywgJ0NyYXlvbicsIDE4XSxcbiAgICAgICAgICAgICAgICBbJzIwMjMtMDYtMTMnLCAnQ3JheW9uJywgNTBdXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFQxOiB7XG4gICAgICAgICAgICBzY2hlbWEgOiB7XG4gICAgICAgICAgICAgICAgSUQ6IFwiSU5URUdFUiBQUklNQVJZIEtFWSBBVVRPSU5DUkVNRU5UXCIsXG4gICAgICAgICAgICAgICAgVDE6IFwiVEVYVFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIFtudWxsLCAnMSddLFxuICAgICAgICAgICAgICAgIFtudWxsLCAnMiddLFxuICAgICAgICAgICAgICAgIFtudWxsLCAnMyddXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFQyOiB7XG4gICAgICAgICAgICBzY2hlbWEgOiB7XG4gICAgICAgICAgICAgICAgSUQ6IFwiSU5UXCIsXG4gICAgICAgICAgICAgICAgVDI6IFwiVEVYVFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uc3RyYWludHM6IFwiRk9SRUlHTiBLRVkoSUQpIFJFRkVSRU5DRVMgVDEoSUQpXCIsXG4gICAgICAgICAgICBlbnRyaWVzOiBbXG4gICAgICAgICAgICAgICAgWzEsICAgICcxJ10sXG4gICAgICAgICAgICAgICAgWzMsICAgICcyJ10sXG4gICAgICAgICAgICAgICAgWzMsICAgICczJ10sXG4gICAgICAgICAgICAgICAgW251bGwsICc0J11cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnQge2RiMn07IiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIHtcbiAgICAgICAgbmFtZSA6IFwiUiAxLTAxIFRhYmxldXIgZXQgUmVwb3J0aW5nXCIsXG4gICAgICAgIHNuYW1lOiBcIlIxLTAxIFRhYmxldXJcIixcbiAgICAgICAgcGF0aCA6IFwiUjEtMDFcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNNXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogXCJDTVwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiQ00xXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ00yXCJcbiAgICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJUUFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiVFBcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBcIlRQMVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlRQMlwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWUgOiBcIlIgMS0wMiBCYXNlcyBkZSBEb25uw6llcyBSZWxhdGlvbm5lbGxlcyAxXCIsXG4gICAgICAgIHNuYW1lOiBcIlIxLTAyIEJEUjFcIixcbiAgICAgICAgcGF0aCA6IFwiUjEtMDJcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIFwiQ01cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlNsaWRlc1wiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiU2xpZGVzXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgXCJDTTFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDTTJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDTTNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJDTTRcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJUUFwiICxcbiAgICAgICAgICAgICAgICBwYXRoIDogXCJUUFwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiVFAxXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVFAyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVFAzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVFA0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVFA1XCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDaGVhdCBTaGVldFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiL2Fzc2V0cy9zcWwvY2hlYXQgc2hlZXQuc3ZnXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lIDogXCJSIDMtMDMgVGVjaG5vbG9naWVzIFdlYlwiLFxuICAgICAgICBzbmFtZTogXCJSMy0wMyBXZWIxXCIsXG4gICAgICAgIHBhdGggOiBcIlIzLTAzXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDTVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiQ01cIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBcIkNNMVwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNNMlwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNNM1wiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiVFBcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBcIlRQXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgXCJUUDFcIixcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDaGVhdCBTaGVldCBIVE1MXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogXCIvYXNzZXRzL3dlYi9IVE1MNS9jaGVhdCBzaGVldC5zdmdcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWUgOiBcIlIgNS0wNi1WQ09EIETDqXZlbG9wcGVtZW50IExvZ2ljaWVsXCIsXG4gICAgICAgIHNuYW1lOiBcIlI1LTA2LVZDT0QgRGV2IExvZ1wiLFxuICAgICAgICBwYXRoIDogXCJSNS0wNi1WQ09EXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDTVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiQ01cIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBcIkNNMVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxuZXhwb3J0IGNvbnN0IHJvb3RfcGF0aCA9IFtcImxvY2FsaG9zdFwiLCBcIjEyNy4wLjAuMVwiXS5pbmNsdWRlcyhsb2NhdGlvbi5ob3N0bmFtZSkgPyBcIi9kaXN0L2Rldi9wYWdlcy9cIiA6IFwiL0NvdXJzL2Rpc3QvZGV2L3BhZ2VzL1wiOyIsIlxuaW1wb3J0IHBhZ2VzLCB7cm9vdF9wYXRofSBmcm9tIFwiLi9jb250ZW50XCI7XG5cbi8qXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlcHJpbnQnLCAoKSA9PiB7XG4gIC8vLi4uXG59KTtcbiovXG5cbi8vVE9ETzogbGlua3MuLi5cbmNvbnN0IG1haW4gICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtYWluXCIpITtcbmNvbnN0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkZXJcIikhO1xuXG5jb25zdCB0aXRsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxFbGVtZW50PihcImgxLCBoMiwgaDMsIGg0XCIpO1xuXG50eXBlIE5vZGUgPSB7XG4gICAgaHRtbCAgICA6IEhUTUxFbGVtZW50LFxuICAgIGxldmVsICAgOiBudW1iZXIsXG4gICAgcGFyZW50ICA6IG51bGx8Tm9kZSxcbiAgICBjaGlsZHJlbjogTm9kZVtdXG59O1xuXG5jb25zdCBodHJlZTogTm9kZSA9IHtcbiAgICBodG1sICAgIDogbWFpbixcbiAgICBsZXZlbCAgIDogMCxcbiAgICBwYXJlbnQgIDogbnVsbCxcbiAgICBjaGlsZHJlbjogW10sXG59O1xubGV0IGh0cmVlX2N1cnNvciA9IGh0cmVlO1xuZm9yKGxldCB0aXRsZSBvZiB0aXRsZXMpIHtcbiAgICBjb25zdCBsZXZlbCA9ICt0aXRsZS50YWdOYW1lLnNsaWNlKDEpO1xuICAgIFxuICAgIHdoaWxlKCBsZXZlbCA8PSBodHJlZV9jdXJzb3IubGV2ZWwgKVxuICAgICAgICBodHJlZV9jdXJzb3IgPSBodHJlZV9jdXJzb3IucGFyZW50ITtcblxuICAgIGNvbnN0IGVsZW06IE5vZGUgPSB7XG4gICAgICAgIGh0bWw6IHRpdGxlLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBwYXJlbnQ6IGh0cmVlX2N1cnNvclxuICAgIH07XG5cblxuICAgIGh0cmVlX2N1cnNvci5jaGlsZHJlbi5wdXNoKGVsZW0pO1xuXG4gICAgaHRyZWVfY3Vyc29yID0gZWxlbTtcbn1cblxuZnVuY3Rpb24gc2VhcmNoQ3VySGVhZGVyKGh0cmVlOiBOb2RlLCBwb3NpdGlvbjogbnVtYmVyKTogbnVsbCB8IE5vZGUge1xuXG4gICAgY29uc3QgaGVhZGVycyA9IGh0cmVlLmNoaWxkcmVuO1xuXG4gICAgZm9yKGxldCBpID0gaGVhZGVycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSlcbiAgICAgICAgaWYoIGhlYWRlcnNbaV0uaHRtbC5vZmZzZXRUb3AgPD0gcG9zaXRpb24gKyAzMiApXG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoQ3VySGVhZGVyKGhlYWRlcnNbaV0sIHBvc2l0aW9uKSA/PyBoZWFkZXJzW2ldO1xuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGhpZCA9IFtcbiAgICBbXSxcbiAgICBbXCJJXCIsIFwiSUlcIiwgXCJJSUlcIiwgXCJJVlwiXSxcbiAgICBbXCIxXCIsIFwiMlwiLFwiM1wiLFwiNVwiLFwiNlwiLFwiN1wiLFwiOFwiLFwiOVwiXSxcbiAgICBbXCJhXCIsIFwiYlwiLFwiY1wiLFwiZFwiLFwiZVwiLFwiZlwiLFwiZ1wiLFwiaFwiXSxcbl1cblxuZnVuY3Rpb24gZ2V0VGl0bGVQcmVmaXgoczogTm9kZSkge1xuXG4gICAgaWYoIHMubGV2ZWwgPj0gaGlkLmxlbmd0aCApXG4gICAgICAgIHJldHVybiBcIlwiO1xuXG4gICAgY29uc3QgaWR4ID0gcy5wYXJlbnQhLmNoaWxkcmVuLmluZGV4T2Yocyk7XG5cbiAgICBjb25zdCBudW0gPSBoaWRbcy5sZXZlbF1baWR4XTtcblxuICAgIHJldHVybiBgJHtudW19LiBgO1xufVxuXG5mdW5jdGlvbiBidWlsZE1lbnUobm9kZXM6IE5vZGVbXSkge1xuXG4gICAgY29uc3QgbWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbWVudS5jbGFzc0xpc3QuYWRkKFwibWVudVwiKTtcblxuICAgIG1lbnUuYXBwZW5kKCAuLi4gbm9kZXMubWFwKCAocyxpZHgpID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBpdGVtLnRleHRDb250ZW50PSBgJHtnZXRUaXRsZVByZWZpeChzKX0ke3MuaHRtbC50ZXh0Q29udGVudH1gO1xuICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3MuaHRtbC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkgKTtcblxuICAgIHJldHVybiBtZW51O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIZWFkZXIoKSB7XG5cbiAgICBjb25zdCBsYXN0ID0gc2VhcmNoQ3VySGVhZGVyKCBodHJlZSwgbWFpbi5zY3JvbGxUb3ApITtcblxuICAgIGxldCBoZWFkZXJzID0gW107XG4gICAgbGV0IGN1cnNvciAgPSBsYXN0O1xuXG4gICAgaWYoIGN1cnNvciAhPT0gbnVsbClcbiAgICAgICAgd2hpbGUoY3Vyc29yLmh0bWwgIT09IG1haW4pIHtcbiAgICAgICAgICAgIGhlYWRlcnMucHVzaChjdXJzb3IpO1xuICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudCE7XG4gICAgICAgIH1cblxuICAgIGNvbnN0IGh0bWwgPSBoZWFkZXJzLnJldmVyc2UoKS5tYXAoIChobm9kZSxpKSA9PiB7XG5cbiAgICAgICAgY29uc3QgaCA9IGhub2RlLmh0bWw7XG4gICAgICAgIGNvbnN0IGhfaHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgbGluay50ZXh0Q29udGVudCA9IGAke2dldFRpdGxlUHJlZml4KGhub2RlKX0ke2gudGV4dENvbnRlbnR9YDtcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBgIyR7aC5pZH1gKTtcblxuICAgICAgICBjb25zdCBtZW51ID0gYnVpbGRNZW51KGhub2RlLnBhcmVudCEuY2hpbGRyZW4pO1xuICAgICAgICBoX2h0bWwuYXBwZW5kKGxpbmssIG1lbnUpO1xuXG4gICAgICAgIHJldHVybiBoX2h0bWw7XG4gICAgfSk7XG5cbiAgICBpZiggbGFzdCAhPT0gbnVsbCAmJiBsYXN0LmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBlbXB0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgIGVtcHR5LmFwcGVuZCggYnVpbGRNZW51KGxhc3QuY2hpbGRyZW4pICk7XG5cbiAgICAgICAgaHRtbC5wdXNoKGVtcHR5KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VfcGFnZV9ocmVmKHBhdGhwcmVmaXg6IHN0cmluZywgcGF0aDogc3RyaW5nLCBkZXNjOiBhbnkpIHtcblxuICAgICAgICAvLyBoNGNrLi4uXG4gICAgICAgIGlmKCBwYXRoWzBdID09PSBcIi9cIiApXG4gICAgICAgICAgICByZXR1cm4gYCR7cm9vdF9wYXRoLnNsaWNlKDAsLTYpfS8ke3BhdGh9YDtcblxuICAgICAgICBsZXQgaHJlZiA9IGAke3BhdGhwcmVmaXh9JHtwYXRofS9gO1xuXG4gICAgICAgIHdoaWxlKGRlc2MuY2hpbGRyZW4/Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzYyA9IGRlc2MuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBocmVmICs9IGAke2Rlc2MucGF0aCA/PyBkZXNjfS9gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZV9wYWdlX21lbnUocGF0aHByZWZpeDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIHBhZ2VzOiBhbnkpIHtcbiAgICAgICAgY29uc3QgZGVzYyA9IHBhZ2VzLmZpbmQoIChwYWdlOiBhbnkpID0+IHBhZ2UgPT09IHBhdGggfHwgcGFnZS5wYXRoID09PSBwYXRoICkhO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gZGVzYy5zbmFtZSA/PyBkZXNjLm5hbWUgPz8gZGVzYztcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgbWFrZV9wYWdlX2hyZWYocGF0aHByZWZpeCwgcGF0aCwgZGVzYykgKTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IG1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgbWVudS5jbGFzc0xpc3QuYWRkKFwibWVudVwiKTtcbiAgICBcbiAgICAgICAgICAgIG1lbnUuYXBwZW5kKCAuLi4gcGFnZXMubWFwKCAocGFnZTphbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICAgICAgaXRlbS50ZXh0Q29udGVudD0gcGFnZS5uYW1lID8/IHBhZ2U7XG5cbiAgICAgICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgbWFrZV9wYWdlX2hyZWYocGF0aHByZWZpeCwgcGFnZS5wYXRoPz9wYWdlLCBwYWdlKSApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSkgKTtcbiAgICBcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kKGxpbmssIG1lbnUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIFxuICAgIGxldCBjdXJwYWdlID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnNsaWNlKHJvb3RfcGF0aC5sZW5ndGgpLnNwbGl0KCcvJyk7XG5cbiAgICBjb25zdCBtb2R1bGVfaHRtbCA9IG1ha2VfcGFnZV9tZW51KHJvb3RfcGF0aCwgY3VycGFnZVswXSwgcGFnZXMpO1xuXG4gICAgY29uc3QgZGVzYyA9IHBhZ2VzLmZpbmQoIChwYWdlOiBhbnkpID0+IHBhZ2UucGF0aCA9PT0gY3VycGFnZVswXSApITtcbiAgICBjb25zdCB0eXBlX2h0bWwgICA9IG1ha2VfcGFnZV9tZW51KHJvb3RfcGF0aCArIGN1cnBhZ2VbMF0gKyBcIi9cIiwgY3VycGFnZVsxXSwgZGVzYy5jaGlsZHJlbik7XG5cbiAgICBjb25zdCBkZXNjX3R5cGUgPSBkZXNjLmNoaWxkcmVuLmZpbmQoIChwYWdlOiBhbnkpID0+IChwYWdlPy5wYXRoID8/IHBhZ2UpID09PSBjdXJwYWdlWzFdICkhO1xuICAgIGlmKCB0eXBlb2YgZGVzY190eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIHRpdGxlIG51bVxuICAgICAgICBjb25zdCBkZXNjMl9pZHggPSBkZXNjX3R5cGUuY2hpbGRyZW4uZmluZEluZGV4KCAocGFnZTogYW55KSA9PiBwYWdlPy5wYXRoID8/IHBhZ2UgPT09IGN1cnBhZ2VbMl0gKSE7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoXCItLWhlYWRlcl9zdGFydF9pZFwiLCBgJHtkZXNjMl9pZHh9YCk7XG4gICAgICAgIC8vIG1lbnVcbiAgICAgICAgY29uc3Qgc2Vzc2lvbl9odG1sICAgPSBtYWtlX3BhZ2VfbWVudShyb290X3BhdGggKyBjdXJwYWdlWzBdICsgXCIvXCIrIGN1cnBhZ2VbMV0gKyBcIi9cIiwgY3VycGFnZVsyXSwgZGVzY190eXBlLmNoaWxkcmVuKTtcbiAgICAgICAgaHRtbFswXSA9IHNlc3Npb25faHRtbDtcbiAgICB9XG5cbiAgICBoZWFkZXIucmVwbGFjZUNoaWxkcmVuKG1vZHVsZV9odG1sLCB0eXBlX2h0bWwsIC4uLmh0bWwpO1xufVxuXG5jb25zdCBwID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpO1xuaWYoICEgcC5oYXMoJ2RzJykgKSB7XG4gICAgbWFpbi5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGVIZWFkZXIpO1xuICAgIHVwZGF0ZUhlYWRlcigpO1xufSIsIndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLXNjcmVlbl93aWR0aCcsIGAke3dpbmRvdy5pbm5lcldpZHRofWApO1xufSk7XG5cbmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zY3JlZW5fd2lkdGgnLCBgJHt3aW5kb3cuaW5uZXJXaWR0aH1gKTsiLCJpbXBvcnQgTElTUyBmcm9tIFwiaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vZGVuaXMtbWlnZGFsL0xJU1MvbWFpbi9pbmRleC5qc1wiXG5cblxuY29uc3QgY29udGVudCA9IGA8c3BhbiBjbGFzcz1cInJlc2V0XCI+W1Jlc2V0XTwvc3Bhbj48c3BhbiBjbGFzcz1cInByZXZcIj5bUHJldl08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbGF5XCI+W1BsYXkvUGF1c2VdPC9zcGFuPjxzcGFuIGNsYXNzPVwibmV4dFwiPltOZXh0XTwvc3Bhbj5gO1xuXG5jb25zdCBjc3MgPSBgXG5gO1xuXG5jb25zdCBzdHlsZXMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKV0ubWFwKHMgPT4ge1xuICAgIGxldCBzdHlsZSA9IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG4gICAgc3R5bGUucmVwbGFjZVN5bmMocy50ZXh0Q29udGVudCk7XG4gICAgcmV0dXJuIHN0eWxlO1xufSk7XG5cbmNsYXNzIEFuaW1QbGF5ZXIgZXh0ZW5kcyBMSVNTKHtcbiAgICBjb250ZW50LFxuICAgIGNzczogW2NzcywgLi4uc3R5bGVzXSxcbiAgICBhdHRyaWJ1dGVzOiBbXCJzcGVlZFwiXVxufSkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RlcElEID0gMDtcblxuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5wcmV2XCIgKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5wcmV2KCkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5uZXh0XCIgKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5uZXh0KCkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5wbGF5XCIgKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5wbGF5KCkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5yZXNldFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5yZXNldCgpKTtcbiAgICB9XG5cbiAgICBuZXh0U3RlcCgpIHtcbiAgICAgICAgKyt0aGlzLnN0ZXBJRDtcbiAgICAgICAgdGhpcy5ob3N0LmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudChcInN0ZXBcIiwge2RldGFpbDogdGhpcy5zdGVwSUR9KSApO1xuICAgIH1cblxuXG4gICAgY2FuY2VsQXV0b1BsYXkoKSB7XG5cbiAgICAgICAgaWYodGhpcy5pZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaWQpO1xuICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJldigpIHtcbiAgICAgICAgY29uc3QgbmV3U3RlcElEID0gdGhpcy5zdGVwSUQgLSAxO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHdoaWxlKHRoaXMuc3RlcElEICE9PSBuZXdTdGVwSUQpXG4gICAgICAgICAgICB0aGlzLm5leHRTdGVwKCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQXV0b1BsYXkoKTtcbiAgICAgICAgdGhpcy5uZXh0U3RlcCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxBdXRvUGxheSgpO1xuICAgICAgICB0aGlzLnN0ZXBJRCA9IDA7XG4gICAgICAgIHRoaXMuaG9zdC5kaXNwYXRjaEV2ZW50KCBuZXcgQ3VzdG9tRXZlbnQoXCJyZXNldFwiKSApO1xuICAgIH1cbiAgICBwbGF5KCkge1xuXG4gICAgICAgIGlmKCB0aGlzLmNhbmNlbEF1dG9QbGF5KCkgKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmlkID0gc2V0SW50ZXJ2YWwoICgpID0+IHRoaXMubmV4dFN0ZXAoKSwgKyh0aGlzLmF0dHJzLnNwZWVkID8/IDUwMCkgKTtcbiAgICB9XG59XG5cbkxJU1MuZGVmaW5lKFwiYW5pbS1wbGF5ZXJcIiwgQW5pbVBsYXllcikiLCJpbXBvcnQgTElTUyBmcm9tIFwiaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vZGVuaXMtbWlnZGFsL0xJU1MvbWFpbi9pbmRleC5qc1wiXG5cbmltcG9ydCB7ZGIyfSBmcm9tIFwiLi9TUUxpdGVcIjtcblxuY29uc3QgQ1NTID1cbmA6aG9zdCB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xufVxuXG46aG9zdCB0YWJsZSB7XG4gICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcblxuICAgICYgY2FwdGlvbiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNnB4O1xuICAgICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgfVxuICAgIFxuICAgICYgLmhpZ2hsaWdodCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICM4QjgwMDA7XG4gICAgICAgIHByaW50LWNvbG9yLWFkanVzdDogZXhhY3Q7XG4gICAgfVxuXG4gICAgLyogVE9ETzogbWFrZSBzdHlsZSBhZG9wdGFibGUgdGhyb3VnaCBMSVNTLi4uICovXG4gICAgLmhpZ2hfMSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgICB9XG4gICAgLmhpZ2hfMiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsdWU7XG4gICAgfVxuICAgIC5oaWdoXzMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbjtcbiAgICB9XG4gICAgLmhpZ2hfbnVsbCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IG9yYW5nZTtcbiAgICB9XG4gICAgLmhpZGUge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgICAuY3VyIHtcbiAgICAgICAgYm9yZGVyIDogNHB4IHNvbGlkIHllbGxvdztcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgIH1cbiAgICAubG93bGlnaHQge1xuICAgICAgICBvcGFjaXR5OiAwLjI1O1xuICAgIH1cblxuICAgICYgdGQsICYgdGgge1xuICAgICAgICBwYWRkaW5nOiA1cHggMTBweDtcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICB9XG5cbiAgICAmIHRkIHtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMjJweDtcbiAgICB9XG5cbiAgICAmIHRoIHtcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMjZweDtcbiAgICB9XG4gICAgXG4gICAgJiA+IHRib2R5ID4gdHIgKyB0ciA+IHRkIHtcbiAgICAgICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkO1xuICAgIH1cbn1gO1xuXG5jbGFzcyBTUUxEeW1UYWJsZSBleHRlbmRzIExJU1Moe1xuICAgIGF0dHJpYnV0ZXM6IFtcInRhYmxlXCIsIFwiaGVhZGVyXCIsIFwiY29sc1wiXSxcbiAgICBjc3M6IENTU1xufSkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGxldCBjb2xzID0gdGhpcy5hdHRycy5jb2xzID8/IFwiKlwiO1xuXG4gICAgICAgIHRoaXMuZXhlYyhgU0VMRUNUICR7Y29sc30gRlJPTSAke3RoaXMuYXR0cnMudGFibGV9O2ApXG4gICAgfVxuXG4gICAgZ2V0IG5iUm93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldFJvdyhyb3dpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzW3Jvd2lkXTtcbiAgICB9XG5cbiAgICBleGVjKHF1ZXJ5KSB7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGIyLmV4ZWNfb25lKHF1ZXJ5KTtcblxuICAgICAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG5cbiAgICAgICAgY29uc3QgY2FwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhcHRpb24nKTtcblxuICAgICAgICBpZiggdGhpcy5hdHRycy5oZWFkZXIgPT09IG51bGwpXG4gICAgICAgICAgICBjYXB0aW9uLnRleHRDb250ZW50ID0gYFRhYmxlICR7dGhpcy5hdHRycy50YWJsZX0gOmA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhcHRpb24udGV4dENvbnRlbnQgPSB0aGlzLmF0dHJzLmhlYWRlcjtcblxuICAgICAgICAvL1RPRE86IGNvbGdyb3VwIChmb3IgaGlnaGxpZ2h0KS5cblxuICAgICAgICBjb25zdCBjb2xncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbGdyb3VwJyk7XG4gICAgICAgIGNvbnN0IHRoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGhlYWQnKTtcbiAgICAgICAgY29uc3QgdHJoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuICAgICAgICB0aGlzLmNvbHMgPSB7fTtcblxuICAgICAgICBjb25zdCBjb2xuYW1lcyA9ICBPYmplY3Qua2V5cyh0aGlzLmRhdGFbMF0pO1xuICAgICAgICBmb3IobGV0IGNvbG5hbWUgb2YgY29sbmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbCcpO1xuICAgICAgICAgICAgLy9jb2wuY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICBjb2xncm91cC5hcHBlbmQoY29sKTtcblxuICAgICAgICAgICAgdGhpcy5jb2xzW2NvbG5hbWVdID0gY29sO1xuXG4gICAgICAgICAgICBjb25zdCB0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgICAgICB0aC50ZXh0Q29udGVudCA9IGNvbG5hbWU7XG4gICAgICAgICAgICB0cmhlYWQuYXBwZW5kKHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVhZC5hcHBlbmQodHJoZWFkKTtcblxuICAgICAgICB0aGlzLnJvd3MgPSBbXTtcblxuICAgICAgICBjb25zdCB0Ym9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG4gICAgICAgIGZvcihsZXQgbGluZSBvZiB0aGlzLmRhdGEpIHtcblxuICAgICAgICAgICAgY29uc3QgdHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgZm9yKGxldCBjb2xuYW1lIG9mIGNvbG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgIHRkLnRleHRDb250ZW50ID0gbGluZVtjb2xuYW1lXSA/PyBcIk4vQVwiO1xuICAgICAgICAgICAgICAgIHRyLmFwcGVuZCh0ZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Ym9keS5hcHBlbmQodHIpO1xuXG4gICAgICAgICAgICB0aGlzLnJvd3MucHVzaChbbGluZSx0cl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGUuYXBwZW5kKGNhcHRpb24sIGNvbGdyb3VwLCB0aGVhZCwgdGJvZHkpO1xuICAgICAgICB0aGlzLmNvbnRlbnQucmVwbGFjZUNoaWxkcmVuKHRhYmxlKTtcbiAgICB9XG5cbiAgICBncm91cEJ5KCBncm91cF9jb2xuYW1lICkge1xuXG4gICAgICAgIGNvbnN0IHRib2R5ID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0Ym9keVwiKTtcblxuICAgICAgICBsZXQgZ3JvdXBzID0ge307XG5cbiAgICAgICAgZm9yKGxldCBsaW5lIG9mIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBsaW5lW2dyb3VwX2NvbG5hbWVdO1xuICAgICAgICAgICAgKGdyb3Vwc1tncm91cF0gPz89IFtdKS5wdXNoKCBsaW5lICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcm93cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGdyb3VwbmFtZSBpbiBncm91cHMpIHtcblxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbZ3JvdXBuYW1lXTtcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGdyb3VwW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuICAgICAgICAgICAgICAgIGZvcihsZXQgY29sIGluIGdyb3VwW2ldKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwudGV4dENvbnRlbnQgPSBlbnRyeVtjb2xdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBjb2wgPT09IGdyb3VwX2NvbG5hbWUgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0QXR0cmlidXRlKFwicm93c3BhblwiLCBncm91cC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKGNlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3dzLnB1c2godHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgcm93cy5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0Ym9keS5yZXBsYWNlQ2hpbGRyZW4oLi4ucm93cyk7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0Q29sKCBmaWx0ZXIgKSB7XG4gICAgICAgIGZvcihsZXQgY29sbmFtZSBpbiB0aGlzLmNvbHMpXG4gICAgICAgICAgICB0aGlzLiNoaWdobGlnaHQodGhpcy5jb2xzW2NvbG5hbWVdLCBmaWx0ZXIoY29sbmFtZSkgKTtcbiAgICB9XG5cbiAgICAjaGlnaGxpZ2h0KHRhcmdldCwgaGlnaGxpZ2h0KSB7IC8vIHRhcmdldDogSFRNTEVsZW1lbnQsIGhpZ2hsaWdodDogYm9vbGVhbnxzdHJpbmd8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4gKSB7XG5cbiAgICAgICAgaWYoIHR5cGVvZiBoaWdobGlnaHQgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdoaWdobGlnaHQnLCBoaWdobGlnaHQpO1xuICAgICAgICBpZiggdHlwZW9mIGhpZ2hsaWdodCA9PT0gXCJzdHJpbmdcIiApXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmNsYXNzTGlzdC5hZGQoaGlnaGxpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGZvcihsZXQgbmFtZSBpbiBoaWdobGlnaHQpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZShuYW1lLCBoaWdobGlnaHRbbmFtZV0pO1xuXG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0Um93KCBmaWx0ZXIgKSB7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0aGlzLiNoaWdobGlnaHQoIHRoaXMucm93c1tpXVsxXSwgZmlsdGVyKHRoaXMucm93c1tpXVswXSwgaSkgKTtcbiAgICB9XG5cbiAgICBoaWdobGlnaHRDZWxscyggZmlsdGVyICkge1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3MubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgY29uc3QgW3Jvd19kYXRhLCByb3dfaHRtbF0gPSB0aGlzLnJvd3NbaV07XG4gICAgICAgICAgICBjb25zdCBjb2xzID0gT2JqZWN0LmtleXMocm93X2RhdGEpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgY29scy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICB0aGlzLiNoaWdobGlnaHQoIHJvd19odG1sLmNoaWxkcmVuW2pdICwgZmlsdGVyKHJvd19kYXRhLCBjb2xzW2pdKSApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5MSVNTLmRlZmluZShcInNxbC1keW10YWJsZVwiLCBTUUxEeW1UYWJsZSkiLCJpbXBvcnQge2RiMn0gZnJvbSBcIi4vU1FMaXRlXCI7XG5cbi8vIExJU1NcblxuaW1wb3J0IExJU1MgZnJvbSBcIkxJU1NcIjtcblxuY29uc3QgY29udGVudCA9IGBcbiAgICA8c2xvdCBuYW1lPVwic2VsZWN0XCI+PC9zbG90PlxuICAgIDxzbG90IG5hbWU9XCJvcHRpb25zXCI+PC9zbG90PlxuICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8c2xvdCBuYW1lPVwicHJlXCI+PC9zbG90PlxuICAgIDxkaXYgY2xhc3M9XCJjaG9pY2VzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJvcHRpb25zXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJxdWVyeVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxwcmUgY2xhc3M9XCJobGpzXCI+PGNvZGU+PGRpdiBjbGFzcz1cInJlc3VsdFwiPjwvZGl2PjwvY29kZT48L3ByZT5cbiAgICA8ZGl2IGNsYXNzPVwic3BhY2luZ1wiPjwvZGl2PlxuICAgIDxzbG90IG5hbWU9XCJwb3N0XCI+PC9zbG90PmA7XG5cbmNvbnN0IGNzcyA9IGBcbiAgICA6aG9zdChbb3B0aW9uXSkgcHJlIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cblxuICAgIDpob3N0IHtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMTlweDtcbiAgICB9XG5cbiAgICAuc2VsZWN0ZWQsIC5oaWdobGlnaHQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBnb2xkO1xuICAgIH1cbiAgICA6aG9zdCAuc3BhY2luZyB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICB9XG4gICAgOmhvc3QgLnF1ZXJ5IHByZS5obGpzIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMDtcblxuICAgICAgICAmID4gY29kZSA+IGRpdiB7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIDpob3N0IHByZS5obGpzIHtcblxuICAgICAgICBtYXJnaW46IDJweDtcblxuICAgICAgICAmID4gY29kZSA+IGRpdiB7XG4gICAgICAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAub3B0aW9ucyBwcmUge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDI1cHg7XG5cbiAgICAgICAgJi53aXRoZGVzYyB7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMHB4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC5vcHRpb25zIHByZTo6YWZ0ZXIge1xuICAgICAgICBjb250ZW50OiBcIj5cIjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICByaWdodDogMHB4O1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogMjVweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogb3JhbmdlO1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIFxuICAgIH1cbiAgICAub3B0aW9ucyBwcmU6aG92ZXIge1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgfVxuICAgIDpob3N0IHtcbiAgICAgICAgLypkaXNwbGF5OiBpbmxpbmUtZmxleDsqL1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBnYXA6IDVweDtcbiAgICB9XG4gICAgc2xvdDpub3QoW25hbWU9XCJwb3N0XCJdKTpub3QoW25hbWU9XCJwcmVcIl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgc3Bhbi52YWx1ZSB7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogNXB4O1xuICAgIH1cblxuICAgIC5vcHRpb24ge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuXG4gICAgLmVycm9yIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGQTA3QSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5xdWVyeSA+IHByZSAudmFsdWUge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1yaWdodDogMTNweDtcbiAgICB9XG5cbiAgICAucXVlcnkgPiBwcmUgLnZhbHVlOjphZnRlciB7XG5cbiAgICAgICAgcmlnaHQ6IC0xOHB4O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGNvbnRlbnQ6IFwi8J+WiVwiO1xuICAgIH1cblxuICAgIDpob3N0ID4gcHJlLmhsanMge1xuICAgICAgICAvKmZsZXgtZ3JvdzogMTsqL1xuICAgIH1cblxuICAgIDpob3N0IC5kZXNjIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC0wLjVlbTtcbiAgICAgICAgLypwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMHB4O1xuICAgICAgICBsZWZ0OiAwcHg7Ki9cblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxOXB4O1xuXG4gICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgKyAwLjVlbSk7XG4gICAgICAgIGJvcmRlci1sZWZ0OiBub25lO1xuICAgICAgICBib3JkZXItdG9wOiBub25lO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRncmF5O1xuICAgICAgICBvcGFjaXR5OiAwLjY7XG4gICAgfVxuXG4gICAgcHJlIHtcbiAgICAgICAgcGFkZGluZzogMC41ZW07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBjb2xvcjogYmxhY2s7XG4gICAgfVxuXG4gICAgY29kZSB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXCJEcm9pZCBTYW5zIE1vbm9cIiwgXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2UsIFwiRHJvaWQgU2FucyBGYWxsYmFja1wiO1xuICAgIH1cblxuICAgIC8qIFRvbW9ycm93IFRoZW1lICovXG4gICAgLyogaHR0cDovL2ptYmxvZy5naXRodWIuY29tL2NvbG9yLXRoZW1lcy1mb3ItZ29vZ2xlLWNvZGUtaGlnaGxpZ2h0anMgKi9cbiAgICAvKiBPcmlnaW5hbCB0aGVtZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc2tlbXBzb24vdG9tb3Jyb3ctdGhlbWUgKi9cblxuICAgIC8qIFRvbW9ycm93IENvbW1lbnQgKi9cbiAgICAuaGxqcy1jb21tZW50LFxuICAgIC5obGpzLXF1b3RlIHtcbiAgICAgICAgY29sb3I6ICM4ZTkwOGM7XG4gICAgfVxuXG4gICAgLyogVG9tb3Jyb3cgUmVkICovXG4gICAgLmhsanMtdmFyaWFibGUsXG4gICAgLmhsanMtdGVtcGxhdGUtdmFyaWFibGUsXG4gICAgLmhsanMtdGFnLFxuICAgIC5obGpzLW5hbWUsXG4gICAgLmhsanMtc2VsZWN0b3ItaWQsXG4gICAgLmhsanMtc2VsZWN0b3ItY2xhc3MsXG4gICAgLmhsanMtcmVnZXhwLFxuICAgIC5obGpzLWRlbGV0aW9uIHtcbiAgICAgICAgY29sb3I6ICNjODI4Mjk7XG4gICAgfVxuXG4gICAgLyogVG9tb3Jyb3cgT3JhbmdlICovXG4gICAgLmhsanMtbnVtYmVyLFxuICAgIC5obGpzLWJ1aWx0X2luLFxuICAgIC5obGpzLWJ1aWx0aW4tbmFtZSxcbiAgICAuaGxqcy1saXRlcmFsLFxuICAgIC5obGpzLXR5cGUsXG4gICAgLmhsanMtcGFyYW1zLFxuICAgIC5obGpzLW1ldGEsXG4gICAgLmhsanMtbGluayB7XG4gICAgICAgIGNvbG9yOiAjZjU4NzFmO1xuICAgIH1cblxuICAgIC8qIFRvbW9ycm93IFllbGxvdyAqL1xuICAgIC5obGpzLWF0dHJpYnV0ZSB7XG4gICAgICAgIGNvbG9yOiAjZWFiNzAwO1xuICAgIH1cblxuICAgIC8qIFRvbW9ycm93IEdyZWVuICovXG4gICAgLmhsanMtc3RyaW5nLFxuICAgIC5obGpzLXN5bWJvbCxcbiAgICAuaGxqcy1idWxsZXQsXG4gICAgLmhsanMtYWRkaXRpb24ge1xuICAgICAgICBjb2xvcjogIzcxOGMwMDtcbiAgICB9XG5cbiAgICAvKiBUb21vcnJvdyBCbHVlICovXG4gICAgLmhsanMtdGl0bGUsXG4gICAgLmhsanMtc2VjdGlvbiB7XG4gICAgICAgIGNvbG9yOiAjNDI3MWFlO1xuICAgIH1cblxuICAgIC8qIFRvbW9ycm93IFB1cnBsZSAqL1xuICAgIC5obGpzLWtleXdvcmQsXG4gICAgLmhsanMtc2VsZWN0b3ItdGFnIHtcbiAgICAgICAgY29sb3I6ICM4OTU5YTg7XG4gICAgfVxuXG4gICAgLmhsanMge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgb3ZlcmZsb3cteDogYXV0bztcbiAgICAgICAgY29sb3I6ICM0ZDRkNGM7XG4gICAgICAgIHBhZGRpbmc6IDAuNWVtO1xuICAgIH1cblxuICAgIC5obGpzLWVtcGhhc2lzIHtcbiAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgIH1cblxuICAgIC5obGpzLXN0cm9uZyB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cbmA7XG5cbi8qXG5jb25zdCBzdHlsZXMgPSBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKV0ubWFwKHMgPT4ge1xuICAgIGxldCBzdHlsZSA9IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG4gICAgc3R5bGUucmVwbGFjZVN5bmMocy50ZXh0Q29udGVudCk7XG4gICAgcmV0dXJuIHN0eWxlO1xufSk7Ki9cblxuY2xhc3MgU1FMSW50ZXJhY3RpdmUgZXh0ZW5kcyBMSVNTKHtcbiAgICBjb250ZW50LFxuICAgIGNzczogW2Nzc10sXG4gICAgYXR0cmlidXRlczogW1wiZnVsbC1yZXNldFwiLCBcIm9wdGlvblwiXVxufSkge1xuXG4gICAgI3Jlc3VsdCAgID0gXCJcIjtcbiAgICAjcXVlcnkgICAgPSBudWxsO1xuICAgICNvcHRpb25zICA9IG51bGw7XG4gICAgI2lucHV0ICAgID0gbnVsbDtcbiAgICAjc2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgI3NlbGVjdFF1ZXJ5ID0gbnVsbDtcblxuICAgIG9uQXR0ckNoYW5nZWQobmFtZSwgX29sZCwgdmFsdWUpIHtcbiAgICAgICAgaWYobmFtZSAhPT0gXCJvcHRpb25cIilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBzZXRPcHRpb24oK3ZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXRPcHRpb24oaWR4KSB7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuI29wdGlvbnMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IHRoaXMuI29wdGlvbnMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBvcHQuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIGkgPT09IGlkeCA/IG51bGwgOiBcIm5vbmVcIik7XG4gICAgICAgICAgICBpZiggaSA9PT0gaWR4KVxuICAgICAgICAgICAgICAgIG9wdC5jbGljaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3F1ZXJ5LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG5cbiAgICAgICAgdGhpcy5ob3N0LnN0eWxlLnNldFByb3BlcnR5KFwiZmxleC13cmFwXCIsIFwid3JhcFwiKTtcblxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuI3Jlc3VsdCAgID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIucmVzdWx0XCIpO1xuICAgICAgICB0aGlzLiNxdWVyeSAgICA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLnF1ZXJ5XCIpO1xuICAgICAgICB0aGlzLiNvcHRpb25zICA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLm9wdGlvbnNcIik7XG4gXG4gICAgICAgIGxldCBzZWxlY3RRdWVyeSA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwic2xvdFtuYW1lPSdzZWxlY3QnXVwiKS5hc3NpZ25lZEVsZW1lbnRzKCk7XG4gICAgICAgIGlmKHNlbGVjdFF1ZXJ5Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHRoaXMuI3NlbGVjdFF1ZXJ5ICA9IHNlbGVjdFF1ZXJ5WzBdLnRleHRDb250ZW50O1xuXG4gICAgICAgIHRoaXMuI29wdGlvbnMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldikgPT4ge1xuXG4gICAgICAgICAgICBsZXQgb3B0aW9uID0gZXYudGFyZ2V0LmNsb3Nlc3QoXCIub3B0aW9uXCIpO1xuICAgICAgICAgICAgaWYob3B0aW9uID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuI3NlbGVjdGVkICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuI3NlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICBvcHRpb24uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuI3NlbGVjdGVkID0gb3B0aW9uO1xuXG4gICAgICAgICAgICB0aGlzLmxhc3RWYXJzID0ge307XG5cbiAgICAgICAgICAgIGNvbnN0IG9wdHN2YWx1ZXMgPSBvcHRpb24ucXVlcnlTZWxlY3RvckFsbCgnLnZhbHVlJyk7XG4gICAgICAgICAgICBmb3IoIGxldCBvcHRzdmFsdWUgb2Ygb3B0c3ZhbHVlcykgeyAvLyBub3Qgb3B0aW1hbCBidXQgaXQgd29ya3NcblxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFZhcnNbb3B0c3ZhbHVlLmRhdGFzZXQubmFtZV0gPSBvcHRzdmFsdWUudGV4dENvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLiNpbnB1dC5xdWVyeVNlbGVjdG9yQWxsKGAudmFsdWVbZGF0YS1uYW1lPVwiJHtvcHRzdmFsdWUuZGF0YXNldC5uYW1lfVwiXWApO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgdmFsdWUgb2YgdmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50ZXh0Q29udGVudCA9IG9wdHN2YWx1ZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4jZXhlY1F1ZXJ5KCApO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcInNsb3Q6bm90KFtuYW1lXSlcIikuYXNzaWduZWRFbGVtZW50cygpWzBdO1xuICAgICAgICAvL1RPRE86IGZpbmQgJiByZXBsYWNlLi4uXG5cbiAgICAgICAgdGhpcy4jaW5wdXQgPSBxdWVyeS5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgdGhpcy4jcXVlcnkuYXBwZW5kKHRoaXMuI2lucHV0KTtcblxuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwic2xvdFtuYW1lPSdvcHRpb25zJ11cIikuYXNzaWduZWRFbGVtZW50cygpO1xuXG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBbLi4udGhpcy4jaW5wdXQuY2hpbGRyZW5bMF0uY2hpbGROb2Rlc107XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICBpZiggbm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGxldCB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRleHQuaW5kZXhPZignJCcpO1xuICAgICAgICAgICAgaWYoIHN0YXJ0ID09PSAtMSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICB3aGlsZSggc3RhcnQgIT09IC0xKSB7IC8vIG5vdCBvcHRpbWFsIGJ1dCBpdCB3b3Jrcy4uLlxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBlbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0KzEpLnNlYXJjaCgvW1xcV10vKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggdGV4dCwgc3RhcnQsIHRleHQuc2xpY2Uoc3RhcnQrMSkgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmQgb2YgU1FMIHZhcmlhYmxlIG5vdCBmb3VuZCAoeW91IGxpa2VseSB1c2VkIGEgcmVzZXJ2ZWQga2V5d29yZCknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kICs9IHN0YXJ0ICsgMTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgdmFsdWUuY2xhc3NMaXN0LmFkZChcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmRhdGFzZXQubmFtZSA9IHRleHQuc2xpY2Uoc3RhcnQrMSwgZW5kKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uIHRleHQuc2xpY2UoMCwgc3RhcnQpLCB2YWx1ZSApO1xuXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoZW5kKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRleHQuaW5kZXhPZignJCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0KTtcblxuICAgICAgICAgICAgbm9kZS5yZXBsYWNlV2l0aCguLi5yZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9wdGlvbl90ZW1wbGF0ZSA9IHRoaXMuI2lucHV0LmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLiNpbnB1dC5xdWVyeVNlbGVjdG9yQWxsKCcudmFsdWUnKTtcbiAgICAgICAgZm9yKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcblxuICAgICAgICAgICAgdmFsdWUudG9nZ2xlQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICAgICAgICAgIGlmKCAhIHZhbHVlLmRhdGFzZXQubmFtZS5zdGFydHNXaXRoKCdtXycpICkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGV2KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZXYua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YWx1ZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChldikgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy4jc2VsZWN0ZWQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3NlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jaW5wdXQuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNzZWxlY3RlZCA9IHRoaXMuI2lucHV0O1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3luY2lucHV0cyA9IHRoaXMuI2lucHV0LnF1ZXJ5U2VsZWN0b3JBbGwoYC52YWx1ZVtkYXRhLW5hbWU9XCIke2V2LnRhcmdldC5kYXRhc2V0Lm5hbWV9XCJdYCk7XG4gICAgICAgICAgICAgICAgZm9yKCBsZXQgaW5wdXQgb2Ygc3luY2lucHV0cyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5wdXQgPT09IGV2LnRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC50ZXh0Q29udGVudCA9IGV2LnRhcmdldC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLiNleGVjUXVlcnkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGxldCBvcHRpb24gb2Ygb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBvcHRpb25fdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgb3B0LmNsYXNzTGlzdC5hZGQoXCJvcHRpb25cIik7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdC5xdWVyeVNlbGVjdG9yQWxsKCcudmFsdWUnKTtcbiAgICAgICAgICAgIGZvcihsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSAgPSB2YWx1ZS5kYXRhc2V0Lm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudGV4dENvbnRlbnQgPSBvcHRpb24uZGF0YXNldFsgbmFtZSBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggb3B0aW9uLnRleHRDb250ZW50ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgb3B0LmNsYXNzTGlzdC5hZGQoJ3dpdGhkZXNjJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZGVzYy5jbGFzc0xpc3QuYWRkKFwiZGVzY1wiKTtcbiAgICAgICAgICAgICAgICBkZXNjLnRleHRDb250ZW50ID0gb3B0aW9uLnRleHRDb250ZW50LnRyaW0oKSArIFwiIDpcIjtcblxuICAgICAgICAgICAgICAgIG9wdC5maXJzdEVsZW1lbnRDaGlsZC5iZWZvcmUoZGVzYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuI29wdGlvbnMuYXBwZW5kKCBvcHQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0aGlzLmF0dHJzLm9wdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb24oK3RoaXMuYXR0cnMub3B0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB0aGlzLiNzZWxlY3RRdWVyeSA9PT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuI29wdGlvbnMuZmlyc3RFbGVtZW50Q2hpbGQuY2xpY2soKTtcbiAgICB9XG5cbiAgICAjZ2V0UXVlcnkoKSB7XG5cbiAgICAgICAgbGV0IHF1ZXJ5ID0gXCJcIjtcbiAgICAgICAgZm9yKGxldCBlbGVtIG9mIHRoaXMuI2lucHV0LmZpcnN0RWxlbWVudENoaWxkLmNoaWxkTm9kZXMgKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtLnRleHRDb250ZW50O1xuICAgICAgICAgICAgaWYoY29udGVudCA9PT0gXCJcIiAmJiBlbGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmKCBxdWVyeVtxdWVyeS5sZW5ndGgtMV0gPT09IFwiIFwiIClcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5zbGljZSgwLC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5ICs9IGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuXG4gICAgI2V4ZWNRdWVyeSgpIHtcblxuXG4gICAgICAgIGxldCBxdWVyaWVzID0gdGhpcy4jZ2V0UXVlcnkoKS5zcGxpdCgnO1xcbicpLnNsaWNlKDAsLTEpLm1hcCggcSA9PiBxICsgXCI7XCIpO1xuXG4gICAgICAgIC8vIGJ1aWxkIHF1ZXJpZXMgdG8gZXhlY3V0ZS4uLlxuXG4gICAgICAgIGNvbnN0IGV4ZWNfcXVlcmllcyA9IFtdO1xuICAgICAgICBsZXQgc2hvd190YWJsZSA9IHRydWU7XG5cbiAgICAgICAgbGV0IHNob3dfcXVlcmllcyA9IG51bGw7XG4gICAgICAgIGlmKCB0aGlzLiNzZWxlY3RRdWVyeSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgIHNob3dfcXVlcmllcyA9IHRoaXMuI3NlbGVjdFF1ZXJ5LnNwbGl0KCc7Jykuc2xpY2UoMCwtMSkubWFwKCBxID0+IHEudHJpbSgpICsgXCI7XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hvdyA9ICgpID0+IHtcbiAgICAgICAgICAgIHNob3dfdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKCBzaG93X3F1ZXJpZXMgPT09IG51bGwgKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGV4ZWNfcXVlcmllcy5wdXNoKC4uLnNob3dfcXVlcmllcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcXVlcmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBxdWVyaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiggcXVlcnkuc3RhcnRzV2l0aChcIlNFTEVDVCBcIikgfHwgcXVlcnkuc3RhcnRzV2l0aChcIlZBTFVFUyBcIikgKSB7XG4gICAgICAgICAgICAgICAgZXhlY19xdWVyaWVzLnB1c2gocXVlcnkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggcXVlcnkuc3RhcnRzV2l0aChcIkNSRUFURSBUQUJMRSBcIikgKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgcSA9IFwiQ1JFQVRFIFRBQkxFIFwiO1xuICAgICAgICAgICAgICAgIGlmKCBxdWVyeS5zdGFydHNXaXRoKFwiQ1JFQVRFIFRBQkxFIElGIEVYSVNUUyBcIikgKVxuICAgICAgICAgICAgICAgICAgICBxID0gXCJDUkVBVEUgVEFCTEUgSUYgRVhJU1RTIFwiO1xuXG4gICAgICAgICAgICAgICAgZXhlY19xdWVyaWVzLnB1c2gocXVlcnkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRiX25hbWUgPSBxdWVyeS5zbGljZSgxMywgcXVlcnkuaW5kZXhPZihcIiBcIiwgcS5sZW5ndGgpICk7XG4gICAgICAgICAgICAgICAgZXhlY19xdWVyaWVzLnB1c2goYFNFTEVDVCBuYW1lLCB0eXBlLCBcIm5vdG51bGxcIiwgZGZsdF92YWx1ZSwgcGssIGhpZGRlblxcbiAgICAgICAgRlJPTSBwcmFnbWFfdGFibGVfeGluZm8oJyR7dGJfbmFtZX0nKTtgKTtcbiAgICAgICAgICAgICAgICBzaG93X3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBzaG93X3RhYmxlIClcbiAgICAgICAgICAgICAgICBzaG93KCk7XG5cbiAgICAgICAgICAgIGV4ZWNfcXVlcmllcy5wdXNoKHF1ZXJ5KTtcblxuICAgICAgICAgICAgc2hvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSBkYjIuZXhlY19tYW55KGV4ZWNfcXVlcmllcyk7XG4gICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KGV4ZWNfcXVlcmllcywgcmVzdWx0cyk7XG4gICAgICAgIFxuICAgICAgICBpZiggdGhpcy5hdHRyc1tcImZ1bGwtcmVzZXRcIl0gPT09IFwidHJ1ZVwiKVxuICAgICAgICAgICAgZGIyLmZ1bGxSZXNldCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkYjIucmVzZXQoKTtcbiAgICB9XG5cblxuICAgICNobGluZShjb2xzaXplcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJysnO1xuICAgICAgICBmb3IobGV0IGNvbHNpemUgb2YgY29sc2l6ZXMpXG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcIi5wYWRFbmQoY29sc2l6ZSArIDIsIFwiLVwiKSArICcrJztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgICNwYWRSb3cocm93LCBjb2xzaXplcykge1xuICAgICAgICByZXR1cm4gcm93Lm1hcCggKF8sIGkpID0+IHJvd1tpXS5wYWRFbmQoY29sc2l6ZXNbaV0gKyAxLCBcIiBcIikgKTtcbiAgICB9XG4gICAgI3Jhd2xpbmUocm93KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcInxcIjtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHJvdy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHJvd1tpXSArIFwifFwiO1xuXG4gICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfVxuXG4gICAgI2xpbmUocm93LCBjb2xzaXplcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJ8XCI7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjb2xzaXplcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHJvd1tpXS5wYWRFbmQoY29sc2l6ZXNbaV0gKyAxLCBcIiBcIikgKyBcInxcIjtcblxuICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB1cGRhdGVSZXN1bHQocXVlcmllcywgZGF0YXMpIHtcblxuICAgICAgICB0aGlzLiNpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdlcnJvcicpO1xuICAgICAgICB0aGlzLiNyZXN1bHQuY2xhc3NMaXN0LnJlbW92ZSgnZXJyb3InKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnJztcblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgbGV0IGNvbXBhcmVfdG8gPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBjb3JyZWN0IHNlbGVjdFxuICAgICAgICAgICAgaWYoIGRhdGFzW2ldICE9PSBudWxsICYmIHR5cGVvZiBkYXRhc1tpXSAhPT0gXCJzdHJpbmdcIikge1xuXG4gICAgICAgICAgICAgICAgLy8gY29tcGFyZV90byBsYXN0IG9yIGZpcnN0XG4gICAgICAgICAgICAgICAgZm9yKGxldCBqID0gZGF0YXMubGVuZ3RoIC0gMTsgaiA+IGk7IC0tailcbiAgICAgICAgICAgICAgICAgICAgaWYoIHF1ZXJpZXNbal0gPT09IHF1ZXJpZXNbaV0gJiYgZGF0YXNbal0gIT09IG51bGwgJiYgdHlwZW9mIGRhdGFzW2pdICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZV90byA9IGRhdGFzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggY29tcGFyZV90byA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBpOyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggcXVlcmllc1tqXSA9PT0gcXVlcmllc1tpXSAmJiBkYXRhc1tqXSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YXNbal0gIT09IFwic3RyaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZV90byA9IGRhdGFzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBxdWVyaWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGF0YSAgPSBkYXRhc1tpXTtcblxuICAgICAgICAgICAgY29udGVudCArPSBgc3FsaXRlPiAke3F1ZXJ5fVxcbmA7XG5cbiAgICAgICAgICAgIGlmKCBkYXRhID09PSBudWxsIClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7IC8vIGV4Y2VwdGlvblxuXG4gICAgICAgICAgICAgICAgdGhpcy4jaW5wdXQuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNyZXN1bHQuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcblxuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gZGF0YTtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggZGF0YS5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBgTm8gcm93IHJldHVybmVkLlxcbmA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXG4gICAgICAgICAgICAgICAgLi4uIGRhdGEubWFwKGVudHJ5ID0+IE9iamVjdC52YWx1ZXMoZW50cnkpLm1hcCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggdmFsdWUgPT09IG51bGwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnTi9BJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAnJHt2YWx1ZX0nYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH0pICkgICBcbiAgICAgICAgICAgIF07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBjb2xzaXplcyA9IG5ldyBBcnJheShoZWFkZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgY29sc2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb2xzaXplc1tpXSA9IGhlYWRlcnNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgcm93IG9mIHJlc3VsdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmKCByb3dbaV0ubGVuZ3RoID4gY29sc2l6ZXNbaV0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sc2l6ZXNbaV0gPSByb3dbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgIFxuICAgICAgICAgICAgbGV0IHJlc3VsdF90ZXh0ID0gdGhpcy4jaGxpbmUoY29sc2l6ZXMpICsgXCJcXG5cIjtcbiAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9ICB0aGlzLiNsaW5lKGhlYWRlcnMsIGNvbHNpemVzKTtcbiAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9ICB0aGlzLiNobGluZShjb2xzaXplcykgKyBcIlxcblwiO1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHJlc3VsdHMubGVuZ3RoOyArK2opIHtcblxuICAgICAgICAgICAgICAgIGxldCByb3cgPSByZXN1bHRzW2pdO1xuXG4gICAgICAgICAgICAgICAgaWYoIGNvbXBhcmVfdG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0X3RleHQgKz0gdGhpcy4jbGluZShyb3csIGNvbHNpemVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IGNoYW5nZXNcblxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBcIklEXCI7XG4gICAgICAgICAgICAgICAgaWYoICEgKGtleSBpbiBkYXRhW2pdKSApXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IFwibmFtZVwiO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNtcF9saW5lID0gY29tcGFyZV90by5maW5kKCBlID0+IGVba2V5XSA9PT0gZGF0YVtqXVtrZXldKTsgLy8gaDRja3lcblxuICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMuI3BhZFJvdyhyb3csIGNvbHNpemVzKTtcblxuICAgICAgICAgICAgICAgIGlmKCBjbXBfbGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvdy5tYXAoIGMgPT4gYDxzdHJvbmc+PGVtPiR7Y308L2VtPjwvc3Ryb25nPmApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMuI3Jhd2xpbmUocm93KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0X3RleHQgKz0gYDxzcGFuIGNsYXNzPVwiaGlnaGxpZ2h0XCI+JHtsaW5lfTwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xuYW1lID0gaGVhZGVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiggZGF0YVtqXVtjb2xuYW1lXSAhPT0gY21wX2xpbmVbY29sbmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dbaV0gPSBgPHNwYW4gY2xhc3M9aGlnaGxpZ2h0PjxlbT48c3Ryb25nPiR7cm93W2ldfTwvc3Ryb25nPjwvZW0+PC9zcGFuPmA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9IHRoaXMuI3Jhd2xpbmUocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9ICB0aGlzLiNobGluZShjb2xzaXplcyk7XG4gICAgXG4gICAgICAgICAgICBjb250ZW50ICs9IHJlc3VsdF90ZXh0ICsgJ1xcbic7ICAgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNyZXN1bHQuaW5uZXJIVE1MID0gY29udGVudDtcblxuICAgICAgICB0aGlzLiNsYXN0RGF0YXMgPSBkYXRhcztcblxuICAgICAgICB0aGlzLmhvc3QuZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KFwiY2hhbmdlXCIsIHtkZXRhaWw6IHtcbiAgICAgICAgICAgIGRhdGFzXG4gICAgICAgIH19KSApO1xuICAgIH1cblxuICAgICNsYXN0RGF0YXMgPSBudWxsO1xuXG4gICAgZ2V0IGxhc3REYXRhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xhc3REYXRhcztcbiAgICB9XG59XG5cbkxJU1MuZGVmaW5lKFwic3FsLWludGVyYWN0aXZlXCIsIFNRTEludGVyYWN0aXZlKSIsIi8qXG4qKiBMSUNFTlNFIGZvciB0aGUgc3FsaXRlMyBXZWJBc3NlbWJseS9KYXZhU2NyaXB0IEFQSXMuXG4qKlxuKiogVGhpcyBidW5kbGUgKHR5cGljYWxseSByZWxlYXNlZCBhcyBzcWxpdGUzLmpzIG9yIHNxbGl0ZTMubWpzKVxuKiogaXMgYW4gYW1hbGdhbWF0aW9uIG9mIEphdmFTY3JpcHQgc291cmNlIGNvZGUgZnJvbSB0d28gcHJvamVjdHM6XG4qKlxuKiogMSkgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZzogdGhlIEVtc2NyaXB0ZW4gXCJnbHVlIGNvZGVcIiBpcyBjb3ZlcmVkIGJ5XG4qKiAgICB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlIGFuZCBVbml2ZXJzaXR5IG9mIElsbGlub2lzL05DU0FcbioqICAgIE9wZW4gU291cmNlIExpY2Vuc2UsIGFzIGRlc2NyaWJlZCBhdDpcbioqXG4qKiAgICBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvaW50cm9kdWNpbmdfZW1zY3JpcHRlbi9lbXNjcmlwdGVuX2xpY2Vuc2UuaHRtbFxuKipcbioqIDIpIGh0dHBzOi8vc3FsaXRlLm9yZzogYWxsIGNvZGUgYW5kIGRvY3VtZW50YXRpb24gbGFiZWxlZCBhcyBiZWluZ1xuKiogICAgZnJvbSB0aGlzIHNvdXJjZSBhcmUgcmVsZWFzZWQgdW5kZXIgdGhlIHNhbWUgdGVybXMgYXMgdGhlIHNxbGl0ZTNcbioqICAgIEMgbGlicmFyeTpcbioqXG4qKiAyMDIyLTEwLTE2XG4qKlxuKiogVGhlIGF1dGhvciBkaXNjbGFpbXMgY29weXJpZ2h0IHRvIHRoaXMgc291cmNlIGNvZGUuICBJbiBwbGFjZSBvZiBhXG4qKiBsZWdhbCBub3RpY2UsIGhlcmUgaXMgYSBibGVzc2luZzpcbioqXG4qKiAqICAgTWF5IHlvdSBkbyBnb29kIGFuZCBub3QgZXZpbC5cbioqICogICBNYXkgeW91IGZpbmQgZm9yZ2l2ZW5lc3MgZm9yIHlvdXJzZWxmIGFuZCBmb3JnaXZlIG90aGVycy5cbioqICogICBNYXkgeW91IHNoYXJlIGZyZWVseSwgbmV2ZXIgdGFraW5nIG1vcmUgdGhhbiB5b3UgZ2l2ZS5cbiovXG4vKlxuKiogVGhpcyBjb2RlIHdhcyBidWlsdCBmcm9tIHNxbGl0ZTMgdmVyc2lvbi4uLlxuKipcbioqIFNRTElURV9WRVJTSU9OIFwiMy40NS4yXCJcbioqIFNRTElURV9WRVJTSU9OX05VTUJFUiAzMDQ1MDAyXG4qKiBTUUxJVEVfU09VUkNFX0lEIFwiMjAyNC0wMy0xMiAxMTowNjoyMyBkOGNkNmQ0OWI0NmEzOTViMTM5NTUzODdkMDVlOWUxYTJhNDdlNTRmYjk5ZjNjOWI1OTgzNWJiZWZhZDZhZjc3XCJcbioqXG4qKiBVc2luZyB0aGUgRW1zY3JpcHRlbiBTREsgdmVyc2lvbiAzLjEuMzAuXG4qL1xuXG52YXIgc3FsaXRlM0luaXRNb2R1bGUgPSAoKCkgPT4ge1xuICAvL3ZhciBfc2NyaXB0RGlyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IFJPT1QgPSBbXCJsb2NhbGhvc3RcIiwgXCIxMjcuMC4wLjFcIl0uaW5jbHVkZXMobG9jYXRpb24uaG9zdG5hbWUpID8gXCIvZGlzdC9kZXYvXCIgOiBcIi9Db3Vycy9kaXN0L2Rldi9cIjtcbiAgY29uc3QgX3NjcmlwdERpciA9IGAke1JPT1R9YXNzZXRzL3NxbC9zcWxpdGUzLndhc21gO1xuXG4gIHJldHVybiAoXG5mdW5jdGlvbihjb25maWcpIHtcbiAgdmFyIHNxbGl0ZTNJbml0TW9kdWxlID0gY29uZmlnIHx8IHt9O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgTW9kdWxlID0gdHlwZW9mIHNxbGl0ZTNJbml0TW9kdWxlICE9ICd1bmRlZmluZWQnID8gc3FsaXRlM0luaXRNb2R1bGUgOiB7fTtcblxuXG52YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSwgcmVhZHlQcm9taXNlUmVqZWN0O1xuTW9kdWxlWydyZWFkeSddID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICByZWFkeVByb21pc2VSZWplY3QgPSByZWplY3Q7XG59KTtcblxuXG5cblxuXG5cbmNvbnN0IHNxbGl0ZTNJbml0TW9kdWxlU3RhdGUgPSBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGVcbiAgICAgIHx8IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgICAgIGRlYnVnTW9kdWxlOiAoKT0+e31cbiAgICAgIH0pO1xuZGVsZXRlIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZTtcbnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoJ2dsb2JhbFRoaXMubG9jYXRpb24gPScsZ2xvYmFsVGhpcy5sb2NhdGlvbik7XG5cblxuTW9kdWxlWydsb2NhdGVGaWxlJ10gPSBmdW5jdGlvbihwYXRoLCBwcmVmaXgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBsZXQgdGhlRmlsZTtcbiAgY29uc3QgdXAgPSB0aGlzLnVybFBhcmFtcztcbiAgaWYodXAuaGFzKHBhdGgpKXtcbiAgICB0aGVGaWxlID0gdXAuZ2V0KHBhdGgpO1xuICB9ZWxzZSBpZih0aGlzLnNxbGl0ZTNEaXIpe1xuICAgIHRoZUZpbGUgPSB0aGlzLnNxbGl0ZTNEaXIgKyBwYXRoO1xuICB9ZWxzZSBpZih0aGlzLnNjcmlwdERpcil7XG4gICAgdGhlRmlsZSA9IHRoaXMuc2NyaXB0RGlyICsgcGF0aDtcbiAgfWVsc2V7XG4gICAgdGhlRmlsZSA9IHByZWZpeCArIHBhdGg7XG4gIH1cbiAgc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZShcbiAgICBcImxvY2F0ZUZpbGUoXCIsYXJndW1lbnRzWzBdLCAnLCcsIGFyZ3VtZW50c1sxXSxcIilcIixcbiAgICAnc3FsaXRlM0luaXRNb2R1bGVTdGF0ZS5zY3JpcHREaXIgPScsdGhpcy5zY3JpcHREaXIsXG4gICAgJ3VwLmVudHJpZXMoKSA9JyxBcnJheS5mcm9tKHVwLmVudHJpZXMoKSksXG4gICAgXCJyZXN1bHQgPVwiLCB0aGVGaWxlXG4gICk7XG4gIHJldHVybiB0aGVGaWxlO1xufS5iaW5kKHNxbGl0ZTNJbml0TW9kdWxlU3RhdGUpO1xuXG5cbmNvbnN0IHhOYW1lT2ZJbnN0YW50aWF0ZVdhc20gPSBmYWxzZVxuICAgICAgPyAnaW5zdGFudGlhdGVXYXNtJ1xuICAgICAgOiAnZW1zY3JpcHRlbi1idWctMTc5NTEnO1xuTW9kdWxlW3hOYW1lT2ZJbnN0YW50aWF0ZVdhc21dID0gZnVuY3Rpb24gY2FsbGVlKGltcG9ydHMsb25TdWNjZXNzKXtcbiAgaW1wb3J0cy5lbnYuZm9vID0gZnVuY3Rpb24oKXt9O1xuICBjb25zdCB1cmkgPSBNb2R1bGUubG9jYXRlRmlsZShcbiAgICBjYWxsZWUudXJpLCAoXG4gICAgICAoJ3VuZGVmaW5lZCc9PT10eXBlb2Ygc2NyaXB0RGlyZWN0b3J5KVxuICAgICAgICA/IFwiXCIgOiBzY3JpcHREaXJlY3RvcnkpXG4gICk7XG4gIHNxbGl0ZTNJbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoXG4gICAgXCJpbnN0YW50aWF0ZVdhc20oKSB1cmkgPVwiLCB1cmlcbiAgKTtcbiAgY29uc3Qgd2ZldGNoID0gKCk9PmZldGNoKHVyaSwge2NyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nfSk7XG4gIGNvbnN0IGxvYWRXYXNtID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdcbiAgICAgICAgPyBhc3luYyAoKT0+e1xuICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh3ZmV0Y2goKSwgaW1wb3J0cylcbiAgICAgICAgICAgIC50aGVuKChhcmcpPT5vblN1Y2Nlc3MoYXJnLmluc3RhbmNlLCBhcmcubW9kdWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgOiBhc3luYyAoKT0+eyBcbiAgICAgICAgICByZXR1cm4gd2ZldGNoKClcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpXG4gICAgICAgICAgICAudGhlbihieXRlcyA9PiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0cykpXG4gICAgICAgICAgICAudGhlbigoYXJnKT0+b25TdWNjZXNzKGFyZy5pbnN0YW5jZSwgYXJnLm1vZHVsZSkpO1xuICAgICAgICB9O1xuICBsb2FkV2FzbSgpO1xuICByZXR1cm4ge307XG59O1xuXG5Nb2R1bGVbeE5hbWVPZkluc3RhbnRpYXRlV2FzbV0udXJpID0gJ3NxbGl0ZTMud2FzbSc7XG5cblxuXG5cblxuXG5cblxudmFyIG1vZHVsZU92ZXJyaWRlcyA9IE9iamVjdC5hc3NpZ24oe30sIE1vZHVsZSk7XG5cbnZhciBhcmd1bWVudHNfID0gW107XG52YXIgdGhpc1Byb2dyYW0gPSAnLi90aGlzLnByb2dyYW0nO1xudmFyIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICB0aHJvdyB0b1Rocm93O1xufTtcblxuXG5cblxuXG52YXIgRU5WSVJPTk1FTlRfSVNfV0VCID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JztcbnZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nO1xuXG5cbnZhciBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHlwZW9mIHByb2Nlc3MgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSAnc3RyaW5nJztcbnZhciBFTlZJUk9OTUVOVF9JU19TSEVMTCA9ICFFTlZJUk9OTUVOVF9JU19XRUIgJiYgIUVOVklST05NRU5UX0lTX05PREUgJiYgIUVOVklST05NRU5UX0lTX1dPUktFUjtcblxuXG52YXIgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG5mdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgcmV0dXJuIE1vZHVsZVsnbG9jYXRlRmlsZSddKHBhdGgsIHNjcmlwdERpcmVjdG9yeSk7XG4gIH1cbiAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG59XG5cblxudmFyIHJlYWRfLFxuICAgIHJlYWRBc3luYyxcbiAgICByZWFkQmluYXJ5LFxuICAgIHNldFdpbmRvd1RpdGxlO1xuXG5cblxuXG5pZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7IFxuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkgeyBcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgfVxuICBcbiAgXG4gIGlmIChfc2NyaXB0RGlyKSB7XG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpcjtcbiAgfVxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBpZiAoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBzY3JpcHREaXJlY3Rvcnkuc3Vic3RyKDAsIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCBcIlwiKS5sYXN0SW5kZXhPZignLycpKzEpO1xuICB9IGVsc2Uge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICB9XG5cbiAgXG4gIFxuICB7XG5cblxuXG4gIHJlYWRfID0gKHVybCkgPT4ge1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgfVxuXG4gIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICByZWFkQmluYXJ5ID0gKHVybCkgPT4ge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKHhoci5yZXNwb25zZSkpO1xuICAgIH07XG4gIH1cblxuICByZWFkQXN5bmMgPSAodXJsLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHhoci5yZXNwb25zZSkpIHsgXG4gICAgICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvbmVycm9yKCk7XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IG9uZXJyb3I7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gIH1cblxuXG4gIH1cblxuICBzZXRXaW5kb3dUaXRsZSA9ICh0aXRsZSkgPT4gZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcbn0gZWxzZVxue1xufVxuXG52YXIgb3V0ID0gTW9kdWxlWydwcmludCddIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG52YXIgZXJyID0gTW9kdWxlWydwcmludEVyciddIHx8IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuXG5cbk9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuXG5cbm1vZHVsZU92ZXJyaWRlcyA9IG51bGw7XG5cblxuXG5cblxuXG5pZiAoTW9kdWxlWydhcmd1bWVudHMnXSkgYXJndW1lbnRzXyA9IE1vZHVsZVsnYXJndW1lbnRzJ107XG5cbmlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO1xuXG5pZiAoTW9kdWxlWydxdWl0J10pIHF1aXRfID0gTW9kdWxlWydxdWl0J107XG5cblxuXG5cblxuXG52YXIgU1RBQ0tfQUxJR04gPSAxNjtcbnZhciBQT0lOVEVSX1NJWkUgPSA0O1xuXG5mdW5jdGlvbiBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2kxJzogY2FzZSAnaTgnOiBjYXNlICd1OCc6IHJldHVybiAxO1xuICAgIGNhc2UgJ2kxNic6IGNhc2UgJ3UxNic6IHJldHVybiAyO1xuICAgIGNhc2UgJ2kzMic6IGNhc2UgJ3UzMic6IHJldHVybiA0O1xuICAgIGNhc2UgJ2k2NCc6IGNhc2UgJ3U2NCc6IHJldHVybiA4O1xuICAgIGNhc2UgJ2Zsb2F0JzogcmV0dXJuIDQ7XG4gICAgY2FzZSAnZG91YmxlJzogcmV0dXJuIDg7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBQT0lOVEVSX1NJWkU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZVswXSA9PT0gJ2knKSB7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBOdW1iZXIodHlwZS5zdWJzdHIoMSkpO1xuICAgICAgICBhc3NlcnQoYml0cyAlIDggPT09IDAsICdnZXROYXRpdmVUeXBlU2l6ZSBpbnZhbGlkIGJpdHMgJyArIGJpdHMgKyAnLCB0eXBlICcgKyB0eXBlKTtcbiAgICAgICAgcmV0dXJuIGJpdHMgLyA4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB3YXNtQmluYXJ5O1xuaWYgKE1vZHVsZVsnd2FzbUJpbmFyeSddKSB3YXNtQmluYXJ5ID0gTW9kdWxlWyd3YXNtQmluYXJ5J107XG52YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVsnbm9FeGl0UnVudGltZSddIHx8IHRydWU7XG5cbmlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT0gJ29iamVjdCcpIHtcbiAgYWJvcnQoJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTtcbn1cblxuXG5cbnZhciB3YXNtTWVtb3J5O1xuXG5cblxuXG5cblxuXG52YXIgQUJPUlQgPSBmYWxzZTtcblxuXG5cblxudmFyIEVYSVRTVEFUVVM7XG5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIFxuICAgIFxuICAgIFxuICAgIGFib3J0KHRleHQpO1xuICB9XG59XG5cblxuXG5cblxuXG5cbnZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpIDogdW5kZWZpbmVkO1xuXG5cbmZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXBPckFycmF5LCBpZHgsIG1heEJ5dGVzVG9SZWFkKSB7XG4gIHZhciBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiAgdmFyIGVuZFB0ciA9IGlkeDtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICB3aGlsZSAoaGVhcE9yQXJyYXlbZW5kUHRyXSAmJiAhKGVuZFB0ciA+PSBlbmRJZHgpKSArK2VuZFB0cjtcblxuICBpZiAoZW5kUHRyIC0gaWR4ID4gMTYgJiYgaGVhcE9yQXJyYXkuYnVmZmVyICYmIFVURjhEZWNvZGVyKSB7XG4gICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuICB9XG4gIHZhciBzdHIgPSAnJztcbiAgXG4gIFxuICB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgdmFyIHUwID0gaGVhcE9yQXJyYXlbaWR4KytdO1xuICAgIGlmICghKHUwICYgMHg4MCkpIHsgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApOyBjb250aW51ZTsgfVxuICAgIHZhciB1MSA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgIGlmICgodTAgJiAweEUwKSA9PSAweEMwKSB7IHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgodTAgJiAzMSkgPDwgNikgfCB1MSk7IGNvbnRpbnVlOyB9XG4gICAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgaWYgKCh1MCAmIDB4RjApID09IDB4RTApIHtcbiAgICAgIHUwID0gKCh1MCAmIDE1KSA8PCAxMikgfCAodTEgPDwgNikgfCB1MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdTAgPSAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IChoZWFwT3JBcnJheVtpZHgrK10gJiA2Myk7XG4gICAgfVxuXG4gICAgaWYgKHUwIDwgMHgxMDAwMCkge1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2ggPSB1MCAtIDB4MTAwMDA7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgfCAoY2ggPj4gMTApLCAweERDMDAgfCAoY2ggJiAweDNGRikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7XG4gIHJldHVybiBwdHIgPyBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgsIHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIDogJyc7XG59XG5cblxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBoZWFwLCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkge1xuICBcbiAgXG4gIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKVxuICAgIHJldHVybiAwO1xuXG4gIHZhciBzdGFydElkeCA9IG91dElkeDtcbiAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7IFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7IFxuICAgIGlmICh1ID49IDB4RDgwMCAmJiB1IDw9IDB4REZGRikge1xuICAgICAgdmFyIHUxID0gc3RyLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8ICh1MSAmIDB4M0ZGKTtcbiAgICB9XG4gICAgaWYgKHUgPD0gMHg3Rikge1xuICAgICAgaWYgKG91dElkeCA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSB1O1xuICAgIH0gZWxzZSBpZiAodSA8PSAweDdGRikge1xuICAgICAgaWYgKG91dElkeCArIDEgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhDMCB8ICh1ID4+IDYpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgfSBlbHNlIGlmICh1IDw9IDB4RkZGRikge1xuICAgICAgaWYgKG91dElkeCArIDIgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhFMCB8ICh1ID4+IDEyKTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEYwIHwgKHUgPj4gMTgpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDYzKTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDYzKTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgIH1cbiAgfVxuICBcbiAgaGVhcFtvdXRJZHhdID0gMDtcbiAgcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSB7XG4gIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCxvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSk7XG59XG5cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cikge1xuICB2YXIgbGVuID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyBcbiAgICBpZiAoYyA8PSAweDdGKSB7XG4gICAgICBsZW4rKztcbiAgICB9IGVsc2UgaWYgKGMgPD0gMHg3RkYpIHtcbiAgICAgIGxlbiArPSAyO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpIHtcbiAgICAgIGxlbiArPSA0OyArK2k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiArPSAzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuO1xufVxuXG5cblxuXG52YXIgSEVBUCxcblxuICBIRUFQOCxcblxuICBIRUFQVTgsXG5cbiAgSEVBUDE2LFxuXG4gIEhFQVBVMTYsXG5cbiAgSEVBUDMyLFxuXG4gIEhFQVBVMzIsXG5cbiAgSEVBUEYzMixcblxuICBIRUFQNjQsXG5cbiAgSEVBUFU2NCxcblxuICBIRUFQRjY0O1xuXG5mdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpIHtcbiAgdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiAgTW9kdWxlWydIRUFQOCddID0gSEVBUDggPSBuZXcgSW50OEFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVAxNiddID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUDMyJ10gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQVTgnXSA9IEhFQVBVOCA9IG5ldyBVaW50OEFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBVMTYnXSA9IEhFQVBVMTYgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUFUzMiddID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQRjMyJ10gPSBIRUFQRjMyID0gbmV3IEZsb2F0MzJBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQRjY0J10gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQNjQnXSA9IEhFQVA2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBVNjQnXSA9IEhFQVBVNjQgPSBuZXcgQmlnVWludDY0QXJyYXkoYik7XG59XG5cbnZhciBTVEFDS19TSVpFID0gNTI0Mjg4O1xuXG52YXIgSU5JVElBTF9NRU1PUlkgPSBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7XG5cblxuXG5cblxuXG5cbiAgaWYgKE1vZHVsZVsnd2FzbU1lbW9yeSddKSB7XG4gICAgd2FzbU1lbW9yeSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddO1xuICB9IGVsc2VcbiAge1xuICAgIHdhc21NZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtcbiAgICAgICdpbml0aWFsJzogSU5JVElBTF9NRU1PUlkgLyA2NTUzNixcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICAnbWF4aW11bSc6IDIxNDc0ODM2NDggLyA2NTUzNlxuICAgIH0pO1xuICB9XG5cbnVwZGF0ZU1lbW9yeVZpZXdzKCk7XG5cblxuXG5JTklUSUFMX01FTU9SWSA9IHdhc21NZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblxuXG5cblxuXG5cbnZhciB3YXNtVGFibGU7XG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBfX0FUUFJFUlVOX18gID0gW107IFxudmFyIF9fQVRJTklUX18gICAgPSBbXTsgXG52YXIgX19BVEVYSVRfXyAgICA9IFtdOyBcbnZhciBfX0FUUE9TVFJVTl9fID0gW107IFxuXG52YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGtlZXBSdW50aW1lQWxpdmUoKSB7XG4gIHJldHVybiBub0V4aXRSdW50aW1lO1xufVxuXG5mdW5jdGlvbiBwcmVSdW4oKSB7XG5cbiAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlUnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICB3aGlsZSAoTW9kdWxlWydwcmVSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUHJlUnVuKE1vZHVsZVsncHJlUnVuJ10uc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTtcbn1cblxuZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKSB7XG4gIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgXG5pZiAoIU1vZHVsZVtcIm5vRlNJbml0XCJdICYmICFGUy5pbml0LmluaXRpYWxpemVkKVxuICBGUy5pbml0KCk7XG5GUy5pZ25vcmVQZXJtaXNzaW9ucyA9IGZhbHNlO1xuXG5UVFkuaW5pdCgpO1xuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbn1cblxuZnVuY3Rpb24gcG9zdFJ1bigpIHtcblxuICBpZiAoTW9kdWxlWydwb3N0UnVuJ10pIHtcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncG9zdFJ1biddID09ICdmdW5jdGlvbicpIE1vZHVsZVsncG9zdFJ1biddID0gW01vZHVsZVsncG9zdFJ1biddXTtcbiAgICB3aGlsZSAoTW9kdWxlWydwb3N0UnVuJ10ubGVuZ3RoKSB7XG4gICAgICBhZGRPblBvc3RSdW4oTW9kdWxlWydwb3N0UnVuJ10uc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7XG4gIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25Jbml0KGNiKSB7XG4gIF9fQVRJTklUX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uRXhpdChjYikge1xufVxuXG5mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHtcbiAgX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcnVuRGVwZW5kZW5jaWVzID0gMDtcbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG52YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsgXG5cbmZ1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcysrO1xuXG4gIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gIH1cblxuICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgY2FsbGJhY2soKTsgXG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuICBpZiAoTW9kdWxlWydvbkFib3J0J10pIHtcbiAgICBNb2R1bGVbJ29uQWJvcnQnXSh3aGF0KTtcbiAgfVxuXG4gIHdoYXQgPSAnQWJvcnRlZCgnICsgd2hhdCArICcpJztcbiAgXG4gIFxuICBlcnIod2hhdCk7XG5cbiAgQUJPUlQgPSB0cnVlO1xuICBFWElUU1RBVFVTID0gMTtcblxuICB3aGF0ICs9ICcuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uJztcblxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG5cbiAgXG4gIFxuICBcbiAgXG4gIFxuICB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG5cbiAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICBcbiAgXG4gIFxuICB0aHJvdyBlO1xufVxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBkYXRhVVJJUHJlZml4ID0gJ2RhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwnO1xuXG5cbmZ1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSkge1xuICBcbiAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCk7XG59XG5cblxuZnVuY3Rpb24gaXNGaWxlVVJJKGZpbGVuYW1lKSB7XG4gIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKCdmaWxlOi8vJyk7XG59XG5cblxudmFyIHdhc21CaW5hcnlGaWxlO1xuICB3YXNtQmluYXJ5RmlsZSA9ICdzcWxpdGUzLndhc20nO1xuICBpZiAoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgICB3YXNtQmluYXJ5RmlsZSA9IGxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO1xuICB9XG5cbmZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gIHRyeSB7XG4gICAgaWYgKGZpbGUgPT0gd2FzbUJpbmFyeUZpbGUgJiYgd2FzbUJpbmFyeSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICAgIH1cbiAgICBpZiAocmVhZEJpbmFyeSkge1xuICAgICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gICAgfVxuICAgIHRocm93IFwiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjtcbiAgfVxuICBjYXRjaCAoZXJyKSB7XG4gICAgYWJvcnQoZXJyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCkge1xuICBcbiAgXG4gIFxuICBcbiAgXG4gIGlmICghd2FzbUJpbmFyeSAmJiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikpIHtcbiAgICBpZiAodHlwZW9mIGZldGNoID09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHJldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHtcbiAgICAgICAgICB0aHJvdyBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgd2FzbUJpbmFyeUZpbGUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2FycmF5QnVmZmVyJ10oKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIFxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7IH0pO1xufVxuXG5cblxuZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgXG4gIHZhciBpbmZvID0ge1xuICAgICdlbnYnOiBhc21MaWJyYXJ5QXJnLFxuICAgICd3YXNpX3NuYXBzaG90X3ByZXZpZXcxJzogYXNtTGlicmFyeUFyZyxcbiAgfTtcbiAgXG4gIFxuICBcbiAgXG4gIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuXG4gICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7XG5cbiAgICB3YXNtVGFibGUgPSBNb2R1bGVbJ2FzbSddWydfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlJ107XG5cbiAgICBhZGRPbkluaXQoTW9kdWxlWydhc20nXVsnX193YXNtX2NhbGxfY3RvcnMnXSk7XG5cbiAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG5cbiAgfVxuICBcbiAgYWRkUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xuXG4gIFxuICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICByZWNlaXZlSW5zdGFuY2UocmVzdWx0WydpbnN0YW5jZSddKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpIHtcbiAgICByZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24oYmluYXJ5KSB7XG4gICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0pLnRoZW4ocmVjZWl2ZXIsIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgZXJyKCdmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAnICsgcmVhc29uKTtcblxuICAgICAgYWJvcnQocmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKSB7XG4gICAgaWYgKCF3YXNtQmluYXJ5ICYmXG4gICAgICAgIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpICYmXG4gICAgICAgIHR5cGVvZiBmZXRjaCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW5mbyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKFxuICAgICAgICAgIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0LFxuICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGVycignd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICcgKyByZWFzb24pO1xuICAgICAgICAgICAgZXJyKCdmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBcbiAgXG4gIFxuICBcbiAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGV4cG9ydHMgPSBNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKGluZm8sIHJlY2VpdmVJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVycignTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpO1xuICAgICAgICBcbiAgICAgICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICAgIH1cbiAgfVxuXG4gIFxuICBpbnN0YW50aWF0ZUFzeW5jKCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtcbiAgcmV0dXJuIHt9OyBcbn1cblxuXG52YXIgdGVtcERvdWJsZTtcbnZhciB0ZW1wSTY0O1xuXG5cblxudmFyIEFTTV9DT05TVFMgPSB7XG4gIFxufTtcblxuXG5cblxuXG4gIFxuICBmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cykge1xuICAgICAgdGhpcy5uYW1lID0gJ0V4aXRTdGF0dXMnO1xuICAgICAgdGhpcy5tZXNzYWdlID0gJ1Byb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJyArIHN0YXR1cyArICcpJztcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cblxuICBmdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICBcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkoTW9kdWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgXG4gICAgXG4gIGZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSA9ICdpOCcpIHtcbiAgICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSAnKic7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOiByZXR1cm4gSEVBUDhbKChwdHIpPj4wKV07XG4gICAgICAgIGNhc2UgJ2k4JzogcmV0dXJuIEhFQVA4WygocHRyKT4+MCldO1xuICAgICAgICBjYXNlICdpMTYnOiByZXR1cm4gSEVBUDE2WygocHRyKT4+MSldO1xuICAgICAgICBjYXNlICdpMzInOiByZXR1cm4gSEVBUDMyWygocHRyKT4+MildO1xuICAgICAgICBjYXNlICdpNjQnOiByZXR1cm4gSEVBUDY0WygocHRyKT4+MyldO1xuICAgICAgICBjYXNlICdmbG9hdCc6IHJldHVybiBIRUFQRjMyWygocHRyKT4+MildO1xuICAgICAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gSEVBUEY2NFsoKHB0cik+PjMpXTtcbiAgICAgICAgY2FzZSAnKic6IHJldHVybiBIRUFQVTMyWygocHRyKT4+MildO1xuICAgICAgICBkZWZhdWx0OiBhYm9ydCgnaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJyArIHR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gIFxuICAgIFxuICBmdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gJ2k4Jykge1xuICAgICAgaWYgKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9ICcqJztcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpMSc6IEhFQVA4WygocHRyKT4+MCldID0gdmFsdWU7IGJyZWFrO1xuICAgICAgICBjYXNlICdpOCc6IEhFQVA4WygocHRyKT4+MCldID0gdmFsdWU7IGJyZWFrO1xuICAgICAgICBjYXNlICdpMTYnOiBIRUFQMTZbKChwdHIpPj4xKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2kzMic6IEhFQVAzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnaTY0JzogKHRlbXBJNjQgPSBbdmFsdWU+Pj4wLCh0ZW1wRG91YmxlPXZhbHVlLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygocHRyKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgocHRyKSsoNCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzogSEVBUEYzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnZG91YmxlJzogSEVBUEY2NFsoKHB0cik+PjMpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnKic6IEhFQVBVMzJbKChwdHIpPj4yKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAnICsgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIHZhciBQQVRIID0ge2lzQWJzOihwYXRoKSA9PiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLHNwbGl0UGF0aDooZmlsZW5hbWUpID0+IHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG4gICAgICAgIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbiAgICAgIH0sbm9ybWFsaXplQXJyYXk6KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgdmFyIHVwID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHVwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBmb3IgKDsgdXA7IHVwLS0pIHtcbiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgIH0sbm9ybWFsaXplOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gUEFUSC5pc0FicyhwYXRoKSxcbiAgICAgICAgICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnN1YnN0cigtMSkgPT09ICcvJztcbiAgICAgICAgXG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG4gICAgICAgIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICAgIHBhdGggPSAnLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgICAgICAgIHBhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG4gICAgICB9LGRpcm5hbWU6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFBBVEguc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgICAgICAgIGRpciA9IHJlc3VsdFsxXTtcbiAgICAgICAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdCArIGRpcjtcbiAgICAgIH0sYmFzZW5hbWU6KHBhdGgpID0+IHtcbiAgICAgICAgXG4gICAgICAgIGlmIChwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG4gICAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICBpZiAobGFzdFNsYXNoID09PSAtMSkgcmV0dXJuIHBhdGg7XG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cihsYXN0U2xhc2grMSk7XG4gICAgICB9LGpvaW46ZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBQQVRILm5vcm1hbGl6ZShwYXRocy5qb2luKCcvJykpO1xuICAgICAgfSxqb2luMjoobCwgcikgPT4ge1xuICAgICAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUobCArICcvJyArIHIpO1xuICAgICAgfX07XG4gIFxuICBmdW5jdGlvbiBnZXRSYW5kb21EZXZpY2UoKSB7XG4gICAgICBpZiAodHlwZW9mIGNyeXB0byA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgY3J5cHRvWydnZXRSYW5kb21WYWx1ZXMnXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmFuZG9tQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnVmZmVyKTsgcmV0dXJuIHJhbmRvbUJ1ZmZlclswXTsgfTtcbiAgICAgIH0gZWxzZVxuICAgICAgXG4gICAgICByZXR1cm4gKCkgPT4gYWJvcnQoXCJyYW5kb21EZXZpY2VcIik7XG4gICAgfVxuICBcbiAgXG4gIFxuICB2YXIgUEFUSF9GUyA9IHtyZXNvbHZlOmZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBGUy5jd2QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodHlwZW9mIHBhdGggIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnOyBcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gUEFUSC5pc0FicyhwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IFBBVEgubm9ybWFsaXplQXJyYXkocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuICAgICAgICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG4gICAgICB9LHJlbGF0aXZlOihmcm9tLCB0bykgPT4ge1xuICAgICAgICBmcm9tID0gUEFUSF9GUy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgICAgICAgdG8gPSBQQVRIX0ZTLnJlc29sdmUodG8pLnN1YnN0cigxKTtcbiAgICAgICAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICAgICAgICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xuICAgICAgfX07XG4gIFxuICBcbiAgXG4gIGZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XG4gICAgdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkrMTtcbiAgICB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LCB1OGFycmF5LCAwLCB1OGFycmF5Lmxlbmd0aCk7XG4gICAgaWYgKGRvbnRBZGROdWxsKSB1OGFycmF5Lmxlbmd0aCA9IG51bUJ5dGVzV3JpdHRlbjtcbiAgICByZXR1cm4gdThhcnJheTtcbiAgfVxuICB2YXIgVFRZID0ge3R0eXM6W10saW5pdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgIH0sc2h1dGRvd246ZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICB9LHJlZ2lzdGVyOmZ1bmN0aW9uKGRldiwgb3BzKSB7XG4gICAgICAgIFRUWS50dHlzW2Rldl0gPSB7IGlucHV0OiBbXSwgb3V0cHV0OiBbXSwgb3BzOiBvcHMgfTtcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCBUVFkuc3RyZWFtX29wcyk7XG4gICAgICB9LHN0cmVhbV9vcHM6e29wZW46ZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO1xuICAgICAgICAgIGlmICghdHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS50dHkgPSB0dHk7XG4gICAgICAgICAgc3RyZWFtLnNlZWthYmxlID0gZmFsc2U7XG4gICAgICAgIH0sY2xvc2U6ZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0sZnN5bmM6ZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgc3RyZWFtLnR0eS5vcHMuZnN5bmMoc3RyZWFtLnR0eSk7XG4gICAgICAgIH0scmVhZDpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcyApIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLmdldF9jaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcihzdHJlYW0udHR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgICB9LHdyaXRlOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LCBidWZmZXJbb2Zmc2V0K2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9fSxkZWZhdWx0X3R0eV9vcHM6e2dldF9jaGFyOmZ1bmN0aW9uKHR0eSkge1xuICAgICAgICAgIGlmICghdHR5LmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93LnByb21wdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXN1bHQgPSB3aW5kb3cucHJvbXB0KCdJbnB1dDogJyk7ICBcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGxpbmUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVhZGxpbmUoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dHkuaW5wdXQgPSBpbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR0eS5pbnB1dC5zaGlmdCgpO1xuICAgICAgICB9LHB1dF9jaGFyOmZ1bmN0aW9uKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpOyBcbiAgICAgICAgICB9XG4gICAgICAgIH0sZnN5bmM6ZnVuY3Rpb24odHR5KSB7XG4gICAgICAgICAgaWYgKHR0eS5vdXRwdXQgJiYgdHR5Lm91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfX0sZGVmYXVsdF90dHkxX29wczp7cHV0X2NoYXI6ZnVuY3Rpb24odHR5LCB2YWwpIHtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gMTApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LGZzeW5jOmZ1bmN0aW9uKHR0eSkge1xuICAgICAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXJyKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH19fTtcbiAgXG4gIFxuICBmdW5jdGlvbiB6ZXJvTWVtb3J5KGFkZHJlc3MsIHNpemUpIHtcbiAgICAgIEhFQVBVOC5maWxsKDAsIGFkZHJlc3MsIGFkZHJlc3MgKyBzaXplKTtcbiAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIGFsaWduTWVtb3J5KHNpemUsIGFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gYWxpZ25tZW50KSAqIGFsaWdubWVudDtcbiAgICB9XG4gIGZ1bmN0aW9uIG1tYXBBbGxvYyhzaXplKSB7XG4gICAgICBzaXplID0gYWxpZ25NZW1vcnkoc2l6ZSwgNjU1MzYpO1xuICAgICAgdmFyIHB0ciA9IF9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24oNjU1MzYsIHNpemUpO1xuICAgICAgaWYgKCFwdHIpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHplcm9NZW1vcnkocHRyLCBzaXplKTtcbiAgICB9XG4gIHZhciBNRU1GUyA9IHtvcHNfdGFibGU6bnVsbCxtb3VudDpmdW5jdGlvbihtb3VudCkge1xuICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShudWxsLCAnLycsIDE2Mzg0IHwgNTExICwgMCk7XG4gICAgICB9LGNyZWF0ZU5vZGU6ZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkge1xuICAgICAgICAgIFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU1FTUZTLm9wc190YWJsZSkge1xuICAgICAgICAgIE1FTUZTLm9wc190YWJsZSA9IHtcbiAgICAgICAgICAgIGRpcjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgICAgIGxvb2t1cDogTUVNRlMubm9kZV9vcHMubG9va3VwLFxuICAgICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCxcbiAgICAgICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSxcbiAgICAgICAgICAgICAgICB1bmxpbms6IE1FTUZTLm5vZGVfb3BzLnVubGluayxcbiAgICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsXG4gICAgICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpcixcbiAgICAgICAgICAgICAgICBzeW1saW5rOiBNRU1GUy5ub2RlX29wcy5zeW1saW5rXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbToge1xuICAgICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0clxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgICAgIHJlYWQ6IE1FTUZTLnN0cmVhbV9vcHMucmVhZCxcbiAgICAgICAgICAgICAgICB3cml0ZTogTUVNRlMuc3RyZWFtX29wcy53cml0ZSxcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZTogTUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSxcbiAgICAgICAgICAgICAgICBtbWFwOiBNRU1GUy5zdHJlYW1fb3BzLm1tYXAsXG4gICAgICAgICAgICAgICAgbXN5bmM6IE1FTUZTLnN0cmVhbV9vcHMubXN5bmNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgICByZWFkbGluazogTUVNRlMubm9kZV9vcHMucmVhZGxpbmtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNocmRldjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLnN0cmVhbTtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSAwOyBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDsgXG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUubGluay5zdHJlYW07XG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2Lm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmNocmRldi5zdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5jb250ZW50c1tuYW1lXSA9IG5vZGU7XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IG5vZGUudGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxnZXRGaWxlRGF0YUFzVHlwZWRBcnJheTpmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5jb250ZW50cykgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBpZiAobm9kZS5jb250ZW50cy5zdWJhcnJheSkgcmV0dXJuIG5vZGUuY29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpOyBcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5vZGUuY29udGVudHMpO1xuICAgICAgfSxleHBhbmRGaWxlU3RvcmFnZTpmdW5jdGlvbihub2RlLCBuZXdDYXBhY2l0eSkge1xuICAgICAgICB2YXIgcHJldkNhcGFjaXR5ID0gbm9kZS5jb250ZW50cyA/IG5vZGUuY29udGVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSA+PSBuZXdDYXBhY2l0eSkgcmV0dXJuOyBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIENBUEFDSVRZX0RPVUJMSU5HX01BWCA9IDEwMjQgKiAxMDI0O1xuICAgICAgICBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAocHJldkNhcGFjaXR5ICogKHByZXZDYXBhY2l0eSA8IENBUEFDSVRZX0RPVUJMSU5HX01BWCA/IDIuMCA6IDEuMTI1KSkgPj4+IDApO1xuICAgICAgICBpZiAocHJldkNhcGFjaXR5ICE9IDApIG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgobmV3Q2FwYWNpdHksIDI1Nik7IFxuICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpOyBcbiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID4gMCkgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpLCAwKTsgXG4gICAgICB9LHJlc2l6ZUZpbGVTdG9yYWdlOmZ1bmN0aW9uKG5vZGUsIG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID09IG5ld1NpemUpIHJldHVybjtcbiAgICAgICAgaWYgKG5ld1NpemUgPT0gMCkge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsOyBcbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50cztcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7IFxuICAgICAgICAgIGlmIChvbGRDb250ZW50cykge1xuICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgTWF0aC5taW4obmV3U2l6ZSwgbm9kZS51c2VkQnl0ZXMpKSk7IFxuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IG5ld1NpemU7XG4gICAgICAgIH1cbiAgICAgIH0sbm9kZV9vcHM6e2dldGF0dHI6ZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgICAgXG4gICAgICAgICAgYXR0ci5kZXYgPSBGUy5pc0NocmRldihub2RlLm1vZGUpID8gbm9kZS5pZCA6IDE7XG4gICAgICAgICAgYXR0ci5pbm8gPSBub2RlLmlkO1xuICAgICAgICAgIGF0dHIubW9kZSA9IG5vZGUubW9kZTtcbiAgICAgICAgICBhdHRyLm5saW5rID0gMTtcbiAgICAgICAgICBhdHRyLnVpZCA9IDA7XG4gICAgICAgICAgYXR0ci5naWQgPSAwO1xuICAgICAgICAgIGF0dHIucmRldiA9IG5vZGUucmRldjtcbiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gNDA5NjtcbiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLnVzZWRCeXRlcztcbiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLmxpbmsubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyLmF0aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIubXRpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgYXR0ci5jdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBhdHRyLmJsa3NpemUgPSA0MDk2O1xuICAgICAgICAgIGF0dHIuYmxvY2tzID0gTWF0aC5jZWlsKGF0dHIuc2l6ZSAvIGF0dHIuYmxrc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgIH0sc2V0YXR0cjpmdW5jdGlvbihub2RlLCBhdHRyKSB7XG4gICAgICAgICAgaWYgKGF0dHIubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlLnRpbWVzdGFtcCA9IGF0dHIudGltZXN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE1FTUZTLnJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsIGF0dHIuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LGxvb2t1cDpmdW5jdGlvbihwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBGUy5nZW5lcmljRXJyb3JzWzQ0XTtcbiAgICAgICAgfSxta25vZDpmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikge1xuICAgICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgICAgICAgfSxyZW5hbWU6ZnVuY3Rpb24ob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbmV3X25vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld19ub2RlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgZGVsZXRlIG9sZF9ub2RlLnBhcmVudC5jb250ZW50c1tvbGRfbm9kZS5uYW1lXTtcbiAgICAgICAgICBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICAgICAgICAgIG9sZF9ub2RlLm5hbWUgPSBuZXdfbmFtZTtcbiAgICAgICAgICBuZXdfZGlyLmNvbnRlbnRzW25ld19uYW1lXSA9IG9sZF9ub2RlO1xuICAgICAgICAgIG5ld19kaXIudGltZXN0YW1wID0gb2xkX25vZGUucGFyZW50LnRpbWVzdGFtcDtcbiAgICAgICAgICBvbGRfbm9kZS5wYXJlbnQgPSBuZXdfZGlyO1xuICAgICAgICB9LHVubGluazpmdW5jdGlvbihwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICBkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO1xuICAgICAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB9LHJtZGlyOmZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO1xuICAgICAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB9LHJlYWRkaXI6ZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gWycuJywgJy4uJ107XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG5vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5jb250ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW50cmllcy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LHN5bWxpbms6ZnVuY3Rpb24ocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCwgbmV3bmFtZSwgNTExICB8IDQwOTYwLCAwKTtcbiAgICAgICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LHJlYWRsaW5rOmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmxpbms7XG4gICAgICAgIH19LHN0cmVhbV9vcHM6e3JlYWQ6ZnVuY3Rpb24oc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBzdHJlYW0ubm9kZS51c2VkQnl0ZXMpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKHNpemUgPiA4ICYmIGNvbnRlbnRzLnN1YmFycmF5KSB7IFxuICAgICAgICAgICAgYnVmZmVyLnNldChjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBzaXplKSwgb2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9LHdyaXRlOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikge1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChidWZmZXIuYnVmZmVyID09PSBIRUFQOC5idWZmZXIpIHtcbiAgICAgICAgICAgIGNhbk93biA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBub2RlID0gc3RyZWFtLm5vZGU7XG4gICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICBcbiAgICAgICAgICBpZiAoYnVmZmVyLnN1YmFycmF5ICYmICghbm9kZS5jb250ZW50cyB8fCBub2RlLmNvbnRlbnRzLnN1YmFycmF5KSkgeyBcbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnVzZWRCeXRlcyA9PT0gMCAmJiBwb3NpdGlvbiA9PT0gMCkgeyBcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiArIGxlbmd0aCA8PSBub2RlLnVzZWRCeXRlcykgeyBcbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgXG4gICAgICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgcG9zaXRpb24rbGVuZ3RoKTtcbiAgICAgICAgICBpZiAobm9kZS5jb250ZW50cy5zdWJhcnJheSAmJiBidWZmZXIuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSwgcG9zaXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgbm9kZS5jb250ZW50c1twb3NpdGlvbiArIGldID0gYnVmZmVyW29mZnNldCArIGldOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChub2RlLnVzZWRCeXRlcywgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH0sbGxzZWVrOmZ1bmN0aW9uKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKHdoZW5jZSA9PT0gMSkge1xuICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2hlbmNlID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5ub2RlLnVzZWRCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgIH0sYWxsb2NhdGU6ZnVuY3Rpb24oc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgIE1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKHN0cmVhbS5ub2RlLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgIHN0cmVhbS5ub2RlLnVzZWRCeXRlcyA9IE1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcywgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSxtbWFwOmZ1bmN0aW9uKHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHRyO1xuICAgICAgICAgIHZhciBhbGxvY2F0ZWQ7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCEoZmxhZ3MgJiAyKSAmJiBjb250ZW50cy5idWZmZXIgPT09IEhFQVA4LmJ1ZmZlcikge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGFsbG9jYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcHRyID0gY29udGVudHMuYnl0ZU9mZnNldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPiAwIHx8IHBvc2l0aW9uICsgbGVuZ3RoIDwgY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChjb250ZW50cy5zdWJhcnJheSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQOC5zZXQoY29udGVudHMsIHB0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IGFsbG9jYXRlZCB9O1xuICAgICAgICB9LG1zeW5jOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgICAgTUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgMCwgbGVuZ3RoLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfX19O1xuICBcbiAgXG4gIGZ1bmN0aW9uIGFzeW5jTG9hZCh1cmwsIG9ubG9hZCwgb25lcnJvciwgbm9SdW5EZXApIHtcbiAgICAgIHZhciBkZXAgPSAhbm9SdW5EZXAgPyBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KCdhbCAnICsgdXJsKSA6ICcnO1xuICAgICAgcmVhZEFzeW5jKHVybCwgKGFycmF5QnVmZmVyKSA9PiB7XG4gICAgICAgIGFzc2VydChhcnJheUJ1ZmZlciwgJ0xvYWRpbmcgZGF0YSBmaWxlIFwiJyArIHVybCArICdcIiBmYWlsZWQgKG5vIGFycmF5QnVmZmVyKS4nKTtcbiAgICAgICAgb25sb2FkKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICAgIGlmIChkZXApIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgIH0sIChldmVudCkgPT4ge1xuICAgICAgICBpZiAob25lcnJvcikge1xuICAgICAgICAgIG9uZXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyAnTG9hZGluZyBkYXRhIGZpbGUgXCInICsgdXJsICsgJ1wiIGZhaWxlZC4nO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkZXApIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICB9XG4gIFxuICB2YXIgRlMgPSB7cm9vdDpudWxsLG1vdW50czpbXSxkZXZpY2VzOnt9LHN0cmVhbXM6W10sbmV4dElub2RlOjEsbmFtZVRhYmxlOm51bGwsY3VycmVudFBhdGg6XCIvXCIsaW5pdGlhbGl6ZWQ6ZmFsc2UsaWdub3JlUGVybWlzc2lvbnM6dHJ1ZSxFcnJub0Vycm9yOm51bGwsZ2VuZXJpY0Vycm9yczp7fSxmaWxlc3lzdGVtczpudWxsLHN5bmNGU1JlcXVlc3RzOjAsbG9va3VwUGF0aDoocGF0aCwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgIHBhdGggPSBQQVRIX0ZTLnJlc29sdmUocGF0aCk7XG4gIFxuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiB7IHBhdGg6ICcnLCBub2RlOiBudWxsIH07XG4gIFxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgZm9sbG93X21vdW50OiB0cnVlLFxuICAgICAgICAgIHJlY3Vyc2VfY291bnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpXG4gIFxuICAgICAgICBpZiAob3B0cy5yZWN1cnNlX2NvdW50ID4gOCkgeyAgXG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKTtcbiAgXG4gICAgICAgIFxuICAgICAgICB2YXIgY3VycmVudCA9IEZTLnJvb3Q7XG4gICAgICAgIHZhciBjdXJyZW50X3BhdGggPSAnLyc7XG4gIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGlzbGFzdCA9IChpID09PSBwYXJ0cy5sZW5ndGgtMSk7XG4gICAgICAgICAgaWYgKGlzbGFzdCAmJiBvcHRzLnBhcmVudCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGN1cnJlbnQgPSBGUy5sb29rdXBOb2RlKGN1cnJlbnQsIHBhcnRzW2ldKTtcbiAgICAgICAgICBjdXJyZW50X3BhdGggPSBQQVRILmpvaW4yKGN1cnJlbnRfcGF0aCwgcGFydHNbaV0pO1xuICBcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzbGFzdCB8fCAoaXNsYXN0ICYmIG9wdHMuZm9sbG93X21vdW50KSkge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tb3VudGVkLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvdykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbGluayA9IEZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG4gIFxuICAgICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChjdXJyZW50X3BhdGgsIHsgcmVjdXJzZV9jb3VudDogb3B0cy5yZWN1cnNlX2NvdW50ICsgMSB9KTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGxvb2t1cC5ub2RlO1xuICBcbiAgICAgICAgICAgICAgaWYgKGNvdW50KysgPiA0MCkgeyAgXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4geyBwYXRoOiBjdXJyZW50X3BhdGgsIG5vZGU6IGN1cnJlbnQgfTtcbiAgICAgIH0sZ2V0UGF0aDoobm9kZSkgPT4ge1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50Lm1vdW50cG9pbnQ7XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBtb3VudDtcbiAgICAgICAgICAgIHJldHVybiBtb3VudFttb3VudC5sZW5ndGgtMV0gIT09ICcvJyA/IG1vdW50ICsgJy8nICsgcGF0aCA6IG1vdW50ICsgcGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IHBhdGggPyBub2RlLm5hbWUgKyAnLycgKyBwYXRoIDogbm9kZS5uYW1lO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSxoYXNoTmFtZToocGFyZW50aWQsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSAwO1xuICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChwYXJlbnRpZCArIGhhc2gpID4+PiAwKSAlIEZTLm5hbWVUYWJsZS5sZW5ndGg7XG4gICAgICB9LGhhc2hBZGROb2RlOihub2RlKSA9PiB7XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgICAgIG5vZGUubmFtZV9uZXh0ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlO1xuICAgICAgfSxoYXNoUmVtb3ZlTm9kZToobm9kZSkgPT4ge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBpZiAoRlMubmFtZVRhYmxlW2hhc2hdID09PSBub2RlKSB7XG4gICAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZS5uYW1lX25leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5hbWVfbmV4dCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICBjdXJyZW50Lm5hbWVfbmV4dCA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sbG9va3VwTm9kZToocGFyZW50LCBuYW1lKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5TG9va3VwKHBhcmVudCk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKHBhcmVudC5pZCwgbmFtZSk7XG4gICAgICAgIGZvciAodmFyIG5vZGUgPSBGUy5uYW1lVGFibGVbaGFzaF07IG5vZGU7IG5vZGUgPSBub2RlLm5hbWVfbmV4dCkge1xuICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaWQgPT09IHBhcmVudC5pZCAmJiBub2RlTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gRlMubG9va3VwKHBhcmVudCwgbmFtZSk7XG4gICAgICB9LGNyZWF0ZU5vZGU6KHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldikgPT4ge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBGUy5GU05vZGUocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KTtcbiAgXG4gICAgICAgIEZTLmhhc2hBZGROb2RlKG5vZGUpO1xuICBcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGRlc3Ryb3lOb2RlOihub2RlKSA9PiB7XG4gICAgICAgIEZTLmhhc2hSZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgfSxpc1Jvb3Q6KG5vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IG5vZGUucGFyZW50O1xuICAgICAgfSxpc01vdW50cG9pbnQ6KG5vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuICEhbm9kZS5tb3VudGVkO1xuICAgICAgfSxpc0ZpbGU6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAzMjc2ODtcbiAgICAgIH0saXNEaXI6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAxNjM4NDtcbiAgICAgIH0saXNMaW5rOihtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NjA7XG4gICAgICB9LGlzQ2hyZGV2Oihtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gODE5MjtcbiAgICAgIH0saXNCbGtkZXY6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAyNDU3NjtcbiAgICAgIH0saXNGSUZPOihtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NjtcbiAgICAgIH0saXNTb2NrZXQ6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNDkxNTIpID09PSA0OTE1MjtcbiAgICAgIH0sZmxhZ01vZGVzOntcInJcIjowLFwicitcIjoyLFwid1wiOjU3NyxcIncrXCI6NTc4LFwiYVwiOjEwODksXCJhK1wiOjEwOTB9LG1vZGVTdHJpbmdUb0ZsYWdzOihzdHIpID0+IHtcbiAgICAgICAgdmFyIGZsYWdzID0gRlMuZmxhZ01vZGVzW3N0cl07XG4gICAgICAgIGlmICh0eXBlb2YgZmxhZ3MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZmlsZSBvcGVuIG1vZGU6ICcgKyBzdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICAgIH0sZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmc6KGZsYWcpID0+IHtcbiAgICAgICAgdmFyIHBlcm1zID0gWydyJywgJ3cnLCAncncnXVtmbGFnICYgM107XG4gICAgICAgIGlmICgoZmxhZyAmIDUxMikpIHtcbiAgICAgICAgICBwZXJtcyArPSAndyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlcm1zO1xuICAgICAgfSxub2RlUGVybWlzc2lvbnM6KG5vZGUsIHBlcm1zKSA9PiB7XG4gICAgICAgIGlmIChGUy5pZ25vcmVQZXJtaXNzaW9ucykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocGVybXMuaW5jbHVkZXMoJ3InKSAmJiAhKG5vZGUubW9kZSAmIDI5MikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygndycpICYmICEobm9kZS5tb2RlICYgMTQ2KSkge1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcm1zLmluY2x1ZGVzKCd4JykgJiYgIShub2RlLm1vZGUgJiA3MykpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sbWF5TG9va3VwOihkaXIpID0+IHtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAneCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkgcmV0dXJuIGVyckNvZGU7XG4gICAgICAgIGlmICghZGlyLm5vZGVfb3BzLmxvb2t1cCkgcmV0dXJuIDI7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxtYXlDcmVhdGU6KGRpciwgbmFtZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xuICAgICAgICAgIHJldHVybiAyMDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKTtcbiAgICAgIH0sbWF5RGVsZXRlOihkaXIsIG5hbWUsIGlzZGlyKSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lcnJubztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHJldHVybiBlcnJDb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc2Rpcikge1xuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDU0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpIHx8IEZTLmdldFBhdGgobm9kZSkgPT09IEZTLmN3ZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gMzE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxtYXlPcGVuOihub2RlLCBmbGFncykgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gNDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBpZiAoRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpICE9PSAncicgfHwgXG4gICAgICAgICAgICAgIChmbGFncyAmIDUxMikpIHsgXG4gICAgICAgICAgICByZXR1cm4gMzE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgRlMuZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZ3MpKTtcbiAgICAgIH0sTUFYX09QRU5fRkRTOjQwOTYsbmV4dGZkOihmZF9zdGFydCA9IDAsIGZkX2VuZCA9IEZTLk1BWF9PUEVOX0ZEUykgPT4ge1xuICAgICAgICBmb3IgKHZhciBmZCA9IGZkX3N0YXJ0OyBmZCA8PSBmZF9lbmQ7IGZkKyspIHtcbiAgICAgICAgICBpZiAoIUZTLnN0cmVhbXNbZmRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMzKTtcbiAgICAgIH0sZ2V0U3RyZWFtOihmZCkgPT4gRlMuc3RyZWFtc1tmZF0sY3JlYXRlU3RyZWFtOihzdHJlYW0sIGZkX3N0YXJ0LCBmZF9lbmQpID0+IHtcbiAgICAgICAgaWYgKCFGUy5GU1N0cmVhbSkge1xuICAgICAgICAgIEZTLkZTU3RyZWFtID0gIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWQgPSB7IH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBGUy5GU1N0cmVhbS5wcm90b3R5cGUgPSB7fTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGUy5GU1N0cmVhbS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZTsgfSxcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7IHRoaXMubm9kZSA9IHZhbDsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUmVhZDoge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDE7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1dyaXRlOiB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMDsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQXBwZW5kOiB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxMDI0KTsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zaGFyZWQuZmxhZ3M7IH0sXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkgeyB0aGlzLnNoYXJlZC5mbGFncyA9IHZhbDsgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbiA6IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNoYXJlZC5wb3NpdGlvbjsgfSxcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7IHRoaXMuc2hhcmVkLnBvc2l0aW9uID0gdmFsOyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3RyZWFtID0gT2JqZWN0LmFzc2lnbihuZXcgRlMuRlNTdHJlYW0oKSwgc3RyZWFtKTtcbiAgICAgICAgdmFyIGZkID0gRlMubmV4dGZkKGZkX3N0YXJ0LCBmZF9lbmQpO1xuICAgICAgICBzdHJlYW0uZmQgPSBmZDtcbiAgICAgICAgRlMuc3RyZWFtc1tmZF0gPSBzdHJlYW07XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LGNsb3NlU3RyZWFtOihmZCkgPT4ge1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7XG4gICAgICB9LGNocmRldl9zdHJlYW1fb3BzOntvcGVuOihzdHJlYW0pID0+IHtcbiAgICAgICAgICB2YXIgZGV2aWNlID0gRlMuZ2V0RGV2aWNlKHN0cmVhbS5ub2RlLnJkZXYpO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzID0gZGV2aWNlLnN0cmVhbV9vcHM7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pIHtcbiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sbGxzZWVrOigpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH19LG1ham9yOihkZXYpID0+ICgoZGV2KSA+PiA4KSxtaW5vcjooZGV2KSA9PiAoKGRldikgJiAweGZmKSxtYWtlZGV2OihtYSwgbWkpID0+ICgobWEpIDw8IDggfCAobWkpKSxyZWdpc3RlckRldmljZTooZGV2LCBvcHMpID0+IHtcbiAgICAgICAgRlMuZGV2aWNlc1tkZXZdID0geyBzdHJlYW1fb3BzOiBvcHMgfTtcbiAgICAgIH0sZ2V0RGV2aWNlOihkZXYpID0+IEZTLmRldmljZXNbZGV2XSxnZXRNb3VudHM6KG1vdW50KSA9PiB7XG4gICAgICAgIHZhciBtb3VudHMgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrID0gW21vdW50XTtcbiAgXG4gICAgICAgIHdoaWxlIChjaGVjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbSA9IGNoZWNrLnBvcCgpO1xuICBcbiAgICAgICAgICBtb3VudHMucHVzaChtKTtcbiAgXG4gICAgICAgICAgY2hlY2sucHVzaC5hcHBseShjaGVjaywgbS5tb3VudHMpO1xuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4gbW91bnRzO1xuICAgICAgfSxzeW5jZnM6KHBvcHVsYXRlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBvcHVsYXRlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IHBvcHVsYXRlO1xuICAgICAgICAgIHBvcHVsYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIEZTLnN5bmNGU1JlcXVlc3RzKys7XG4gIFxuICAgICAgICBpZiAoRlMuc3luY0ZTUmVxdWVzdHMgPiAxKSB7XG4gICAgICAgICAgZXJyKCd3YXJuaW5nOiAnICsgRlMuc3luY0ZTUmVxdWVzdHMgKyAnIEZTLnN5bmNmcyBvcGVyYXRpb25zIGluIGZsaWdodCBhdCBvbmNlLCBwcm9iYWJseSBqdXN0IGRvaW5nIGV4dHJhIHdvcmsnKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhGUy5yb290Lm1vdW50KTtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gIFxuICAgICAgICBmdW5jdGlvbiBkb0NhbGxiYWNrKGVyckNvZGUpIHtcbiAgICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cy0tO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJDb2RlKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnJDb2RlKSB7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIGlmICghZG9uZS5lcnJvcmVkKSB7XG4gICAgICAgICAgICAgIGRvbmUuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBkb0NhbGxiYWNrKGVyckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKytjb21wbGV0ZWQgPj0gbW91bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9DYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gIFxuICAgICAgICBcbiAgICAgICAgbW91bnRzLmZvckVhY2goKG1vdW50KSA9PiB7XG4gICAgICAgICAgaWYgKCFtb3VudC50eXBlLnN5bmNmcykge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vdW50LnR5cGUuc3luY2ZzKG1vdW50LCBwb3B1bGF0ZSwgZG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxtb3VudDoodHlwZSwgb3B0cywgbW91bnRwb2ludCkgPT4ge1xuICAgICAgICB2YXIgcm9vdCA9IG1vdW50cG9pbnQgPT09ICcvJztcbiAgICAgICAgdmFyIHBzZXVkbyA9ICFtb3VudHBvaW50O1xuICAgICAgICB2YXIgbm9kZTtcbiAgXG4gICAgICAgIGlmIChyb290ICYmIEZTLnJvb3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJvb3QgJiYgIXBzZXVkbykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG1vdW50cG9pbnQsIHsgZm9sbG93X21vdW50OiBmYWxzZSB9KTtcbiAgXG4gICAgICAgICAgbW91bnRwb2ludCA9IGxvb2t1cC5wYXRoOyAgXG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICBcbiAgICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBtb3VudCA9IHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIG9wdHM6IG9wdHMsXG4gICAgICAgICAgbW91bnRwb2ludDogbW91bnRwb2ludCxcbiAgICAgICAgICBtb3VudHM6IFtdXG4gICAgICAgIH07XG4gIFxuICAgICAgICBcbiAgICAgICAgdmFyIG1vdW50Um9vdCA9IHR5cGUubW91bnQobW91bnQpO1xuICAgICAgICBtb3VudFJvb3QubW91bnQgPSBtb3VudDtcbiAgICAgICAgbW91bnQucm9vdCA9IG1vdW50Um9vdDtcbiAgXG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgRlMucm9vdCA9IG1vdW50Um9vdDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgbm9kZS5tb3VudGVkID0gbW91bnQ7XG4gIFxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChub2RlLm1vdW50KSB7XG4gICAgICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5wdXNoKG1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBtb3VudFJvb3Q7XG4gICAgICB9LHVubW91bnQ6KG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICBcbiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudGVkO1xuICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTtcbiAgXG4gICAgICAgIE9iamVjdC5rZXlzKEZTLm5hbWVUYWJsZSkuZm9yRWFjaCgoaGFzaCkgPT4ge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICBcbiAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgXG4gICAgICAgICAgICBpZiAobW91bnRzLmluY2x1ZGVzKGN1cnJlbnQubW91bnQpKSB7XG4gICAgICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gIFxuICAgICAgICBcbiAgICAgICAgbm9kZS5tb3VudGVkID0gbnVsbDtcbiAgXG4gICAgICAgIFxuICAgICAgICB2YXIgaWR4ID0gbm9kZS5tb3VudC5tb3VudHMuaW5kZXhPZihtb3VudCk7XG4gICAgICAgIG5vZGUubW91bnQubW91bnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfSxsb29rdXA6KHBhcmVudCwgbmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICAgICAgfSxta25vZDoocGF0aCwgbW9kZSwgZGV2KSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09ICcuJyB8fCBuYW1lID09PSAnLi4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMubWtub2QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5ta25vZChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICB9LGNyZWF0ZToocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDQzOCA7XG4gICAgICAgIG1vZGUgJj0gNDA5NTtcbiAgICAgICAgbW9kZSB8PSAzMjc2ODtcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgfSxta2RpcjoocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDUxMSA7XG4gICAgICAgIG1vZGUgJj0gNTExIHwgNTEyO1xuICAgICAgICBtb2RlIHw9IDE2Mzg0O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LG1rZGlyVHJlZToocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICB2YXIgZGlycyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIGQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKCFkaXJzW2ldKSBjb250aW51ZTtcbiAgICAgICAgICBkICs9ICcvJyArIGRpcnNbaV07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEZTLm1rZGlyKGQsIG1vZGUpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgaWYgKGUuZXJybm8gIT0gMjApIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LG1rZGV2OihwYXRoLCBtb2RlLCBkZXYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZXYgPSBtb2RlO1xuICAgICAgICAgIG1vZGUgPSA0MzggO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgfD0gODE5MjtcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIGRldik7XG4gICAgICB9LHN5bWxpbms6KG9sZHBhdGgsIG5ld3BhdGgpID0+IHtcbiAgICAgICAgaWYgKCFQQVRIX0ZTLnJlc29sdmUob2xkcGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3cGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld3BhdGgpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5ld25hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5zeW1saW5rKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCk7XG4gICAgICB9LHJlbmFtZToob2xkX3BhdGgsIG5ld19wYXRoKSA9PiB7XG4gICAgICAgIHZhciBvbGRfZGlybmFtZSA9IFBBVEguZGlybmFtZShvbGRfcGF0aCk7XG4gICAgICAgIHZhciBuZXdfZGlybmFtZSA9IFBBVEguZGlybmFtZShuZXdfcGF0aCk7XG4gICAgICAgIHZhciBvbGRfbmFtZSA9IFBBVEguYmFzZW5hbWUob2xkX3BhdGgpO1xuICAgICAgICB2YXIgbmV3X25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld19wYXRoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsb29rdXAsIG9sZF9kaXIsIG5ld19kaXI7XG4gIFxuICAgICAgICBcbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChvbGRfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG9sZF9kaXIgPSBsb29rdXAubm9kZTtcbiAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIG5ld19kaXIgPSBsb29rdXAubm9kZTtcbiAgXG4gICAgICAgIGlmICghb2xkX2RpciB8fCAhbmV3X2RpcikgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG9sZF9kaXIubW91bnQgIT09IG5ld19kaXIubW91bnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3NSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBvbGRfbm9kZSA9IEZTLmxvb2t1cE5vZGUob2xkX2Rpciwgb2xkX25hbWUpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gUEFUSF9GUy5yZWxhdGl2ZShvbGRfcGF0aCwgbmV3X2Rpcm5hbWUpO1xuICAgICAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlbGF0aXZlID0gUEFUSF9GUy5yZWxhdGl2ZShuZXdfcGF0aCwgb2xkX2Rpcm5hbWUpO1xuICAgICAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBuZXdfbm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChvbGRfbm9kZSA9PT0gbmV3X25vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBpc2RpciA9IEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShvbGRfZGlyLCBvbGRfbmFtZSwgaXNkaXIpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgZXJyQ29kZSA9IG5ld19ub2RlID9cbiAgICAgICAgICBGUy5tYXlEZWxldGUobmV3X2RpciwgbmV3X25hbWUsIGlzZGlyKSA6XG4gICAgICAgICAgRlMubWF5Q3JlYXRlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9sZF9kaXIubm9kZV9vcHMucmVuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQob2xkX25vZGUpIHx8IChuZXdfbm9kZSAmJiBGUy5pc01vdW50cG9pbnQobmV3X25vZGUpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG5ld19kaXIgIT09IG9sZF9kaXIpIHtcbiAgICAgICAgICBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsICd3Jyk7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUob2xkX25vZGUpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZShvbGRfbm9kZSwgbmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBGUy5oYXNoQWRkTm9kZShvbGRfbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0scm1kaXI6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUocGFyZW50LCBuYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5ybWRpcikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5ub2RlX29wcy5ybWRpcihwYXJlbnQsIG5hbWUpO1xuICAgICAgICBGUy5kZXN0cm95Tm9kZShub2RlKTtcbiAgICAgIH0scmVhZGRpcjoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnJlYWRkaXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZV9vcHMucmVhZGRpcihub2RlKTtcbiAgICAgIH0sdW5saW5rOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgZmFsc2UpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnVubGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5ub2RlX29wcy51bmxpbmsocGFyZW50LCBuYW1lKTtcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XG4gICAgICB9LHJlYWRsaW5rOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgpO1xuICAgICAgICB2YXIgbGluayA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVRIX0ZTLnJlc29sdmUoRlMuZ2V0UGF0aChsaW5rLnBhcmVudCksIGxpbmsubm9kZV9vcHMucmVhZGxpbmsobGluaykpO1xuICAgICAgfSxzdGF0OihwYXRoLCBkb250Rm9sbG93KSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5nZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLmdldGF0dHIobm9kZSk7XG4gICAgICB9LGxzdGF0OihwYXRoKSA9PiB7XG4gICAgICAgIHJldHVybiBGUy5zdGF0KHBhdGgsIHRydWUpO1xuICAgICAgfSxjaG1vZDoocGF0aCwgbW9kZSwgZG9udEZvbGxvdykgPT4ge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIG1vZGU6IChtb2RlICYgNDA5NSkgfCAobm9kZS5tb2RlICYgfjQwOTUpLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KTtcbiAgICAgIH0sbGNobW9kOihwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIEZTLmNobW9kKHBhdGgsIG1vZGUsIHRydWUpO1xuICAgICAgfSxmY2htb2Q6KGZkLCBtb2RlKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNobW9kKHN0cmVhbS5ub2RlLCBtb2RlKTtcbiAgICAgIH0sY2hvd246KHBhdGgsIHVpZCwgZ2lkLCBkb250Rm9sbG93KSA9PiB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgICAgfSxsY2hvd246KHBhdGgsIHVpZCwgZ2lkKSA9PiB7XG4gICAgICAgIEZTLmNob3duKHBhdGgsIHVpZCwgZ2lkLCB0cnVlKTtcbiAgICAgIH0sZmNob3duOihmZCwgdWlkLCBnaWQpID0+IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2hvd24oc3RyZWFtLm5vZGUsIHVpZCwgZ2lkKTtcbiAgICAgIH0sdHJ1bmNhdGU6KHBhdGgsIGxlbikgPT4ge1xuICAgICAgICBpZiAobGVuIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgJ3cnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHNpemU6IGxlbixcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfSk7XG4gICAgICB9LGZ0cnVuY2F0ZTooZmQsIGxlbikgPT4ge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLnRydW5jYXRlKHN0cmVhbS5ub2RlLCBsZW4pO1xuICAgICAgfSx1dGltZToocGF0aCwgYXRpbWUsIG10aW1lKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHRpbWVzdGFtcDogTWF0aC5tYXgoYXRpbWUsIG10aW1lKVxuICAgICAgICB9KTtcbiAgICAgIH0sb3BlbjoocGF0aCwgZmxhZ3MsIG1vZGUpID0+IHtcbiAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3MgPSB0eXBlb2YgZmxhZ3MgPT0gJ3N0cmluZycgPyBGUy5tb2RlU3RyaW5nVG9GbGFncyhmbGFncykgOiBmbGFncztcbiAgICAgICAgbW9kZSA9IHR5cGVvZiBtb2RlID09ICd1bmRlZmluZWQnID8gNDM4ICA6IG1vZGU7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA2NCkpIHtcbiAgICAgICAgICBtb2RlID0gKG1vZGUgJiA0MDk1KSB8IDMyNzY4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHtcbiAgICAgICAgICAgICAgZm9sbG93OiAhKGZsYWdzICYgMTMxMDcyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgY3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGZsYWdzICYgNjQpKSB7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKChmbGFncyAmIDEyOCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5vZGUgPSBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgICAgICAgIGNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgZmxhZ3MgJj0gfjUxMjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKChmbGFncyAmIDY1NTM2KSAmJiAhRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heU9wZW4obm9kZSwgZmxhZ3MpO1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICgoZmxhZ3MgJiA1MTIpICYmICFjcmVhdGVkKSB7XG4gICAgICAgICAgRlMudHJ1bmNhdGUobm9kZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZsYWdzICY9IH4oMTI4IHwgNTEyIHwgMTMxMDcyKTtcbiAgXG4gICAgICAgIFxuICAgICAgICB2YXIgc3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIHBhdGg6IEZTLmdldFBhdGgobm9kZSksICBcbiAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgc2Vla2FibGU6IHRydWUsXG4gICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgc3RyZWFtX29wczogbm9kZS5zdHJlYW1fb3BzLFxuICAgICAgICAgIFxuICAgICAgICAgIHVuZ290dGVuOiBbXSxcbiAgICAgICAgICBlcnJvcjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydsb2dSZWFkRmlsZXMnXSAmJiAhKGZsYWdzICYgMSkpIHtcbiAgICAgICAgICBpZiAoIUZTLnJlYWRGaWxlcykgRlMucmVhZEZpbGVzID0ge307XG4gICAgICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7XG4gICAgICAgICAgICBGUy5yZWFkRmlsZXNbcGF0aF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxjbG9zZTooc3RyZWFtKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cykgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5jbG9zZShzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRlMuY2xvc2VTdHJlYW0oc3RyZWFtLmZkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZmQgPSBudWxsO1xuICAgICAgfSxpc0Nsb3NlZDooc3RyZWFtKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZmQgPT09IG51bGw7XG4gICAgICB9LGxsc2Vlazooc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkgPT4ge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnNlZWthYmxlIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoZW5jZSAhPSAwICYmIHdoZW5jZSAhPSAxICYmIHdoZW5jZSAhPSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb3NpdGlvbiA9IHN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICAgICAgc3RyZWFtLnVuZ290dGVuID0gW107XG4gICAgICAgIHJldHVybiBzdHJlYW0ucG9zaXRpb247XG4gICAgICB9LHJlYWQ6KHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IHN0cmVhbS5zdHJlYW1fb3BzLnJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgIH0sd3JpdGU6KHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5zZWVrYWJsZSAmJiBzdHJlYW0uZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgXG4gICAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgMCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bik7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICAgIH0sYWxsb2NhdGU6KHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBsZW5ndGggPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMzgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfSxtbWFwOihzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmICgocHJvdCAmIDIpICE9PSAwXG4gICAgICAgICAgICAmJiAoZmxhZ3MgJiAyKSA9PT0gMFxuICAgICAgICAgICAgJiYgKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubW1hcCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKTtcbiAgICAgIH0sbXN5bmM6KHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSA9PiB7XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpO1xuICAgICAgfSxtdW5tYXA6KHN0cmVhbSkgPT4gMCxpb2N0bDooc3RyZWFtLCBjbWQsIGFyZykgPT4ge1xuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sIGNtZCwgYXJnKTtcbiAgICAgIH0scmVhZEZpbGU6KHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCAwO1xuICAgICAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICd1dGY4JyAmJiBvcHRzLmVuY29kaW5nICE9PSAnYmluYXJ5Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZyB0eXBlIFwiJyArIG9wdHMuZW5jb2RpbmcgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0O1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzKTtcbiAgICAgICAgdmFyIHN0YXQgPSBGUy5zdGF0KHBhdGgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgRlMucmVhZChzdHJlYW0sIGJ1ZiwgMCwgbGVuZ3RoLCAwKTtcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICAgIHJldCA9IFVURjhBcnJheVRvU3RyaW5nKGJ1ZiwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICByZXQgPSBidWY7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sd3JpdGVGaWxlOihwYXRoLCBkYXRhLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgNTc3O1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzLCBvcHRzLm1vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoQnl0ZXNVVEY4KGRhdGEpKzEpO1xuICAgICAgICAgIHZhciBhY3R1YWxOdW1CeXRlcyA9IHN0cmluZ1RvVVRGOEFycmF5KGRhdGEsIGJ1ZiwgMCwgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBidWYsIDAsIGFjdHVhbE51bUJ5dGVzLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCwgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgfSxjd2Q6KCkgPT4gRlMuY3VycmVudFBhdGgsY2hkaXI6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIGlmIChsb29rdXAubm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRGlyKGxvb2t1cC5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLCAneCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICB9LGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczooKSA9PiB7XG4gICAgICAgIEZTLm1rZGlyKCcvdG1wJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZScpO1xuICAgICAgICBGUy5ta2RpcignL2hvbWUvd2ViX3VzZXInKTtcbiAgICAgIH0sY3JlYXRlRGVmYXVsdERldmljZXM6KCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgRlMubWtkaXIoJy9kZXYnKTtcbiAgICAgICAgXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKEZTLm1ha2VkZXYoMSwgMyksIHtcbiAgICAgICAgICByZWFkOiAoKSA9PiAwLFxuICAgICAgICAgIHdyaXRlOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpID0+IGxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L251bGwnLCBGUy5tYWtlZGV2KDEsIDMpKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgVFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNSwgMCksIFRUWS5kZWZhdWx0X3R0eV9vcHMpO1xuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LCAwKSwgVFRZLmRlZmF1bHRfdHR5MV9vcHMpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHknLCBGUy5tYWtlZGV2KDUsIDApKTtcbiAgICAgICAgRlMubWtkZXYoJy9kZXYvdHR5MScsIEZTLm1ha2VkZXYoNiwgMCkpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHJhbmRvbV9kZXZpY2UgPSBnZXRSYW5kb21EZXZpY2UoKTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3JhbmRvbScsIHJhbmRvbV9kZXZpY2UpO1xuICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAndXJhbmRvbScsIHJhbmRvbV9kZXZpY2UpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIEZTLm1rZGlyKCcvZGV2L3NobScpO1xuICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0vdG1wJyk7XG4gICAgICB9LGNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllczooKSA9PiB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jJyk7XG4gICAgICAgIHZhciBwcm9jX3NlbGYgPSBGUy5ta2RpcignL3Byb2Mvc2VsZicpO1xuICAgICAgICBGUy5ta2RpcignL3Byb2Mvc2VsZi9mZCcpO1xuICAgICAgICBGUy5tb3VudCh7XG4gICAgICAgICAgbW91bnQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwcm9jX3NlbGYsICdmZCcsIDE2Mzg0IHwgNTExICwgNzMpO1xuICAgICAgICAgICAgbm9kZS5ub2RlX29wcyA9IHtcbiAgICAgICAgICAgICAgbG9va3VwOiAocGFyZW50LCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGZkID0gK25hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICBtb3VudDogeyBtb3VudHBvaW50OiAnZmFrZScgfSxcbiAgICAgICAgICAgICAgICAgIG5vZGVfb3BzOiB7IHJlYWRsaW5rOiAoKSA9PiBzdHJlYW0ucGF0aCB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0LnBhcmVudCA9IHJldDsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge30sICcvcHJvYy9zZWxmL2ZkJyk7XG4gICAgICB9LGNyZWF0ZVN0YW5kYXJkU3RyZWFtczooKSA9PiB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKE1vZHVsZVsnc3RkaW4nXSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRpbicsIE1vZHVsZVsnc3RkaW4nXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRlMuc3ltbGluaygnL2Rldi90dHknLCAnL2Rldi9zdGRpbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZG91dCddKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZG91dCcsIG51bGwsIE1vZHVsZVsnc3Rkb3V0J10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3Rkb3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1vZHVsZVsnc3RkZXJyJ10pIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkZXJyJywgbnVsbCwgTW9kdWxlWydzdGRlcnInXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRlMuc3ltbGluaygnL2Rldi90dHkxJywgJy9kZXYvc3RkZXJyJyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIFxuICAgICAgICB2YXIgc3RkaW4gPSBGUy5vcGVuKCcvZGV2L3N0ZGluJywgMCk7XG4gICAgICAgIHZhciBzdGRvdXQgPSBGUy5vcGVuKCcvZGV2L3N0ZG91dCcsIDEpO1xuICAgICAgICB2YXIgc3RkZXJyID0gRlMub3BlbignL2Rldi9zdGRlcnInLCAxKTtcbiAgICAgIH0sZW5zdXJlRXJybm9FcnJvcjooKSA9PiB7XG4gICAgICAgIGlmIChGUy5FcnJub0Vycm9yKSByZXR1cm47XG4gICAgICAgIEZTLkVycm5vRXJyb3IgPSAgZnVuY3Rpb24gRXJybm9FcnJvcihlcnJubywgbm9kZSkge1xuICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyA9ICBmdW5jdGlvbihlcnJubykge1xuICAgICAgICAgICAgdGhpcy5lcnJubyA9IGVycm5vO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyhlcnJubyk7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlID0gJ0ZTIGVycm9yJztcbiAgXG4gICAgICAgIH07XG4gICAgICAgIEZTLkVycm5vRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gICAgICAgIEZTLkVycm5vRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRlMuRXJybm9FcnJvcjtcbiAgICAgICAgXG4gICAgICAgIFs0NF0uZm9yRWFjaCgoY29kZSkgPT4ge1xuICAgICAgICAgIEZTLmdlbmVyaWNFcnJvcnNbY29kZV0gPSBuZXcgRlMuRXJybm9FcnJvcihjb2RlKTtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdLnN0YWNrID0gJzxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4nO1xuICAgICAgICB9KTtcbiAgICAgIH0sc3RhdGljSW5pdDooKSA9PiB7XG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcbiAgXG4gICAgICAgIEZTLm5hbWVUYWJsZSA9IG5ldyBBcnJheSg0MDk2KTtcbiAgXG4gICAgICAgIEZTLm1vdW50KE1FTUZTLCB7fSwgJy8nKTtcbiAgXG4gICAgICAgIEZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO1xuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGV2aWNlcygpO1xuICAgICAgICBGUy5jcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKTtcbiAgXG4gICAgICAgIEZTLmZpbGVzeXN0ZW1zID0ge1xuICAgICAgICAgICdNRU1GUyc6IE1FTUZTLFxuICAgICAgICB9O1xuICAgICAgfSxpbml0OihpbnB1dCwgb3V0cHV0LCBlcnJvcikgPT4ge1xuICAgICAgICBGUy5pbml0LmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgXG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcbiAgXG4gICAgICAgIFxuICAgICAgICBNb2R1bGVbJ3N0ZGluJ10gPSBpbnB1dCB8fCBNb2R1bGVbJ3N0ZGluJ107XG4gICAgICAgIE1vZHVsZVsnc3Rkb3V0J10gPSBvdXRwdXQgfHwgTW9kdWxlWydzdGRvdXQnXTtcbiAgICAgICAgTW9kdWxlWydzdGRlcnInXSA9IGVycm9yIHx8IE1vZHVsZVsnc3RkZXJyJ107XG4gIFxuICAgICAgICBGUy5jcmVhdGVTdGFuZGFyZFN0cmVhbXMoKTtcbiAgICAgIH0scXVpdDooKSA9PiB7XG4gICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEZTLnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuc3RyZWFtc1tpXTtcbiAgICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH0sZ2V0TW9kZTooY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgdmFyIG1vZGUgPSAwO1xuICAgICAgICBpZiAoY2FuUmVhZCkgbW9kZSB8PSAyOTIgfCA3MztcbiAgICAgICAgaWYgKGNhbldyaXRlKSBtb2RlIHw9IDE0NjtcbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICB9LGZpbmRPYmplY3Q6KHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspID0+IHtcbiAgICAgICAgdmFyIHJldCA9IEZTLmFuYWx5emVQYXRoKHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspO1xuICAgICAgICBpZiAoIXJldC5leGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0Lm9iamVjdDtcbiAgICAgIH0sYW5hbHl6ZVBhdGg6KHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspID0+IHtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgICAgIHBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgaXNSb290OiBmYWxzZSwgZXhpc3RzOiBmYWxzZSwgZXJyb3I6IDAsIG5hbWU6IG51bGwsIHBhdGg6IG51bGwsIG9iamVjdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLCBwYXJlbnRQYXRoOiBudWxsLCBwYXJlbnRPYmplY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICByZXQucGFyZW50RXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGFyZW50UGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5wYXJlbnRPYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRSZXNvbHZlTGFzdExpbmsgfSk7XG4gICAgICAgICAgcmV0LmV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgcmV0LnBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgICByZXQub2JqZWN0ID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgcmV0Lm5hbWUgPSBsb29rdXAubm9kZS5uYW1lO1xuICAgICAgICAgIHJldC5pc1Jvb3QgPSBsb29rdXAucGF0aCA9PT0gJy8nO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0LmVycm9yID0gZS5lcnJubztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sY3JlYXRlUGF0aDoocGFyZW50LCBwYXRoLCBjYW5SZWFkLCBjYW5Xcml0ZSkgPT4ge1xuICAgICAgICBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpO1xuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykucmV2ZXJzZSgpO1xuICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gUEFUSC5qb2luMihwYXJlbnQsIHBhcnQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBGUy5ta2RpcihjdXJyZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH0sY3JlYXRlRmlsZToocGFyZW50LCBuYW1lLCBwcm9wZXJ0aWVzLCBjYW5SZWFkLCBjYW5Xcml0ZSkgPT4ge1xuICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSk7XG4gICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIHJldHVybiBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICB9LGNyZWF0ZURhdGFGaWxlOihwYXJlbnQsIG5hbWUsIGRhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pID0+IHtcbiAgICAgICAgdmFyIHBhdGggPSBuYW1lO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgICBwYXRoID0gbmFtZSA/IFBBVEguam9pbjIocGFyZW50LCBuYW1lKSA6IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGRhdGEgPSBhcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUgfCAxNDYpO1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKG5vZGUsIDU3Nyk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCwgY2FuT3duKTtcbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxjcmVhdGVEZXZpY2U6KHBhcmVudCwgbmFtZSwgaW5wdXQsIG91dHB1dCkgPT4ge1xuICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSk7XG4gICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZSghIWlucHV0LCAhIW91dHB1dCk7XG4gICAgICAgIGlmICghRlMuY3JlYXRlRGV2aWNlLm1ham9yKSBGUy5jcmVhdGVEZXZpY2UubWFqb3IgPSA2NDtcbiAgICAgICAgdmFyIGRldiA9IEZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssIDApO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwge1xuICAgICAgICAgIG9wZW46IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2U6IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG91dHB1dCAmJiBvdXRwdXQuYnVmZmVyICYmIG91dHB1dC5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG91dHB1dCgxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWFkOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MgKSA9PiB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQraV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGU6IChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgPT4ge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dChidWZmZXJbb2Zmc2V0K2ldKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEZTLm1rZGV2KHBhdGgsIG1vZGUsIGRldik7XG4gICAgICB9LGZvcmNlTG9hZEZpbGU6KG9iaikgPT4ge1xuICAgICAgICBpZiAob2JqLmlzRGV2aWNlIHx8IG9iai5pc0ZvbGRlciB8fCBvYmoubGluayB8fCBvYmouY29udGVudHMpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGF6eSBsb2FkaW5nIHNob3VsZCBoYXZlIGJlZW4gcGVyZm9ybWVkIChjb250ZW50cyBzZXQpIGluIGNyZWF0ZUxhenlGaWxlLCBidXQgaXQgd2FzIG5vdC4gTGF6eSBsb2FkaW5nIG9ubHkgd29ya3MgaW4gd2ViIHdvcmtlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyBvbiB0aGUgbWFpbiB0aHJlYWQuXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlYWRfKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBvYmouY29udGVudHMgPSBpbnRBcnJheUZyb21TdHJpbmcocmVhZF8ob2JqLnVybCksIHRydWUpO1xuICAgICAgICAgICAgb2JqLnVzZWRCeXRlcyA9IG9iai5jb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIHdpdGhvdXQgcmVhZCgpIG9yIFhNTEh0dHBSZXF1ZXN0LicpO1xuICAgICAgICB9XG4gICAgICB9LGNyZWF0ZUxhenlGaWxlOihwYXJlbnQsIG5hbWUsIHVybCwgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBMYXp5VWludDhBcnJheSgpIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsgXG4gICAgICAgIH1cbiAgICAgICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmdldCA9ICBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KSB7XG4gICAgICAgICAgaWYgKGlkeCA+IHRoaXMubGVuZ3RoLTEgfHwgaWR4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gaWR4ICUgdGhpcy5jaHVua1NpemU7XG4gICAgICAgICAgdmFyIGNodW5rTnVtID0gKGlkeCAvIHRoaXMuY2h1bmtTaXplKXwwO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldHRlcihjaHVua051bSlbY2h1bmtPZmZzZXRdO1xuICAgICAgICB9O1xuICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuc2V0RGF0YUdldHRlciA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgICAgdGhpcy5nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5jYWNoZUxlbmd0aCA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoKCkge1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICB4aHIub3BlbignSEVBRCcsIHVybCwgZmFsc2UpO1xuICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgIGlmICghKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArIFwiLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgdmFyIGRhdGFsZW5ndGggPSBOdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1sZW5ndGhcIikpO1xuICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgdmFyIGhhc0J5dGVTZXJ2aW5nID0gKGhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkFjY2VwdC1SYW5nZXNcIikpICYmIGhlYWRlciA9PT0gXCJieXRlc1wiO1xuICAgICAgICAgIHZhciB1c2VzR3ppcCA9IChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUVuY29kaW5nXCIpKSAmJiBoZWFkZXIgPT09IFwiZ3ppcFwiO1xuICBcbiAgICAgICAgICB2YXIgY2h1bmtTaXplID0gMTAyNCoxMDI0OyBcbiAgXG4gICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcbiAgXG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGRvWEhSID0gKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IHRvKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJhbmdlIChcIiArIGZyb20gKyBcIiwgXCIgKyB0byArIFwiKSBvciBubyBieXRlcyByZXF1ZXN0ZWQhXCIpO1xuICAgICAgICAgICAgaWYgKHRvID4gZGF0YWxlbmd0aC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IFwiICsgZGF0YWxlbmd0aCArIFwiIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciFcIik7XG4gIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoZGF0YWxlbmd0aCAhPT0gY2h1bmtTaXplKSB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIFwiYnl0ZXM9XCIgKyBmcm9tICsgXCItXCIgKyB0byk7XG4gIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIGlmICh4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICAgICAgaWYgKCEoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBsb2FkIFwiICsgdXJsICsgXCIuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKHhoci5yZXNwb25zZSB8fCBbXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0IHx8ICcnLCB0cnVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBsYXp5QXJyYXkgPSB0aGlzO1xuICAgICAgICAgIGxhenlBcnJheS5zZXREYXRhR2V0dGVyKChjaHVua051bSkgPT4ge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtOdW0gKiBjaHVua1NpemU7XG4gICAgICAgICAgICB2YXIgZW5kID0gKGNodW5rTnVtKzEpICogY2h1bmtTaXplIC0gMTsgXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGRhdGFsZW5ndGgtMSk7IFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9IGRvWEhSKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdkb1hIUiBmYWlsZWQhJyk7XG4gICAgICAgICAgICByZXR1cm4gbGF6eUFycmF5LmNodW5rc1tjaHVua051bV07XG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIGlmICh1c2VzR3ppcCB8fCAhZGF0YWxlbmd0aCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoID0gMTsgXG4gICAgICAgICAgICBkYXRhbGVuZ3RoID0gdGhpcy5nZXR0ZXIoMCkubGVuZ3RoO1xuICAgICAgICAgICAgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcbiAgICAgICAgICAgIG91dChcIkxhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZFwiKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgdGhpcy5fY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKCFFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHRocm93ICdDYW5ub3QgZG8gc3luY2hyb25vdXMgYmluYXJ5IFhIUnMgb3V0c2lkZSB3ZWJ3b3JrZXJzIGluIG1vZGVybiBicm93c2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjJztcbiAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gbmV3IExhenlVaW50OEFycmF5KCk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eUFycmF5LCB7XG4gICAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgICAgZ2V0OiAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaHVua1NpemU6IHtcbiAgICAgICAgICAgICAgZ2V0OiAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1NpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgY29udGVudHM6IGxhenlBcnJheSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0geyBpc0RldmljZTogZmFsc2UsIHVybDogdXJsIH07XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlRmlsZShwYXJlbnQsIG5hbWUsIHByb3BlcnRpZXMsIGNhblJlYWQsIGNhbldyaXRlKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuY29udGVudHMpIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gcHJvcGVydGllcy5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLnVybCkge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgICAgICAgIG5vZGUudXJsID0gcHJvcGVydGllcy51cmw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIHtcbiAgICAgICAgICB1c2VkQnl0ZXM6IHtcbiAgICAgICAgICAgIGdldDogIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGg7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIHN0cmVhbV9vcHMgPSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnN0cmVhbV9vcHMpO1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIHZhciBmbiA9IG5vZGUuc3RyZWFtX29wc1trZXldO1xuICAgICAgICAgIHN0cmVhbV9vcHNba2V5XSA9IGZ1bmN0aW9uIGZvcmNlTG9hZExhenlGaWxlKCkge1xuICAgICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB3cml0ZUNodW5rcyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uID49IGNvbnRlbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oY29udGVudHMubGVuZ3RoIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgaWYgKGNvbnRlbnRzLnNsaWNlKSB7IFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsgXG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzLmdldChwb3NpdGlvbiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3RyZWFtX29wcy5yZWFkID0gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgIHJldHVybiB3cml0ZUNodW5rcyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgc3RyZWFtX29wcy5tbWFwID0gKHN0cmVhbSwgbGVuZ3RoLCBwb3NpdGlvbiwgcHJvdCwgZmxhZ3MpID0+IHtcbiAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgIHZhciBwdHIgPSBtbWFwQWxsb2MobGVuZ3RoKTtcbiAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3cml0ZUNodW5rcyhzdHJlYW0sIEhFQVA4LCBwdHIsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IHRydWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gc3RyZWFtX29wcztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGNyZWF0ZVByZWxvYWRlZEZpbGU6KHBhcmVudCwgbmFtZSwgdXJsLCBjYW5SZWFkLCBjYW5Xcml0ZSwgb25sb2FkLCBvbmVycm9yLCBkb250Q3JlYXRlRmlsZSwgY2FuT3duLCBwcmVGaW5pc2gpID0+IHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgZnVsbG5hbWUgPSBuYW1lID8gUEFUSF9GUy5yZXNvbHZlKFBBVEguam9pbjIocGFyZW50LCBuYW1lKSkgOiBwYXJlbnQ7XG4gICAgICAgIHZhciBkZXAgPSBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KCdjcCAnICsgZnVsbG5hbWUpOyBcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KSB7XG4gICAgICAgICAgZnVuY3Rpb24gZmluaXNoKGJ5dGVBcnJheSkge1xuICAgICAgICAgICAgaWYgKHByZUZpbmlzaCkgcHJlRmluaXNoKCk7XG4gICAgICAgICAgICBpZiAoIWRvbnRDcmVhdGVGaWxlKSB7XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKHBhcmVudCwgbmFtZSwgYnl0ZUFycmF5LCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbmxvYWQpIG9ubG9hZCgpO1xuICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQnJvd3Nlci5oYW5kbGVkQnlQcmVsb2FkUGx1Z2luKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9uZXJyb3IpIG9uZXJyb3IoKTtcbiAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5pc2goYnl0ZUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYXN5bmNMb2FkKHVybCwgKGJ5dGVBcnJheSkgPT4gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KSwgb25lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzc0RhdGEodXJsKTtcbiAgICAgICAgfVxuICAgICAgfSxpbmRleGVkREI6KCkgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cubW96SW5kZXhlZERCIHx8IHdpbmRvdy53ZWJraXRJbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCO1xuICAgICAgfSxEQl9OQU1FOigpID0+IHtcbiAgICAgICAgcmV0dXJuICdFTV9GU18nICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgfSxEQl9WRVJTSU9OOjIwLERCX1NUT1JFX05BTUU6XCJGSUxFX0RBVEFcIixzYXZlRmlsZXNUb0RCOihwYXRocywgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgICAgIG9ubG9hZCA9IG9ubG9hZCB8fCAoKCkgPT4ge30pO1xuICAgICAgICBvbmVycm9yID0gb25lcnJvciB8fCAoKCkgPT4ge30pO1xuICAgICAgICB2YXIgaW5kZXhlZERCID0gRlMuaW5kZXhlZERCKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBvbmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcbiAgICAgICAgICBvdXQoJ2NyZWF0aW5nIGRiJyk7XG4gICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgIHZhciBmaWxlcyA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgICAgIHZhciBvayA9IDAsIGZhaWwgPSAwLCB0b3RhbCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgICAgICBpZiAoZmFpbCA9PSAwKSBvbmxvYWQoKTsgZWxzZSBvbmVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHZhciBwdXRSZXF1ZXN0ID0gZmlsZXMucHV0KEZTLmFuYWx5emVQYXRoKHBhdGgpLm9iamVjdC5jb250ZW50cywgcGF0aCk7XG4gICAgICAgICAgICBwdXRSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHsgb2srKzsgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCkgfTtcbiAgICAgICAgICAgIHB1dFJlcXVlc3Qub25lcnJvciA9ICgpID0+IHsgZmFpbCsrOyBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgIH0sbG9hZEZpbGVzRnJvbURCOihwYXRocywgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgICAgIG9ubG9hZCA9IG9ubG9hZCB8fCAoKCkgPT4ge30pO1xuICAgICAgICBvbmVycm9yID0gb25lcnJvciB8fCAoKCkgPT4ge30pO1xuICAgICAgICB2YXIgaW5kZXhlZERCID0gRlMuaW5kZXhlZERCKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBvbmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IG9uZXJyb3I7IFxuICAgICAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbRlMuREJfU1RPUkVfTkFNRV0sICdyZWFkb25seScpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgb25lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZpbGVzID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgICAgICAgdmFyIG9rID0gMCwgZmFpbCA9IDAsIHRvdGFsID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpOyBlbHNlIG9uZXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgdmFyIGdldFJlcXVlc3QgPSBmaWxlcy5nZXQocGF0aCk7XG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKEZTLmFuYWx5emVQYXRoKHBhdGgpLmV4aXN0cykge1xuICAgICAgICAgICAgICAgIEZTLnVubGluayhwYXRoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBGUy5jcmVhdGVEYXRhRmlsZShQQVRILmRpcm5hbWUocGF0aCksIFBBVEguYmFzZW5hbWUocGF0aCksIGdldFJlcXVlc3QucmVzdWx0LCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgb2srKztcbiAgICAgICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2V0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4geyBmYWlsKys7IGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgfX07XG4gIHZhciBTWVNDQUxMUyA9IHtERUZBVUxUX1BPTExNQVNLOjUsY2FsY3VsYXRlQXQ6ZnVuY3Rpb24oZGlyZmQsIHBhdGgsIGFsbG93RW1wdHkpIHtcbiAgICAgICAgaWYgKFBBVEguaXNBYnMocGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGRpcjtcbiAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7XG4gICAgICAgICAgZGlyID0gRlMuY3dkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChkaXJmZCk7XG4gICAgICAgICAgZGlyID0gZGlyc3RyZWFtLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBVEguam9pbjIoZGlyLCBwYXRoKTtcbiAgICAgIH0sZG9TdGF0OmZ1bmN0aW9uKGZ1bmMsIHBhdGgsIGJ1Zikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzdGF0ID0gZnVuYyhwYXRoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUubm9kZSAmJiBQQVRILm5vcm1hbGl6ZShwYXRoKSAhPT0gUEFUSC5ub3JtYWxpemUoRlMuZ2V0UGF0aChlLm5vZGUpKSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gLTU0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIEhFQVAzMlsoKGJ1Zik+PjIpXSA9IHN0YXQuZGV2O1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoOCkpPj4yKV0gPSBzdGF0LmlubztcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDEyKSk+PjIpXSA9IHN0YXQubW9kZTtcbiAgICAgICAgSEVBUFUzMlsoKChidWYpKygxNikpPj4yKV0gPSBzdGF0Lm5saW5rO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMjApKT4+MildID0gc3RhdC51aWQ7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygyNCkpPj4yKV0gPSBzdGF0LmdpZDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDI4KSk+PjIpXSA9IHN0YXQucmRldjtcbiAgICAgICAgKHRlbXBJNjQgPSBbc3RhdC5zaXplPj4+MCwodGVtcERvdWJsZT1zdGF0LnNpemUsKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgoYnVmKSsoNDApKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoNDQpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKyg0OCkpPj4yKV0gPSA0MDk2O1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNTIpKT4+MildID0gc3RhdC5ibG9ja3M7XG4gICAgICAgIHZhciBhdGltZSA9IHN0YXQuYXRpbWUuZ2V0VGltZSgpO1xuICAgICAgICB2YXIgbXRpbWUgPSBzdGF0Lm10aW1lLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XG4gICAgICAgICh0ZW1wSTY0ID0gW01hdGguZmxvb3IoYXRpbWUgLyAxMDAwKT4+PjAsKHRlbXBEb3VibGU9TWF0aC5mbG9vcihhdGltZSAvIDEwMDApLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGJ1ZikrKDU2KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDYwKSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQVTMyWygoKGJ1ZikrKDY0KSk+PjIpXSA9IChhdGltZSAlIDEwMDApICogMTAwMDtcbiAgICAgICAgKHRlbXBJNjQgPSBbTWF0aC5mbG9vcihtdGltZSAvIDEwMDApPj4+MCwodGVtcERvdWJsZT1NYXRoLmZsb29yKG10aW1lIC8gMTAwMCksKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgoYnVmKSsoNzIpKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoNzYpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIEhFQVBVMzJbKCgoYnVmKSsoODApKT4+MildID0gKG10aW1lICUgMTAwMCkgKiAxMDAwO1xuICAgICAgICAodGVtcEk2NCA9IFtNYXRoLmZsb29yKGN0aW1lIC8gMTAwMCk+Pj4wLCh0ZW1wRG91YmxlPU1hdGguZmxvb3IoY3RpbWUgLyAxMDAwKSwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKChidWYpKyg4OCkpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChidWYpKyg5MikpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUFUzMlsoKChidWYpKyg5NikpPj4yKV0gPSAoY3RpbWUgJSAxMDAwKSAqIDEwMDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW3N0YXQuaW5vPj4+MCwodGVtcERvdWJsZT1zdGF0LmlubywoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKChidWYpKygxMDQpKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoMTA4KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sZG9Nc3luYzpmdW5jdGlvbihhZGRyLCBzdHJlYW0sIGxlbiwgZmxhZ3MsIG9mZnNldCkge1xuICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IEhFQVBVOC5zbGljZShhZGRyLCBhZGRyICsgbGVuKTtcbiAgICAgICAgRlMubXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuLCBmbGFncyk7XG4gICAgICB9LHZhcmFyZ3M6dW5kZWZpbmVkLGdldDpmdW5jdGlvbigpIHtcbiAgICAgICAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xuICAgICAgICB2YXIgcmV0ID0gSEVBUDMyWygoKFNZU0NBTExTLnZhcmFyZ3MpLSg0KSk+PjIpXTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sZ2V0U3RyOmZ1bmN0aW9uKHB0cikge1xuICAgICAgICB2YXIgcmV0ID0gVVRGOFRvU3RyaW5nKHB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LGdldFN0cmVhbUZyb21GRDpmdW5jdGlvbihmZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfX07XG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfY2htb2QocGF0aCwgbW9kZSkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBGUy5jaG1vZChwYXRoLCBtb2RlKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9mYWNjZXNzYXQoZGlyZmQsIHBhdGgsIGFtb2RlLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgaWYgKGFtb2RlICYgfjcpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAtMjg7XG4gICAgICB9XG4gICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIC00NDtcbiAgICAgIH1cbiAgICAgIHZhciBwZXJtcyA9ICcnO1xuICAgICAgaWYgKGFtb2RlICYgNCkgcGVybXMgKz0gJ3InO1xuICAgICAgaWYgKGFtb2RlICYgMikgcGVybXMgKz0gJ3cnO1xuICAgICAgaWYgKGFtb2RlICYgMSkgcGVybXMgKz0gJ3gnO1xuICAgICAgaWYgKHBlcm1zICAmJiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgcGVybXMpKSB7XG4gICAgICAgIHJldHVybiAtMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9mY2htb2QoZmQsIG1vZGUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBGUy5mY2htb2QoZmQsIG1vZGUpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZjaG93bjMyKGZkLCBvd25lciwgZ3JvdXApIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBGUy5mY2hvd24oZmQsIG93bmVyLCBncm91cCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEVyck5vKHZhbHVlKSB7XG4gICAgICBIRUFQMzJbKChfX19lcnJub19sb2NhdGlvbigpKT4+MildID0gdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9mY250bDY0KGZkLCBjbWQsIHZhcmFyZ3MpIHtcbiAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICB2YXIgYXJnID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgaWYgKGFyZyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXdTdHJlYW07XG4gICAgICAgICAgbmV3U3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKHN0cmVhbSwgYXJnKTtcbiAgICAgICAgICByZXR1cm4gbmV3U3RyZWFtLmZkO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAwOyAgXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gc3RyZWFtLmZsYWdzO1xuICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICB2YXIgYXJnID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgc3RyZWFtLmZsYWdzIHw9IGFyZztcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICB7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIFxuICAgICAgICAgIEhFQVAxNlsoKChhcmcpKyhvZmZzZXQpKT4+MSldID0gMjtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiAwOyBcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAtMjg7IFxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0RXJyTm8oMjgpO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHJldHVybiAtMjg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZnN0YXQ2NChmZCwgYnVmKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KEZTLnN0YXQsIHN0cmVhbS5wYXRoLCBidWYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgdmFyIE1BWF9JTlQ1MyA9IDkwMDcxOTkyNTQ3NDA5OTI7XG4gIFxuICB2YXIgTUlOX0lOVDUzID0gLTkwMDcxOTkyNTQ3NDA5OTI7XG4gIGZ1bmN0aW9uIGJpZ2ludFRvSTUzQ2hlY2tlZChudW0pIHtcbiAgICAgIHJldHVybiAobnVtIDwgTUlOX0lOVDUzIHx8IG51bSA+IE1BWF9JTlQ1MykgPyBOYU4gOiBOdW1iZXIobnVtKTtcbiAgICB9XG4gIFxuICBcbiAgXG4gIFxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2Z0cnVuY2F0ZTY0KGZkLCAgbGVuZ3RoKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgbGVuZ3RoID0gYmlnaW50VG9JNTNDaGVja2VkKGxlbmd0aCk7IGlmIChpc05hTihsZW5ndGgpKSByZXR1cm4gLTYxO1xuICAgICAgRlMuZnRydW5jYXRlKGZkLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2dldGN3ZChidWYsIHNpemUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBpZiAoc2l6ZSA9PT0gMCkgcmV0dXJuIC0yODtcbiAgICAgIHZhciBjd2QgPSBGUy5jd2QoKTtcbiAgICAgIHZhciBjd2RMZW5ndGhJbkJ5dGVzID0gbGVuZ3RoQnl0ZXNVVEY4KGN3ZCkgKyAxO1xuICAgICAgaWYgKHNpemUgPCBjd2RMZW5ndGhJbkJ5dGVzKSByZXR1cm4gLTY4O1xuICAgICAgc3RyaW5nVG9VVEY4KGN3ZCwgYnVmLCBzaXplKTtcbiAgICAgIHJldHVybiBjd2RMZW5ndGhJbkJ5dGVzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9pb2N0bChmZCwgb3AsIHZhcmFyZ3MpIHtcbiAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgMjE1MDk6XG4gICAgICAgIGNhc2UgMjE1MDU6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUxMDpcbiAgICAgICAgY2FzZSAyMTUxMTpcbiAgICAgICAgY2FzZSAyMTUxMjpcbiAgICAgICAgY2FzZSAyMTUwNjpcbiAgICAgICAgY2FzZSAyMTUwNzpcbiAgICAgICAgY2FzZSAyMTUwODoge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDsgXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUxOToge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICB2YXIgYXJncCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIEhFQVAzMlsoKGFyZ3ApPj4yKV0gPSAwO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MjA6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIC0yODsgXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUzMToge1xuICAgICAgICAgIHZhciBhcmdwID0gU1lTQ0FMTFMuZ2V0KCk7XG4gICAgICAgICAgcmV0dXJuIEZTLmlvY3RsKHN0cmVhbSwgb3AsIGFyZ3ApO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MjM6IHtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUyNDoge1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gLTI4OyBcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLCBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5sc3RhdCwgcGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtkaXJhdChkaXJmZCwgcGF0aCwgbW9kZSkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgXG4gICAgICBcbiAgICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoLTFdID09PSAnLycpIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxlbmd0aC0xKTtcbiAgICAgIEZTLm1rZGlyKHBhdGgsIG1vZGUsIDApO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX25ld2ZzdGF0YXQoZGlyZmQsIHBhdGgsIGJ1ZiwgZmxhZ3MpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgdmFyIG5vZm9sbG93ID0gZmxhZ3MgJiAyNTY7XG4gICAgICB2YXIgYWxsb3dFbXB0eSA9IGZsYWdzICYgNDA5NjtcbiAgICAgIGZsYWdzID0gZmxhZ3MgJiAofjY0MDApO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCBhbGxvd0VtcHR5KTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQobm9mb2xsb3cgPyBGUy5sc3RhdCA6IEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcbiAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICB2YXIgbW9kZSA9IHZhcmFyZ3MgPyBTWVNDQUxMUy5nZXQoKSA6IDA7XG4gICAgICByZXR1cm4gRlMub3BlbihwYXRoLCBmbGFncywgbW9kZSkuZmQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3JlYWRsaW5rYXQoZGlyZmQsIHBhdGgsIGJ1ZiwgYnVmc2l6ZSkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgaWYgKGJ1ZnNpemUgPD0gMCkgcmV0dXJuIC0yODtcbiAgICAgIHZhciByZXQgPSBGUy5yZWFkbGluayhwYXRoKTtcbiAgXG4gICAgICB2YXIgbGVuID0gTWF0aC5taW4oYnVmc2l6ZSwgbGVuZ3RoQnl0ZXNVVEY4KHJldCkpO1xuICAgICAgdmFyIGVuZENoYXIgPSBIRUFQOFtidWYrbGVuXTtcbiAgICAgIHN0cmluZ1RvVVRGOChyZXQsIGJ1ZiwgYnVmc2l6ZSsxKTtcbiAgICAgIFxuICAgICAgXG4gICAgICBIRUFQOFtidWYrbGVuXSA9IGVuZENoYXI7XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9ybWRpcihwYXRoKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIEZTLnJtZGlyKHBhdGgpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3N0YXQ2NChwYXRoLCBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBwYXRoLCBidWYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF91bmxpbmthdChkaXJmZCwgcGF0aCwgZmxhZ3MpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIGlmIChmbGFncyA9PT0gMCkge1xuICAgICAgICBGUy51bmxpbmsocGF0aCk7XG4gICAgICB9IGVsc2UgaWYgKGZsYWdzID09PSA1MTIpIHtcbiAgICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhYm9ydCgnSW52YWxpZCBmbGFncyBwYXNzZWQgdG8gdW5saW5rYXQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEk1M0Zyb21JNjQocHRyKSB7XG4gICAgICByZXR1cm4gSEVBUFUzMltwdHI+PjJdICsgSEVBUDMyW3B0cis0Pj4yXSAqIDQyOTQ5NjcyOTY7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gX19fc3lzY2FsbF91dGltZW5zYXQoZGlyZmQsIHBhdGgsIHRpbWVzLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgsIHRydWUpO1xuICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICB2YXIgYXRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbXRpbWUgPSBhdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWNvbmRzID0gcmVhZEk1M0Zyb21JNjQodGltZXMpO1xuICAgICAgICB2YXIgbmFub3NlY29uZHMgPSBIRUFQMzJbKCgodGltZXMpKyg4KSk+PjIpXTtcbiAgICAgICAgYXRpbWUgPSAoc2Vjb25kcyoxMDAwKSArIChuYW5vc2Vjb25kcy8oMTAwMCoxMDAwKSk7XG4gICAgICAgIHRpbWVzICs9IDE2O1xuICAgICAgICBzZWNvbmRzID0gcmVhZEk1M0Zyb21JNjQodGltZXMpO1xuICAgICAgICBuYW5vc2Vjb25kcyA9IEhFQVAzMlsoKCh0aW1lcykrKDgpKT4+MildO1xuICAgICAgICBtdGltZSA9IChzZWNvbmRzKjEwMDApICsgKG5hbm9zZWNvbmRzLygxMDAwKjEwMDApKTtcbiAgICAgIH1cbiAgICAgIEZTLnV0aW1lKHBhdGgsIGF0aW1lLCBtdGltZSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIHZhciBub3dJc01vbm90b25pYyA9IHRydWU7O1xuICBmdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMoKSB7XG4gICAgICByZXR1cm4gbm93SXNNb25vdG9uaWM7XG4gICAgfVxuXG4gIFxuICBmdW5jdGlvbiBfX2lzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4geWVhciU0ID09PSAwICYmICh5ZWFyJTEwMCAhPT0gMCB8fCB5ZWFyJTQwMCA9PT0gMCk7XG4gICAgfVxuICBcbiAgdmFyIF9fTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkUgPSBbMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XTtcbiAgXG4gIHZhciBfX01PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFID0gWzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07XG4gIGZ1bmN0aW9uIF9feWRheV9mcm9tX2RhdGUoZGF0ZSkge1xuICAgICAgdmFyIGlzTGVhcFllYXIgPSBfX2lzTGVhcFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgIHZhciBtb250aERheXNDdW11bGF0aXZlID0gKGlzTGVhcFllYXIgPyBfX01PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFIDogX19NT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRSk7XG4gICAgICB2YXIgeWRheSA9IG1vbnRoRGF5c0N1bXVsYXRpdmVbZGF0ZS5nZXRNb250aCgpXSArIGRhdGUuZ2V0RGF0ZSgpIC0gMTsgXG4gIFxuICAgICAgcmV0dXJuIHlkYXk7XG4gICAgfVxuICBmdW5jdGlvbiBfX2xvY2FsdGltZV9qcyh0aW1lLCB0bVB0cikge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShyZWFkSTUzRnJvbUk2NCh0aW1lKSoxMDAwKTtcbiAgICAgIEhFQVAzMlsoKHRtUHRyKT4+MildID0gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKyg0KSk+PjIpXSA9IGRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoOCkpPj4yKV0gPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygxMikpPj4yKV0gPSBkYXRlLmdldERhdGUoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDE2KSk+PjIpXSA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDIwKSk+PjIpXSA9IGRhdGUuZ2V0RnVsbFllYXIoKS0xOTAwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjQpKT4+MildID0gZGF0ZS5nZXREYXkoKTtcbiAgXG4gICAgICB2YXIgeWRheSA9IF9feWRheV9mcm9tX2RhdGUoZGF0ZSl8MDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI4KSk+PjIpXSA9IHlkYXk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygzNikpPj4yKV0gPSAtKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwKTtcbiAgXG4gICAgICBcbiAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyT2Zmc2V0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCA2LCAxKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgZHN0ID0gKHN1bW1lck9mZnNldCAhPSB3aW50ZXJPZmZzZXQgJiYgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KSl8MDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDMyKSk+PjIpXSA9IGRzdDtcbiAgICB9XG5cbiAgXG4gIFxuICBmdW5jdGlvbiBfX21tYXBfanMobGVuLCBwcm90LCBmbGFncywgZmQsIG9mZiwgYWxsb2NhdGVkLCBhZGRyKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgcmVzID0gRlMubW1hcChzdHJlYW0sIGxlbiwgb2ZmLCBwcm90LCBmbGFncyk7XG4gICAgICB2YXIgcHRyID0gcmVzLnB0cjtcbiAgICAgIEhFQVAzMlsoKGFsbG9jYXRlZCk+PjIpXSA9IHJlcy5hbGxvY2F0ZWQ7XG4gICAgICBIRUFQVTMyWygoYWRkcik+PjIpXSA9IHB0cjtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgXG4gIFxuICBmdW5jdGlvbiBfX211bm1hcF9qcyhhZGRyLCBsZW4sIHByb3QsIGZsYWdzLCBmZCwgb2Zmc2V0KSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBpZiAocHJvdCAmIDIpIHtcbiAgICAgICAgU1lTQ0FMTFMuZG9Nc3luYyhhZGRyLCBzdHJlYW0sIGxlbiwgZmxhZ3MsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBGUy5tdW5tYXAoc3RyZWFtKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2NhdGVVVEY4KHN0cikge1xuICAgICAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gICAgICB2YXIgcmV0ID0gX21hbGxvYyhzaXplKTtcbiAgICAgIGlmIChyZXQpIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUDgsIHJldCwgc2l6ZSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgZnVuY3Rpb24gX190enNldF9qcyh0aW1lem9uZSwgZGF5bGlnaHQsIHR6bmFtZSkge1xuICAgICAgXG4gICAgICB2YXIgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgd2ludGVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDAsIDEpO1xuICAgICAgdmFyIHN1bW1lciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCA2LCAxKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSB3aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heCh3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCk7XG4gIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIEhFQVBVMzJbKCh0aW1lem9uZSk+PjIpXSA9IHN0ZFRpbWV6b25lT2Zmc2V0ICogNjA7XG4gIFxuICAgICAgSEVBUDMyWygoZGF5bGlnaHQpPj4yKV0gPSBOdW1iZXIod2ludGVyT2Zmc2V0ICE9IHN1bW1lck9mZnNldCk7XG4gIFxuICAgICAgZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogXCJHTVRcIjtcbiAgICAgIH07XG4gICAgICB2YXIgd2ludGVyTmFtZSA9IGV4dHJhY3Rab25lKHdpbnRlcik7XG4gICAgICB2YXIgc3VtbWVyTmFtZSA9IGV4dHJhY3Rab25lKHN1bW1lcik7XG4gICAgICB2YXIgd2ludGVyTmFtZVB0ciA9IGFsbG9jYXRlVVRGOCh3aW50ZXJOYW1lKTtcbiAgICAgIHZhciBzdW1tZXJOYW1lUHRyID0gYWxsb2NhdGVVVEY4KHN1bW1lck5hbWUpO1xuICAgICAgaWYgKHN1bW1lck9mZnNldCA8IHdpbnRlck9mZnNldCkge1xuICAgICAgICBcbiAgICAgICAgSEVBUFUzMlsoKHR6bmFtZSk+PjIpXSA9IHdpbnRlck5hbWVQdHI7XG4gICAgICAgIEhFQVBVMzJbKCgodHpuYW1lKSsoNCkpPj4yKV0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSEVBUFUzMlsoKHR6bmFtZSk+PjIpXSA9IHN1bW1lck5hbWVQdHI7XG4gICAgICAgIEhFQVBVMzJbKCgodHpuYW1lKSsoNCkpPj4yKV0gPSB3aW50ZXJOYW1lUHRyO1xuICAgICAgfVxuICAgIH1cblxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9kYXRlX25vdygpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cblxuICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztfZW1zY3JpcHRlbl9nZXRfbm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIDtcblxuICBmdW5jdGlvbiBnZXRIZWFwTWF4KCkge1xuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICByZXR1cm4gMjE0NzQ4MzY0ODtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKHNpemUpIHtcbiAgICAgIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gICAgICB0cnkge1xuICAgICAgICBcbiAgICAgICAgd2FzbU1lbW9yeS5ncm93KChzaXplIC0gYi5ieXRlTGVuZ3RoICsgNjU1MzUpID4+PiAxNik7IFxuICAgICAgICB1cGRhdGVNZW1vcnlWaWV3cygpO1xuICAgICAgICByZXR1cm4gMSA7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgfVxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcChyZXF1ZXN0ZWRTaXplKSB7XG4gICAgICB2YXIgb2xkU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XG4gICAgICByZXF1ZXN0ZWRTaXplID0gcmVxdWVzdGVkU2l6ZSA+Pj4gMDtcbiAgICAgIFxuICAgICAgXG4gIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gIFxuICAgICAgXG4gICAgICBcbiAgICAgIHZhciBtYXhIZWFwU2l6ZSA9IGdldEhlYXBNYXgoKTtcbiAgICAgIGlmIChyZXF1ZXN0ZWRTaXplID4gbWF4SGVhcFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICBcbiAgICAgIGxldCBhbGlnblVwID0gKHgsIG11bHRpcGxlKSA9PiB4ICsgKG11bHRpcGxlIC0geCAlIG11bHRpcGxlKSAlIG11bHRpcGxlO1xuICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIGZvciAodmFyIGN1dERvd24gPSAxOyBjdXREb3duIDw9IDQ7IGN1dERvd24gKj0gMikge1xuICAgICAgICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAwLjIgLyBjdXREb3duKTsgXG4gICAgICAgIFxuICAgICAgICBvdmVyR3Jvd25IZWFwU2l6ZSA9IE1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLCByZXF1ZXN0ZWRTaXplICsgMTAwNjYzMjk2ICk7XG4gIFxuICAgICAgICB2YXIgbmV3U2l6ZSA9IE1hdGgubWluKG1heEhlYXBTaXplLCBhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpKTtcbiAgXG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIobmV3U2l6ZSk7XG4gICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB2YXIgRU5WID0ge307XG4gIFxuICBmdW5jdGlvbiBnZXRFeGVjdXRhYmxlTmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzUHJvZ3JhbSB8fCAnLi90aGlzLnByb2dyYW0nO1xuICAgIH1cbiAgZnVuY3Rpb24gZ2V0RW52U3RyaW5ncygpIHtcbiAgICAgIGlmICghZ2V0RW52U3RyaW5ncy5zdHJpbmdzKSB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIGxhbmcgPSAoKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fCAnQycpLnJlcGxhY2UoJy0nLCAnXycpICsgJy5VVEYtOCc7XG4gICAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgICAgJ1VTRVInOiAnd2ViX3VzZXInLFxuICAgICAgICAgICdMT0dOQU1FJzogJ3dlYl91c2VyJyxcbiAgICAgICAgICAnUEFUSCc6ICcvJyxcbiAgICAgICAgICAnUFdEJzogJy8nLFxuICAgICAgICAgICdIT01FJzogJy9ob21lL3dlYl91c2VyJyxcbiAgICAgICAgICAnTEFORyc6IGxhbmcsXG4gICAgICAgICAgJ18nOiBnZXRFeGVjdXRhYmxlTmFtZSgpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciB4IGluIEVOVikge1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChFTlZbeF0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIGVudlt4XTtcbiAgICAgICAgICBlbHNlIGVudlt4XSA9IEVOVlt4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB4IGluIGVudikge1xuICAgICAgICAgIHN0cmluZ3MucHVzaCh4ICsgJz0nICsgZW52W3hdKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRFbnZTdHJpbmdzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEVudlN0cmluZ3Muc3RyaW5ncztcbiAgICB9XG4gIFxuICBcbiAgZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0ciwgYnVmZmVyLCBkb250QWRkTnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgSEVBUDhbKChidWZmZXIrKyk+PjApXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWRvbnRBZGROdWxsKSBIRUFQOFsoKGJ1ZmZlcik+PjApXSA9IDA7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gX2Vudmlyb25fZ2V0KF9fZW52aXJvbiwgZW52aXJvbl9idWYpIHtcbiAgICAgIHZhciBidWZTaXplID0gMDtcbiAgICAgIGdldEVudlN0cmluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZywgaSkge1xuICAgICAgICB2YXIgcHRyID0gZW52aXJvbl9idWYgKyBidWZTaXplO1xuICAgICAgICBIRUFQVTMyWygoKF9fZW52aXJvbikrKGkqNCkpPj4yKV0gPSBwdHI7XG4gICAgICAgIHdyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcsIHB0cik7XG4gICAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICBcbiAgZnVuY3Rpb24gX2Vudmlyb25fc2l6ZXNfZ2V0KHBlbnZpcm9uX2NvdW50LCBwZW52aXJvbl9idWZfc2l6ZSkge1xuICAgICAgdmFyIHN0cmluZ3MgPSBnZXRFbnZTdHJpbmdzKCk7XG4gICAgICBIRUFQVTMyWygocGVudmlyb25fY291bnQpPj4yKV0gPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgIHZhciBidWZTaXplID0gMDtcbiAgICAgIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgSEVBUFUzMlsoKHBlbnZpcm9uX2J1Zl9zaXplKT4+MildID0gYnVmU2l6ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICBmdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQsIHBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgdHlwZSA9IHN0cmVhbS50dHkgPyAyIDpcbiAgICAgICAgICAgICAgICAgRlMuaXNEaXIoc3RyZWFtLm1vZGUpID8gMyA6XG4gICAgICAgICAgICAgICAgIEZTLmlzTGluayhzdHJlYW0ubW9kZSkgPyA3IDpcbiAgICAgICAgICAgICAgICAgNDtcbiAgICAgIEhFQVA4WygocGJ1Zik+PjApXSA9IHR5cGU7XG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgXG4gIGZ1bmN0aW9uIGRvUmVhZHYoc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgcmV0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbKChpb3YpPj4yKV07XG4gICAgICAgIHZhciBsZW4gPSBIRUFQVTMyWygoKGlvdikrKDQpKT4+MildO1xuICAgICAgICBpb3YgKz0gODtcbiAgICAgICAgdmFyIGN1cnIgPSBGUy5yZWFkKHN0cmVhbSwgSEVBUDgscHRyLCBsZW4sIG9mZnNldCk7XG4gICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICByZXQgKz0gY3VycjtcbiAgICAgICAgaWYgKGN1cnIgPCBsZW4pIGJyZWFrOyBcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IGN1cnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gX2ZkX3JlYWQoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgbnVtID0gZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250KTtcbiAgICAgIEhFQVBVMzJbKChwbnVtKT4+MildID0gbnVtO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbiAgfVxuXG4gIFxuICBcbiAgXG4gIFxuICBmdW5jdGlvbiBfZmRfc2VlayhmZCwgIG9mZnNldCwgd2hlbmNlLCBuZXdPZmZzZXQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBvZmZzZXQgPSBiaWdpbnRUb0k1M0NoZWNrZWQob2Zmc2V0KTsgaWYgKGlzTmFOKG9mZnNldCkpIHJldHVybiA2MTtcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgKHRlbXBJNjQgPSBbc3RyZWFtLnBvc2l0aW9uPj4+MCwodGVtcERvdWJsZT1zdHJlYW0ucG9zaXRpb24sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKChuZXdPZmZzZXQpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChuZXdPZmZzZXQpKyg0KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cyAmJiBvZmZzZXQgPT09IDAgJiYgd2hlbmNlID09PSAwKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsOyBcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZmRfc3luYyhmZCkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzICYmIHN0cmVhbS5zdHJlYW1fb3BzLmZzeW5jKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5mc3luYyhzdHJlYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7IFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICBcbiAgZnVuY3Rpb24gZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgcmV0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgdmFyIHB0ciA9IEhFQVBVMzJbKChpb3YpPj4yKV07XG4gICAgICAgIHZhciBsZW4gPSBIRUFQVTMyWygoKGlvdikrKDQpKT4+MildO1xuICAgICAgICBpb3YgKz0gODtcbiAgICAgICAgdmFyIGN1cnIgPSBGUy53cml0ZShzdHJlYW0sIEhFQVA4LHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgcmV0ICs9IGN1cnI7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIF9mZF93cml0ZShmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHZhciBudW0gPSBkb1dyaXRldihzdHJlYW0sIGlvdiwgaW92Y250KTtcbiAgICAgIEhFQVBVMzJbKChwbnVtKT4+MildID0gbnVtO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbiAgfVxuXG4gIHZhciBGU05vZGUgPSAgZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHRoaXM7ICBcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5tb3VudCA9IHBhcmVudC5tb3VudDtcbiAgICB0aGlzLm1vdW50ZWQgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBGUy5uZXh0SW5vZGUrKztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5ub2RlX29wcyA9IHt9O1xuICAgIHRoaXMuc3RyZWFtX29wcyA9IHt9O1xuICAgIHRoaXMucmRldiA9IHJkZXY7XG4gIH07XG4gIHZhciByZWFkTW9kZSA9IDI5MiB8IDczO1xuICB2YXIgd3JpdGVNb2RlID0gMTQ2O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGU05vZGUucHJvdG90eXBlLCB7XG4gICByZWFkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiByZWFkTW9kZSkgPT09IHJlYWRNb2RlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgdmFsID8gdGhpcy5tb2RlIHw9IHJlYWRNb2RlIDogdGhpcy5tb2RlICY9IH5yZWFkTW9kZTtcbiAgICB9XG4gICB9LFxuICAgd3JpdGU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHdyaXRlTW9kZSkgPT09IHdyaXRlTW9kZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgIHZhbCA/IHRoaXMubW9kZSB8PSB3cml0ZU1vZGUgOiB0aGlzLm1vZGUgJj0gfndyaXRlTW9kZTtcbiAgICB9XG4gICB9LFxuICAgaXNGb2xkZXI6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICByZXR1cm4gRlMuaXNEaXIodGhpcy5tb2RlKTtcbiAgICB9XG4gICB9LFxuICAgaXNEZXZpY2U6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICByZXR1cm4gRlMuaXNDaHJkZXYodGhpcy5tb2RlKTtcbiAgICB9XG4gICB9XG4gIH0pO1xuICBGUy5GU05vZGUgPSBGU05vZGU7XG4gIEZTLnN0YXRpY0luaXQoKTs7XG52YXIgQVNTRVJUSU9OUyA9IGZhbHNlO1xuXG52YXIgYXNtTGlicmFyeUFyZyA9IHtcbiAgXCJfX3N5c2NhbGxfY2htb2RcIjogX19fc3lzY2FsbF9jaG1vZCxcbiAgXCJfX3N5c2NhbGxfZmFjY2Vzc2F0XCI6IF9fX3N5c2NhbGxfZmFjY2Vzc2F0LFxuICBcIl9fc3lzY2FsbF9mY2htb2RcIjogX19fc3lzY2FsbF9mY2htb2QsXG4gIFwiX19zeXNjYWxsX2ZjaG93bjMyXCI6IF9fX3N5c2NhbGxfZmNob3duMzIsXG4gIFwiX19zeXNjYWxsX2ZjbnRsNjRcIjogX19fc3lzY2FsbF9mY250bDY0LFxuICBcIl9fc3lzY2FsbF9mc3RhdDY0XCI6IF9fX3N5c2NhbGxfZnN0YXQ2NCxcbiAgXCJfX3N5c2NhbGxfZnRydW5jYXRlNjRcIjogX19fc3lzY2FsbF9mdHJ1bmNhdGU2NCxcbiAgXCJfX3N5c2NhbGxfZ2V0Y3dkXCI6IF9fX3N5c2NhbGxfZ2V0Y3dkLFxuICBcIl9fc3lzY2FsbF9pb2N0bFwiOiBfX19zeXNjYWxsX2lvY3RsLFxuICBcIl9fc3lzY2FsbF9sc3RhdDY0XCI6IF9fX3N5c2NhbGxfbHN0YXQ2NCxcbiAgXCJfX3N5c2NhbGxfbWtkaXJhdFwiOiBfX19zeXNjYWxsX21rZGlyYXQsXG4gIFwiX19zeXNjYWxsX25ld2ZzdGF0YXRcIjogX19fc3lzY2FsbF9uZXdmc3RhdGF0LFxuICBcIl9fc3lzY2FsbF9vcGVuYXRcIjogX19fc3lzY2FsbF9vcGVuYXQsXG4gIFwiX19zeXNjYWxsX3JlYWRsaW5rYXRcIjogX19fc3lzY2FsbF9yZWFkbGlua2F0LFxuICBcIl9fc3lzY2FsbF9ybWRpclwiOiBfX19zeXNjYWxsX3JtZGlyLFxuICBcIl9fc3lzY2FsbF9zdGF0NjRcIjogX19fc3lzY2FsbF9zdGF0NjQsXG4gIFwiX19zeXNjYWxsX3VubGlua2F0XCI6IF9fX3N5c2NhbGxfdW5saW5rYXQsXG4gIFwiX19zeXNjYWxsX3V0aW1lbnNhdFwiOiBfX19zeXNjYWxsX3V0aW1lbnNhdCxcbiAgXCJfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pY1wiOiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMsXG4gIFwiX2xvY2FsdGltZV9qc1wiOiBfX2xvY2FsdGltZV9qcyxcbiAgXCJfbW1hcF9qc1wiOiBfX21tYXBfanMsXG4gIFwiX211bm1hcF9qc1wiOiBfX211bm1hcF9qcyxcbiAgXCJfdHpzZXRfanNcIjogX190enNldF9qcyxcbiAgXCJlbXNjcmlwdGVuX2RhdGVfbm93XCI6IF9lbXNjcmlwdGVuX2RhdGVfbm93LFxuICBcImVtc2NyaXB0ZW5fZ2V0X25vd1wiOiBfZW1zY3JpcHRlbl9nZXRfbm93LFxuICBcImVtc2NyaXB0ZW5fcmVzaXplX2hlYXBcIjogX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsXG4gIFwiZW52aXJvbl9nZXRcIjogX2Vudmlyb25fZ2V0LFxuICBcImVudmlyb25fc2l6ZXNfZ2V0XCI6IF9lbnZpcm9uX3NpemVzX2dldCxcbiAgXCJmZF9jbG9zZVwiOiBfZmRfY2xvc2UsXG4gIFwiZmRfZmRzdGF0X2dldFwiOiBfZmRfZmRzdGF0X2dldCxcbiAgXCJmZF9yZWFkXCI6IF9mZF9yZWFkLFxuICBcImZkX3NlZWtcIjogX2ZkX3NlZWssXG4gIFwiZmRfc3luY1wiOiBfZmRfc3luYyxcbiAgXCJmZF93cml0ZVwiOiBfZmRfd3JpdGUsXG4gIFwibWVtb3J5XCI6IHdhc21NZW1vcnlcbn07XG52YXIgYXNtID0gY3JlYXRlV2FzbSgpO1xuXG52YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gTW9kdWxlW1wiX19fd2FzbV9jYWxsX2N0b3JzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX19fd2FzbV9jYWxsX2N0b3JzID0gTW9kdWxlW1wiX19fd2FzbV9jYWxsX2N0b3JzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiX193YXNtX2NhbGxfY3RvcnNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdGF0dXM2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0YXR1czY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RhdHVzNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19zdGF0dXM2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RhdHVzNjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdGF0dXMgPSBNb2R1bGVbXCJfc3FsaXRlM19zdGF0dXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdGF0dXMgPSBNb2R1bGVbXCJfc3FsaXRlM19zdGF0dXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0YXR1c1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2RiX3N0YXR1cyA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX3N0YXR1c1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2RiX3N0YXR1cyA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX3N0YXR1c1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZGJfc3RhdHVzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfbXNpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19tc2l6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX21zaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfbXNpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX21zaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmZzX2ZpbmQgPSBNb2R1bGVbXCJfc3FsaXRlM192ZnNfZmluZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Zmc19maW5kID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmZzX2ZpbmRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Zmc19maW5kXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2luaXRpYWxpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19pbml0aWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfaW5pdGlhbGl6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfaW5pdGlhbGl6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX21hbGxvYyA9IE1vZHVsZVtcIl9zcWxpdGUzX21hbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX21hbGxvYyA9IE1vZHVsZVtcIl9zcWxpdGUzX21hbGxvY1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfbWFsbG9jXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZnJlZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19mcmVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZnJlZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Zmc19yZWdpc3RlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Zmc19yZWdpc3RlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Zmc19yZWdpc3RlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Zmc19yZWdpc3RlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmZzX3JlZ2lzdGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM192ZnNfdW5yZWdpc3RlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Zmc191bnJlZ2lzdGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Zmc191bnJlZ2lzdGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfbWFsbG9jNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19tYWxsb2M2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX21hbGxvYzY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfbWFsbG9jNjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX21hbGxvYzY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVhbGxvYyA9IE1vZHVsZVtcIl9zcWxpdGUzX3JlYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZWFsbG9jID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVhbGxvY1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVhbGxvY1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3JlYWxsb2M2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3JlYWxsb2M2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3JlYWxsb2M2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3JlYWxsb2M2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVhbGxvYzY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3RleHRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfdGV4dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfdGV4dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3JhbmRvbW5lc3MgPSBNb2R1bGVbXCJfc3FsaXRlM19yYW5kb21uZXNzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmFuZG9tbmVzcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3JhbmRvbW5lc3NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3JhbmRvbW5lc3NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdHJpY21wID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RyaWNtcFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0cmljbXAgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJpY21wXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdHJpY21wXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RybmljbXAgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJuaWNtcFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0cm5pY21wID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RybmljbXBcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0cm5pY21wXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdXJpX3BhcmFtZXRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9wYXJhbWV0ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM191cmlfcGFyYW1ldGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX3BhcmFtZXRlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdXJpX3BhcmFtZXRlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9fX2Vycm5vX2xvY2F0aW9uID0gTW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfX19lcnJub19sb2NhdGlvbiA9IE1vZHVsZVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiX19lcnJub19sb2NhdGlvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3VyaV9ib29sZWFuID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX2Jvb2xlYW5cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM191cmlfYm9vbGVhbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9ib29sZWFuXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM191cmlfYm9vbGVhblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3NlcmlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3NlcmlhbGl6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3NlcmlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3NlcmlhbGl6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc2VyaWFsaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJlcGFyZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXBhcmVfdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmVwYXJlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJlcGFyZV92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJlcGFyZV92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0ZXAgPSBNb2R1bGVbXCJfc3FsaXRlM19zdGVwXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RlcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0ZXBcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0ZXBcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5faW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5faW50NjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5faW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5faW50NjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl9pbnQ2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzZXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXNldCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc2V0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXNldFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2V4ZWMgPSBNb2R1bGVbXCJfc3FsaXRlM19leGVjXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXhlYyA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4ZWNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2V4ZWNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5faW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2ludFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5faW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5faW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZmluYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19maW5hbGl6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2ZpbmFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfZmluYWxpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2ZpbmFsaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZmlsZV9jb250cm9sID0gTW9kdWxlW1wiX3NxbGl0ZTNfZmlsZV9jb250cm9sXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZmlsZV9jb250cm9sID0gTW9kdWxlW1wiX3NxbGl0ZTNfZmlsZV9jb250cm9sXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19maWxlX2NvbnRyb2xcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9uYW1lXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX25hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fbmFtZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX25hbWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl90ZXh0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fdGV4dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX3RleHRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fdHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl90eXBlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX3R5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fdHlwZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX3R5cGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19lcnJtc2cgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJtc2dcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19lcnJtc2cgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJtc2dcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2Vycm1zZ1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2Rlc2VyaWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGVzZXJpYWxpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kZXNlcmlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2Rlc2VyaWFsaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kZXNlcmlhbGl6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jbGVhcl9iaW5kaW5ncyA9IE1vZHVsZVtcIl9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jbGVhcl9iaW5kaW5nc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9ibG9iXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2Jsb2JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2Jsb2JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9ieXRlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2J5dGVzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfYnl0ZXMgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9ieXRlc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfYnl0ZXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9kb3VibGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9kb3VibGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2RvdWJsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2ludFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2ludFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfaW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9pbnQ2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfaW50NjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2ludDY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfc3VidHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3N1YnR5cGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9zdWJ0eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfc3VidHlwZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfc3VidHlwZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX3BvaW50ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9wb2ludGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfcG9pbnRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3BvaW50ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX3BvaW50ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV90eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfdHlwZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX3R5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV90eXBlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV90eXBlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2UgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9ub2NoYW5nZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX25vY2hhbmdlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2VcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX25vY2hhbmdlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9mcm9tYmluZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2Zyb21iaW5kID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2Zyb21iaW5kXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfZHVwID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZHVwXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfZHVwID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZHVwXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9kdXBcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9mcmVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZnJlZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2ZyZWUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9mcmVlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9mcmVlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfYmxvYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Jsb2JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9ibG9iXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZ1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZ1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9kb3VibGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2RvdWJsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9lcnJvciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9lcnJvciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9pbnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfaW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2ludFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2ludFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9pbnQ2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9pbnQ2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2ludDY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X251bGwgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfbnVsbFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9udWxsID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X251bGxcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9udWxsXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfcG9pbnRlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9wb2ludGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9wb2ludGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfc3VidHlwZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfdGV4dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3RleHRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF90ZXh0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfemVyb2Jsb2JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM191c2VyX2RhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM191c2VyX2RhdGFcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM191c2VyX2RhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM191c2VyX2RhdGFcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3VzZXJfZGF0YVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfbm9jaGFuZ2UgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX25vY2hhbmdlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfbm9jaGFuZ2VcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfbm9jaGFuZ2VcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX2luX2ZpcnN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9pbl9maXJzdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfaW5fZmlyc3QgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2luX2ZpcnN0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX2luX2ZpcnN0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9pbl9uZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9pbl9uZXh0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9pbl9uZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9pbl9uZXh0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX2luX25leHRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19nZXRfYXV4ZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX2dldF9hdXhkYXRhXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZ2V0X2F1eGRhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM19nZXRfYXV4ZGF0YVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZ2V0X2F1eGRhdGFcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zZXRfYXV4ZGF0YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3NldF9hdXhkYXRhXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc2V0X2F1eGRhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXRfYXV4ZGF0YVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc2V0X2F1eGRhdGFcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fY291bnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fY291bnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl9jb3VudFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2RhdGFfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19kYXRhX2NvdW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZGF0YV9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2RhdGFfY291bnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2RhdGFfY291bnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9ibG9iXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fYmxvYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX2Jsb2JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fYnl0ZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fYnl0ZXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fYnl0ZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fYnl0ZXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl9ieXRlc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbHVtbl9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fZG91YmxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9kb3VibGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl9kb3VibGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fdmFsdWUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fdmFsdWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5fdmFsdWUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fdmFsdWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl92YWx1ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfYmxvYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfYmxvYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9ibG9iXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2RvdWJsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9kb3VibGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfZG91YmxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2ludFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfaW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9pbnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfaW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfaW50NjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9pbnQ2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9pbnQ2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfbnVsbCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfbnVsbFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfbnVsbCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfbnVsbFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9udWxsXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF9wb2ludGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9wb2ludGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9wb2ludGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9wb2ludGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX3BvaW50ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3RleHRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3RleHRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfdGV4dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXhcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2RiX2hhbmRsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX2hhbmRsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2RiX2hhbmRsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX2hhbmRsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZGJfaGFuZGxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RtdF9yZWFkb25seSA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0bXRfcmVhZG9ubHlcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdG10X3JlYWRvbmx5ID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RtdF9yZWFkb25seVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RtdF9yZWFkb25seVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0bXRfaXNleHBsYWluID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RtdF9pc2V4cGxhaW5cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdG10X2lzZXhwbGFpbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0bXRfaXNleHBsYWluXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdG10X2lzZXhwbGFpblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0bXRfc3RhdHVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RtdF9zdGF0dXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdG10X3N0YXR1cyA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0bXRfc3RhdHVzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdG10X3N0YXR1c1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3NxbCA9IE1vZHVsZVtcIl9zcWxpdGUzX3NxbFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3NxbCA9IE1vZHVsZVtcIl9zcWxpdGUzX3NxbFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3FsXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXhwYW5kZWRfc3FsID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXhwYW5kZWRfc3FsXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXhwYW5kZWRfc3FsID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXhwYW5kZWRfc3FsXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19leHBhbmRlZF9zcWxcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmV1cGRhdGVfb2xkID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX29sZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9vbGQgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfb2xkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmV1cGRhdGVfb2xkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2NvdW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2NvdW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmV1cGRhdGVfY291bnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmV1cGRhdGVfZGVwdGggPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfZGVwdGhcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfZGVwdGggPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfZGVwdGhcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmV1cGRhdGVfbmV3ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX25ld1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9uZXcgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfbmV3XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmV1cGRhdGVfbmV3XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9udW1lcmljX3R5cGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zZXRfYXV0aG9yaXplciA9IE1vZHVsZVtcIl9zcWxpdGUzX3NldF9hdXRob3JpemVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXRfYXV0aG9yaXplclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc2V0X2F1dGhvcml6ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdHJnbG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RyZ2xvYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0cmdsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJnbG9iXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdHJnbG9iXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RybGlrZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cmxpa2VcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdHJsaWtlID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RybGlrZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RybGlrZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfYXV0b19leHRlbnNpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19hdXRvX2V4dGVuc2lvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJlcGFyZV92MyA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXBhcmVfdjNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmVwYXJlX3YzID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJlcGFyZV92M1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJlcGFyZV92M1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfbW9kdWxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX21vZHVsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NyZWF0ZV9tb2R1bGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZHJvcF9tb2R1bGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfZHJvcF9tb2R1bGVzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZHJvcF9tb2R1bGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfZHJvcF9tb2R1bGVzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kcm9wX21vZHVsZXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kZWNsYXJlX3Z0YWIgPSBNb2R1bGVbXCJfc3FsaXRlM19kZWNsYXJlX3Z0YWJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kZWNsYXJlX3Z0YWIgPSBNb2R1bGVbXCJfc3FsaXRlM19kZWNsYXJlX3Z0YWJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2RlY2xhcmVfdnRhYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfb25fY29uZmxpY3RcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3RcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX2NvbGxhdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24gPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2NvbGxhdGlvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9jb2xsYXRpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX2luID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9pblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfaW4gPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2luXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX2luXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWUgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX3Joc192YWx1ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9kaXN0aW5jdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfZGlzdGluY3RcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX2Rpc3RpbmN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9kaXN0aW5jdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9kaXN0aW5jdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2tleXdvcmRfbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2tleXdvcmRfbmFtZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2tleXdvcmRfbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2tleXdvcmRfbmFtZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfa2V5d29yZF9uYW1lXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2tleXdvcmRfY291bnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19rZXl3b3JkX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfa2V5d29yZF9jb3VudFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfa2V5d29yZF9jb3VudFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2tleXdvcmRfY2hlY2sgPSBNb2R1bGVbXCJfc3FsaXRlM19rZXl3b3JkX2NoZWNrXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfa2V5d29yZF9jaGVjayA9IE1vZHVsZVtcIl9zcWxpdGUzX2tleXdvcmRfY2hlY2tcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2tleXdvcmRfY2hlY2tcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb21wbGV0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbXBsZXRlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29tcGxldGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21wbGV0ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29tcGxldGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19saWJ2ZXJzaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGlidmVyc2lvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2xpYnZlcnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19saWJ2ZXJzaW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19saWJ2ZXJzaW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc2h1dGRvd24gPSBNb2R1bGVbXCJfc3FsaXRlM19zaHV0ZG93blwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3NodXRkb3duID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2h1dGRvd25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3NodXRkb3duXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWQgPSBNb2R1bGVbXCJfc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jaGFuZ2VzNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19jaGFuZ2VzNjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jaGFuZ2VzNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19jaGFuZ2VzNjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NoYW5nZXM2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NoYW5nZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19jaGFuZ2VzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY2hhbmdlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2NoYW5nZXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NoYW5nZXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjQgPSBNb2R1bGVbXCJfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjQgPSBNb2R1bGVbXCJfc3FsaXRlM190b3RhbF9jaGFuZ2VzNjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3RvdGFsX2NoYW5nZXM2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3RvdGFsX2NoYW5nZXMgPSBNb2R1bGVbXCJfc3FsaXRlM190b3RhbF9jaGFuZ2VzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdG90YWxfY2hhbmdlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3RvdGFsX2NoYW5nZXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3RvdGFsX2NoYW5nZXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM190eG5fc3RhdGUgPSBNb2R1bGVbXCJfc3FsaXRlM190eG5fc3RhdGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM190eG5fc3RhdGUgPSBNb2R1bGVbXCJfc3FsaXRlM190eG5fc3RhdGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3R4bl9zdGF0ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2Nsb3NlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2xvc2VfdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jbG9zZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2Nsb3NlX3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jbG9zZV92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2J1c3lfaGFuZGxlciA9IE1vZHVsZVtcIl9zcWxpdGUzX2J1c3lfaGFuZGxlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2J1c3lfaGFuZGxlciA9IE1vZHVsZVtcIl9zcWxpdGUzX2J1c3lfaGFuZGxlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYnVzeV9oYW5kbGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2J1c3lfdGltZW91dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2J1c3lfdGltZW91dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2J1c3lfdGltZW91dCA9IE1vZHVsZVtcIl9zcWxpdGUzX2J1c3lfdGltZW91dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYnVzeV90aW1lb3V0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jcmVhdGVfZnVuY3Rpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM190cmFjZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX3RyYWNlX3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdHJhY2VfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM190cmFjZV92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdHJhY2VfdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb21taXRfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbW1pdF9ob29rXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29tbWl0X2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21taXRfaG9va1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29tbWl0X2hvb2tcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM191cGRhdGVfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX3VwZGF0ZV9ob29rXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdXBkYXRlX2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM191cGRhdGVfaG9va1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdXBkYXRlX2hvb2tcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yb2xsYmFja19ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfcm9sbGJhY2tfaG9va1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3JvbGxiYWNrX2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM19yb2xsYmFja19ob29rXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yb2xsYmFja19ob29rXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfaG9va1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2tcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXVwZGF0ZV9ob29rXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXJyb3Jfb2Zmc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJyb3Jfb2Zmc2V0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXJyb3Jfb2Zmc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJyb3Jfb2Zmc2V0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19lcnJvcl9vZmZzZXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19lcnJjb2RlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJyY29kZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2VycmNvZGUgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJjb2RlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19lcnJjb2RlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4dGVuZGVkX2VycmNvZGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2VycnN0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX2VycnN0clwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2VycnN0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX2VycnN0clwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXJyc3RyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfbGltaXQgPSBNb2R1bGVbXCJfc3FsaXRlM19saW1pdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2xpbWl0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGltaXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2xpbWl0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfb3BlbiA9IE1vZHVsZVtcIl9zcWxpdGUzX29wZW5cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19vcGVuID0gTW9kdWxlW1wiX3NxbGl0ZTNfb3BlblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfb3BlblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX29wZW5fdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19vcGVuX3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfb3Blbl92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX29wZW5fdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX29wZW5fdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jcmVhdGVfY29sbGF0aW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19nZXRfYXV0b2NvbW1pdCA9IE1vZHVsZVtcIl9zcWxpdGUzX2dldF9hdXRvY29tbWl0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQgPSBNb2R1bGVbXCJfc3FsaXRlM19nZXRfYXV0b2NvbW1pdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZ2V0X2F1dG9jb21taXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGFcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGFcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3RhYmxlX2NvbHVtbl9tZXRhZGF0YVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2Rlc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2RlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2Rlc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdXJpX2tleSA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9rZXlcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM191cmlfa2V5ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXJpX2tleVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdXJpX2tleVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3VyaV9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9pbnQ2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3VyaV9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9pbnQ2NFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdXJpX2ludDY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZGJfbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX25hbWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kYl9uYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfbmFtZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZGJfbmFtZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2RiX2ZpbGVuYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGJfZmlsZW5hbWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kYl9maWxlbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX2ZpbGVuYW1lXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kYl9maWxlbmFtZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21waWxlb3B0aW9uX2dldFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2RpZmYgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fZGlmZlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9kaWZmID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2RpZmZcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9kaWZmXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2F0dGFjaCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9hdHRhY2hcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fYXR0YWNoID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2F0dGFjaFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2F0dGFjaFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9jcmVhdGUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY3JlYXRlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jcmVhdGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9jcmVhdGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fZGVsZXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9kZWxldGUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fZGVsZXRlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fZGVsZXRlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlciA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9lbmFibGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fZW5hYmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2VuYWJsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2luZGlyZWN0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHkgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25faXNlbXB0eVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHlcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9pc2VtcHR5XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZyA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZ1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9zdGFydFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9zdGFydF92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X25leHRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9uZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfbmV4dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X29wID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfb3BcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9vcCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X29wXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9vcFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X3BrID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfcGtcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9wayA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3BrXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9wa1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X29sZCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X29sZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X29sZCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X29sZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfb2xkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfbmV3ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfbmV3XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfbmV3ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfbmV3XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9uZXdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3RcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHMgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHMgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2ZrX2NvbmZsaWN0c1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ludmVydFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ludmVydFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2FwcGx5XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX25ldyA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX25ld1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2Vncm91cF9uZXdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2Vncm91cF9hZGRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2NvbmZpZyA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jb25maWdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fY29uZmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NvbmZpZ1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2NvbmZpZ1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3NvdXJjZWlkID0gTW9kdWxlW1wiX3NxbGl0ZTNfc291cmNlaWRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zb3VyY2VpZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3NvdXJjZWlkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zb3VyY2VpZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3B0clwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcHN0YWNrX3B0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3B0clwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9wc3RhY2tfcHRyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3BzdGFja19hbGxvY1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZ1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZ1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9wc3RhY2tfcmVtYWluaW5nXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGEgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19xdW90YVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGFcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl9lcnJvciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfZXJyb3JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX2Vycm9yID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9lcnJvclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl9lcnJvclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9zdHJ1Y3QgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cnVjdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9zdHJ1Y3RcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9zdHJ1Y3RcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2VudW1fanNvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZW51bV9qc29uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24gPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2VudW1fanNvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9lbnVtX2pzb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Zmc191bmxpbmsgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Zmc191bmxpbmtcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Zmc191bmxpbmsgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Zmc191bmxpbmtcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdmZzX3VubGlua1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfdmZzID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl92ZnNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX3ZmcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfdmZzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX3Zmc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfcmVzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX3Jlc2V0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9yZXNldCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfcmVzZXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfcmVzZXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX2V4cG9ydF9jaHVua2VkID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfZXhwb3J0X2NodW5rZWQgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2V4cG9ydF9jaHVua2VkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX2V4cG9ydF9jaHVua2VkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2sgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFjayA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2tcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2tcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHMgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHMgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdnRhYl9jb25maWcgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Z0YWJfY29uZmlnXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdnRhYl9jb25maWdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdnRhYl9jb25maWdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfaXAgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl9jb25maWdfaXBcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19waWkgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19waWlcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19waWkgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19waWlcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3MgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19zXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfY29uZmlnX3NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2NvbmZpZ19pID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9jb25maWdfaVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fY29uZmlnX2kgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2NvbmZpZ19pXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2NvbmZpZ19pXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9jb25maWdfaWkgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2NvbmZpZ19paVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fY29uZmlnX2lpID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9jb25maWdfaWlcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fY29uZmlnX2lpXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9jb25maWdfaiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fY29uZmlnX2pcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2NvbmZpZ19qID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9jb25maWdfalwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9jb25maWdfalwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21faW5pdF93YXNtZnMgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2luaXRfd2FzbWZzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9pbml0X3dhc21mcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21faW5pdF93YXNtZnNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21faW5pdF93YXNtZnNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50cHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0clwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9pbnRwdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50cHRyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3RfaW50cHRyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X3ZvaWRwdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0clwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3ZvaWRwdHJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9tYXhcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWF4ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW4gPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfdGltZXMyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X3RpbWVzMlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfdGltZXMyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3RfaW50NjRfdGltZXMyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5tYXhcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWlubWF4ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NHB0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NHB0clwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NHB0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NHB0clwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X2ludDY0cHRyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3Rfc3RhY2tfb3ZlcmZsb3dcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3Rfc3RyX2hlbGxvID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsb1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9zdHJfaGVsbG8gPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfc3RyX2hlbGxvXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3Rfc3RyX2hlbGxvXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fU1FMVGVzdGVyX3N0cmdsb2JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX21hbGxvYyA9IE1vZHVsZVtcIl9tYWxsb2NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJtYWxsb2NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfZnJlZSA9IE1vZHVsZVtcIl9mcmVlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX2ZyZWUgPSBNb2R1bGVbXCJfZnJlZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcImZyZWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfcmVhbGxvYyA9IE1vZHVsZVtcIl9yZWFsbG9jXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3JlYWxsb2MgPSBNb2R1bGVbXCJfcmVhbGxvY1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInJlYWxsb2NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ24gPSBNb2R1bGVbXCJfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgc3RhY2tTYXZlID0gTW9kdWxlW1wic3RhY2tTYXZlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoc3RhY2tTYXZlID0gTW9kdWxlW1wic3RhY2tTYXZlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3RhY2tTYXZlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgc3RhY2tSZXN0b3JlID0gTW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoc3RhY2tSZXN0b3JlID0gTW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3RhY2tSZXN0b3JlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgc3RhY2tBbGxvYyA9IE1vZHVsZVtcInN0YWNrQWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChzdGFja0FsbG9jID0gTW9kdWxlW1wic3RhY2tBbGxvY1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInN0YWNrQWxsb2NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cblxuXG5cblxuXG5Nb2R1bGVbXCJ3YXNtTWVtb3J5XCJdID0gd2FzbU1lbW9yeTtcblxuXG52YXIgY2FsbGVkUnVuO1xuXG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gIFxuICBpZiAoIWNhbGxlZFJ1bikgcnVuKCk7XG4gIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7IFxufTtcblxuXG5mdW5jdGlvbiBydW4oYXJncykge1xuICBhcmdzID0gYXJncyB8fCBhcmd1bWVudHNfO1xuXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJlUnVuKCk7XG5cbiAgXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgXG4gICAgXG4gICAgaWYgKGNhbGxlZFJ1bikgcmV0dXJuO1xuICAgIGNhbGxlZFJ1biA9IHRydWU7XG4gICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICBpZiAoQUJPUlQpIHJldHVybjtcblxuICAgIGluaXRSdW50aW1lKCk7XG5cbiAgICByZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7XG4gICAgaWYgKE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSkgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKCk7XG5cbiAgICBwb3N0UnVuKCk7XG4gIH1cblxuICBpZiAoTW9kdWxlWydzZXRTdGF0dXMnXSkge1xuICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJ1J1bm5pbmcuLi4nKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnJyk7XG4gICAgICB9LCAxKTtcbiAgICAgIGRvUnVuKCk7XG4gICAgfSwgMSk7XG4gIH0gZWxzZVxuICB7XG4gICAgZG9SdW4oKTtcbiAgfVxufVxuXG5pZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07XG4gIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7XG4gICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTtcbiAgfVxufVxuXG5ydW4oKTtcblxuXG5cblxuXG5pZighTW9kdWxlLnBvc3RSdW4pIE1vZHVsZS5wb3N0UnVuID0gW107XG5Nb2R1bGUucG9zdFJ1bi5wdXNoKGZ1bmN0aW9uKE1vZHVsZSl7XG4gICd1c2Ugc3RyaWN0JztcbiAgXG5cblxuXG5cblxuXG5cblxuXG5cbid1c2Ugc3RyaWN0Jztcbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcCA9IGZ1bmN0aW9uIHNxbGl0ZTNBcGlCb290c3RyYXAoXG4gIGFwaUNvbmZpZyA9IChnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgfHwgc3FsaXRlM0FwaUJvb3RzdHJhcC5kZWZhdWx0Q29uZmlnKVxuKXtcbiAgaWYoc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzKXsgXG4gICAgY29uc29sZS53YXJuKFwic3FsaXRlM0FwaUJvb3RzdHJhcCgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cIixcbiAgICAgICAgICAgICAgICAgXCJDb25maWcgYW5kIGV4dGVybmFsIGluaXRpYWxpemVycyBhcmUgaWdub3JlZCBvbiBjYWxscyBhZnRlciB0aGUgZmlyc3QuXCIpO1xuICAgIHJldHVybiBzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTM7XG4gIH1cbiAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICBleHBvcnRzOiB1bmRlZmluZWQsXG4gICAgbWVtb3J5OiB1bmRlZmluZWQsXG4gICAgYmlnSW50RW5hYmxlZDogKCgpPT57XG4gICAgICBpZigndW5kZWZpbmVkJyE9PXR5cGVvZiBNb2R1bGUpe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuICEhTW9kdWxlLkhFQVBVNjQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFnbG9iYWxUaGlzLkJpZ0ludDY0QXJyYXk7XG4gICAgfSkoKSxcbiAgICBkZWJ1ZzogY29uc29sZS5kZWJ1Zy5iaW5kKGNvbnNvbGUpLFxuICAgIHdhcm46IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpLFxuICAgIGVycm9yOiBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksXG4gICAgbG9nOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgIHdhc21mc09wZnNEaXI6ICcvb3BmcycsXG4gICAgXG4gICAgdXNlU3RkQWxsb2M6IGZhbHNlXG4gIH0sIGFwaUNvbmZpZyB8fCB7fSk7XG5cbiAgT2JqZWN0LmFzc2lnbihjb25maWcsIHtcbiAgICBhbGxvY0V4cG9ydE5hbWU6IGNvbmZpZy51c2VTdGRBbGxvYyA/ICdtYWxsb2MnIDogJ3NxbGl0ZTNfbWFsbG9jJyxcbiAgICBkZWFsbG9jRXhwb3J0TmFtZTogY29uZmlnLnVzZVN0ZEFsbG9jID8gJ2ZyZWUnIDogJ3NxbGl0ZTNfZnJlZScsXG4gICAgcmVhbGxvY0V4cG9ydE5hbWU6IGNvbmZpZy51c2VTdGRBbGxvYyA/ICdyZWFsbG9jJyA6ICdzcWxpdGUzX3JlYWxsb2MnXG4gIH0sIGNvbmZpZyk7XG5cbiAgW1xuICAgIFxuICAgIFxuICAgICdleHBvcnRzJywgJ21lbW9yeScsICd3YXNtZnNPcGZzRGlyJ1xuICBdLmZvckVhY2goKGspPT57XG4gICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbmZpZ1trXSl7XG4gICAgICBjb25maWdba10gPSBjb25maWdba10oKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgY29uc3QgY2FwaSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIFxuICBjb25zdCB3YXNtID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBcbiAgY29uc3QgX19yY1N0ciA9IChyYyk9PntcbiAgICByZXR1cm4gKGNhcGkuc3FsaXRlM19qc19yY19zdHIgJiYgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYykpXG4gICAgICAgICAgIHx8IChcIlVua25vd24gcmVzdWx0IGNvZGUgI1wiK3JjKTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19pc0ludCA9IChuKT0+J251bWJlcic9PT10eXBlb2YgbiAmJiBuPT09KG4gfCAwKTtcblxuICBcbiAgY2xhc3MgU1FMaXRlM0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgbGV0IHJjO1xuICAgICAgaWYoYXJncy5sZW5ndGgpe1xuICAgICAgICBpZihfX2lzSW50KGFyZ3NbMF0pKXtcbiAgICAgICAgICByYyA9IGFyZ3NbMF07XG4gICAgICAgICAgaWYoMT09PWFyZ3MubGVuZ3RoKXtcbiAgICAgICAgICAgIHN1cGVyKF9fcmNTdHIoYXJnc1swXSkpO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc3QgcmNTdHIgPSBfX3JjU3RyKHJjKTtcbiAgICAgICAgICAgIGlmKCdvYmplY3QnPT09dHlwZW9mIGFyZ3NbMV0pe1xuICAgICAgICAgICAgICBzdXBlcihyY1N0cixhcmdzWzFdKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBhcmdzWzBdID0gcmNTdHIrJzonO1xuICAgICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBpZigyPT09YXJncy5sZW5ndGggJiYgJ29iamVjdCc9PT10eXBlb2YgYXJnc1sxXSl7XG4gICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHN1cGVyKGFyZ3Muam9pbignICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0Q29kZSA9IHJjIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgdGhpcy5uYW1lID0gJ1NRTGl0ZTNFcnJvcic7XG4gICAgfVxuICB9O1xuXG4gIFxuICBTUUxpdGUzRXJyb3IudG9zcyA9ICguLi5hcmdzKT0+e1xuICAgIHRocm93IG5ldyBTUUxpdGUzRXJyb3IoLi4uYXJncyk7XG4gIH07XG4gIGNvbnN0IHRvc3MzID0gU1FMaXRlM0Vycm9yLnRvc3M7XG5cbiAgaWYoY29uZmlnLndhc21mc09wZnNEaXIgJiYgIS9eXFwvW14vXSskLy50ZXN0KGNvbmZpZy53YXNtZnNPcGZzRGlyKSl7XG4gICAgdG9zczMoXCJjb25maWcud2FzbWZzT3Bmc0RpciBtdXN0IGJlIGZhbHN5IG9yIGluIHRoZSBmb3JtICcvZGlyLW5hbWUnLlwiKTtcbiAgfVxuXG4gIFxuICBjb25zdCBpc0ludDMyID0gKG4pPT57XG4gICAgcmV0dXJuICgnYmlnaW50JyE9PXR5cGVvZiBuIClcbiAgICAgICYmICEhKG49PT0obnwwKSAmJiBuPD0yMTQ3NDgzNjQ3ICYmIG4+PS0yMTQ3NDgzNjQ4KTtcbiAgfTtcbiAgXG4gIGNvbnN0IGJpZ0ludEZpdHM2NCA9IGZ1bmN0aW9uIGYoYil7XG4gICAgaWYoIWYuX21heCl7XG4gICAgICBmLl9tYXggPSBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZcIik7XG4gICAgICBmLl9taW4gPSB+Zi5fbWF4O1xuICAgIH1cbiAgICByZXR1cm4gYiA+PSBmLl9taW4gJiYgYiA8PSBmLl9tYXg7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGJpZ0ludEZpdHMzMiA9IChiKT0+KGIgPj0gKC0weDdmZmZmZmZmbiAtIDFuKSAmJiBiIDw9IDB4N2ZmZmZmZmZuKTtcblxuICBcbiAgY29uc3QgYmlnSW50Rml0c0RvdWJsZSA9IGZ1bmN0aW9uIGYoYil7XG4gICAgaWYoIWYuX21pbil7XG4gICAgICBmLl9taW4gPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgIGYuX21heCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgICByZXR1cm4gYiA+PSBmLl9taW4gJiYgYiA8PSBmLl9tYXg7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGlzVHlwZWRBcnJheSA9ICh2KT0+e1xuICAgIHJldHVybiAodiAmJiB2LmNvbnN0cnVjdG9yICYmIGlzSW50MzIodi5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVCkpID8gdiA6IGZhbHNlO1xuICB9O1xuXG5cbiAgXG4gIGNvbnN0IF9fU0FCID0gKCd1bmRlZmluZWQnPT09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKVxuICAgICAgICA/IGZ1bmN0aW9uKCl7fSA6IFNoYXJlZEFycmF5QnVmZmVyO1xuICBcbiAgY29uc3QgaXNTaGFyZWRUeXBlZEFycmF5ID0gKGFUeXBlZEFycmF5KT0+KGFUeXBlZEFycmF5LmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCKTtcblxuICBcbiAgY29uc3QgdHlwZWRBcnJheVBhcnQgPSAoYVR5cGVkQXJyYXksIGJlZ2luLCBlbmQpPT57XG4gICAgcmV0dXJuIGlzU2hhcmVkVHlwZWRBcnJheShhVHlwZWRBcnJheSlcbiAgICAgID8gYVR5cGVkQXJyYXkuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgIDogYVR5cGVkQXJyYXkuc3ViYXJyYXkoYmVnaW4sIGVuZCk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGlzQmluZGFibGVUeXBlZEFycmF5ID0gKHYpPT57XG4gICAgcmV0dXJuIHYgJiYgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgICAgICAgIHx8IHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgfHwgdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfTtcblxuICBcbiAgY29uc3QgaXNTUUxhYmxlVHlwZWRBcnJheSA9ICh2KT0+e1xuICAgIHJldHVybiB2ICYmICh2IGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICAgICAgICAgICB8fCB2IGluc3RhbmNlb2YgSW50OEFycmF5XG4gICAgICAgICAgICAgICAgIHx8IHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGFmZmlybUJpbmRhYmxlVHlwZWRBcnJheSA9ICh2KT0+e1xuICAgIHJldHVybiBpc0JpbmRhYmxlVHlwZWRBcnJheSh2KVxuICAgICAgfHwgdG9zczMoXCJWYWx1ZSBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgVHlwZWRBcnJheSB0eXBlLlwiKTtcbiAgfTtcblxuICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcblxuICBcbiAgY29uc3QgdHlwZWRBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24odHlwZWRBcnJheSwgYmVnaW4sIGVuZCl7XG4gICAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZSh0eXBlZEFycmF5UGFydCh0eXBlZEFycmF5LCBiZWdpbixlbmQpKTtcbiAgfTtcblxuICBcbiAgY29uc3QgZmxleGlibGVTdHJpbmcgPSBmdW5jdGlvbih2KXtcbiAgICBpZihpc1NRTGFibGVUeXBlZEFycmF5KHYpKXtcbiAgICAgIHJldHVybiB0eXBlZEFycmF5VG9TdHJpbmcoXG4gICAgICAgICh2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpID8gbmV3IFVpbnQ4QXJyYXkodikgOiB2XG4gICAgICApO1xuICAgIH1cbiAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkodikpIHJldHVybiB2LmpvaW4oXCJcIik7XG4gICAgZWxzZSBpZih3YXNtLmlzUHRyKHYpKSB2ID0gd2FzbS5jc3RyVG9Kcyh2KTtcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBcbiAgY2xhc3MgV2FzbUFsbG9jRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgXG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICBpZigyPT09YXJncy5sZW5ndGggJiYgJ29iamVjdCc9PT10eXBlb2YgYXJnc1sxXSl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgfWVsc2UgaWYoYXJncy5sZW5ndGgpe1xuICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgc3VwZXIoXCJBbGxvY2F0aW9uIGZhaWxlZC5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdENvZGUgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgIHRoaXMubmFtZSA9ICdXYXNtQWxsb2NFcnJvcic7XG4gICAgfVxuICB9O1xuICBcbiAgV2FzbUFsbG9jRXJyb3IudG9zcyA9ICguLi5hcmdzKT0+e1xuICAgIHRocm93IG5ldyBXYXNtQWxsb2NFcnJvciguLi5hcmdzKTtcbiAgfTtcblxuICBPYmplY3QuYXNzaWduKGNhcGksIHtcbiAgICBcbiAgICBzcWxpdGUzX2JpbmRfYmxvYjogdW5kZWZpbmVkLFxuXG4gICAgXG4gICAgc3FsaXRlM19iaW5kX3RleHQ6IHVuZGVmaW5lZCxcblxuICAgIFxuICAgIHNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyOiAoXG4gICAgICBwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCwgcEFwcCxcbiAgICAgIHhGdW5jLCB4U3RlcCwgeEZpbmFsLCB4RGVzdHJveVxuICAgICk9Pnt9LFxuICAgIFxuICAgIHNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uOiAoXG4gICAgICBwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCwgcEFwcCxcbiAgICAgIHhGdW5jLCB4U3RlcCwgeEZpbmFsXG4gICAgKT0+e30sXG4gICAgXG4gICAgc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uOiAoXG4gICAgICBwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCwgcEFwcCxcbiAgICAgIHhTdGVwLCB4RmluYWwsIHhWYWx1ZSwgeEludmVyc2UsIHhEZXN0cm95XG4gICAgKT0+e30sXG4gICAgXG4gICAgc3FsaXRlM19wcmVwYXJlX3YzOiAoZGJQdHIsIHNxbCwgc3FsQnl0ZUxlbiwgcHJlcEZsYWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHN0bXRQdHJQdHIsIHN0clB0clB0cik9Pnt9LFxuXG4gICAgXG4gICAgc3FsaXRlM19wcmVwYXJlX3YyOiAoZGJQdHIsIHNxbCwgc3FsQnl0ZUxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICBzdG10UHRyUHRyLHN0clB0clB0cik9Pnt9LFxuXG4gICAgXG4gICAgc3FsaXRlM19leGVjOiAocERiLCBzcWwsIGNhbGxiYWNrLCBwVm9pZCwgcEVyck1zZyk9Pnt9LFxuXG4gICAgXG4gICAgc3FsaXRlM19yYW5kb21uZXNzOiAobiwgb3V0UHRyKT0+e30sXG4gIH0pO1xuXG4gIFxuICBjb25zdCB1dGlsID0ge1xuICAgIGFmZmlybUJpbmRhYmxlVHlwZWRBcnJheSwgZmxleGlibGVTdHJpbmcsXG4gICAgYmlnSW50Rml0czMyLCBiaWdJbnRGaXRzNjQsIGJpZ0ludEZpdHNEb3VibGUsXG4gICAgaXNCaW5kYWJsZVR5cGVkQXJyYXksXG4gICAgaXNJbnQzMiwgaXNTUUxhYmxlVHlwZWRBcnJheSwgaXNUeXBlZEFycmF5LFxuICAgIHR5cGVkQXJyYXlUb1N0cmluZyxcbiAgICBpc1VJVGhyZWFkOiAoKT0+KGdsb2JhbFRoaXMud2luZG93PT09Z2xvYmFsVGhpcyAmJiAhIWdsb2JhbFRoaXMuZG9jdW1lbnQpLFxuICAgIFxuICAgIGlzU2hhcmVkVHlwZWRBcnJheSxcbiAgICB0b3NzOiBmdW5jdGlvbiguLi5hcmdzKXt0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpfSxcbiAgICB0b3NzMyxcbiAgICB0eXBlZEFycmF5UGFydCxcbiAgICBcbiAgICBhZmZpcm1EYkhlYWRlcjogZnVuY3Rpb24oYnl0ZXMpe1xuICAgICAgaWYoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICBjb25zdCBoZWFkZXIgPSBcIlNRTGl0ZSBmb3JtYXQgM1wiO1xuICAgICAgaWYoIGhlYWRlci5sZW5ndGggPiBieXRlcy5ieXRlTGVuZ3RoICl7XG4gICAgICAgIHRvc3MzKFwiSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci5cIik7XG4gICAgICB9XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaWYoIGhlYWRlci5jaGFyQ29kZUF0KGkpICE9PSBieXRlc1tpXSApe1xuICAgICAgICAgIHRvc3MzKFwiSW5wdXQgZG9lcyBub3QgY29udGFpbiBhbiBTUUxpdGUzIGRhdGFiYXNlIGhlYWRlci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGFmZmlybUlzRGI6IGZ1bmN0aW9uKGJ5dGVzKXtcbiAgICAgIGlmKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgY29uc3QgbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICBpZihuPDUxMiB8fCBuJTUxMiE9PTApIHtcbiAgICAgICAgdG9zczMoXCJCeXRlIGFycmF5IHNpemVcIixuLFwiaXMgaW52YWxpZCBmb3IgYW4gU1FMaXRlMyBkYi5cIik7XG4gICAgICB9XG4gICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGJ5dGVzKTtcbiAgICB9XG4gIH07XG5cbiAgT2JqZWN0LmFzc2lnbih3YXNtLCB7XG4gICAgXG4gICAgcHRyU2l6ZW9mOiBjb25maWcud2FzbVB0clNpemVvZiB8fCA0LFxuICAgIFxuICAgIHB0cklSOiBjb25maWcud2FzbVB0cklSIHx8IFwiaTMyXCIsXG4gICAgXG4gICAgYmlnSW50RW5hYmxlZDogISFjb25maWcuYmlnSW50RW5hYmxlZCxcbiAgICBcbiAgICBleHBvcnRzOiBjb25maWcuZXhwb3J0c1xuICAgICAgfHwgdG9zczMoXCJNaXNzaW5nIEFQSSBjb25maWcuZXhwb3J0cyAoV0FTTSBtb2R1bGUgZXhwb3J0cykuXCIpLFxuXG4gICAgXG4gICAgbWVtb3J5OiBjb25maWcubWVtb3J5IHx8IGNvbmZpZy5leHBvcnRzWydtZW1vcnknXVxuICAgICAgfHwgdG9zczMoXCJBUEkgY29uZmlnIG9iamVjdCByZXF1aXJlcyBhIFdlYkFzc2VtYmx5Lk1lbW9yeSBvYmplY3RcIixcbiAgICAgICAgICAgICAgXCJpbiBlaXRoZXIgY29uZmlnLmV4cG9ydHMubWVtb3J5IChleHBvcnRlZClcIixcbiAgICAgICAgICAgICAgXCJvciBjb25maWcubWVtb3J5IChpbXBvcnRlZCkuXCIpLFxuXG4gICAgXG4gICAgYWxsb2M6IHVuZGVmaW5lZCxcblxuICAgIFxuICAgIHJlYWxsb2M6IHVuZGVmaW5lZCxcblxuICAgIFxuICAgIGRlYWxsb2M6IHVuZGVmaW5lZFxuXG4gICAgXG4gIH0pO1xuXG4gIFxuICB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkgPSBmdW5jdGlvbihzcmNUeXBlZEFycmF5KXtcbiAgICBpZihzcmNUeXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgc3JjVHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHNyY1R5cGVkQXJyYXkpO1xuICAgIH1cbiAgICBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXkoc3JjVHlwZWRBcnJheSk7XG4gICAgY29uc3QgcFJldCA9IHdhc20uYWxsb2Moc3JjVHlwZWRBcnJheS5ieXRlTGVuZ3RoIHx8IDEpO1xuICAgIHdhc20uaGVhcEZvclNpemUoc3JjVHlwZWRBcnJheS5jb25zdHJ1Y3Rvcikuc2V0KFxuICAgICAgc3JjVHlwZWRBcnJheS5ieXRlTGVuZ3RoID8gc3JjVHlwZWRBcnJheSA6IFswXSwgcFJldFxuICAgICk7XG4gICAgcmV0dXJuIHBSZXQ7XG4gIH07XG5cbiAge1xuICAgIFxuICAgIGNvbnN0IGtleUFsbG9jID0gY29uZmlnLmFsbG9jRXhwb3J0TmFtZSxcbiAgICAgICAgICBrZXlEZWFsbG9jID0gY29uZmlnLmRlYWxsb2NFeHBvcnROYW1lLFxuICAgICAgICAgIGtleVJlYWxsb2MgPSBjb25maWcucmVhbGxvY0V4cG9ydE5hbWU7XG4gICAgZm9yKGNvbnN0IGtleSBvZiBba2V5QWxsb2MsIGtleURlYWxsb2MsIGtleVJlYWxsb2NdKXtcbiAgICAgIGNvbnN0IGYgPSB3YXNtLmV4cG9ydHNba2V5XTtcbiAgICAgIGlmKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgdG9zczMoXCJNaXNzaW5nIHJlcXVpcmVkIGV4cG9ydHNbXCIsa2V5LFwiXSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgd2FzbS5hbGxvYyA9IGZ1bmN0aW9uIGYobil7XG4gICAgICByZXR1cm4gZi5pbXBsKG4pIHx8IFdhc21BbGxvY0Vycm9yLnRvc3MoXCJGYWlsZWQgdG8gYWxsb2NhdGVcIixuLFwiIGJ5dGVzLlwiKTtcbiAgICB9O1xuICAgIHdhc20uYWxsb2MuaW1wbCA9IHdhc20uZXhwb3J0c1trZXlBbGxvY107XG4gICAgd2FzbS5yZWFsbG9jID0gZnVuY3Rpb24gZihtLG4pe1xuICAgICAgY29uc3QgbTIgPSBmLmltcGwobSxuKTtcbiAgICAgIHJldHVybiBuID8gKG0yIHx8IFdhc21BbGxvY0Vycm9yLnRvc3MoXCJGYWlsZWQgdG8gcmVhbGxvY2F0ZVwiLG4sXCIgYnl0ZXMuXCIpKSA6IDA7XG4gICAgfTtcbiAgICB3YXNtLnJlYWxsb2MuaW1wbCA9IHdhc20uZXhwb3J0c1trZXlSZWFsbG9jXTtcbiAgICB3YXNtLmRlYWxsb2MgPSB3YXNtLmV4cG9ydHNba2V5RGVhbGxvY107XG4gIH1cblxuICBcbiAgd2FzbS5jb21waWxlT3B0aW9uVXNlZCA9IGZ1bmN0aW9uIGYob3B0TmFtZSl7XG4gICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgaWYoZi5fcmVzdWx0KSByZXR1cm4gZi5fcmVzdWx0O1xuICAgICAgZWxzZSBpZighZi5fb3B0KXtcbiAgICAgICAgZi5fcnggPSAvXihbXj1dKyk9KC4rKS87XG4gICAgICAgIGYuX3J4SW50ID0gL14tP1xcZCskLztcbiAgICAgICAgZi5fb3B0ID0gZnVuY3Rpb24ob3B0LCBydil7XG4gICAgICAgICAgY29uc3QgbSA9IGYuX3J4LmV4ZWMob3B0KTtcbiAgICAgICAgICBydlswXSA9IChtID8gbVsxXSA6IG9wdCk7XG4gICAgICAgICAgcnZbMV0gPSBtID8gKGYuX3J4SW50LnRlc3QobVsyXSkgPyArbVsyXSA6IG1bMl0pIDogdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJjID0ge30sIG92ID0gWzAsMF07XG4gICAgICBsZXQgaSA9IDAsIGs7XG4gICAgICB3aGlsZSgoayA9IGNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX2dldChpKyspKSl7XG4gICAgICAgIGYuX29wdChrLG92KTtcbiAgICAgICAgcmNbb3ZbMF1dID0gb3ZbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZi5fcmVzdWx0ID0gcmM7XG4gICAgfWVsc2UgaWYoQXJyYXkuaXNBcnJheShvcHROYW1lKSl7XG4gICAgICBjb25zdCByYyA9IHt9O1xuICAgICAgb3B0TmFtZS5mb3JFYWNoKCh2KT0+e1xuICAgICAgICByY1t2XSA9IGNhcGkuc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQodik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByYztcbiAgICB9ZWxzZSBpZignb2JqZWN0JyA9PT0gdHlwZW9mIG9wdE5hbWUpe1xuICAgICAgT2JqZWN0LmtleXMob3B0TmFtZSkuZm9yRWFjaCgoayk9PiB7XG4gICAgICAgIG9wdE5hbWVba10gPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkKGspO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb3B0TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICdzdHJpbmcnPT09dHlwZW9mIG9wdE5hbWVcbiAgICApID8gISFjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkKG9wdE5hbWUpIDogZmFsc2U7XG4gIH07XG5cbiAgXG4gIHdhc20ucHN0YWNrID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICBcbiAgICByZXN0b3JlOiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlLFxuICAgIFxuICAgIGFsbG9jOiBmdW5jdGlvbihuKXtcbiAgICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIG4gJiYgIShuID0gd2FzbS5zaXplb2ZJUihuKSkpe1xuICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKFwiSW52YWxpZCB2YWx1ZSBmb3IgcHN0YWNrLmFsbG9jKFwiLGFyZ3VtZW50c1swXSxcIilcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9wc3RhY2tfYWxsb2MobilcbiAgICAgICAgfHwgV2FzbUFsbG9jRXJyb3IudG9zcyhcIkNvdWxkIG5vdCBhbGxvY2F0ZVwiLG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJieXRlcyBmcm9tIHRoZSBwc3RhY2suXCIpO1xuICAgIH0sXG4gICAgXG4gICAgYWxsb2NDaHVua3M6IGZ1bmN0aW9uKG4sc3ope1xuICAgICAgaWYoJ3N0cmluZyc9PT10eXBlb2Ygc3ogJiYgIShzeiA9IHdhc20uc2l6ZW9mSVIoc3opKSl7XG4gICAgICAgIFdhc21BbGxvY0Vycm9yLnRvc3MoXCJJbnZhbGlkIHNpemUgdmFsdWUgZm9yIGFsbG9jQ2h1bmtzKFwiLGFyZ3VtZW50c1sxXSxcIilcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZW0gPSB3YXNtLnBzdGFjay5hbGxvYyhuICogc3opO1xuICAgICAgY29uc3QgcmMgPSBbXTtcbiAgICAgIGxldCBpID0gMCwgb2Zmc2V0ID0gMDtcbiAgICAgIGZvcig7IGkgPCBuOyArK2ksIG9mZnNldCArPSBzeikgcmMucHVzaChtZW0gKyBvZmZzZXQpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH0sXG4gICAgXG4gICAgYWxsb2NQdHI6IChuPTEsc2FmZVB0clNpemU9dHJ1ZSk9PntcbiAgICAgIHJldHVybiAxPT09blxuICAgICAgICA/IHdhc20ucHN0YWNrLmFsbG9jKHNhZmVQdHJTaXplID8gOCA6IHdhc20ucHRyU2l6ZW9mKVxuICAgICAgICA6IHdhc20ucHN0YWNrLmFsbG9jQ2h1bmtzKG4sIHNhZmVQdHJTaXplID8gOCA6IHdhc20ucHRyU2l6ZW9mKTtcbiAgICB9LFxuXG4gICAgXG4gICAgY2FsbDogZnVuY3Rpb24oZil7XG4gICAgICBjb25zdCBzdGFja1BvcyA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgICB0cnl7IHJldHVybiBmKHNxbGl0ZTMpIH0gZmluYWxseXtcbiAgICAgICAgd2FzbS5wc3RhY2sucmVzdG9yZShzdGFja1Bvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3YXNtLnBzdGFjaywge1xuICAgIFxuICAgIHBvaW50ZXI6IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGl0ZXJhYmxlOiB0cnVlLCB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19wdHJcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIHF1b3RhOiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLCBpdGVyYWJsZTogdHJ1ZSwgd3JpdGVhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGFcbiAgICB9LFxuICAgIFxuICAgIHJlbWFpbmluZzoge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSwgaXRlcmFibGU6IHRydWUsIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZ1xuICAgIH1cbiAgfSk7XG5cbiAgY2FwaS5zcWxpdGUzX3JhbmRvbW5lc3MgPSAoLi4uYXJncyk9PntcbiAgICBpZigxPT09YXJncy5sZW5ndGggJiYgdXRpbC5pc1R5cGVkQXJyYXkoYXJnc1swXSlcbiAgICAgICYmIDE9PT1hcmdzWzBdLkJZVEVTX1BFUl9FTEVNRU5UKXtcbiAgICAgIGNvbnN0IHRhID0gYXJnc1swXTtcbiAgICAgIGlmKDA9PT10YS5ieXRlTGVuZ3RoKXtcbiAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmFuZG9tbmVzcygwLDApO1xuICAgICAgICByZXR1cm4gdGE7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFjayA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgbiA9IHRhLmJ5dGVMZW5ndGgsIG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IHIgPSB3YXNtLmV4cG9ydHMuc3FsaXRlM19yYW5kb21uZXNzO1xuICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgY29uc3QgbkFsbG9jID0gbiA8IDUxMiA/IG4gOiA1MTI7XG4gICAgICAgIGNvbnN0IHB0ciA9IHdhc20ucHN0YWNrLmFsbG9jKG5BbGxvYyk7XG4gICAgICAgIGRve1xuICAgICAgICAgIGNvbnN0IGogPSAobj5uQWxsb2MgPyBuQWxsb2MgOiBuKTtcbiAgICAgICAgICByKGosIHB0cik7XG4gICAgICAgICAgdGEuc2V0KHR5cGVkQXJyYXlQYXJ0KGhlYXAsIHB0ciwgcHRyK2opLCBvZmZzZXQpO1xuICAgICAgICAgIG4gLT0gajtcbiAgICAgICAgICBvZmZzZXQgKz0gajtcbiAgICAgICAgfSB3aGlsZShuID4gMCk7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJIaWdobHkgdW5leHBlY3RlZCAoYW5kIGlnbm9yZWQhKSBcIitcbiAgICAgICAgICAgICAgICAgICAgICBcImV4Y2VwdGlvbiBpbiBzcWxpdGUzX3JhbmRvbW5lc3MoKTpcIixlKTtcbiAgICAgIH1maW5hbGx5e1xuICAgICAgICB3YXNtLnBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YTtcbiAgICB9XG4gICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmFuZG9tbmVzcyguLi5hcmdzKTtcbiAgfTtcblxuICBcbiAgbGV0IF9fd2FzbWZzT3Bmc0RpciA9IHVuZGVmaW5lZDtcbiAgXG4gIGNhcGkuc3FsaXRlM193YXNtZnNfb3Bmc19kaXIgPSBmdW5jdGlvbigpe1xuICAgIGlmKHVuZGVmaW5lZCAhPT0gX193YXNtZnNPcGZzRGlyKSByZXR1cm4gX193YXNtZnNPcGZzRGlyO1xuICAgIFxuICAgIGNvbnN0IHBkaXIgPSBjb25maWcud2FzbWZzT3Bmc0RpcjtcbiAgICBpZighcGRpclxuICAgICAgIHx8ICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGVcbiAgICAgICB8fCAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlXG4gICAgICAgfHwgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUpe1xuICAgICAgcmV0dXJuIF9fd2FzbWZzT3Bmc0RpciA9IFwiXCI7XG4gICAgfVxuICAgIHRyeXtcbiAgICAgIGlmKHBkaXIgJiYgMD09PXdhc20ueENhbGxXcmFwcGVkKFxuICAgICAgICAnc3FsaXRlM193YXNtX2luaXRfd2FzbWZzJywgJ2kzMicsIFsnc3RyaW5nJ10sIHBkaXJcbiAgICAgICkpe1xuICAgICAgICByZXR1cm4gX193YXNtZnNPcGZzRGlyID0gcGRpcjtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gX193YXNtZnNPcGZzRGlyID0gXCJcIjtcbiAgICAgIH1cbiAgICB9Y2F0Y2goZSl7XG4gICAgICBcbiAgICAgIHJldHVybiBfX3dhc21mc09wZnNEaXIgPSBcIlwiO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3dhc21mc19maWxlbmFtZV9pc19wZXJzaXN0ZW50ID0gZnVuY3Rpb24obmFtZSl7XG4gICAgY29uc3QgcCA9IGNhcGkuc3FsaXRlM193YXNtZnNfb3Bmc19kaXIoKTtcbiAgICByZXR1cm4gKHAgJiYgbmFtZSkgPyBuYW1lLnN0YXJ0c1dpdGgocCsnLycpIDogZmFsc2U7XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc19kYl91c2VzX3ZmcyA9IGZ1bmN0aW9uKHBEYix2ZnNOYW1lLGRiTmFtZT0wKXtcbiAgICB0cnl7XG4gICAgICBjb25zdCBwSyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZCh2ZnNOYW1lKTtcbiAgICAgIGlmKCFwSykgcmV0dXJuIGZhbHNlO1xuICAgICAgZWxzZSBpZighcERiKXtcbiAgICAgICAgcmV0dXJuIHBLPT09Y2FwaS5zcWxpdGUzX3Zmc19maW5kKDApID8gcEsgOiBmYWxzZTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gcEs9PT1jYXBpLnNxbGl0ZTNfanNfZGJfdmZzKHBEYixkYk5hbWUpID8gcEsgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9Y2F0Y2goZSl7XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc192ZnNfbGlzdCA9IGZ1bmN0aW9uKCl7XG4gICAgY29uc3QgcmMgPSBbXTtcbiAgICBsZXQgcFZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZCgwKTtcbiAgICB3aGlsZShwVmZzKXtcbiAgICAgIGNvbnN0IG9WZnMgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcyhwVmZzKTtcbiAgICAgIHJjLnB1c2god2FzbS5jc3RyVG9KcyhvVmZzLiR6TmFtZSkpO1xuICAgICAgcFZmcyA9IG9WZnMuJHBOZXh0O1xuICAgICAgb1Zmcy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiByYztcbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX2RiX2V4cG9ydCA9IGZ1bmN0aW9uKHBEYiwgc2NoZW1hPTApe1xuICAgIHBEYiA9IHdhc20ueFdyYXAudGVzdENvbnZlcnRBcmcoJ3NxbGl0ZTMqJywgcERiKTtcbiAgICBpZighcERiKSB0b3NzMygnSW52YWxpZCBzcWxpdGUzKiBhcmd1bWVudC4nKTtcbiAgICBpZighd2FzbS5iaWdJbnRFbmFibGVkKSB0b3NzMygnQmlnSW50NjQgc3VwcG9ydCBpcyBub3QgZW5hYmxlZC4nKTtcbiAgICBjb25zdCBzY29wZSA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgbGV0IHBPdXQ7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcFNpemUgPSB3YXNtLnNjb3BlZEFsbG9jKDggKyB3YXNtLnB0clNpemVvZik7XG4gICAgICBjb25zdCBwcE91dCA9IHBTaXplICsgODtcbiAgICAgIFxuICAgICAgY29uc3QgelNjaGVtYSA9IHNjaGVtYVxuICAgICAgICAgICAgPyAod2FzbS5pc1B0cihzY2hlbWEpID8gc2NoZW1hIDogd2FzbS5zY29wZWRBbGxvY0NTdHJpbmcoJycrc2NoZW1hKSlcbiAgICAgICAgICAgIDogMDtcbiAgICAgIGxldCByYyA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplKFxuICAgICAgICBwRGIsIHpTY2hlbWEsIHBwT3V0LCBwU2l6ZSwgMFxuICAgICAgKTtcbiAgICAgIGlmKHJjKXtcbiAgICAgICAgdG9zczMoXCJEYXRhYmFzZSBzZXJpYWxpemF0aW9uIGZhaWxlZCB3aXRoIGNvZGVcIixcbiAgICAgICAgICAgICBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpKTtcbiAgICAgIH1cbiAgICAgIHBPdXQgPSB3YXNtLnBlZWtQdHIocHBPdXQpO1xuICAgICAgY29uc3Qgbk91dCA9IHdhc20ucGVlayhwU2l6ZSwgJ2k2NCcpO1xuICAgICAgcmMgPSBuT3V0XG4gICAgICAgID8gd2FzbS5oZWFwOHUoKS5zbGljZShwT3V0LCBwT3V0ICsgTnVtYmVyKG5PdXQpKVxuICAgICAgICA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfWZpbmFsbHl7XG4gICAgICBpZihwT3V0KSB3YXNtLmV4cG9ydHMuc3FsaXRlM19mcmVlKHBPdXQpO1xuICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfZGJfdmZzID1cbiAgICAoZGJQb2ludGVyLCBkYk5hbWU9MCk9Pndhc20uc3FsaXRlM193YXNtX2RiX3ZmcyhkYlBvaW50ZXIsIGRiTmFtZSk7XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc19hZ2dyZWdhdGVfY29udGV4dCA9IChwQ3R4LCBuKT0+e1xuICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQocEN0eCwgbilcbiAgICAgIHx8IChuID8gV2FzbUFsbG9jRXJyb3IudG9zcyhcIkNhbm5vdCBhbGxvY2F0ZVwiLG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJieXRlcyBmb3Igc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dCgpXCIpXG4gICAgICAgICAgOiAwKTtcbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX3Bvc2l4X2NyZWF0ZV9maWxlID0gZnVuY3Rpb24oZmlsZW5hbWUsIGRhdGEsIGRhdGFMZW4pe1xuICAgIGxldCBwRGF0YTtcbiAgICBpZihkYXRhICYmIHdhc20uaXNQdHIoZGF0YSkpe1xuICAgICAgcERhdGEgPSBkYXRhO1xuICAgIH1lbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSl7XG4gICAgICBwRGF0YSA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShkYXRhKTtcbiAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGg8MyB8fCAhdXRpbC5pc0ludDMyKGRhdGFMZW4pIHx8IGRhdGFMZW48MCl7XG4gICAgICAgIGRhdGFMZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBTUUxpdGUzRXJyb3IudG9zcyhcIkludmFsaWQgMm5kIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Bvc2l4X2NyZWF0ZV9maWxlKCkuXCIpO1xuICAgIH1cbiAgICB0cnl7XG4gICAgICBpZighdXRpbC5pc0ludDMyKGRhdGFMZW4pIHx8IGRhdGFMZW48MCl7XG4gICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFwiSW52YWxpZCAzcmQgYXJndW1lbnQgZm9yIHNxbGl0ZTNfanNfcG9zaXhfY3JlYXRlX2ZpbGUoKS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCByYyA9IHdhc20uc3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlKGZpbGVuYW1lLCBwRGF0YSwgZGF0YUxlbik7XG4gICAgICBpZihyYykgU1FMaXRlM0Vycm9yLnRvc3MoXCJDcmVhdGlvbiBvZiBmaWxlIGZhaWxlZCB3aXRoIHNxbGl0ZTMgcmVzdWx0IGNvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyKHJjKSk7XG4gICAgfWZpbmFsbHl7XG4gICAgICAgd2FzbS5kZWFsbG9jKHBEYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc192ZnNfY3JlYXRlX2ZpbGUgPSBmdW5jdGlvbih2ZnMsIGZpbGVuYW1lLCBkYXRhLCBkYXRhTGVuKXtcbiAgICBjb25maWcud2FybihcInNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlKCkgaXMgZGVwcmVjYXRlZCBhbmRcIixcbiAgICAgICAgICAgICAgICBcInNob3VsZCBiZSBhdm9pZGVkIGJlY2F1c2UgaXQgY2FuIGxlYWQgdG8gQy1sZXZlbCBjcmFzaGVzLlwiLFxuICAgICAgICAgICAgICAgIFwiU2VlIGl0cyBkb2N1bWVudGF0aW9uIGZvciBhbHRlcm5hdGl2ZSBvcHRpb25zLlwiKTtcbiAgICBsZXQgcERhdGE7XG4gICAgaWYoZGF0YSl7XG4gICAgICBpZih3YXNtLmlzUHRyKGRhdGEpKXtcbiAgICAgICAgcERhdGEgPSBkYXRhO1xuICAgICAgfWVsc2UgaWYoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgfVxuICAgICAgaWYoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe1xuICAgICAgICBwRGF0YSA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShkYXRhKTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aDw0IHx8ICF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbjwwKXtcbiAgICAgICAgICBkYXRhTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXCJJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLlwiKTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgICBwRGF0YSA9IDA7XG4gICAgfVxuICAgIGlmKCF1dGlsLmlzSW50MzIoZGF0YUxlbikgfHwgZGF0YUxlbjwwKXtcbiAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgICBTUUxpdGUzRXJyb3IudG9zcyhcIkludmFsaWQgNHRoIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpLlwiKTtcbiAgICB9XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcmMgPSB3YXNtLnNxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUodmZzLCBmaWxlbmFtZSwgcERhdGEsIGRhdGFMZW4pO1xuICAgICAgaWYocmMpIFNRTGl0ZTNFcnJvci50b3NzKFwiQ3JlYXRpb24gb2YgZmlsZSBmYWlsZWQgd2l0aCBzcWxpdGUzIHJlc3VsdCBjb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYykpO1xuICAgIH1maW5hbGx5e1xuICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfc3FsX3RvX3N0cmluZyA9IChzcWwpPT57XG4gICAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBzcWwpe1xuICAgICAgcmV0dXJuIHNxbDtcbiAgICB9XG4gICAgY29uc3QgeCA9IGZsZXhpYmxlU3RyaW5nKHYpO1xuICAgIHJldHVybiB4PT09diA/IHVuZGVmaW5lZCA6IHg7XG4gIH1cblxuICBpZiggdXRpbC5pc1VJVGhyZWFkKCkgKXtcbiAgICBcblxuICAgIFxuICAgIGNvbnN0IF9fa3Z2ZnNJbmZvID0gZnVuY3Rpb24od2hpY2gpe1xuICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmMucHJlZml4ID0gJ2t2dmZzLScrd2hpY2g7XG4gICAgICByYy5zdG9yZXMgPSBbXTtcbiAgICAgIGlmKCdzZXNzaW9uJz09PXdoaWNoIHx8IFwiXCI9PT13aGljaCkgcmMuc3RvcmVzLnB1c2goZ2xvYmFsVGhpcy5zZXNzaW9uU3RvcmFnZSk7XG4gICAgICBpZignbG9jYWwnPT09d2hpY2ggfHwgXCJcIj09PXdoaWNoKSByYy5zdG9yZXMucHVzaChnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19qc19rdnZmc19jbGVhciA9IGZ1bmN0aW9uKHdoaWNoPVwiXCIpe1xuICAgICAgbGV0IHJjID0gMDtcbiAgICAgIGNvbnN0IGt2aW5mbyA9IF9fa3Z2ZnNJbmZvKHdoaWNoKTtcbiAgICAgIGt2aW5mby5zdG9yZXMuZm9yRWFjaCgocyk9PntcbiAgICAgICAgY29uc3QgdG9SbSA9IFtdIDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciggaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpICl7XG4gICAgICAgICAgY29uc3QgayA9IHMua2V5KGkpO1xuICAgICAgICAgIGlmKGsuc3RhcnRzV2l0aChrdmluZm8ucHJlZml4KSkgdG9SbS5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIHRvUm0uZm9yRWFjaCgoa2spPT5zLnJlbW92ZUl0ZW0oa2spKTtcbiAgICAgICAgcmMgKz0gdG9SbS5sZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByYztcbiAgICB9O1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2pzX2t2dmZzX3NpemUgPSBmdW5jdGlvbih3aGljaD1cIlwiKXtcbiAgICAgIGxldCBzeiA9IDA7XG4gICAgICBjb25zdCBrdmluZm8gPSBfX2t2dmZzSW5mbyh3aGljaCk7XG4gICAgICBrdmluZm8uc3RvcmVzLmZvckVhY2goKHMpPT57XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICBjb25zdCBrID0gcy5rZXkoaSk7XG4gICAgICAgICAgaWYoay5zdGFydHNXaXRoKGt2aW5mby5wcmVmaXgpKXtcbiAgICAgICAgICAgIHN6ICs9IGsubGVuZ3RoO1xuICAgICAgICAgICAgc3ogKz0gcy5nZXRJdGVtKGspLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN6ICogMiA7XG4gICAgfTtcblxuICB9XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19kYl9jb25maWcgPSBmdW5jdGlvbihwRGIsIG9wLCAuLi5hcmdzKXtcbiAgICBpZighdGhpcy5zKXtcbiAgICAgIHRoaXMucyA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcycsJ2ludCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFsnc3FsaXRlMyonLCAnaW50JywgJ3N0cmluZzpzdGF0aWMnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgdGhpcy5waWkgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX3dhc21fZGJfY29uZmlnX3BpaScsICdpbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnc3FsaXRlMyonLCAnaW50JywgJyonLCdpbnQnLCAnaW50J10pO1xuICAgICAgdGhpcy5pcCA9IHdhc20ueFdyYXAoJ3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfaXAnLCdpbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgWydzcWxpdGUzKicsICdpbnQnLCAnaW50JywnKiddKTtcbiAgICB9XG4gICAgc3dpdGNoKG9wKXtcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfRktFWTpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfVFJJR0dFUjpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfRlRTM19UT0tFTklaRVI6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0xPQURfRVhURU5TSU9OOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX05PX0NLUFRfT05fQ0xPU0U6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1FQU0c6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfVFJJR0dFUl9FUVA6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfUkVTRVRfREFUQUJBU0U6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfREVGRU5TSVZFOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1dSSVRBQkxFX1NDSEVNQTpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19MRUdBQ1lfQUxURVJfVEFCTEU6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RNTDpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19EUVNfRERMOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9WSUVXOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0xFR0FDWV9GSUxFX0ZPUk1BVDpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19UUlVTVEVEX1NDSEVNQTpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19TVE1UX1NDQU5TVEFUVVM6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfUkVWRVJTRV9TQ0FOT1JERVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXAocERiLCBvcCwgYXJnc1swXSwgYXJnc1sxXSB8fCAwKTtcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19MT09LQVNJREU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGlpKHBEYiwgb3AsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX01BSU5EQk5BTUU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucyhwRGIsIG9wLCBhcmdzWzBdKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTUlTVVNFO1xuICAgIH1cbiAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMgPSBmdW5jdGlvbihwVmFsLHRocm93SWZDYW5ub3RDb252ZXJ0PXRydWUpe1xuICAgIGxldCBhcmc7XG4gICAgY29uc3QgdmFsVHlwZSA9IGNhcGkuc3FsaXRlM192YWx1ZV90eXBlKHBWYWwpO1xuICAgIHN3aXRjaCh2YWxUeXBlKXtcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9JTlRFR0VSOlxuICAgICAgICAgIGlmKHdhc20uYmlnSW50RW5hYmxlZCl7XG4gICAgICAgICAgICBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfaW50NjQocFZhbCk7XG4gICAgICAgICAgICBpZih1dGlsLmJpZ0ludEZpdHNEb3VibGUoYXJnKSkgYXJnID0gTnVtYmVyKGFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2RvdWJsZShwVmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9GTE9BVDpcbiAgICAgICAgICBhcmcgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfZG91YmxlKHBWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX1RFWFQ6XG4gICAgICAgICAgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX3RleHQocFZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQkxPQjp7XG4gICAgICAgICAgY29uc3QgbiA9IGNhcGkuc3FsaXRlM192YWx1ZV9ieXRlcyhwVmFsKTtcbiAgICAgICAgICBjb25zdCBwQmxvYiA9IGNhcGkuc3FsaXRlM192YWx1ZV9ibG9iKHBWYWwpO1xuICAgICAgICAgIGlmKG4gJiYgIXBCbG9iKSBzcWxpdGUzLldhc21BbGxvY0Vycm9yLnRvc3MoXG4gICAgICAgICAgICBcIkNhbm5vdCBhbGxvY2F0ZSBtZW1vcnkgZm9yIGJsb2IgYXJndW1lbnQgb2ZcIixuLFwiYnl0ZShzKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhcmcgPSBuID8gd2FzbS5oZWFwOHUoKS5zbGljZShwQmxvYiwgcEJsb2IgKyBOdW1iZXIobikpIDogbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX05VTEw6XG4gICAgICAgICAgYXJnID0gbnVsbDsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYodGhyb3dJZkNhbm5vdENvbnZlcnQpe1xuICAgICAgICAgICAgdG9zczMoY2FwaS5TUUxJVEVfTUlTTUFUQ0gsXG4gICAgICAgICAgICAgICAgICBcIlVuaGFuZGxlZCBzcWxpdGUzX3ZhbHVlX3R5cGUoKTpcIix2YWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzID0gZnVuY3Rpb24oYXJnYyxwQXJndix0aHJvd0lmQ2Fubm90Q29udmVydD10cnVlKXtcbiAgICBsZXQgaTtcbiAgICBjb25zdCB0Z3QgPSBbXTtcbiAgICBmb3IoaSA9IDA7IGkgPCBhcmdjOyArK2kpe1xuICAgICAgXG4gICAgICB0Z3QucHVzaChjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMoXG4gICAgICAgIHdhc20ucGVla1B0cihwQXJndiArICh3YXNtLnB0clNpemVvZiAqIGkpKSxcbiAgICAgICAgdGhyb3dJZkNhbm5vdENvbnZlcnRcbiAgICAgICkpO1xuICAgIH1cbiAgICByZXR1cm4gdGd0O1xuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzID0gZnVuY3Rpb24ocEN0eCxlKXtcbiAgICBpZihlIGluc3RhbmNlb2YgV2FzbUFsbG9jRXJyb3Ipe1xuICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbShwQ3R4KTtcbiAgICB9ZWxzZXtcbiAgICAgIDtcbiAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3IocEN0eCwgJycrZSwgLTEpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcyA9IGZ1bmN0aW9uKHBDdHgsdmFsKXtcbiAgICBpZih2YWwgaW5zdGFuY2VvZiBFcnJvcil7XG4gICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIHZhbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeXtcbiAgICAgIHN3aXRjaCh0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludChwQ3R4LCB2YWwgPyAxIDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgaWYodXRpbC5iaWdJbnRGaXRzMzIodmFsKSl7XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfaW50KHBDdHgsIE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgIH1lbHNlIGlmKHV0aWwuYmlnSW50Rml0c0RvdWJsZSh2YWwpKXtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9kb3VibGUocEN0eCwgTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfWVsc2UgaWYod2FzbS5iaWdJbnRFbmFibGVkKXtcbiAgICAgICAgICAgICAgaWYodXRpbC5iaWdJbnRGaXRzNjQodmFsKSkgY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQ2NChwQ3R4LCB2YWwpO1xuICAgICAgICAgICAgICBlbHNlIHRvc3MzKFwiQmlnSW50IHZhbHVlXCIsdmFsLnRvU3RyaW5nKCksXCJpcyB0b28gQmlnSW50IGZvciBpbnQ2NC5cIik7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdG9zczMoXCJCaWdJbnQgdmFsdWVcIix2YWwudG9TdHJpbmcoKSxcImlzIHRvbyBCaWdJbnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgbGV0IGY7XG4gICAgICAgICAgICBpZih1dGlsLmlzSW50MzIodmFsKSl7XG4gICAgICAgICAgICAgIGYgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludDtcbiAgICAgICAgICAgIH1lbHNlIGlmKHdhc20uYmlnSW50RW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWwpXG4gICAgICAgICAgICAgICAgICAgICAmJiB1dGlsLmJpZ0ludEZpdHM2NChCaWdJbnQodmFsKSkpe1xuICAgICAgICAgICAgICBmID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQ2NDtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBmID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9kb3VibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmKHBDdHgsIHZhbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgY29uc3QgW3AsIG5dID0gd2FzbS5hbGxvY0NTdHJpbmcodmFsLHRydWUpO1xuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF90ZXh0KHBDdHgsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmKG51bGw9PT12YWwpIHtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9udWxsKHBDdHgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1lbHNlIGlmKHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodmFsKSl7XG4gICAgICAgICAgICAgIGNvbnN0IHBCbG9iID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KHZhbCk7XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfYmxvYihcbiAgICAgICAgICAgICAgICBwQ3R4LCBwQmxvYiwgdmFsLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRvc3MzKFwiRG9uJ3Qgbm90IGhvdyB0byBoYW5kbGUgdGhpcyBVREYgcmVzdWx0IHZhbHVlOlwiLCh0eXBlb2YgdmFsKSwgdmFsKTtcbiAgICAgIH1cbiAgICB9Y2F0Y2goZSl7XG4gICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2NvbHVtbl9qcyA9IGZ1bmN0aW9uKHBTdG10LCBpQ29sLCB0aHJvd0lmQ2Fubm90Q29udmVydD10cnVlKXtcbiAgICBjb25zdCB2ID0gY2FwaS5zcWxpdGUzX2NvbHVtbl92YWx1ZShwU3RtdCwgaUNvbCk7XG4gICAgcmV0dXJuICgwPT09dikgPyB1bmRlZmluZWQgOiBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanModiwgdGhyb3dJZkNhbm5vdENvbnZlcnQpO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX25ld09sZFZhbHVlID0gZnVuY3Rpb24ocE9iaiwgaUNvbCwgaW1wbCl7XG4gICAgaW1wbCA9IGNhcGlbaW1wbF07XG4gICAgaWYoIXRoaXMucHRyKSB0aGlzLnB0ciA9IHdhc20uYWxsb2NQdHIoKTtcbiAgICBlbHNlIHdhc20ucG9rZVB0cih0aGlzLnB0ciwgMCk7XG4gICAgY29uc3QgcmMgPSBpbXBsKHBPYmosIGlDb2wsIHRoaXMucHRyKTtcbiAgICBpZihyYykgcmV0dXJuIFNRTGl0ZTNFcnJvci50b3NzKHJjLGFyZ3VtZW50c1syXStcIigpIGZhaWxlZCB3aXRoIGNvZGUgXCIrcmMpO1xuICAgIGNvbnN0IHB2ID0gd2FzbS5wZWVrUHRyKHRoaXMucHRyKTtcbiAgICByZXR1cm4gcHYgPyBjYXBpLnNxbGl0ZTNfdmFsdWVfdG9fanMoIHB2LCB0cnVlICkgOiB1bmRlZmluZWQ7XG4gIH0uYmluZChPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3ByZXVwZGF0ZV9uZXdfanMgPVxuICAgIChwRGIsIGlDb2wpPT5fX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX25ldycpO1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfcHJldXBkYXRlX29sZF9qcyA9XG4gICAgKHBEYiwgaUNvbCk9Pl9fbmV3T2xkVmFsdWUocERiLCBpQ29sLCAnc3FsaXRlM19wcmV1cGRhdGVfb2xkJyk7XG5cbiAgXG4gIGNhcGkuc3FsaXRlM2NoYW5nZXNldF9uZXdfanMgPVxuICAgIChwQ2hhbmdlc2V0SXRlciwgaUNvbCkgPT4gX19uZXdPbGRWYWx1ZShwQ2hhbmdlc2V0SXRlciwgaUNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3Jyk7XG5cbiAgXG4gIGNhcGkuc3FsaXRlM2NoYW5nZXNldF9vbGRfanMgPVxuICAgIChwQ2hhbmdlc2V0SXRlciwgaUNvbCk9Pl9fbmV3T2xkVmFsdWUocENoYW5nZXNldEl0ZXIsIGlDb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3FsaXRlM2NoYW5nZXNldF9vbGQnKTtcblxuICBcbiAgY29uc3Qgc3FsaXRlMyA9IHtcbiAgICBXYXNtQWxsb2NFcnJvcjogV2FzbUFsbG9jRXJyb3IsXG4gICAgU1FMaXRlM0Vycm9yOiBTUUxpdGUzRXJyb3IsXG4gICAgY2FwaSxcbiAgICB1dGlsLFxuICAgIHdhc20sXG4gICAgY29uZmlnLFxuICAgIFxuICAgIHZlcnNpb246IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICBcbiAgICBjbGllbnQ6IHVuZGVmaW5lZCxcblxuICAgIFxuICAgIGFzeW5jUG9zdEluaXQ6IGFzeW5jIGZ1bmN0aW9uIGZmKCl7XG4gICAgICBpZihmZi5pc1JlYWR5IGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIGZmLmlzUmVhZHk7XG4gICAgICBsZXQgbGlhID0gc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYztcbiAgICAgIGRlbGV0ZSBzcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVyc0FzeW5jO1xuICAgICAgY29uc3QgcG9zdEluaXQgPSBhc3luYyAoKT0+e1xuICAgICAgICBpZighc3FsaXRlMy5fX2lzVW5kZXJUZXN0KXtcbiAgICAgICAgICBcbiAgICAgICAgICBkZWxldGUgc3FsaXRlMy51dGlsO1xuICAgICAgICAgIFxuICAgICAgICAgIGRlbGV0ZSBzcWxpdGUzLlN0cnVjdEJpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3FsaXRlMztcbiAgICAgIH07XG4gICAgICBjb25zdCBjYXRjaGVyID0gKGUpPT57XG4gICAgICAgIGNvbmZpZy5lcnJvcihcImFuIGFzeW5jIHNxbGl0ZTMgaW5pdGlhbGl6ZXIgZmFpbGVkOlwiLGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfTtcbiAgICAgIGlmKCFsaWEgfHwgIWxpYS5sZW5ndGgpe1xuICAgICAgICByZXR1cm4gZmYuaXNSZWFkeSA9IHBvc3RJbml0KCkuY2F0Y2goY2F0Y2hlcik7XG4gICAgICB9XG4gICAgICBsaWEgPSBsaWEubWFwKChmKT0+e1xuICAgICAgICByZXR1cm4gKGYgaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBhc3luYyB4PT5mKHNxbGl0ZTMpIDogZjtcbiAgICAgIH0pO1xuICAgICAgbGlhLnB1c2gocG9zdEluaXQpO1xuICAgICAgbGV0IHAgPSBQcm9taXNlLnJlc29sdmUoc3FsaXRlMyk7XG4gICAgICB3aGlsZShsaWEubGVuZ3RoKSBwID0gcC50aGVuKGxpYS5zaGlmdCgpKTtcbiAgICAgIHJldHVybiBmZi5pc1JlYWR5ID0gcC5jYXRjaChjYXRjaGVyKTtcbiAgICB9LFxuICAgIFxuICAgIHNjcmlwdEluZm86IHVuZGVmaW5lZFxuICB9O1xuICB0cnl7XG4gICAgc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMuZm9yRWFjaCgoZik9PntcbiAgICAgIGYoc3FsaXRlMyk7XG4gICAgfSk7XG4gIH1jYXRjaChlKXtcbiAgICBcbiAgICBjb25zb2xlLmVycm9yKFwic3FsaXRlMyBib290c3RyYXAgaW5pdGlhbGl6ZXIgdGhyZXc6XCIsZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuICBkZWxldGUgc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnM7XG4gIHNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMyA9IHNxbGl0ZTM7XG4gIHJldHVybiBzcWxpdGUzO1xufTtcblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycyA9IFtdO1xuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzQXN5bmMgPSBbXTtcblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmRlZmF1bHRDb25maWcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMyA9IHVuZGVmaW5lZDtcblxuXG5cblxuZ2xvYmFsVGhpcy5XaFdhc21VdGlsSW5zdGFsbGVyID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZih1bmRlZmluZWQ9PT10YXJnZXQuYmlnSW50RW5hYmxlZCl7XG4gICAgdGFyZ2V0LmJpZ0ludEVuYWJsZWQgPSAhIWdsb2JhbFRoaXNbJ0JpZ0ludDY0QXJyYXknXTtcbiAgfVxuXG4gIFxuICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpPT57dGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKX07XG5cbiAgaWYoIXRhcmdldC5leHBvcnRzKXtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCAnZXhwb3J0cycsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogKCk9Pih0YXJnZXQuaW5zdGFuY2UgJiYgdGFyZ2V0Lmluc3RhbmNlLmV4cG9ydHMpXG4gICAgfSk7XG4gIH1cblxuICBcbiAgXG5cbiAgXG4gIGNvbnN0IHB0cklSID0gdGFyZ2V0LnBvaW50ZXJJUiB8fCAnaTMyJztcbiAgY29uc3QgcHRyU2l6ZW9mID0gdGFyZ2V0LnB0clNpemVvZiA9XG4gICAgICAgICgnaTMyJz09PXB0cklSID8gNFxuICAgICAgICAgOiAoJ2k2NCc9PT1wdHJJUlxuICAgICAgICAgICAgPyA4IDogdG9zcyhcIlVuaGFuZGxlZCBwdHJTaXplb2Y6XCIscHRySVIpKSk7XG4gIFxuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIFxuICBjYWNoZS5oZWFwU2l6ZSA9IDA7XG4gIFxuICBjYWNoZS5tZW1vcnkgPSBudWxsO1xuICBcbiAgY2FjaGUuZnJlZUZ1bmNJbmRleGVzID0gW107XG4gIFxuICBjYWNoZS5zY29wZWRBbGxvYyA9IFtdO1xuXG4gIGNhY2hlLnV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNhY2hlLnV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpO1xuXG4gIFxuICB0YXJnZXQuc2l6ZW9mSVIgPSAobik9PntcbiAgICBzd2l0Y2gobil7XG4gICAgICAgIGNhc2UgJ2k4JzogcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgJ2kxNic6IHJldHVybiAyO1xuICAgICAgICBjYXNlICdpMzInOiBjYXNlICdmMzInOiBjYXNlICdmbG9hdCc6IHJldHVybiA0O1xuICAgICAgICBjYXNlICdpNjQnOiBjYXNlICdmNjQnOiBjYXNlICdkb3VibGUnOiByZXR1cm4gODtcbiAgICAgICAgY2FzZSAnKic6IHJldHVybiBwdHJTaXplb2Y7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICgnJytuKS5lbmRzV2l0aCgnKicpID8gcHRyU2l6ZW9mIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY29uc3QgaGVhcFdyYXBwZXJzID0gZnVuY3Rpb24oKXtcbiAgICBpZighY2FjaGUubWVtb3J5KXtcbiAgICAgIGNhY2hlLm1lbW9yeSA9ICh0YXJnZXQubWVtb3J5IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5KVxuICAgICAgICA/IHRhcmdldC5tZW1vcnkgOiB0YXJnZXQuZXhwb3J0cy5tZW1vcnk7XG4gICAgfWVsc2UgaWYoY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aCl7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGIgPSBjYWNoZS5tZW1vcnkuYnVmZmVyO1xuICAgIGNhY2hlLkhFQVA4ID0gbmV3IEludDhBcnJheShiKTsgY2FjaGUuSEVBUDhVID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgY2FjaGUuSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYik7IGNhY2hlLkhFQVAxNlUgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gICAgY2FjaGUuSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7IGNhY2hlLkhFQVAzMlUgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gICAgaWYodGFyZ2V0LmJpZ0ludEVuYWJsZWQpe1xuICAgICAgY2FjaGUuSEVBUDY0ID0gbmV3IEJpZ0ludDY0QXJyYXkoYik7IGNhY2hlLkhFQVA2NFUgPSBuZXcgQmlnVWludDY0QXJyYXkoYik7XG4gICAgfVxuICAgIGNhY2hlLkhFQVAzMkYgPSBuZXcgRmxvYXQzMkFycmF5KGIpOyBjYWNoZS5IRUFQNjRGID0gbmV3IEZsb2F0NjRBcnJheShiKTtcbiAgICBjYWNoZS5oZWFwU2l6ZSA9IGIuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5oZWFwOCA9ICgpPT5oZWFwV3JhcHBlcnMoKS5IRUFQODtcblxuICBcbiAgdGFyZ2V0LmhlYXA4dSA9ICgpPT5oZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG5cbiAgXG4gIHRhcmdldC5oZWFwMTYgPSAoKT0+aGVhcFdyYXBwZXJzKCkuSEVBUDE2O1xuXG4gIFxuICB0YXJnZXQuaGVhcDE2dSA9ICgpPT5oZWFwV3JhcHBlcnMoKS5IRUFQMTZVO1xuXG4gIFxuICB0YXJnZXQuaGVhcDMyID0gKCk9PmhlYXBXcmFwcGVycygpLkhFQVAzMjtcblxuICBcbiAgdGFyZ2V0LmhlYXAzMnUgPSAoKT0+aGVhcFdyYXBwZXJzKCkuSEVBUDMyVTtcblxuICBcbiAgdGFyZ2V0LmhlYXBGb3JTaXplID0gZnVuY3Rpb24obix1bnNpZ25lZCA9IHRydWUpe1xuICAgIGxldCBjdG9yO1xuICAgIGNvbnN0IGMgPSAoY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgPyBjYWNoZSA6IGhlYXBXcmFwcGVycygpO1xuICAgIHN3aXRjaChuKXtcbiAgICAgICAgY2FzZSBJbnQ4QXJyYXk6IHJldHVybiBjLkhFQVA4OyBjYXNlIFVpbnQ4QXJyYXk6IHJldHVybiBjLkhFQVA4VTtcbiAgICAgICAgY2FzZSBJbnQxNkFycmF5OiByZXR1cm4gYy5IRUFQMTY7IGNhc2UgVWludDE2QXJyYXk6IHJldHVybiBjLkhFQVAxNlU7XG4gICAgICAgIGNhc2UgSW50MzJBcnJheTogcmV0dXJuIGMuSEVBUDMyOyBjYXNlIFVpbnQzMkFycmF5OiByZXR1cm4gYy5IRUFQMzJVO1xuICAgICAgICBjYXNlIDg6ICByZXR1cm4gdW5zaWduZWQgPyBjLkhFQVA4VSA6IGMuSEVBUDg7XG4gICAgICAgIGNhc2UgMTY6IHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDE2VSA6IGMuSEVBUDE2O1xuICAgICAgICBjYXNlIDMyOiByZXR1cm4gdW5zaWduZWQgPyBjLkhFQVAzMlUgOiBjLkhFQVAzMjtcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICBpZihjLkhFQVA2NCkgcmV0dXJuIHVuc2lnbmVkID8gYy5IRUFQNjRVIDogYy5IRUFQNjQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYodGFyZ2V0LmJpZ0ludEVuYWJsZWQpe1xuICAgICAgICAgICAgaWYobj09PWdsb2JhbFRoaXNbJ0JpZ1VpbnQ2NEFycmF5J10pIHJldHVybiBjLkhFQVA2NFU7XG4gICAgICAgICAgICBlbHNlIGlmKG49PT1nbG9iYWxUaGlzWydCaWdJbnQ2NEFycmF5J10pIHJldHVybiBjLkhFQVA2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICB9XG4gICAgdG9zcyhcIkludmFsaWQgaGVhcEZvclNpemUoKSBzaXplOiBleHBlY3RpbmcgOCwgMTYsIDMyLFwiLFxuICAgICAgICAgXCJvciAoaWYgQmlnSW50IGlzIGVuYWJsZWQpIDY0LlwiKTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmZ1bmN0aW9uVGFibGUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0YXJnZXQuZXhwb3J0cy5fX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlO1xuICAgIFxuICB9O1xuXG4gIFxuICB0YXJnZXQuZnVuY3Rpb25FbnRyeSA9IGZ1bmN0aW9uKGZwdHIpe1xuICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICByZXR1cm4gZnB0ciA8IGZ0Lmxlbmd0aCA/IGZ0LmdldChmcHRyKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmpzRnVuY1RvV2FzbSA9IGZ1bmN0aW9uIGYoZnVuYywgc2lnKXtcbiAgICBcbiAgICBpZighZi5fKXtcbiAgICAgIGYuXyA9IHtcbiAgICAgICAgXG4gICAgICAgIHNpZ1R5cGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgICAgICAgIGk6ICdpMzInLCBwOiAnaTMyJywgUDogJ2kzMicsIHM6ICdpMzInLFxuICAgICAgICAgIGo6ICdpNjQnLCBmOiAnZjMyJywgZDogJ2Y2NCdcbiAgICAgICAgfSksXG4gICAgICAgIFxuICAgICAgICB0eXBlQ29kZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgICAgICAgZjY0OiAweDdjLCBmMzI6IDB4N2QsIGk2NDogMHg3ZSwgaTMyOiAweDdmXG4gICAgICAgIH0pLFxuICAgICAgICBcbiAgICAgICAgdWxlYjEyOEVuY29kZTogZnVuY3Rpb24odGd0LCBtZXRob2QsIG4pe1xuICAgICAgICAgIGlmKG48MTI4KSB0Z3RbbWV0aG9kXShuKTtcbiAgICAgICAgICBlbHNlIHRndFttZXRob2RdKCAobiAlIDEyOCkgfCAxMjgsIG4+PjcpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcnhKU2lnOiAvXihcXHcpXFwoKFxcdyopXFwpJC8sXG4gICAgICAgIFxuICAgICAgICBzaWdQYXJhbXM6IGZ1bmN0aW9uKHNpZyl7XG4gICAgICAgICAgY29uc3QgbSA9IGYuXy5yeEpTaWcuZXhlYyhzaWcpO1xuICAgICAgICAgIHJldHVybiBtID8gbVsyXSA6IHNpZy5zdWJzdHIoMSk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBsZXR0ZXJUeXBlOiAoeCk9PmYuXy5zaWdUeXBlc1t4XSB8fCB0b3NzKFwiSW52YWxpZCBzaWduYXR1cmUgbGV0dGVyOlwiLHgpLFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBwdXNoU2lnVHlwZTogKGRlc3QsIGxldHRlcik9PmRlc3QucHVzaChmLl8udHlwZUNvZGVzW2YuXy5sZXR0ZXJUeXBlKGxldHRlcildKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYoJ3N0cmluZyc9PT10eXBlb2YgZnVuYyl7XG4gICAgICBjb25zdCB4ID0gc2lnO1xuICAgICAgc2lnID0gZnVuYztcbiAgICAgIGZ1bmMgPSB4O1xuICAgIH1cbiAgICBjb25zdCBzaWdQYXJhbXMgPSBmLl8uc2lnUGFyYW1zKHNpZyk7XG4gICAgY29uc3Qgd2FzbUNvZGUgPSBbMHgwMSwgMHg2MF07XG4gICAgZi5fLnVsZWIxMjhFbmNvZGUod2FzbUNvZGUsICdwdXNoJywgc2lnUGFyYW1zLmxlbmd0aCk7XG4gICAgZm9yKGNvbnN0IHggb2Ygc2lnUGFyYW1zKSBmLl8ucHVzaFNpZ1R5cGUod2FzbUNvZGUsIHgpO1xuICAgIGlmKCd2Jz09PXNpZ1swXSkgd2FzbUNvZGUucHVzaCgwKTtcbiAgICBlbHNle1xuICAgICAgd2FzbUNvZGUucHVzaCgxKTtcbiAgICAgIGYuXy5wdXNoU2lnVHlwZSh3YXNtQ29kZSwgc2lnWzBdKTtcbiAgICB9XG4gICAgZi5fLnVsZWIxMjhFbmNvZGUod2FzbUNvZGUsICd1bnNoaWZ0Jywgd2FzbUNvZGUubGVuZ3RoKTtcbiAgICB3YXNtQ29kZS51bnNoaWZ0KFxuICAgICAgMHgwMCwgMHg2MSwgMHg3MywgMHg2ZCwgXG4gICAgICAweDAxLCAweDAwLCAweDAwLCAweDAwLCBcbiAgICAgIDB4MDEgXG4gICAgKTtcbiAgICB3YXNtQ29kZS5wdXNoKFxuICAgICAgIDB4MDIsIDB4MDcsXG4gICAgICBcbiAgICAgIDB4MDEsIDB4MDEsIDB4NjUsIDB4MDEsIDB4NjYsIDB4MDAsIDB4MDAsXG4gICAgICAgMHgwNywgMHgwNSxcbiAgICAgIFxuICAgICAgMHgwMSwgMHgwMSwgMHg2NiwgMHgwMCwgMHgwMFxuICAgICk7XG4gICAgcmV0dXJuIChuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoXG4gICAgICBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KHdhc21Db2RlKSksIHtcbiAgICAgICAgZTogeyBmOiBmdW5jIH1cbiAgICAgIH0pKS5leHBvcnRzWydmJ107XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9faW5zdGFsbEZ1bmN0aW9uID0gZnVuY3Rpb24gZihmdW5jLCBzaWcsIHNjb3BlZCl7XG4gICAgaWYoc2NvcGVkICYmICFjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgpe1xuICAgICAgdG9zcyhcIk5vIHNjb3BlZEFsbG9jUHVzaCgpIHNjb3BlIGlzIGFjdGl2ZS5cIik7XG4gICAgfVxuICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIGZ1bmMpe1xuICAgICAgY29uc3QgeCA9IHNpZztcbiAgICAgIHNpZyA9IGZ1bmM7XG4gICAgICBmdW5jID0geDtcbiAgICB9XG4gICAgaWYoJ3N0cmluZychPT10eXBlb2Ygc2lnIHx8ICEoZnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgICB0b3NzKFwiSW52YWxpZCBhcmd1bWVudHM6IGV4cGVjdGluZyAoZnVuY3Rpb24sc2lnbmF0dXJlKSBcIitcbiAgICAgICAgICAgXCJvciAoc2lnbmF0dXJlLGZ1bmN0aW9uKS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICBjb25zdCBvbGRMZW4gPSBmdC5sZW5ndGg7XG4gICAgbGV0IHB0cjtcbiAgICB3aGlsZShjYWNoZS5mcmVlRnVuY0luZGV4ZXMubGVuZ3RoKXtcbiAgICAgIHB0ciA9IGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5wb3AoKTtcbiAgICAgIGlmKGZ0LmdldChwdHIpKXsgXG4gICAgICAgIHB0ciA9IG51bGw7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZighcHRyKXtcbiAgICAgIHB0ciA9IG9sZExlbjtcbiAgICAgIGZ0Lmdyb3coMSk7XG4gICAgfVxuICAgIHRyeXtcbiAgICAgIFxuICAgICAgZnQuc2V0KHB0ciwgZnVuYyk7XG4gICAgICBpZihzY29wZWQpe1xuICAgICAgICBjYWNoZS5zY29wZWRBbGxvY1tjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgtMV0ucHVzaChwdHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB0cjtcbiAgICB9Y2F0Y2goZSl7XG4gICAgICBpZighKGUgaW5zdGFuY2VvZiBUeXBlRXJyb3IpKXtcbiAgICAgICAgaWYocHRyPT09b2xkTGVuKSBjYWNoZS5mcmVlRnVuY0luZGV4ZXMucHVzaChvbGRMZW4pO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnB0ciA9IHRhcmdldC5qc0Z1bmNUb1dhc20oZnVuYywgc2lnKTtcbiAgICAgIGZ0LnNldChwdHIsIGZwdHIpO1xuICAgICAgaWYoc2NvcGVkKXtcbiAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoLTFdLnB1c2gocHRyKTtcbiAgICAgIH1cbiAgICB9Y2F0Y2goZSl7XG4gICAgICBpZihwdHI9PT1vbGRMZW4pIGNhY2hlLmZyZWVGdW5jSW5kZXhlcy5wdXNoKG9sZExlbik7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gcHRyO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuaW5zdGFsbEZ1bmN0aW9uID0gKGZ1bmMsIHNpZyk9Pl9faW5zdGFsbEZ1bmN0aW9uKGZ1bmMsIHNpZywgZmFsc2UpO1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkSW5zdGFsbEZ1bmN0aW9uID0gKGZ1bmMsIHNpZyk9Pl9faW5zdGFsbEZ1bmN0aW9uKGZ1bmMsIHNpZywgdHJ1ZSk7XG5cbiAgXG4gIHRhcmdldC51bmluc3RhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uKHB0cil7XG4gICAgaWYoIXB0ciAmJiAwIT09cHRyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGZpID0gY2FjaGUuZnJlZUZ1bmNJbmRleGVzO1xuICAgIGNvbnN0IGZ0ID0gdGFyZ2V0LmZ1bmN0aW9uVGFibGUoKTtcbiAgICBmaS5wdXNoKHB0cik7XG4gICAgY29uc3QgcmMgPSBmdC5nZXQocHRyKTtcbiAgICBmdC5zZXQocHRyLCBudWxsKTtcbiAgICByZXR1cm4gcmM7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5wZWVrID0gZnVuY3Rpb24gZihwdHIsIHR5cGU9J2k4Jyl7XG4gICAgaWYodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgY29uc3QgYyA9IChjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICA/IGNhY2hlIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkocHRyKSA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGxldCByYztcbiAgICBkb3tcbiAgICAgIGlmKGxpc3QpIHB0ciA9IGFyZ3VtZW50c1swXS5zaGlmdCgpO1xuICAgICAgc3dpdGNoKHR5cGUpe1xuICAgICAgICAgIGNhc2UgJ2kxJzpcbiAgICAgICAgICBjYXNlICdpOCc6IHJjID0gYy5IRUFQOFtwdHI+PjBdOyBicmVhaztcbiAgICAgICAgICBjYXNlICdpMTYnOiByYyA9IGMuSEVBUDE2W3B0cj4+MV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2kzMic6IHJjID0gYy5IRUFQMzJbcHRyPj4yXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmxvYXQnOiBjYXNlICdmMzInOiByYyA9IGMuSEVBUDMyRltwdHI+PjJdOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkb3VibGUnOiBjYXNlICdmNjQnOiByYyA9IE51bWJlcihjLkhFQVA2NEZbcHRyPj4zXSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2k2NCc6XG4gICAgICAgICAgICBpZih0YXJnZXQuYmlnSW50RW5hYmxlZCl7XG4gICAgICAgICAgICAgIHJjID0gQmlnSW50KGMuSEVBUDY0W3B0cj4+M10pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0b3NzKCdJbnZhbGlkIHR5cGUgZm9yIHBlZWsoKTonLHR5cGUpO1xuICAgICAgfVxuICAgICAgaWYobGlzdCkgbGlzdC5wdXNoKHJjKTtcbiAgICB9d2hpbGUobGlzdCAmJiBhcmd1bWVudHNbMF0ubGVuZ3RoKTtcbiAgICByZXR1cm4gbGlzdCB8fCByYztcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnBva2UgPSBmdW5jdGlvbihwdHIsIHZhbHVlLCB0eXBlPSdpOCcpe1xuICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSBwdHJJUjtcbiAgICBjb25zdCBjID0gKGNhY2hlLm1lbW9yeSAmJiBjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgID8gY2FjaGUgOiBoZWFwV3JhcHBlcnMoKTtcbiAgICBmb3IoY29uc3QgcCBvZiAoQXJyYXkuaXNBcnJheShwdHIpID8gcHRyIDogW3B0cl0pKXtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2kxJzpcbiAgICAgICAgICBjYXNlICdpOCc6IGMuSEVBUDhbcD4+MF0gPSB2YWx1ZTsgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnaTE2JzogYy5IRUFQMTZbcD4+MV0gPSB2YWx1ZTsgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnaTMyJzogYy5IRUFQMzJbcD4+Ml0gPSB2YWx1ZTsgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnZmxvYXQnOiBjYXNlICdmMzInOiBjLkhFQVAzMkZbcD4+Ml0gPSB2YWx1ZTsgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnZG91YmxlJzogY2FzZSAnZjY0JzogYy5IRUFQNjRGW3A+PjNdID0gdmFsdWU7IGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ2k2NCc6XG4gICAgICAgICAgICBpZihjLkhFQVA2NCl7XG4gICAgICAgICAgICAgIGMuSEVBUDY0W3A+PjNdID0gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIGZvciBwb2tlKCk6ICcgKyB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5wZWVrUHRyID0gKC4uLnB0cik9PnRhcmdldC5wZWVrKCAoMT09PXB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIpLCBwdHJJUiApO1xuXG4gIFxuICB0YXJnZXQucG9rZVB0ciA9IChwdHIsIHZhbHVlPTApPT50YXJnZXQucG9rZShwdHIsIHZhbHVlLCBwdHJJUik7XG5cbiAgXG4gIHRhcmdldC5wZWVrOCA9ICguLi5wdHIpPT50YXJnZXQucGVlayggKDE9PT1wdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyKSwgJ2k4JyApO1xuICBcbiAgdGFyZ2V0LnBva2U4ID0gKHB0ciwgdmFsdWUpPT50YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTgnKTtcbiAgXG4gIHRhcmdldC5wZWVrMTYgPSAoLi4ucHRyKT0+dGFyZ2V0LnBlZWsoICgxPT09cHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciksICdpMTYnICk7XG4gIFxuICB0YXJnZXQucG9rZTE2ID0gKHB0ciwgdmFsdWUpPT50YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTE2Jyk7XG4gIFxuICB0YXJnZXQucGVlazMyID0gKC4uLnB0cik9PnRhcmdldC5wZWVrKCAoMT09PXB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIpLCAnaTMyJyApO1xuICBcbiAgdGFyZ2V0LnBva2UzMiA9IChwdHIsIHZhbHVlKT0+dGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2kzMicpO1xuICBcbiAgdGFyZ2V0LnBlZWs2NCA9ICguLi5wdHIpPT50YXJnZXQucGVlayggKDE9PT1wdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyKSwgJ2k2NCcgKTtcbiAgXG4gIHRhcmdldC5wb2tlNjQgPSAocHRyLCB2YWx1ZSk9PnRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpNjQnKTtcbiAgXG4gIHRhcmdldC5wZWVrMzJmID0gKC4uLnB0cik9PnRhcmdldC5wZWVrKCAoMT09PXB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIpLCAnZjMyJyApO1xuICBcbiAgdGFyZ2V0LnBva2UzMmYgPSAocHRyLCB2YWx1ZSk9PnRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdmMzInKTtcbiAgXG4gIHRhcmdldC5wZWVrNjRmID0gKC4uLnB0cik9PnRhcmdldC5wZWVrKCAoMT09PXB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIpLCAnZjY0JyApO1xuICBcbiAgdGFyZ2V0LnBva2U2NGYgPSAocHRyLCB2YWx1ZSk9PnRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdmNjQnKTtcblxuICBcbiAgdGFyZ2V0LmdldE1lbVZhbHVlID0gdGFyZ2V0LnBlZWs7XG4gIFxuICB0YXJnZXQuZ2V0UHRyVmFsdWUgPSB0YXJnZXQucGVla1B0cjtcbiAgXG4gIHRhcmdldC5zZXRNZW1WYWx1ZSA9IHRhcmdldC5wb2tlO1xuICBcbiAgdGFyZ2V0LnNldFB0clZhbHVlID0gdGFyZ2V0LnBva2VQdHI7XG5cbiAgXG4gIHRhcmdldC5pc1B0cjMyID0gKHB0cik9PignbnVtYmVyJz09PXR5cGVvZiBwdHIgJiYgKHB0cj09PShwdHJ8MCkpICYmIHB0cj49MCk7XG5cbiAgXG4gIHRhcmdldC5pc1B0ciA9IHRhcmdldC5pc1B0cjMyO1xuXG4gIFxuICB0YXJnZXQuY3N0cmxlbiA9IGZ1bmN0aW9uKHB0cil7XG4gICAgaWYoIXB0ciB8fCAhdGFyZ2V0LmlzUHRyKHB0cikpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGggPSBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG4gICAgbGV0IHBvcyA9IHB0cjtcbiAgICBmb3IoIDsgaFtwb3NdICE9PSAwOyArK3BvcyApe31cbiAgICByZXR1cm4gcG9zIC0gcHRyO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX1NBQiA9ICgndW5kZWZpbmVkJz09PXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBmdW5jdGlvbigpe30gOiBTaGFyZWRBcnJheUJ1ZmZlcjtcbiAgY29uc3QgX191dGY4RGVjb2RlID0gZnVuY3Rpb24oYXJyYXlCdWZmZXIsIGJlZ2luLCBlbmQpe1xuICAgIHJldHVybiBjYWNoZS51dGY4RGVjb2Rlci5kZWNvZGUoXG4gICAgICAoYXJyYXlCdWZmZXIuYnVmZmVyIGluc3RhbmNlb2YgX19TQUIpXG4gICAgICAgID8gYXJyYXlCdWZmZXIuc2xpY2UoYmVnaW4sIGVuZClcbiAgICAgICAgOiBhcnJheUJ1ZmZlci5zdWJhcnJheShiZWdpbiwgZW5kKVxuICAgICk7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5jc3RyVG9KcyA9IGZ1bmN0aW9uKHB0cil7XG4gICAgY29uc3QgbiA9IHRhcmdldC5jc3RybGVuKHB0cik7XG4gICAgcmV0dXJuIG4gPyBfX3V0ZjhEZWNvZGUoaGVhcFdyYXBwZXJzKCkuSEVBUDhVLCBwdHIsIHB0cituKSA6IChudWxsPT09biA/IG4gOiBcIlwiKTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmpzdHJsZW4gPSBmdW5jdGlvbihzdHIpe1xuICAgIFxuICAgIGlmKCdzdHJpbmcnIT09dHlwZW9mIHN0cikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbiA9IHN0ci5sZW5ndGg7XG4gICAgbGV0IGxlbiA9IDA7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG47ICsraSl7XG4gICAgICBsZXQgdSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYodT49MHhkODAwICYmIHU8PTB4ZGZmZil7XG4gICAgICAgIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzRkYpO1xuICAgICAgfVxuICAgICAgaWYodTw9MHg3ZikgKytsZW47XG4gICAgICBlbHNlIGlmKHU8PTB4N2ZmKSBsZW4gKz0gMjtcbiAgICAgIGVsc2UgaWYodTw9MHhmZmZmKSBsZW4gKz0gMztcbiAgICAgIGVsc2UgbGVuICs9IDQ7XG4gICAgfVxuICAgIHJldHVybiBsZW47XG4gIH07XG5cbiAgXG4gIHRhcmdldC5qc3RyY3B5ID0gZnVuY3Rpb24oanN0ciwgdGd0LCBvZmZzZXQgPSAwLCBtYXhCeXRlcyA9IC0xLCBhZGROdWwgPSB0cnVlKXtcbiAgICBcbiAgICBpZighdGd0IHx8ICghKHRndCBpbnN0YW5jZW9mIEludDhBcnJheSkgJiYgISh0Z3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkpe1xuICAgICAgdG9zcyhcImpzdHJjcHkoKSB0YXJnZXQgbXVzdCBiZSBhbiBJbnQ4QXJyYXkgb3IgVWludDhBcnJheS5cIik7XG4gICAgfVxuICAgIGlmKG1heEJ5dGVzPDApIG1heEJ5dGVzID0gdGd0Lmxlbmd0aCAtIG9mZnNldDtcbiAgICBpZighKG1heEJ5dGVzPjApIHx8ICEob2Zmc2V0Pj0wKSkgcmV0dXJuIDA7XG4gICAgbGV0IGkgPSAwLCBtYXggPSBqc3RyLmxlbmd0aDtcbiAgICBjb25zdCBiZWdpbiA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgbWF4Qnl0ZXMgLSAoYWRkTnVsID8gMSA6IDApO1xuICAgIGZvcig7IGkgPCBtYXggJiYgb2Zmc2V0IDwgZW5kOyArK2kpe1xuICAgICAgbGV0IHUgPSBqc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZih1Pj0weGQ4MDAgJiYgdTw9MHhkZmZmKXtcbiAgICAgICAgdSA9IDB4MTAwMDAgKyAoKHUgJiAweDNGRikgPDwgMTApIHwgKGpzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzRkYpO1xuICAgICAgfVxuICAgICAgaWYodTw9MHg3Zil7XG4gICAgICAgIGlmKG9mZnNldCA+PSBlbmQpIGJyZWFrO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gdTtcbiAgICAgIH1lbHNlIGlmKHU8PTB4N2ZmKXtcbiAgICAgICAgaWYob2Zmc2V0ICsgMSA+PSBlbmQpIGJyZWFrO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHhDMCB8ICh1ID4+IDYpO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICh1ICYgMHgzZik7XG4gICAgICB9ZWxzZSBpZih1PD0weGZmZmYpe1xuICAgICAgICBpZihvZmZzZXQgKyAyID49IGVuZCkgYnJlYWs7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweGUwIHwgKHUgPj4gMTIpO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDB4M2YpO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICh1ICYgMHgzZik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYob2Zmc2V0ICsgMyA+PSBlbmQpIGJyZWFrO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHhmMCB8ICh1ID4+IDE4KTtcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAoKHUgPj4gMTIpICYgMHgzZik7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgMHgzZik7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKHUgJiAweDNmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoYWRkTnVsKSB0Z3Rbb2Zmc2V0KytdID0gMDtcbiAgICByZXR1cm4gb2Zmc2V0IC0gYmVnaW47XG4gIH07XG5cbiAgXG4gIHRhcmdldC5jc3RybmNweSA9IGZ1bmN0aW9uKHRndFB0ciwgc3JjUHRyLCBuKXtcbiAgICBpZighdGd0UHRyIHx8ICFzcmNQdHIpIHRvc3MoXCJjc3RybmNweSgpIGRvZXMgbm90IGFjY2VwdCBOVUxMIHN0cmluZ3MuXCIpO1xuICAgIGlmKG48MCkgbiA9IHRhcmdldC5jc3RybGVuKHN0clB0cikrMTtcbiAgICBlbHNlIGlmKCEobj4wKSkgcmV0dXJuIDA7XG4gICAgY29uc3QgaGVhcCA9IHRhcmdldC5oZWFwOHUoKTtcbiAgICBsZXQgaSA9IDAsIGNoO1xuICAgIGZvcig7IGkgPCBuICYmIChjaCA9IGhlYXBbc3JjUHRyK2ldKTsgKytpKXtcbiAgICAgIGhlYXBbdGd0UHRyK2ldID0gY2g7XG4gICAgfVxuICAgIGlmKGk8bikgaGVhcFt0Z3RQdHIgKyBpKytdID0gMDtcbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmpzdHJUb1VpbnRBcnJheSA9IChzdHIsIGFkZE51bD1mYWxzZSk9PntcbiAgICByZXR1cm4gY2FjaGUudXRmOEVuY29kZXIuZW5jb2RlKGFkZE51bCA/IChzdHIrXCJcXDBcIikgOiBzdHIpO1xuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICB9O1xuXG4gIGNvbnN0IF9fYWZmaXJtQWxsb2MgPSAob2JqLGZ1bmNOYW1lKT0+e1xuICAgIGlmKCEob2JqLmFsbG9jIGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgIShvYmouZGVhbGxvYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgICB0b3NzKFwiT2JqZWN0IGlzIG1pc3NpbmcgYWxsb2MoKSBhbmQvb3IgZGVhbGxvYygpIGZ1bmN0aW9uKHMpXCIsXG4gICAgICAgICAgIFwicmVxdWlyZWQgYnlcIixmdW5jTmFtZStcIigpLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgX19hbGxvY0NTdHIgPSBmdW5jdGlvbihqc3RyLCByZXR1cm5XaXRoTGVuZ3RoLCBhbGxvY2F0b3IsIGZ1bmNOYW1lKXtcbiAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgZnVuY05hbWUpO1xuICAgIGlmKCdzdHJpbmcnIT09dHlwZW9mIGpzdHIpIHJldHVybiBudWxsO1xuICAgIGlmKDApe1xuICAgICAgY29uc3QgbiA9IHRhcmdldC5qc3RybGVuKGpzdHIpLFxuICAgICAgICAgICAgcHRyID0gYWxsb2NhdG9yKG4rMSk7XG4gICAgICB0YXJnZXQuanN0cmNweShqc3RyLCB0YXJnZXQuaGVhcDh1KCksIHB0ciwgbisxLCB0cnVlKTtcbiAgICAgIHJldHVybiByZXR1cm5XaXRoTGVuZ3RoID8gW3B0ciwgbl0gOiBwdHI7XG4gICAgfWVsc2V7XG4gICAgICBjb25zdCB1ID0gY2FjaGUudXRmOEVuY29kZXIuZW5jb2RlKGpzdHIpLFxuICAgICAgICAgICAgcHRyID0gYWxsb2NhdG9yKHUubGVuZ3RoKzEpLFxuICAgICAgICAgICAgaGVhcCA9IGhlYXBXcmFwcGVycygpLkhFQVA4VTtcbiAgICAgIGhlYXAuc2V0KHUsIHB0cik7XG4gICAgICBoZWFwW3B0ciArIHUubGVuZ3RoXSA9IDA7XG4gICAgICByZXR1cm4gcmV0dXJuV2l0aExlbmd0aCA/IFtwdHIsIHUubGVuZ3RoXSA6IHB0cjtcbiAgICB9XG4gIH07XG5cbiAgXG4gIHRhcmdldC5hbGxvY0NTdHJpbmcgPVxuICAgIChqc3RyLCByZXR1cm5XaXRoTGVuZ3RoPWZhbHNlKT0+X19hbGxvY0NTdHIoanN0ciwgcmV0dXJuV2l0aExlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5hbGxvYywgJ2FsbG9jQ1N0cmluZygpJyk7XG5cbiAgXG4gIHRhcmdldC5zY29wZWRBbGxvY1B1c2ggPSBmdW5jdGlvbigpe1xuICAgIF9fYWZmaXJtQWxsb2ModGFyZ2V0LCAnc2NvcGVkQWxsb2NQdXNoJyk7XG4gICAgY29uc3QgYSA9IFtdO1xuICAgIGNhY2hlLnNjb3BlZEFsbG9jLnB1c2goYSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5zY29wZWRBbGxvY1BvcCA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgJ3Njb3BlZEFsbG9jUG9wJyk7XG4gICAgY29uc3QgbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICA/IGNhY2hlLnNjb3BlZEFsbG9jLmluZGV4T2Yoc3RhdGUpXG4gICAgICAgICAgOiBjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgtMTtcbiAgICBpZihuPDApIHRvc3MoXCJJbnZhbGlkIHN0YXRlIG9iamVjdCBmb3Igc2NvcGVkQWxsb2NQb3AoKS5cIik7XG4gICAgaWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpIHN0YXRlID0gY2FjaGUuc2NvcGVkQWxsb2Nbbl07XG4gICAgY2FjaGUuc2NvcGVkQWxsb2Muc3BsaWNlKG4sMSk7XG4gICAgZm9yKGxldCBwOyAocCA9IHN0YXRlLnBvcCgpKTsgKXtcbiAgICAgIGlmKHRhcmdldC5mdW5jdGlvbkVudHJ5KHApKXtcbiAgICAgICAgXG4gICAgICAgIHRhcmdldC51bmluc3RhbGxGdW5jdGlvbihwKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgdGFyZ2V0LmRlYWxsb2MocCk7XG4gICAgfVxuICB9O1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkQWxsb2MgPSBmdW5jdGlvbihuKXtcbiAgICBpZighY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKXtcbiAgICAgIHRvc3MoXCJObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwID0gdGFyZ2V0LmFsbG9jKG4pO1xuICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aC0xXS5wdXNoKHApO1xuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQuc2NvcGVkQWxsb2MsICdsZXZlbCcsIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6ICgpPT5jYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgsXG4gICAgc2V0OiAoKT0+dG9zcyhcIlRoZSAnYWN0aXZlJyBwcm9wZXJ0eSBpcyByZWFkLW9ubHkuXCIpXG4gIH0pO1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkQWxsb2NDU3RyaW5nID1cbiAgICAoanN0ciwgcmV0dXJuV2l0aExlbmd0aD1mYWxzZSk9Pl9fYWxsb2NDU3RyKGpzdHIsIHJldHVybldpdGhMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2MsICdzY29wZWRBbGxvY0NTdHJpbmcoKScpO1xuXG4gIFxuICBjb25zdCBfX2FsbG9jTWFpbkFyZ3YgPSBmdW5jdGlvbihpc1Njb3BlZCwgbGlzdCl7XG4gICAgY29uc3QgcExpc3QgPSB0YXJnZXRbXG4gICAgICBpc1Njb3BlZCA/ICdzY29wZWRBbGxvYycgOiAnYWxsb2MnXG4gICAgXSgobGlzdC5sZW5ndGggKyAxKSAqIHRhcmdldC5wdHJTaXplb2YpO1xuICAgIGxldCBpID0gMDtcbiAgICBsaXN0LmZvckVhY2goKGUpPT57XG4gICAgICB0YXJnZXQucG9rZVB0cihwTGlzdCArICh0YXJnZXQucHRyU2l6ZW9mICogaSsrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpc1Njb3BlZCA/ICdzY29wZWRBbGxvY0NTdHJpbmcnIDogJ2FsbG9jQ1N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICBdKFwiXCIrZSkpO1xuICAgIH0pO1xuICAgIHRhcmdldC5wb2tlUHRyKHBMaXN0ICsgKHRhcmdldC5wdHJTaXplb2YgKiBpKSwgMCk7XG4gICAgcmV0dXJuIHBMaXN0O1xuICB9O1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkQWxsb2NNYWluQXJndiA9IChsaXN0KT0+X19hbGxvY01haW5Bcmd2KHRydWUsIGxpc3QpO1xuXG4gIFxuICB0YXJnZXQuYWxsb2NNYWluQXJndiA9IChsaXN0KT0+X19hbGxvY01haW5Bcmd2KGZhbHNlLCBsaXN0KTtcblxuICBcbiAgdGFyZ2V0LmNBcmd2VG9KcyA9IChhcmdjLCBwQXJndik9PntcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFyZ2M7ICsraSl7XG4gICAgICBjb25zdCBhcmcgPSB0YXJnZXQucGVla1B0cihwQXJndiArICh0YXJnZXQucHRyU2l6ZW9mICogaSkpO1xuICAgICAgbGlzdC5wdXNoKCBhcmcgPyB0YXJnZXQuY3N0clRvSnMoYXJnKSA6IG51bGwgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5zY29wZWRBbGxvY0NhbGwgPSBmdW5jdGlvbihmdW5jKXtcbiAgICB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgdHJ5eyByZXR1cm4gZnVuYygpIH0gZmluYWxseXsgdGFyZ2V0LnNjb3BlZEFsbG9jUG9wKCkgfVxuICB9O1xuXG4gIFxuICBjb25zdCBfX2FsbG9jUHRyID0gZnVuY3Rpb24oaG93TWFueSwgc2FmZVB0clNpemUsIG1ldGhvZCl7XG4gICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsIG1ldGhvZCk7XG4gICAgY29uc3QgcElyID0gc2FmZVB0clNpemUgPyAnaTY0JyA6IHB0cklSO1xuICAgIGxldCBtID0gdGFyZ2V0W21ldGhvZF0oaG93TWFueSAqIChzYWZlUHRyU2l6ZSA/IDggOiBwdHJTaXplb2YpKTtcbiAgICB0YXJnZXQucG9rZShtLCAwLCBwSXIpXG4gICAgaWYoMT09PWhvd01hbnkpe1xuICAgICAgcmV0dXJuIG07XG4gICAgfVxuICAgIGNvbnN0IGEgPSBbbV07XG4gICAgZm9yKGxldCBpID0gMTsgaSA8IGhvd01hbnk7ICsraSl7XG4gICAgICBtICs9IChzYWZlUHRyU2l6ZSA/IDggOiBwdHJTaXplb2YpO1xuICAgICAgYVtpXSA9IG07XG4gICAgICB0YXJnZXQucG9rZShtLCAwLCBwSXIpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmFsbG9jUHRyID1cbiAgICAoaG93TWFueT0xLCBzYWZlUHRyU2l6ZT10cnVlKT0+X19hbGxvY1B0cihob3dNYW55LCBzYWZlUHRyU2l6ZSwgJ2FsbG9jJyk7XG5cbiAgXG4gIHRhcmdldC5zY29wZWRBbGxvY1B0ciA9XG4gICAgKGhvd01hbnk9MSwgc2FmZVB0clNpemU9dHJ1ZSk9Pl9fYWxsb2NQdHIoaG93TWFueSwgc2FmZVB0clNpemUsICdzY29wZWRBbGxvYycpO1xuXG4gIFxuICB0YXJnZXQueEdldCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB0YXJnZXQuZXhwb3J0c1tuYW1lXSB8fCB0b3NzKFwiQ2Fubm90IGZpbmQgZXhwb3J0ZWQgc3ltYm9sOlwiLG5hbWUpO1xuICB9O1xuXG4gIGNvbnN0IF9fYXJnY01pc21hdGNoID1cbiAgICAgICAgKGYsbik9PnRvc3MoZitcIigpIHJlcXVpcmVzXCIsbixcImFyZ3VtZW50KHMpLlwiKTtcblxuICBcbiAgdGFyZ2V0LnhDYWxsID0gZnVuY3Rpb24oZm5hbWUsIC4uLmFyZ3Mpe1xuICAgIGNvbnN0IGYgPSB0YXJnZXQueEdldChmbmFtZSk7XG4gICAgaWYoIShmIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB0b3NzKFwiRXhwb3J0ZWQgc3ltYm9sXCIsZm5hbWUsXCJpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgaWYoZi5sZW5ndGghPT1hcmdzLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZm5hbWUsZi5sZW5ndGgpXG4gICAgO1xuICAgIHJldHVybiAoMj09PWFyZ3VtZW50cy5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pKVxuICAgICAgPyBmLmFwcGx5KG51bGwsIGFyZ3VtZW50c1sxXSlcbiAgICAgIDogZi5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICBcbiAgY2FjaGUueFdyYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjYWNoZS54V3JhcC5jb252ZXJ0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgXG4gIGNhY2hlLnhXcmFwLmNvbnZlcnQuYXJnID0gbmV3IE1hcDtcbiAgXG4gIGNhY2hlLnhXcmFwLmNvbnZlcnQucmVzdWx0ID0gbmV3IE1hcDtcbiAgY29uc3QgeEFyZyA9IGNhY2hlLnhXcmFwLmNvbnZlcnQuYXJnLCB4UmVzdWx0ID0gY2FjaGUueFdyYXAuY29udmVydC5yZXN1bHQ7XG5cbiAgaWYodGFyZ2V0LmJpZ0ludEVuYWJsZWQpe1xuICAgIHhBcmcuc2V0KCdpNjQnLCAoaSk9PkJpZ0ludChpKSk7XG4gIH1cbiAgY29uc3QgX194QXJnUHRyID0gJ2kzMicgPT09IHB0cklSXG4gICAgICAgID8gKChpKT0+KGkgfCAwKSkgOiAoKGkpPT4oQmlnSW50KGkpIHwgQmlnSW50KDApKSk7XG4gIHhBcmcuc2V0KCdpMzInLCBfX3hBcmdQdHIgKVxuICAgIC5zZXQoJ2kxNicsIChpKT0+KChpIHwgMCkgJiAweEZGRkYpKVxuICAgIC5zZXQoJ2k4JywgKGkpPT4oKGkgfCAwKSAmIDB4RkYpKVxuICAgIC5zZXQoJ2YzMicsIChpKT0+TnVtYmVyKGkpLnZhbHVlT2YoKSlcbiAgICAuc2V0KCdmbG9hdCcsIHhBcmcuZ2V0KCdmMzInKSlcbiAgICAuc2V0KCdmNjQnLCB4QXJnLmdldCgnZjMyJykpXG4gICAgLnNldCgnZG91YmxlJywgeEFyZy5nZXQoJ2Y2NCcpKVxuICAgIC5zZXQoJ2ludCcsIHhBcmcuZ2V0KCdpMzInKSlcbiAgICAuc2V0KCdudWxsJywgKGkpPT5pKVxuICAgIC5zZXQobnVsbCwgeEFyZy5nZXQoJ251bGwnKSlcbiAgICAuc2V0KCcqKicsIF9feEFyZ1B0cilcbiAgICAuc2V0KCcqJywgX194QXJnUHRyKTtcbiAgeFJlc3VsdC5zZXQoJyonLCBfX3hBcmdQdHIpXG4gICAgLnNldCgncG9pbnRlcicsIF9feEFyZ1B0cilcbiAgICAuc2V0KCdudW1iZXInLCAodik9Pk51bWJlcih2KSlcbiAgICAuc2V0KCd2b2lkJywgKHYpPT51bmRlZmluZWQpXG4gICAgLnNldCgnbnVsbCcsICh2KT0+dilcbiAgICAuc2V0KG51bGwsIHhSZXN1bHQuZ2V0KCdudWxsJykpO1xuXG4gIHsgXG4gICAgY29uc3QgY29weVRvUmVzdWx0ID0gWydpOCcsICdpMTYnLCAnaTMyJywgJ2ludCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdmMzInLCAnZmxvYXQnLCAnZjY0JywgJ2RvdWJsZSddO1xuICAgIGlmKHRhcmdldC5iaWdJbnRFbmFibGVkKSBjb3B5VG9SZXN1bHQucHVzaCgnaTY0Jyk7XG4gICAgY29uc3QgYWRhcHRQdHIgPSB4QXJnLmdldChwdHJJUik7XG4gICAgZm9yKGNvbnN0IHQgb2YgY29weVRvUmVzdWx0KXtcbiAgICAgIHhBcmcuc2V0KHQrJyonLCBhZGFwdFB0cik7XG4gICAgICB4UmVzdWx0LnNldCh0KycqJywgYWRhcHRQdHIpO1xuICAgICAgeFJlc3VsdC5zZXQodCwgKHhBcmcuZ2V0KHQpIHx8IHRvc3MoXCJNaXNzaW5nIGFyZyBjb252ZXJ0ZXI6XCIsdCkpKTtcbiAgICB9XG4gIH1cblxuICBcbiAgY29uc3QgX194QXJnU3RyaW5nID0gZnVuY3Rpb24odil7XG4gICAgaWYoJ3N0cmluZyc9PT10eXBlb2YgdikgcmV0dXJuIHRhcmdldC5zY29wZWRBbGxvY0NTdHJpbmcodik7XG4gICAgcmV0dXJuIHYgPyBfX3hBcmdQdHIodikgOiBudWxsO1xuICB9O1xuICB4QXJnLnNldCgnc3RyaW5nJywgX194QXJnU3RyaW5nKVxuICAgIC5zZXQoJ3V0ZjgnLCBfX3hBcmdTdHJpbmcpXG4gICAgLnNldCgncG9pbnRlcicsIF9feEFyZ1N0cmluZyk7XG4gIFxuXG4gIHhSZXN1bHQuc2V0KCdzdHJpbmcnLCAoaSk9PnRhcmdldC5jc3RyVG9KcyhpKSlcbiAgICAuc2V0KCd1dGY4JywgeFJlc3VsdC5nZXQoJ3N0cmluZycpKVxuICAgIC5zZXQoJ3N0cmluZzpkZWFsbG9jJywgKGkpPT57XG4gICAgICB0cnkgeyByZXR1cm4gaSA/IHRhcmdldC5jc3RyVG9KcyhpKSA6IG51bGwgfVxuICAgICAgZmluYWxseXsgdGFyZ2V0LmRlYWxsb2MoaSkgfVxuICAgIH0pXG4gICAgLnNldCgndXRmODpkZWFsbG9jJywgeFJlc3VsdC5nZXQoJ3N0cmluZzpkZWFsbG9jJykpXG4gICAgLnNldCgnanNvbicsIChpKT0+SlNPTi5wYXJzZSh0YXJnZXQuY3N0clRvSnMoaSkpKVxuICAgIC5zZXQoJ2pzb246ZGVhbGxvYycsIChpKT0+e1xuICAgICAgdHJ5eyByZXR1cm4gaSA/IEpTT04ucGFyc2UodGFyZ2V0LmNzdHJUb0pzKGkpKSA6IG51bGwgfVxuICAgICAgZmluYWxseXsgdGFyZ2V0LmRlYWxsb2MoaSkgfVxuICAgIH0pO1xuXG4gIFxuICBjb25zdCBBYnN0cmFjdEFyZ0FkYXB0ZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iob3B0KXtcbiAgICAgIHRoaXMubmFtZSA9IG9wdC5uYW1lIHx8ICd1bm5hbWVkIGFkYXB0ZXInO1xuICAgIH1cbiAgICBcbiAgICBjb252ZXJ0QXJnKHYsYXJndixhcmdJbmRleCl7XG4gICAgICB0b3NzKFwiQWJzdHJhY3RBcmdBZGFwdGVyIG11c3QgYmUgc3ViY2xhc3NlZC5cIik7XG4gICAgfVxuICB9O1xuXG4gIFxuICB4QXJnLkZ1bmNQdHJBZGFwdGVyID0gY2xhc3MgRnVuY1B0ckFkYXB0ZXIgZXh0ZW5kcyBBYnN0cmFjdEFyZ0FkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgc3VwZXIob3B0KTtcbiAgICAgIGlmKHhBcmcuRnVuY1B0ckFkYXB0ZXIud2Fybk9uVXNlKXtcbiAgICAgICAgY29uc29sZS53YXJuKCd4QXJnLkZ1bmNQdHJBZGFwdGVyIGlzIGFuIGludGVybmFsLW9ubHkgQVBJJyxcbiAgICAgICAgICAgICAgICAgICAgICdhbmQgaXMgbm90IGludGVuZGVkIHRvIGJlIGludm9rZWQgZnJvbScsXG4gICAgICAgICAgICAgICAgICAgICAnY2xpZW50LWxldmVsIGNvZGUuIEludm9rZWQgd2l0aDonLG9wdCk7XG4gICAgICB9XG4gICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCBcInVubmFtZWRcIjtcbiAgICAgIHRoaXMuc2lnbmF0dXJlID0gb3B0LnNpZ25hdHVyZTtcbiAgICAgIGlmKG9wdC5jb250ZXh0S2V5IGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICB0aGlzLmNvbnRleHRLZXkgPSBvcHQuY29udGV4dEtleTtcbiAgICAgICAgaWYoIW9wdC5iaW5kU2NvcGUpIG9wdC5iaW5kU2NvcGUgPSAnY29udGV4dCc7XG4gICAgICB9XG4gICAgICB0aGlzLmJpbmRTY29wZSA9IG9wdC5iaW5kU2NvcGVcbiAgICAgICAgfHwgdG9zcyhcIkZ1bmNQdHJBZGFwdGVyIG9wdGlvbnMgcmVxdWlyZXMgYSBiaW5kU2NvcGUgKGV4cGxpY2l0IG9yIGltcGxpZWQpLlwiKTtcbiAgICAgIGlmKEZ1bmNQdHJBZGFwdGVyLmJpbmRTY29wZXMuaW5kZXhPZihvcHQuYmluZFNjb3BlKTwwKXtcbiAgICAgICAgdG9zcyhcIkludmFsaWQgb3B0aW9ucy5iaW5kU2NvcGUgKFwiK29wdC5iaW5kTW9kK1wiKSBmb3IgRnVuY1B0ckFkYXB0ZXIuIFwiK1xuICAgICAgICAgICAgIFwiRXhwZWN0aW5nIG9uZSBvZjogKFwiK0Z1bmNQdHJBZGFwdGVyLmJpbmRTY29wZXMuam9pbignLCAnKSsnKScpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1RyYW5zaWVudCA9ICd0cmFuc2llbnQnPT09dGhpcy5iaW5kU2NvcGU7XG4gICAgICB0aGlzLmlzQ29udGV4dCA9ICdjb250ZXh0Jz09PXRoaXMuYmluZFNjb3BlO1xuICAgICAgdGhpcy5pc1Blcm1hbmVudCA9ICdwZXJtYW5lbnQnPT09dGhpcy5iaW5kU2NvcGU7XG4gICAgICB0aGlzLnNpbmdsZXRvbiA9ICgnc2luZ2xldG9uJz09PXRoaXMuYmluZFNjb3BlKSA/IFtdIDogdW5kZWZpbmVkO1xuICAgICAgXG4gICAgICB0aGlzLmNhbGxQcm94eSA9IChvcHQuY2FsbFByb3h5IGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgID8gb3B0LmNhbGxQcm94eSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBcblxuICAgIFxuICAgIGNvbnRleHRLZXkoYXJndixhcmdJbmRleCl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBcbiAgICBjb250ZXh0TWFwKGtleSl7XG4gICAgICBjb25zdCBjbSA9ICh0aGlzLl9fY21hcCB8fCAodGhpcy5fX2NtYXAgPSBuZXcgTWFwKSk7XG4gICAgICBsZXQgcmMgPSBjbS5nZXQoa2V5KTtcbiAgICAgIGlmKHVuZGVmaW5lZD09PXJjKSBjbS5zZXQoa2V5LCAocmMgPSBbXSkpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH1cblxuICAgIFxuICAgIGNvbnZlcnRBcmcodixhcmd2LGFyZ0luZGV4KXtcbiAgICAgIFxuICAgICAgbGV0IHBhaXIgPSB0aGlzLnNpbmdsZXRvbjtcbiAgICAgIGlmKCFwYWlyICYmIHRoaXMuaXNDb250ZXh0KXtcbiAgICAgICAgcGFpciA9IHRoaXMuY29udGV4dE1hcCh0aGlzLmNvbnRleHRLZXkoYXJndixhcmdJbmRleCkpO1xuICAgICAgICBcbiAgICAgIH1cbiAgICAgIGlmKHBhaXIgJiYgcGFpclswXT09PXYpIHJldHVybiBwYWlyWzFdO1xuICAgICAgaWYodiBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmNhbGxQcm94eSkgdiA9IHRoaXMuY2FsbFByb3h5KHYpO1xuICAgICAgICBjb25zdCBmcCA9IF9faW5zdGFsbEZ1bmN0aW9uKHYsIHRoaXMuc2lnbmF0dXJlLCB0aGlzLmlzVHJhbnNpZW50KTtcbiAgICAgICAgaWYoRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCl7XG4gICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXCJGdW5jUHRyQWRhcHRlciBpbnN0YWxsZWRcIiwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRLZXkoYXJndixhcmdJbmRleCksICdAJytmcCwgdik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFpcil7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYocGFpclsxXSl7XG4gICAgICAgICAgICBpZihGdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsKXtcbiAgICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXCJGdW5jUHRyQWRhcHRlciB1bmluc3RhbGxpbmdcIiwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0S2V5KGFyZ3YsYXJnSW5kZXgpLCAnQCcrcGFpclsxXSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjYWNoZS5zY29wZWRBbGxvY1tjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgtMV0ucHVzaChwYWlyWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpe31cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFpclswXSA9IHY7XG4gICAgICAgICAgcGFpclsxXSA9IGZwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcDtcbiAgICAgIH1lbHNlIGlmKHRhcmdldC5pc1B0cih2KSB8fCBudWxsPT09diB8fCB1bmRlZmluZWQ9PT12KXtcbiAgICAgICAgXG4gICAgICAgIGlmKHBhaXIgJiYgcGFpclsxXSAmJiBwYWlyWzFdIT09dil7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCl7XG4gICAgICAgICAgICBGdW5jUHRyQWRhcHRlci5kZWJ1Z091dChcIkZ1bmNQdHJBZGFwdGVyIHVuaW5zdGFsbGluZ1wiLCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0S2V5KGFyZ3YsYXJnSW5kZXgpLCAnQCcrcGFpclsxXSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeXsgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoLTFdLnB1c2gocGFpclsxXSkgfVxuICAgICAgICAgIGNhdGNoKGUpe31cbiAgICAgICAgICBwYWlyWzBdID0gcGFpclsxXSA9ICh2IHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYgfHwgMDtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBGdW5jUHRyQWRhcHRlciBhcmd1bWVudCB0eXBlLiBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGluZyBhIGZ1bmN0aW9uIHBvaW50ZXIgb3IgYSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5uYW1lID8gdGhpcy5uYW1lKycgJyA6ICcnKStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIG1hdGNoaW5nIHNpZ25hdHVyZSBcIitcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpZ25hdHVyZStcIi5cIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFxuICB4QXJnLkZ1bmNQdHJBZGFwdGVyLndhcm5PblVzZSA9IGZhbHNlO1xuXG4gIFxuICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwgPSBmYWxzZTtcblxuICBcbiAgeEFyZy5GdW5jUHRyQWRhcHRlci5kZWJ1Z091dCA9IGNvbnNvbGUuZGVidWcuYmluZChjb25zb2xlKTtcblxuICB4QXJnLkZ1bmNQdHJBZGFwdGVyLmJpbmRTY29wZXMgPSBbXG4gICAgJ3RyYW5zaWVudCcsICdjb250ZXh0JywgJ3NpbmdsZXRvbicsICdwZXJtYW5lbnQnXG4gIF07XG5cbiAgY29uc3QgX194QXJnQWRhcHRlckNoZWNrID1cbiAgICAgICAgKHQpPT54QXJnLmdldCh0KSB8fCB0b3NzKFwiQXJndW1lbnQgYWRhcHRlciBub3QgZm91bmQ6XCIsdCk7XG5cbiAgY29uc3QgX194UmVzdWx0QWRhcHRlckNoZWNrID1cbiAgICAgICAgKHQpPT54UmVzdWx0LmdldCh0KSB8fCB0b3NzKFwiUmVzdWx0IGFkYXB0ZXIgbm90IGZvdW5kOlwiLHQpO1xuXG4gIGNhY2hlLnhXcmFwLmNvbnZlcnRBcmcgPSAodCwuLi5hcmdzKT0+X194QXJnQWRhcHRlckNoZWNrKHQpKC4uLmFyZ3MpO1xuICBjYWNoZS54V3JhcC5jb252ZXJ0QXJnTm9DaGVjayA9ICh0LC4uLmFyZ3MpPT54QXJnLmdldCh0KSguLi5hcmdzKTtcblxuICBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0ID1cbiAgICAodCx2KT0+KG51bGw9PT10ID8gdiA6ICh0ID8gX194UmVzdWx0QWRhcHRlckNoZWNrKHQpKHYpIDogdW5kZWZpbmVkKSk7XG4gIGNhY2hlLnhXcmFwLmNvbnZlcnRSZXN1bHROb0NoZWNrID1cbiAgICAodCx2KT0+KG51bGw9PT10ID8gdiA6ICh0ID8geFJlc3VsdC5nZXQodCkodikgOiB1bmRlZmluZWQpKTtcblxuICBcbiAgdGFyZ2V0LnhXcmFwID0gZnVuY3Rpb24oZkFyZywgcmVzdWx0VHlwZSwgLi4uYXJnVHlwZXMpe1xuICAgIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSl7XG4gICAgICBhcmdUeXBlcyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gICAgaWYodGFyZ2V0LmlzUHRyKGZBcmcpKXtcbiAgICAgIGZBcmcgPSB0YXJnZXQuZnVuY3Rpb25FbnRyeShmQXJnKVxuICAgICAgICB8fCB0b3NzKFwiRnVuY3Rpb24gcG9pbnRlciBub3QgZm91bmQgaW4gV0FTTSBmdW5jdGlvbiB0YWJsZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGZJc0Z1bmMgPSAoZkFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcbiAgICBjb25zdCB4ZiA9IGZJc0Z1bmMgPyBmQXJnIDogdGFyZ2V0LnhHZXQoZkFyZyk7XG4gICAgaWYoZklzRnVuYykgZkFyZyA9IHhmLm5hbWUgfHwgJ3VubmFtZWQgZnVuY3Rpb24nO1xuICAgIGlmKGFyZ1R5cGVzLmxlbmd0aCE9PXhmLmxlbmd0aCkgX19hcmdjTWlzbWF0Y2goZkFyZywgeGYubGVuZ3RoKTtcbiAgICBpZigobnVsbD09PXJlc3VsdFR5cGUpICYmIDA9PT14Zi5sZW5ndGgpe1xuICAgICAgXG4gICAgICByZXR1cm4geGY7XG4gICAgfVxuICAgIDtcbiAgICBpZih1bmRlZmluZWQhPT1yZXN1bHRUeXBlICYmIG51bGwhPT1yZXN1bHRUeXBlKSBfX3hSZXN1bHRBZGFwdGVyQ2hlY2socmVzdWx0VHlwZSk7XG4gICAgZm9yKGNvbnN0IHQgb2YgYXJnVHlwZXMpe1xuICAgICAgaWYodCBpbnN0YW5jZW9mIEFic3RyYWN0QXJnQWRhcHRlcikgeEFyZy5zZXQodCwgKC4uLmFyZ3MpPT50LmNvbnZlcnRBcmcoLi4uYXJncykpO1xuICAgICAgZWxzZSBfX3hBcmdBZGFwdGVyQ2hlY2sodCk7XG4gICAgfVxuICAgIGNvbnN0IGN4dyA9IGNhY2hlLnhXcmFwO1xuICAgIGlmKDA9PT14Zi5sZW5ndGgpe1xuICAgICAgXG4gICAgICByZXR1cm4gKC4uLmFyZ3MpPT4oYXJncy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICA/IF9fYXJnY01pc21hdGNoKGZBcmcsIHhmLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IGN4dy5jb252ZXJ0UmVzdWx0KHJlc3VsdFR5cGUsIHhmLmNhbGwobnVsbCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3Mpe1xuICAgICAgaWYoYXJncy5sZW5ndGghPT14Zi5sZW5ndGgpIF9fYXJnY01pc21hdGNoKGZBcmcsIHhmLmxlbmd0aCk7XG4gICAgICBjb25zdCBzY29wZSA9IHRhcmdldC5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgIHRyeXtcbiAgICAgICAgXG4gICAgICAgIGZvcihjb25zdCBpIGluIGFyZ3MpIGFyZ3NbaV0gPSBjeHcuY29udmVydEFyZ05vQ2hlY2soXG4gICAgICAgICAgYXJnVHlwZXNbaV0sIGFyZ3NbaV0sIGFyZ3MsIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGN4dy5jb252ZXJ0UmVzdWx0Tm9DaGVjayhyZXN1bHRUeXBlLCB4Zi5hcHBseShudWxsLGFyZ3MpKTtcbiAgICAgIH1maW5hbGx5e1xuICAgICAgICB0YXJnZXQuc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9feEFkYXB0ZXIgPSBmdW5jdGlvbihmdW5jLCBhcmdjLCB0eXBlTmFtZSwgYWRhcHRlciwgbW9kZU5hbWUsIHhjdlBhcnQpe1xuICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIHR5cGVOYW1lKXtcbiAgICAgIGlmKDE9PT1hcmdjKSByZXR1cm4geGN2UGFydC5nZXQodHlwZU5hbWUpO1xuICAgICAgZWxzZSBpZigyPT09YXJnYyl7XG4gICAgICAgIGlmKCFhZGFwdGVyKXtcbiAgICAgICAgICBkZWxldGUgeGN2UGFydC5nZXQodHlwZU5hbWUpO1xuICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9ZWxzZSBpZighKGFkYXB0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgICAgICAgIHRvc3MobW9kZU5hbWUsXCJyZXF1aXJlcyBhIGZ1bmN0aW9uIGFyZ3VtZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB4Y3ZQYXJ0LnNldCh0eXBlTmFtZSwgYWRhcHRlcik7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgIH1cbiAgICB0b3NzKFwiSW52YWxpZCBhcmd1bWVudHMgdG9cIixtb2RlTmFtZSk7XG4gIH07XG5cbiAgXG4gIHRhcmdldC54V3JhcC5yZXN1bHRBZGFwdGVyID0gZnVuY3Rpb24gZih0eXBlTmFtZSwgYWRhcHRlcil7XG4gICAgcmV0dXJuIF9feEFkYXB0ZXIoZiwgYXJndW1lbnRzLmxlbmd0aCwgdHlwZU5hbWUsIGFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Jlc3VsdEFkYXB0ZXIoKScsIHhSZXN1bHQpO1xuICB9O1xuXG4gIFxuICB0YXJnZXQueFdyYXAuYXJnQWRhcHRlciA9IGZ1bmN0aW9uIGYodHlwZU5hbWUsIGFkYXB0ZXIpe1xuICAgIHJldHVybiBfX3hBZGFwdGVyKGYsIGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVOYW1lLCBhZGFwdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICdhcmdBZGFwdGVyKCknLCB4QXJnKTtcbiAgfTtcblxuICB0YXJnZXQueFdyYXAuRnVuY1B0ckFkYXB0ZXIgPSB4QXJnLkZ1bmNQdHJBZGFwdGVyO1xuXG4gIFxuICB0YXJnZXQueENhbGxXcmFwcGVkID0gZnVuY3Rpb24oZkFyZywgcmVzdWx0VHlwZSwgYXJnVHlwZXMsIC4uLmFyZ3Mpe1xuICAgIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzNdKSkgYXJncyA9IGFyZ3VtZW50c1szXTtcbiAgICByZXR1cm4gdGFyZ2V0LnhXcmFwKGZBcmcsIHJlc3VsdFR5cGUsIGFyZ1R5cGVzfHxbXSkuYXBwbHkobnVsbCwgYXJnc3x8W10pO1xuICB9O1xuXG4gIFxuICB0YXJnZXQueFdyYXAudGVzdENvbnZlcnRBcmcgPSBjYWNoZS54V3JhcC5jb252ZXJ0QXJnO1xuXG4gIFxuICB0YXJnZXQueFdyYXAudGVzdENvbnZlcnRSZXN1bHQgPSBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0O1xuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlci55YXdsID0gZnVuY3Rpb24oY29uZmlnKXtcbiAgY29uc3Qgd2ZldGNoID0gKCk9PmZldGNoKGNvbmZpZy51cmksIHtjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ30pO1xuICBjb25zdCB3dWkgPSB0aGlzO1xuICBjb25zdCBmaW5hbFRoZW4gPSBmdW5jdGlvbihhcmcpe1xuICAgIFxuICAgIGlmKGNvbmZpZy53YXNtVXRpbFRhcmdldCl7XG4gICAgICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpPT57dGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKX07XG4gICAgICBjb25zdCB0Z3QgPSBjb25maWcud2FzbVV0aWxUYXJnZXQ7XG4gICAgICB0Z3QubW9kdWxlID0gYXJnLm1vZHVsZTtcbiAgICAgIHRndC5pbnN0YW5jZSA9IGFyZy5pbnN0YW5jZTtcbiAgICAgIFxuICAgICAgaWYoIXRndC5pbnN0YW5jZS5leHBvcnRzLm1lbW9yeSl7XG4gICAgICAgIFxuICAgICAgICB0Z3QubWVtb3J5ID0gKGNvbmZpZy5pbXBvcnRzICYmIGNvbmZpZy5pbXBvcnRzLmVudlxuICAgICAgICAgICAgICAgICAgICAgICYmIGNvbmZpZy5pbXBvcnRzLmVudi5tZW1vcnkpXG4gICAgICAgICAgfHwgdG9zcyhcIk1pc3NpbmcgJ21lbW9yeScgb2JqZWN0IVwiKTtcbiAgICAgIH1cbiAgICAgIGlmKCF0Z3QuYWxsb2MgJiYgYXJnLmluc3RhbmNlLmV4cG9ydHMubWFsbG9jKXtcbiAgICAgICAgY29uc3QgZXhwb3J0cyA9IGFyZy5pbnN0YW5jZS5leHBvcnRzO1xuICAgICAgICB0Z3QuYWxsb2MgPSBmdW5jdGlvbihuKXtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0cy5tYWxsb2MobikgfHwgdG9zcyhcIkFsbG9jYXRpb24gb2ZcIixuLFwiYnl0ZXMgZmFpbGVkLlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGd0LmRlYWxsb2MgPSBmdW5jdGlvbihtKXtleHBvcnRzLmZyZWUobSl9O1xuICAgICAgfVxuICAgICAgd3VpKHRndCk7XG4gICAgfVxuICAgIGlmKGNvbmZpZy5vbmxvYWQpIGNvbmZpZy5vbmxvYWQoYXJnLGNvbmZpZyk7XG4gICAgcmV0dXJuIGFyZyA7XG4gIH07XG4gIGNvbnN0IGxvYWRXYXNtID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdcbiAgICAgICAgPyBmdW5jdGlvbiBsb2FkV2FzbVN0cmVhbWluZygpe1xuICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh3ZmV0Y2goKSwgY29uZmlnLmltcG9ydHN8fHt9KVxuICAgICAgICAgICAgLnRoZW4oZmluYWxUaGVuKTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uIGxvYWRXYXNtT2xkU2Nob29sKCl7IFxuICAgICAgICAgIHJldHVybiB3ZmV0Y2goKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICAgIC50aGVuKGJ5dGVzID0+IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBjb25maWcuaW1wb3J0c3x8e30pKVxuICAgICAgICAgICAgLnRoZW4oZmluYWxUaGVuKTtcbiAgICAgICAgfTtcbiAgcmV0dXJuIGxvYWRXYXNtO1xufS5iaW5kKGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcik7XG5cblxuXG4ndXNlIHN0cmljdCc7XG5nbG9iYWxUaGlzLkphY2N3YWJ5dCA9IGZ1bmN0aW9uIFN0cnVjdEJpbmRlckZhY3RvcnkoY29uZmlnKXtcblxuXG4gIFxuICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpPT57dGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKX07XG5cbiAgXG4gIGlmKCEoY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5NZW1vcnkpXG4gICAgICYmICEoY29uZmlnLmhlYXAgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgIHRvc3MoXCJjb25maWcuaGVhcCBtdXN0IGJlIFdlYkFzc2VtYmx5Lk1lbW9yeSBpbnN0YW5jZSBvciBhIGZ1bmN0aW9uLlwiKTtcbiAgfVxuICBbJ2FsbG9jJywnZGVhbGxvYyddLmZvckVhY2goZnVuY3Rpb24oayl7XG4gICAgKGNvbmZpZ1trXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fFxuICAgICAgdG9zcyhcIkNvbmZpZyBvcHRpb24gJ1wiK2srXCInIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gIH0pO1xuICBjb25zdCBTQkYgPSBTdHJ1Y3RCaW5kZXJGYWN0b3J5O1xuICBjb25zdCBoZWFwID0gKGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgID8gY29uZmlnLmhlYXAgOiAoKCk9Pm5ldyBVaW50OEFycmF5KGNvbmZpZy5oZWFwLmJ1ZmZlcikpLFxuICAgICAgICBhbGxvYyA9IGNvbmZpZy5hbGxvYyxcbiAgICAgICAgZGVhbGxvYyA9IGNvbmZpZy5kZWFsbG9jLFxuICAgICAgICBsb2cgPSBjb25maWcubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gICAgICAgIG1lbWJlclByZWZpeCA9IChjb25maWcubWVtYmVyUHJlZml4IHx8IFwiXCIpLFxuICAgICAgICBtZW1iZXJTdWZmaXggPSAoY29uZmlnLm1lbWJlclN1ZmZpeCB8fCBcIlwiKSxcbiAgICAgICAgYmlnSW50RW5hYmxlZCA9ICh1bmRlZmluZWQ9PT1jb25maWcuYmlnSW50RW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgID8gISFnbG9iYWxUaGlzWydCaWdJbnQ2NEFycmF5J10gOiAhIWNvbmZpZy5iaWdJbnRFbmFibGVkKSxcbiAgICAgICAgQmlnSW50ID0gZ2xvYmFsVGhpc1snQmlnSW50J10sXG4gICAgICAgIEJpZ0ludDY0QXJyYXkgPSBnbG9iYWxUaGlzWydCaWdJbnQ2NEFycmF5J10sXG4gICAgICAgIFxuICAgICAgICBwdHJTaXplb2YgPSBjb25maWcucHRyU2l6ZW9mIHx8IDQsXG4gICAgICAgIHB0cklSID0gY29uZmlnLnB0cklSIHx8ICdpMzInXG4gIDtcblxuICBpZighU0JGLmRlYnVnRmxhZ3Mpe1xuICAgIFNCRi5fX21ha2VEZWJ1Z0ZsYWdzID0gZnVuY3Rpb24oZGVyaXZlRnJvbT1udWxsKXtcbiAgICAgIFxuICAgICAgaWYoZGVyaXZlRnJvbSAmJiBkZXJpdmVGcm9tLl9fZmxhZ3MpIGRlcml2ZUZyb20gPSBkZXJpdmVGcm9tLl9fZmxhZ3M7XG4gICAgICBjb25zdCBmID0gZnVuY3Rpb24gZihmbGFncyl7XG4gICAgICAgIGlmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICByZXR1cm4gZi5fX2ZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZsYWdzPDApe1xuICAgICAgICAgIGRlbGV0ZSBmLl9fZmxhZ3MuZ2V0dGVyOyBkZWxldGUgZi5fX2ZsYWdzLnNldHRlcjtcbiAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmFsbG9jOyBkZWxldGUgZi5fX2ZsYWdzLmRlYWxsb2M7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGYuX19mbGFncy5nZXR0ZXIgID0gMCE9PSgweDAxICYgZmxhZ3MpO1xuICAgICAgICAgIGYuX19mbGFncy5zZXR0ZXIgID0gMCE9PSgweDAyICYgZmxhZ3MpO1xuICAgICAgICAgIGYuX19mbGFncy5hbGxvYyAgID0gMCE9PSgweDA0ICYgZmxhZ3MpO1xuICAgICAgICAgIGYuX19mbGFncy5kZWFsbG9jID0gMCE9PSgweDA4ICYgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmLl9mbGFncztcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwnX19mbGFncycsIHtcbiAgICAgICAgaXRlcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBPYmplY3QuY3JlYXRlKGRlcml2ZUZyb20pXG4gICAgICB9KTtcbiAgICAgIGlmKCFkZXJpdmVGcm9tKSBmKDApO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbiAgICBTQkYuZGVidWdGbGFncyA9IFNCRi5fX21ha2VEZWJ1Z0ZsYWdzKCk7XG4gIH1cblxuICBjb25zdCBpc0xpdHRsZUVuZGlhbiA9IChmdW5jdGlvbigpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlICk7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlcilbMF0gPT09IDI1NjtcbiAgfSkoKTtcbiAgXG5cbiAgXG4gIGNvbnN0IGlzRnVuY1NpZyA9IChzKT0+JygnPT09c1sxXTtcbiAgXG4gIGNvbnN0IGlzUHRyU2lnID0gKHMpPT4ncCc9PT1zIHx8ICdQJz09PXM7XG4gIGNvbnN0IGlzQXV0b1B0clNpZyA9IChzKT0+J1AnPT09cyA7XG4gIGNvbnN0IHNpZ0xldHRlciA9IChzKT0+aXNGdW5jU2lnKHMpID8gJ3AnIDogc1swXTtcbiAgXG4gIGNvbnN0IHNpZ0lSID0gZnVuY3Rpb24ocyl7XG4gICAgc3dpdGNoKHNpZ0xldHRlcihzKSl7XG4gICAgICAgIGNhc2UgJ2MnOiBjYXNlICdDJzogcmV0dXJuICdpOCc7XG4gICAgICAgIGNhc2UgJ2knOiByZXR1cm4gJ2kzMic7XG4gICAgICAgIGNhc2UgJ3AnOiBjYXNlICdQJzogY2FzZSAncyc6IHJldHVybiBwdHJJUjtcbiAgICAgICAgY2FzZSAnaic6IHJldHVybiAnaTY0JztcbiAgICAgICAgY2FzZSAnZic6IHJldHVybiAnZmxvYXQnO1xuICAgICAgICBjYXNlICdkJzogcmV0dXJuICdkb3VibGUnO1xuICAgIH1cbiAgICB0b3NzKFwiVW5oYW5kbGVkIHNpZ25hdHVyZSBJUjpcIixzKTtcbiAgfTtcblxuICBjb25zdCBhZmZpcm1CaWdJbnRBcnJheSA9IEJpZ0ludDY0QXJyYXlcbiAgICAgICAgPyAoKT0+dHJ1ZSA6ICgpPT50b3NzKCdCaWdJbnQ2NEFycmF5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG4gIFxuICBjb25zdCBzaWdEVkdldHRlciA9IGZ1bmN0aW9uKHMpe1xuICAgIHN3aXRjaChzaWdMZXR0ZXIocykpIHtcbiAgICAgICAgY2FzZSAncCc6IGNhc2UgJ1AnOiBjYXNlICdzJzoge1xuICAgICAgICAgIHN3aXRjaChwdHJTaXplb2Ype1xuICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiAnZ2V0SW50MzInO1xuICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdnZXRCaWdJbnQ2NCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2knOiByZXR1cm4gJ2dldEludDMyJztcbiAgICAgICAgY2FzZSAnYyc6IHJldHVybiAnZ2V0SW50OCc7XG4gICAgICAgIGNhc2UgJ0MnOiByZXR1cm4gJ2dldFVpbnQ4JztcbiAgICAgICAgY2FzZSAnaic6IHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmICdnZXRCaWdJbnQ2NCc7XG4gICAgICAgIGNhc2UgJ2YnOiByZXR1cm4gJ2dldEZsb2F0MzInO1xuICAgICAgICBjYXNlICdkJzogcmV0dXJuICdnZXRGbG9hdDY0JztcbiAgICB9XG4gICAgdG9zcyhcIlVuaGFuZGxlZCBEYXRhVmlldyBnZXR0ZXIgZm9yIHNpZ25hdHVyZTpcIixzKTtcbiAgfTtcbiAgXG4gIGNvbnN0IHNpZ0RWU2V0dGVyID0gZnVuY3Rpb24ocyl7XG4gICAgc3dpdGNoKHNpZ0xldHRlcihzKSl7XG4gICAgICAgIGNhc2UgJ3AnOiBjYXNlICdQJzogY2FzZSAncyc6IHtcbiAgICAgICAgICBzd2l0Y2gocHRyU2l6ZW9mKXtcbiAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gJ3NldEludDMyJztcbiAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnc2V0QmlnSW50NjQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpJzogcmV0dXJuICdzZXRJbnQzMic7XG4gICAgICAgIGNhc2UgJ2MnOiByZXR1cm4gJ3NldEludDgnO1xuICAgICAgICBjYXNlICdDJzogcmV0dXJuICdzZXRVaW50OCc7XG4gICAgICAgIGNhc2UgJ2onOiByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnc2V0QmlnSW50NjQnO1xuICAgICAgICBjYXNlICdmJzogcmV0dXJuICdzZXRGbG9hdDMyJztcbiAgICAgICAgY2FzZSAnZCc6IHJldHVybiAnc2V0RmxvYXQ2NCc7XG4gICAgfVxuICAgIHRvc3MoXCJVbmhhbmRsZWQgRGF0YVZpZXcgc2V0dGVyIGZvciBzaWduYXR1cmU6XCIscyk7XG4gIH07XG4gIFxuICBjb25zdCBzaWdEVlNldFdyYXBwZXIgPSBmdW5jdGlvbihzKXtcbiAgICBzd2l0Y2goc2lnTGV0dGVyKHMpKSB7XG4gICAgICAgIGNhc2UgJ2knOiBjYXNlICdmJzogY2FzZSAnYyc6IGNhc2UgJ0MnOiBjYXNlICdkJzogcmV0dXJuIE51bWJlcjtcbiAgICAgICAgY2FzZSAnaic6IHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmIEJpZ0ludDtcbiAgICAgICAgY2FzZSAncCc6IGNhc2UgJ1AnOiBjYXNlICdzJzpcbiAgICAgICAgICBzd2l0Y2gocHRyU2l6ZW9mKXtcbiAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gTnVtYmVyO1xuICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBhZmZpcm1CaWdJbnRBcnJheSgpICYmIEJpZ0ludDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRvc3MoXCJVbmhhbmRsZWQgRGF0YVZpZXcgc2V0IHdyYXBwZXIgZm9yIHNpZ25hdHVyZTpcIixzKTtcbiAgfTtcblxuICBcbiAgY29uc3Qgc1Byb3BOYW1lID0gKHMsayk9PnMrJzo6JytrO1xuXG4gIGNvbnN0IF9fcHJvcFRocm93T25TZXQgPSBmdW5jdGlvbihzdHJ1Y3ROYW1lLHByb3BOYW1lKXtcbiAgICByZXR1cm4gKCk9PnRvc3Moc1Byb3BOYW1lKHN0cnVjdE5hbWUscHJvcE5hbWUpLFwiaXMgcmVhZC1vbmx5LlwiKTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19pbnN0YW5jZVBvaW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gIFxuICBjb25zdCB4UHRyUHJvcE5hbWUgPSAnKHBvaW50ZXItaXMtZXh0ZXJuYWwpJztcblxuICBcbiAgY29uc3QgX19mcmVlU3RydWN0ID0gZnVuY3Rpb24oY3Rvciwgb2JqLCBtKXtcbiAgICBpZighbSkgbSA9IF9faW5zdGFuY2VQb2ludGVyTWFwLmdldChvYmopO1xuICAgIGlmKG0pIHtcbiAgICAgIF9faW5zdGFuY2VQb2ludGVyTWFwLmRlbGV0ZShvYmopO1xuICAgICAgaWYoQXJyYXkuaXNBcnJheShvYmoub25kaXNwb3NlKSl7XG4gICAgICAgIGxldCB4O1xuICAgICAgICB3aGlsZSgoeCA9IG9iai5vbmRpc3Bvc2Uuc2hpZnQoKSkpe1xuICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgIGlmKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgeC5jYWxsKG9iaik7XG4gICAgICAgICAgICBlbHNlIGlmKHggaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSB4LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGVsc2UgaWYoJ251bWJlcicgPT09IHR5cGVvZiB4KSBkZWFsbG9jKHgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJvbmRpc3Bvc2UoKSBmb3JcIixjdG9yLnN0cnVjdE5hbWUsJ0AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG0sJ3RocmV3LiBOT1QgcHJvcGFnYXRpbmcgaXQuJyxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmKG9iai5vbmRpc3Bvc2UgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgIHRyeXtvYmoub25kaXNwb3NlKCl9XG4gICAgICAgIGNhdGNoKGUpe1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUud2FybihcIm9uZGlzcG9zZSgpIGZvclwiLGN0b3Iuc3RydWN0TmFtZSwnQCcsXG4gICAgICAgICAgICAgICAgICAgICAgIG0sJ3RocmV3LiBOT1QgcHJvcGFnYXRpbmcgaXQuJyxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIG9iai5vbmRpc3Bvc2U7XG4gICAgICBpZihjdG9yLmRlYnVnRmxhZ3MuX19mbGFncy5kZWFsbG9jKXtcbiAgICAgICAgbG9nKFwiZGVidWcuZGVhbGxvYzpcIiwob2JqW3hQdHJQcm9wTmFtZV0/XCJFWFRFUk5BTFwiOlwiXCIpLFxuICAgICAgICAgICAgY3Rvci5zdHJ1Y3ROYW1lLFwiaW5zdGFuY2U6XCIsXG4gICAgICAgICAgICBjdG9yLnN0cnVjdEluZm8uc2l6ZW9mLFwiYnl0ZXMgQFwiK20pO1xuICAgICAgfVxuICAgICAgaWYoIW9ialt4UHRyUHJvcE5hbWVdKSBkZWFsbG9jKG0pO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY29uc3Qgcm9wID0gKHYpPT57cmV0dXJuIHtjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmFibGU6IGZhbHNlLCB2YWx1ZTogdn19O1xuXG4gIFxuICBjb25zdCBfX2FsbG9jU3RydWN0ID0gZnVuY3Rpb24oY3Rvciwgb2JqLCBtKXtcbiAgICBsZXQgZmlsbCA9ICFtO1xuICAgIGlmKG0pIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHhQdHJQcm9wTmFtZSwgcm9wKG0pKTtcbiAgICBlbHNle1xuICAgICAgbSA9IGFsbG9jKGN0b3Iuc3RydWN0SW5mby5zaXplb2YpO1xuICAgICAgaWYoIW0pIHRvc3MoXCJBbGxvY2F0aW9uIG9mXCIsY3Rvci5zdHJ1Y3ROYW1lLFwic3RydWN0dXJlIGZhaWxlZC5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZihjdG9yLmRlYnVnRmxhZ3MuX19mbGFncy5hbGxvYyl7XG4gICAgICAgIGxvZyhcImRlYnVnLmFsbG9jOlwiLChmaWxsP1wiXCI6XCJFWFRFUk5BTFwiKSxcbiAgICAgICAgICAgIGN0b3Iuc3RydWN0TmFtZSxcImluc3RhbmNlOlwiLFxuICAgICAgICAgICAgY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZixcImJ5dGVzIEBcIittKTtcbiAgICAgIH1cbiAgICAgIGlmKGZpbGwpIGhlYXAoKS5maWxsKDAsIG0sIG0gKyBjdG9yLnN0cnVjdEluZm8uc2l6ZW9mKTtcbiAgICAgIF9faW5zdGFuY2VQb2ludGVyTWFwLnNldChvYmosIG0pO1xuICAgIH1jYXRjaChlKXtcbiAgICAgIF9fZnJlZVN0cnVjdChjdG9yLCBvYmosIG0pO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBfX21lbW9yeUR1bXAgPSBmdW5jdGlvbigpe1xuICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50ZXI7XG4gICAgcmV0dXJuIHBcbiAgICAgID8gbmV3IFVpbnQ4QXJyYXkoaGVhcCgpLnNsaWNlKHAsIHArdGhpcy5zdHJ1Y3RJbmZvLnNpemVvZikpXG4gICAgICA6IG51bGw7XG4gIH07XG5cbiAgY29uc3QgX19tZW1iZXJLZXkgPSAoayk9Pm1lbWJlclByZWZpeCArIGsgKyBtZW1iZXJTdWZmaXg7XG4gIGNvbnN0IF9fbWVtYmVyS2V5UHJvcCA9IHJvcChfX21lbWJlcktleSk7XG5cbiAgXG4gIGNvbnN0IF9fbG9va3VwTWVtYmVyID0gZnVuY3Rpb24oc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQ9dHJ1ZSl7XG4gICAgbGV0IG0gPSBzdHJ1Y3RJbmZvLm1lbWJlcnNbbWVtYmVyTmFtZV07XG4gICAgaWYoIW0gJiYgKG1lbWJlclByZWZpeCB8fCBtZW1iZXJTdWZmaXgpKXtcbiAgICAgIFxuICAgICAgZm9yKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyhzdHJ1Y3RJbmZvLm1lbWJlcnMpKXtcbiAgICAgICAgaWYodi5rZXk9PT1tZW1iZXJOYW1lKXsgbSA9IHY7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgICBpZighbSAmJiB0b3NzSWZOb3RGb3VuZCl7XG4gICAgICAgIHRvc3Moc1Byb3BOYW1lKHN0cnVjdEluZm8ubmFtZSxtZW1iZXJOYW1lKSwnaXMgbm90IGEgbWFwcGVkIHN0cnVjdCBtZW1iZXIuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX21lbWJlclNpZ25hdHVyZSA9IGZ1bmN0aW9uIGYob2JqLG1lbWJlck5hbWUsZW1zY3JpcHRlbkZvcm1hdD1mYWxzZSl7XG4gICAgaWYoIWYuXykgZi5fID0gKHgpPT54LnJlcGxhY2UoL1tedmlwUHNqcmRjQ10vZyxcIlwiKS5yZXBsYWNlKC9bcFBzY0NdL2csJ2knKTtcbiAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgIHJldHVybiBlbXNjcmlwdGVuRm9ybWF0ID8gZi5fKG0uc2lnbmF0dXJlKSA6IG0uc2lnbmF0dXJlO1xuICB9O1xuXG4gIGNvbnN0IF9fcHRyUHJvcERlc2NyaXB0b3IgPSB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbigpe3JldHVybiBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQodGhpcyl9LFxuICAgIHNldDogKCk9PnRvc3MoXCJDYW5ub3QgYXNzaWduIHRoZSAncG9pbnRlcicgcHJvcGVydHkgb2YgYSBzdHJ1Y3QuXCIpXG4gICAgXG4gICAgXG4gICAgXG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fc3RydWN0TWVtYmVyS2V5cyA9IHJvcChmdW5jdGlvbigpe1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBmb3IoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLnN0cnVjdEluZm8ubWVtYmVycykpe1xuICAgICAgYS5wdXNoKHRoaXMubWVtYmVyS2V5KGspKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH0pO1xuXG4gIGNvbnN0IF9fdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gIGNvbnN0IF9fdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgXG4gIGNvbnN0IF9fU0FCID0gKCd1bmRlZmluZWQnPT09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKVxuICAgICAgICA/IGZ1bmN0aW9uKCl7fSA6IFNoYXJlZEFycmF5QnVmZmVyO1xuICBjb25zdCBfX3V0ZjhEZWNvZGUgPSBmdW5jdGlvbihhcnJheUJ1ZmZlciwgYmVnaW4sIGVuZCl7XG4gICAgcmV0dXJuIF9fdXRmOERlY29kZXIuZGVjb2RlKFxuICAgICAgKGFycmF5QnVmZmVyLmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCKVxuICAgICAgICA/IGFycmF5QnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpXG4gICAgICAgIDogYXJyYXlCdWZmZXIuc3ViYXJyYXkoYmVnaW4sIGVuZClcbiAgICApO1xuICB9O1xuICBcbiAgY29uc3QgX19tZW1iZXJJc1N0cmluZyA9IGZ1bmN0aW9uKG9iaixtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZD1mYWxzZSl7XG4gICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgcmV0dXJuIChtICYmIDE9PT1tLnNpZ25hdHVyZS5sZW5ndGggJiYgJ3MnPT09bS5zaWduYXR1cmVbMF0pID8gbSA6IGZhbHNlO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2FmZmlybUNTdHJpbmdTaWduYXR1cmUgPSBmdW5jdGlvbihtZW1iZXIpe1xuICAgIGlmKCdzJz09PW1lbWJlci5zaWduYXR1cmUpIHJldHVybjtcbiAgICB0b3NzKFwiSW52YWxpZCBtZW1iZXIgdHlwZSBzaWduYXR1cmUgZm9yIEMtc3RyaW5nIHZhbHVlOlwiLFxuICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWVtYmVyKSk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fbWVtYmVyVG9Kc1N0cmluZyA9IGZ1bmN0aW9uIGYob2JqLG1lbWJlck5hbWUpe1xuICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdHJ1ZSk7XG4gICAgX19hZmZpcm1DU3RyaW5nU2lnbmF0dXJlKG0pO1xuICAgIGNvbnN0IGFkZHIgPSBvYmpbbS5rZXldO1xuICAgIFxuICAgIGlmKCFhZGRyKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgcG9zID0gYWRkcjtcbiAgICBjb25zdCBtZW0gPSBoZWFwKCk7XG4gICAgZm9yKCA7IG1lbVtwb3NdIT09MDsgKytwb3MgKSB7XG4gICAgICBcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiAoYWRkcj09PXBvcykgPyBcIlwiIDogX191dGY4RGVjb2RlKG1lbSwgYWRkciwgcG9zKTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19hZGRPbkRpc3Bvc2UgPSBmdW5jdGlvbihvYmosIC4uLnYpe1xuICAgIGlmKG9iai5vbmRpc3Bvc2Upe1xuICAgICAgaWYoIUFycmF5LmlzQXJyYXkob2JqLm9uZGlzcG9zZSkpe1xuICAgICAgICBvYmoub25kaXNwb3NlID0gW29iai5vbmRpc3Bvc2VdO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgb2JqLm9uZGlzcG9zZSA9IFtdO1xuICAgIH1cbiAgICBvYmoub25kaXNwb3NlLnB1c2goLi4udik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fYWxsb2NDU3RyaW5nID0gZnVuY3Rpb24oc3RyKXtcbiAgICBjb25zdCB1ID0gX191dGY4RW5jb2Rlci5lbmNvZGUoc3RyKTtcbiAgICBjb25zdCBtZW0gPSBhbGxvYyh1Lmxlbmd0aCsxKTtcbiAgICBpZighbWVtKSB0b3NzKFwiQWxsb2NhdGlvbiBlcnJvciB3aGlsZSBkdXBsaWNhdGluZyBzdHJpbmc6XCIsc3RyKTtcbiAgICBjb25zdCBoID0gaGVhcCgpO1xuICAgIFxuICAgIFxuICAgIGguc2V0KHUsIG1lbSk7XG4gICAgaFttZW0gKyB1Lmxlbmd0aF0gPSAwO1xuICAgIFxuICAgIHJldHVybiBtZW07XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fc2V0TWVtYmVyQ1N0cmluZyA9IGZ1bmN0aW9uKG9iaiwgbWVtYmVyTmFtZSwgc3RyKXtcbiAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgIF9fYWZmaXJtQ1N0cmluZ1NpZ25hdHVyZShtKTtcbiAgICBcbiAgICBjb25zdCBtZW0gPSBfX2FsbG9jQ1N0cmluZyhzdHIpO1xuICAgIG9ialttLmtleV0gPSBtZW07XG4gICAgX19hZGRPbkRpc3Bvc2Uob2JqLCBtZW0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgXG4gIGNvbnN0IFN0cnVjdFR5cGUgPSBmdW5jdGlvbiBjdG9yKHN0cnVjdE5hbWUsIHN0cnVjdEluZm8pe1xuICAgIGlmKGFyZ3VtZW50c1syXSE9PXJvcCl7XG4gICAgICB0b3NzKFwiRG8gbm90IGNhbGwgdGhlIFN0cnVjdFR5cGUgY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgXCJmcm9tIGNsaWVudC1sZXZlbCBjb2RlLlwiKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyx7XG4gICAgICBcbiAgICAgIHN0cnVjdE5hbWU6IHJvcChzdHJ1Y3ROYW1lKSxcbiAgICAgIHN0cnVjdEluZm86IHJvcChzdHJ1Y3RJbmZvKVxuICAgIH0pO1xuICB9O1xuXG4gIFxuICBTdHJ1Y3RUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgIGRpc3Bvc2U6IHJvcChmdW5jdGlvbigpe19fZnJlZVN0cnVjdCh0aGlzLmNvbnN0cnVjdG9yLCB0aGlzKX0pLFxuICAgIGxvb2t1cE1lbWJlcjogcm9wKGZ1bmN0aW9uKG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kPXRydWUpe1xuICAgICAgcmV0dXJuIF9fbG9va3VwTWVtYmVyKHRoaXMuc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQpO1xuICAgIH0pLFxuICAgIG1lbWJlclRvSnNTdHJpbmc6IHJvcChmdW5jdGlvbihtZW1iZXJOYW1lKXtcbiAgICAgIHJldHVybiBfX21lbWJlclRvSnNTdHJpbmcodGhpcywgbWVtYmVyTmFtZSk7XG4gICAgfSksXG4gICAgbWVtYmVySXNTdHJpbmc6IHJvcChmdW5jdGlvbihtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZD10cnVlKXtcbiAgICAgIHJldHVybiBfX21lbWJlcklzU3RyaW5nKHRoaXMsIG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kKTtcbiAgICB9KSxcbiAgICBtZW1iZXJLZXk6IF9fbWVtYmVyS2V5UHJvcCxcbiAgICBtZW1iZXJLZXlzOiBfX3N0cnVjdE1lbWJlcktleXMsXG4gICAgbWVtYmVyU2lnbmF0dXJlOiByb3AoZnVuY3Rpb24obWVtYmVyTmFtZSwgZW1zY3JpcHRlbkZvcm1hdD1mYWxzZSl7XG4gICAgICByZXR1cm4gX19tZW1iZXJTaWduYXR1cmUodGhpcywgbWVtYmVyTmFtZSwgZW1zY3JpcHRlbkZvcm1hdCk7XG4gICAgfSksXG4gICAgbWVtb3J5RHVtcDogcm9wKF9fbWVtb3J5RHVtcCksXG4gICAgcG9pbnRlcjogX19wdHJQcm9wRGVzY3JpcHRvcixcbiAgICBzZXRNZW1iZXJDU3RyaW5nOiByb3AoZnVuY3Rpb24obWVtYmVyTmFtZSwgc3RyKXtcbiAgICAgIHJldHVybiBfX3NldE1lbWJlckNTdHJpbmcodGhpcywgbWVtYmVyTmFtZSwgc3RyKTtcbiAgICB9KVxuICB9KTtcbiAgXG4gIE9iamVjdC5hc3NpZ24oU3RydWN0VHlwZS5wcm90b3R5cGUse1xuICAgIGFkZE9uRGlzcG9zZTogZnVuY3Rpb24oLi4udil7XG4gICAgICBfX2FkZE9uRGlzcG9zZSh0aGlzLC4uLnYpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3RydWN0VHlwZSwge1xuICAgIGFsbG9jQ1N0cmluZzogcm9wKF9fYWxsb2NDU3RyaW5nKSxcbiAgICBpc0E6IHJvcCgodik9PnYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSxcbiAgICBoYXNFeHRlcm5hbFBvaW50ZXI6IHJvcCgodik9Pih2IGluc3RhbmNlb2YgU3RydWN0VHlwZSkgJiYgISF2W3hQdHJQcm9wTmFtZV0pLFxuICAgIG1lbWJlcktleTogX19tZW1iZXJLZXlQcm9wXG4gIH0pO1xuXG4gIGNvbnN0IGlzTnVtZXJpY1ZhbHVlID0gKHYpPT5OdW1iZXIuaXNGaW5pdGUodikgfHwgKHYgaW5zdGFuY2VvZiAoQmlnSW50IHx8IE51bWJlcikpO1xuXG4gIFxuICBjb25zdCBtYWtlTWVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIGYoY3RvcixuYW1lLCBkZXNjcil7XG4gICAgaWYoIWYuXyl7XG4gICAgICBcbiAgICAgIGYuXyA9IHtnZXR0ZXJzOiB7fSwgc2V0dGVyczoge30sIHN3Ont9fTtcbiAgICAgIGNvbnN0IGEgPSBbJ2knLCdjJywnQycsJ3AnLCdQJywncycsJ2YnLCdkJywndigpJ107XG4gICAgICBpZihiaWdJbnRFbmFibGVkKSBhLnB1c2goJ2onKTtcbiAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2KXtcbiAgICAgICAgXG4gICAgICAgIGYuXy5nZXR0ZXJzW3ZdID0gc2lnRFZHZXR0ZXIodikgO1xuICAgICAgICBmLl8uc2V0dGVyc1t2XSA9IHNpZ0RWU2V0dGVyKHYpIDtcbiAgICAgICAgZi5fLnN3W3ZdID0gc2lnRFZTZXRXcmFwcGVyKHYpICA7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJ4U2lnMSA9IC9eW2lwUHNqZmRjQ10kLyxcbiAgICAgICAgICAgIHJ4U2lnMiA9IC9eW3ZpcFBzamZkY0NdXFwoW2lwUHNqZmRjQ10qXFwpJC87XG4gICAgICBmLnNpZ0NoZWNrID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBrZXksc2lnKXtcbiAgICAgICAgaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSl7XG4gICAgICAgICAgdG9zcyhvYmouc3RydWN0TmFtZSwnYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBuYW1lZCcsa2V5KycuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcnhTaWcxLnRlc3Qoc2lnKSB8fCByeFNpZzIudGVzdChzaWcpXG4gICAgICAgICAgfHwgdG9zcyhcIk1hbGZvcm1lZCBzaWduYXR1cmUgZm9yXCIsXG4gICAgICAgICAgICAgICAgICBzUHJvcE5hbWUob2JqLnN0cnVjdE5hbWUsbmFtZSkrXCI6XCIsc2lnKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGN0b3IubWVtYmVyS2V5KG5hbWUpO1xuICAgIGYuc2lnQ2hlY2soY3Rvci5wcm90b3R5cGUsIG5hbWUsIGtleSwgZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICBkZXNjci5rZXkgPSBrZXk7XG4gICAgZGVzY3IubmFtZSA9IG5hbWU7XG4gICAgY29uc3Qgc2lnR2x5cGggPSBzaWdMZXR0ZXIoZGVzY3Iuc2lnbmF0dXJlKTtcbiAgICBjb25zdCB4UHJvcE5hbWUgPSBzUHJvcE5hbWUoY3Rvci5wcm90b3R5cGUuc3RydWN0TmFtZSxrZXkpO1xuICAgIGNvbnN0IGRiZyA9IGN0b3IucHJvdG90eXBlLmRlYnVnRmxhZ3MuX19mbGFncztcbiAgICBcbiAgICBjb25zdCBwcm9wID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBwcm9wLmNvbmZpZ3VyYWJsZSA9IGZhbHNlO1xuICAgIHByb3AuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgIHByb3AuZ2V0ID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmKGRiZy5nZXR0ZXIpe1xuICAgICAgICBsb2coXCJkZWJ1Zy5nZXR0ZXI6XCIsZi5fLmdldHRlcnNbc2lnR2x5cGhdLFwiZm9yXCIsIHNpZ0lSKHNpZ0dseXBoKSxcbiAgICAgICAgICAgIHhQcm9wTmFtZSwnQCcsIHRoaXMucG9pbnRlciwnKycsZGVzY3Iub2Zmc2V0LCdzeicsZGVzY3Iuc2l6ZW9mKTtcbiAgICAgIH1cbiAgICAgIGxldCByYyA9IChcbiAgICAgICAgbmV3IERhdGFWaWV3KGhlYXAoKS5idWZmZXIsIHRoaXMucG9pbnRlciArIGRlc2NyLm9mZnNldCwgZGVzY3Iuc2l6ZW9mKVxuICAgICAgKVtmLl8uZ2V0dGVyc1tzaWdHbHlwaF1dKDAsIGlzTGl0dGxlRW5kaWFuKTtcbiAgICAgIGlmKGRiZy5nZXR0ZXIpIGxvZyhcImRlYnVnLmdldHRlcjpcIix4UHJvcE5hbWUsXCJyZXN1bHQgPVwiLHJjKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9O1xuICAgIGlmKGRlc2NyLnJlYWRPbmx5KXtcbiAgICAgIHByb3Auc2V0ID0gX19wcm9wVGhyb3dPblNldChjdG9yLnByb3RvdHlwZS5zdHJ1Y3ROYW1lLGtleSk7XG4gICAgfWVsc2V7XG4gICAgICBwcm9wLnNldCA9IGZ1bmN0aW9uKHYpe1xuICAgICAgICBpZihkYmcuc2V0dGVyKXtcbiAgICAgICAgICBsb2coXCJkZWJ1Zy5zZXR0ZXI6XCIsZi5fLnNldHRlcnNbc2lnR2x5cGhdLFwiZm9yXCIsIHNpZ0lSKHNpZ0dseXBoKSxcbiAgICAgICAgICAgICAgeFByb3BOYW1lLCdAJywgdGhpcy5wb2ludGVyLCcrJyxkZXNjci5vZmZzZXQsJ3N6JyxkZXNjci5zaXplb2YsIHYpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCF0aGlzLnBvaW50ZXIpe1xuICAgICAgICAgIHRvc3MoXCJDYW5ub3Qgc2V0IHN0cnVjdCBwcm9wZXJ0eSBvbiBkaXNwb3NlZCBpbnN0YW5jZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYobnVsbD09PXYpIHYgPSAwO1xuICAgICAgICBlbHNlIHdoaWxlKCFpc051bWVyaWNWYWx1ZSh2KSl7XG4gICAgICAgICAgaWYoaXNBdXRvUHRyU2lnKGRlc2NyLnNpZ25hdHVyZSkgJiYgKHYgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHYgPSB2LnBvaW50ZXIgfHwgMDtcbiAgICAgICAgICAgIGlmKGRiZy5zZXR0ZXIpIGxvZyhcImRlYnVnLnNldHRlcjpcIix4UHJvcE5hbWUsXCJyZXNvbHZlZCB0b1wiLHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvc3MoXCJJbnZhbGlkIHZhbHVlIGZvciBwb2ludGVyLXR5cGVcIix4UHJvcE5hbWUrJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAoXG4gICAgICAgICAgbmV3IERhdGFWaWV3KGhlYXAoKS5idWZmZXIsIHRoaXMucG9pbnRlciArIGRlc2NyLm9mZnNldCwgZGVzY3Iuc2l6ZW9mKVxuICAgICAgICApW2YuXy5zZXR0ZXJzW3NpZ0dseXBoXV0oMCwgZi5fLnN3W3NpZ0dseXBoXSh2KSwgaXNMaXR0bGVFbmRpYW4pO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHByb3ApO1xuICB9O1xuICBcbiAgXG4gIGNvbnN0IFN0cnVjdEJpbmRlciA9IGZ1bmN0aW9uIFN0cnVjdEJpbmRlcihzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvKXtcbiAgICBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICBzdHJ1Y3RJbmZvID0gc3RydWN0TmFtZTtcbiAgICAgIHN0cnVjdE5hbWUgPSBzdHJ1Y3RJbmZvLm5hbWU7XG4gICAgfWVsc2UgaWYoIXN0cnVjdEluZm8ubmFtZSl7XG4gICAgICBzdHJ1Y3RJbmZvLm5hbWUgPSBzdHJ1Y3ROYW1lO1xuICAgIH1cbiAgICBpZighc3RydWN0TmFtZSkgdG9zcyhcIlN0cnVjdCBuYW1lIGlzIHJlcXVpcmVkLlwiKTtcbiAgICBsZXQgbGFzdE1lbWJlciA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHN0cnVjdEluZm8ubWVtYmVycykuZm9yRWFjaCgoayk9PntcbiAgICAgIFxuICAgICAgY29uc3QgbSA9IHN0cnVjdEluZm8ubWVtYmVyc1trXTtcbiAgICAgIGlmKCFtLnNpemVvZikgdG9zcyhzdHJ1Y3ROYW1lLFwibWVtYmVyXCIsayxcImlzIG1pc3Npbmcgc2l6ZW9mLlwiKTtcbiAgICAgIGVsc2UgaWYobS5zaXplb2Y9PT0xKXtcbiAgICAgICAgKG0uc2lnbmF0dXJlID09PSAnYycgfHwgbS5zaWduYXR1cmUgPT09ICdDJykgfHxcbiAgICAgICAgICB0b3NzKFwiVW5leHBlY3RlZCBzaXplb2Y9PTEgbWVtYmVyXCIsXG4gICAgICAgICAgICAgICBzUHJvcE5hbWUoc3RydWN0SW5mby5uYW1lLGspLFxuICAgICAgICAgICAgICAgXCJ3aXRoIHNpZ25hdHVyZVwiLG0uc2lnbmF0dXJlKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmKDAhPT0obS5zaXplb2YlNCkpe1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgc3RydWN0IG1lbWJlciBkZXNjcmlwdGlvbiA9XCIsbSxcImZyb21cIixzdHJ1Y3RJbmZvKTtcbiAgICAgICAgICB0b3NzKHN0cnVjdE5hbWUsXCJtZW1iZXJcIixrLFwic2l6ZW9mIGlzIG5vdCBhbGlnbmVkLiBzaXplb2Y9XCIrbS5zaXplb2YpO1xuICAgICAgICB9XG4gICAgICAgIGlmKDAhPT0obS5vZmZzZXQlNCkpe1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgc3RydWN0IG1lbWJlciBkZXNjcmlwdGlvbiA9XCIsbSxcImZyb21cIixzdHJ1Y3RJbmZvKTtcbiAgICAgICAgICB0b3NzKHN0cnVjdE5hbWUsXCJtZW1iZXJcIixrLFwib2Zmc2V0IGlzIG5vdCBhbGlnbmVkLiBvZmZzZXQ9XCIrbS5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZighbGFzdE1lbWJlciB8fCBsYXN0TWVtYmVyLm9mZnNldCA8IG0ub2Zmc2V0KSBsYXN0TWVtYmVyID0gbTtcbiAgICB9KTtcbiAgICBpZighbGFzdE1lbWJlcikgdG9zcyhcIk5vIG1lbWJlciBwcm9wZXJ0eSBkZXNjcmlwdGlvbnMgZm91bmQuXCIpO1xuICAgIGVsc2UgaWYoc3RydWN0SW5mby5zaXplb2YgPCBsYXN0TWVtYmVyLm9mZnNldCtsYXN0TWVtYmVyLnNpemVvZil7XG4gICAgICB0b3NzKFwiSW52YWxpZCBzdHJ1Y3QgY29uZmlnOlwiLHN0cnVjdE5hbWUsXG4gICAgICAgICAgIFwibWF4IG1lbWJlciBvZmZzZXQgKFwiK2xhc3RNZW1iZXIub2Zmc2V0K1wiKSBcIixcbiAgICAgICAgICAgXCJleHRlbmRzIHBhc3QgZW5kIG9mIHN0cnVjdCAoc2l6ZW9mPVwiK3N0cnVjdEluZm8uc2l6ZW9mK1wiKS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGRlYnVnRmxhZ3MgPSByb3AoU0JGLl9fbWFrZURlYnVnRmxhZ3MoU3RydWN0QmluZGVyLmRlYnVnRmxhZ3MpKTtcbiAgICBcbiAgICBjb25zdCBTdHJ1Y3RDdG9yID0gZnVuY3Rpb24gU3RydWN0Q3RvcihleHRlcm5hbE1lbW9yeSl7XG4gICAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBTdHJ1Y3RDdG9yKSl7XG4gICAgICAgIHRvc3MoXCJUaGVcIixzdHJ1Y3ROYW1lLFwiY29uc3RydWN0b3IgbWF5IG9ubHkgYmUgY2FsbGVkIHZpYSAnbmV3Jy5cIik7XG4gICAgICB9ZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgaWYoZXh0ZXJuYWxNZW1vcnkhPT0oZXh0ZXJuYWxNZW1vcnl8MCkgfHwgZXh0ZXJuYWxNZW1vcnk8PTApe1xuICAgICAgICAgIHRvc3MoXCJJbnZhbGlkIHBvaW50ZXIgdmFsdWUgZm9yXCIsc3RydWN0TmFtZSxcImNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2FsbG9jU3RydWN0KFN0cnVjdEN0b3IsIHRoaXMsIGV4dGVybmFsTWVtb3J5KTtcbiAgICAgIH1lbHNle1xuICAgICAgICBfX2FsbG9jU3RydWN0KFN0cnVjdEN0b3IsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3RydWN0Q3Rvcix7XG4gICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgaXNBOiByb3AoKHYpPT52IGluc3RhbmNlb2YgU3RydWN0Q3RvciksXG4gICAgICBtZW1iZXJLZXk6IF9fbWVtYmVyS2V5UHJvcCxcbiAgICAgIG1lbWJlcktleXM6IF9fc3RydWN0TWVtYmVyS2V5cyxcbiAgICAgIG1ldGhvZEluZm9Gb3JLZXk6IHJvcChmdW5jdGlvbihtS2V5KXtcbiAgICAgIH0pLFxuICAgICAgc3RydWN0SW5mbzogcm9wKHN0cnVjdEluZm8pLFxuICAgICAgc3RydWN0TmFtZTogcm9wKHN0cnVjdE5hbWUpXG4gICAgfSk7XG4gICAgU3RydWN0Q3Rvci5wcm90b3R5cGUgPSBuZXcgU3RydWN0VHlwZShzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvLCByb3ApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdEN0b3IucHJvdG90eXBlLHtcbiAgICAgIGRlYnVnRmxhZ3M6IGRlYnVnRmxhZ3MsXG4gICAgICBjb25zdHJ1Y3Rvcjogcm9wKFN0cnVjdEN0b3IpXG4gICAgICBcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goXG4gICAgICAobmFtZSk9Pm1ha2VNZW1iZXJXcmFwcGVyKFN0cnVjdEN0b3IsIG5hbWUsIHN0cnVjdEluZm8ubWVtYmVyc1tuYW1lXSlcbiAgICApO1xuICAgIHJldHVybiBTdHJ1Y3RDdG9yO1xuICB9O1xuICBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZSA9IFN0cnVjdFR5cGU7XG4gIFN0cnVjdEJpbmRlci5jb25maWcgPSBjb25maWc7XG4gIFN0cnVjdEJpbmRlci5hbGxvY0NTdHJpbmcgPSBfX2FsbG9jQ1N0cmluZztcbiAgaWYoIVN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKXtcbiAgICBTdHJ1Y3RCaW5kZXIuZGVidWdGbGFncyA9IFNCRi5fX21ha2VEZWJ1Z0ZsYWdzKFNCRi5kZWJ1Z0ZsYWdzKTtcbiAgfVxuICByZXR1cm4gU3RydWN0QmluZGVyO1xufTtcblxuXG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbihzcWxpdGUzKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpPT57dGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKX07XG4gIGNvbnN0IHRvc3MzID0gc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcztcbiAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaSwgd2FzbSA9IHNxbGl0ZTMud2FzbSwgdXRpbCA9IHNxbGl0ZTMudXRpbDtcbiAgZ2xvYmFsVGhpcy5XaFdhc21VdGlsSW5zdGFsbGVyKHdhc20pO1xuICBkZWxldGUgZ2xvYmFsVGhpcy5XaFdhc21VdGlsSW5zdGFsbGVyO1xuXG4gIGlmKDApe1xuICAgIFxuICAgIFxuICAgIGNvbnN0IGRlYWxsb2MgPSB3YXNtLmV4cG9ydHNbc3FsaXRlMy5jb25maWcuZGVhbGxvY0V4cG9ydE5hbWVdO1xuICAgIGNvbnN0IG5GdW5jID0gd2FzbS5mdW5jdGlvblRhYmxlKCkubGVuZ3RoO1xuICAgIGxldCBpO1xuICAgIGZvcihpID0gMDsgaSA8IG5GdW5jOyArK2kpe1xuICAgICAgY29uc3QgZSA9IHdhc20uZnVuY3Rpb25FbnRyeShpKTtcbiAgICAgIGlmKGRlYWxsb2MgPT09IGUpe1xuICAgICAgICBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZGVhbGxvYyAhPT0gd2FzbS5mdW5jdGlvbkVudHJ5KGNhcGkuU1FMSVRFX1dBU01fREVBTExPQykpe1xuICAgICAgdG9zcyhcIkludGVybmFsIGVycm9yOiBjYW5ub3QgZmluZCBmdW5jdGlvbiBwb2ludGVyIGZvciBTUUxJVEVfV0FTTV9ERUFMTE9DLlwiKTtcbiAgICB9XG4gIH1cblxuICBcbiAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcyA9IFtcbiAgICBcbiAgICBbXCJzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0XCIsXCJ2b2lkKlwiLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJpbnRcIl0sXG4gICAgXG4gICAgXG4gICAgW1wic3FsaXRlM19iaW5kX2RvdWJsZVwiLFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiLCBcImY2NFwiXSxcbiAgICBbXCJzcWxpdGUzX2JpbmRfaW50XCIsXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfYmluZF9udWxsXCIsdW5kZWZpbmVkLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudFwiLCBcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleFwiLFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX2JpbmRfcG9pbnRlclwiLCBcImludFwiLFxuICAgICBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIiwgXCIqXCIsIFwic3RyaW5nOnN0YXRpY1wiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19idXN5X2hhbmRsZXJcIixcImludFwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIHNpZ25hdHVyZTogJ2kocGkpJyxcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YsYXJnSW5kZXgpPT5hcmd2WzBdXG4gICAgICB9KSxcbiAgICAgIFwiKlwiXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19idXN5X3RpbWVvdXRcIixcImludFwiLCBcInNxbGl0ZTMqXCIsIFwiaW50XCJdLFxuICAgIFxuICAgIFxuICAgIFtcInNxbGl0ZTNfY2hhbmdlc1wiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfY2xlYXJfYmluZGluZ3NcIixcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19jb2xsYXRpb25fbmVlZGVkXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCIqXCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl9ibG9iXCIsXCIqXCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl9ieXRlc1wiLFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl9jb3VudFwiLCBcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fZG91YmxlXCIsXCJmNjRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX2ludFwiLFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl9uYW1lXCIsXCJzdHJpbmdcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX3RleHRcIixcInN0cmluZ1wiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fdHlwZVwiLFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl92YWx1ZVwiLFwic3FsaXRlM192YWx1ZSpcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29tbWl0X2hvb2tcIiwgXCJ2b2lkKlwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6ICdzcWxpdGUzX2NvbW1pdF9ob29rJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnaShwKScsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2KT0+YXJndlswXVxuICAgICAgfSksXG4gICAgICAnKidcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0XCIsIFwic3RyaW5nXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkXCIsIFwiaW50XCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfY29tcGxldGVcIiwgXCJpbnRcIiwgXCJzdHJpbmc6ZmxleGlibGVcIl0sXG4gICAgW1wic3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZVwiLCBcInNxbGl0ZTMqXCIsIFwic3FsaXRlM19jb250ZXh0KlwiXSxcblxuICAgIFxuICAgIFxuICAgIFtcInNxbGl0ZTNfZGF0YV9jb3VudFwiLCBcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19kYl9maWxlbmFtZVwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfZGJfaGFuZGxlXCIsIFwic3FsaXRlMypcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfZGJfbmFtZVwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTMqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfZGJfc3RhdHVzXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJpbnRcIiwgXCIqXCIsIFwiKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2VycmNvZGVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX2Vycm1zZ1wiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfZXJyb3Jfb2Zmc2V0XCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19lcnJzdHJcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19leGVjXCIsIFwiaW50XCIsIFtcbiAgICAgIFwic3FsaXRlMypcIiwgXCJzdHJpbmc6ZmxleGlibGVcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgc2lnbmF0dXJlOiAnaShwaXBwKScsXG4gICAgICAgIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIGxldCBhTmFtZXM7XG4gICAgICAgICAgcmV0dXJuIChwVm9pZCwgbkNvbHMsIHBDb2xWYWxzLCBwQ29sTmFtZXMpPT57XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBhVmFscyA9IHdhc20uY0FyZ3ZUb0pzKG5Db2xzLCBwQ29sVmFscyk7XG4gICAgICAgICAgICAgIGlmKCFhTmFtZXMpIGFOYW1lcyA9IHdhc20uY0FyZ3ZUb0pzKG5Db2xzLCBwQ29sTmFtZXMpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYVZhbHMsIGFOYW1lcykgfCAwO1xuICAgICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgXCIqXCIsIFwiKipcIlxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfZXhwYW5kZWRfc3FsXCIsIFwic3RyaW5nXCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2Rlc1wiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfZmlsZV9jb250cm9sXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfZmluYWxpemVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfZnJlZVwiLCB1bmRlZmluZWQsXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfZ2V0X2F1dG9jb21taXRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX2dldF9hdXhkYXRhXCIsIFwiKlwiLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19pbml0aWFsaXplXCIsIHVuZGVmaW5lZF0sXG4gICAgXG4gICAgW1wic3FsaXRlM19rZXl3b3JkX2NvdW50XCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfa2V5d29yZF9uYW1lXCIsIFwiaW50XCIsIFtcImludFwiLCBcIioqXCIsIFwiKlwiXV0sXG4gICAgW1wic3FsaXRlM19rZXl3b3JkX2NoZWNrXCIsIFwiaW50XCIsIFtcInN0cmluZ1wiLCBcImludFwiXV0sXG4gICAgW1wic3FsaXRlM19saWJ2ZXJzaW9uXCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXJcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19saW1pdFwiLCBcImludFwiLCBbXCJzcWxpdGUzKlwiLCBcImludFwiLCBcImludFwiXV0sXG4gICAgW1wic3FsaXRlM19tYWxsb2NcIiwgXCIqXCIsXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19vcGVuXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX29wZW5fdjJcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIiwgXCIqXCIsIFwiaW50XCIsIFwic3RyaW5nXCJdLFxuICAgIFxuICAgIFxuICAgIFtcInNxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlclwiLCB1bmRlZmluZWQsIFtcbiAgICAgIFwic3FsaXRlMypcIiwgXCJpbnRcIiwgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiAneFByb2dyZXNzSGFuZGxlcicsXG4gICAgICAgIHNpZ25hdHVyZTogJ2kocCknLFxuICAgICAgICBiaW5kU2NvcGU6ICdjb250ZXh0JyxcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YsYXJnSW5kZXgpPT5hcmd2WzBdXG4gICAgICB9KSwgXCIqXCJcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX3JlYWxsb2NcIiwgXCIqXCIsXCIqXCIsXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19yZXNldFwiLCBcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgXG4gICAgW1wic3FsaXRlM19yZXN1bHRfYmxvYlwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcIipcIiwgXCJpbnRcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2RvdWJsZVwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcImY2NFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9lcnJvclwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcInN0cmluZ1wiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yX25vbWVtXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZ1wiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9pbnRcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfbnVsbFwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9wb2ludGVyXCIsIHVuZGVmaW5lZCxcbiAgICAgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiKlwiLCBcInN0cmluZzpzdGF0aWNcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X3N1YnR5cGVcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfdmFsdWUqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X3RleHRcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X3plcm9ibG9iXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfcm9sbGJhY2tfaG9va1wiLCBcInZvaWQqXCIsIFtcbiAgICAgIFwic3FsaXRlMypcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogJ3NxbGl0ZTNfcm9sbGJhY2tfaG9vaycsXG4gICAgICAgIHNpZ25hdHVyZTogJ3YocCknLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndik9PmFyZ3ZbMF1cbiAgICAgIH0pLFxuICAgICAgJyonXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19zZXRfYXV0aG9yaXplclwiLCBcImludFwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6IFwic3FsaXRlM19zZXRfYXV0aG9yaXplcjo6eEF1dGhcIixcbiAgICAgICAgc2lnbmF0dXJlOiBcImkocGlcIitcInNzc3MpXCIsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2LCBhcmdJbmRleCk9PmFyZ3ZbMF0sXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIHJldHVybiAocFYsIGlDb2RlLCBzMCwgczEsIHMyLCBzMyk9PntcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgczAgPSBzMCAmJiB3YXNtLmNzdHJUb0pzKHMwKTsgczEgPSBzMSAmJiB3YXNtLmNzdHJUb0pzKHMxKTtcbiAgICAgICAgICAgICAgczIgPSBzMiAmJiB3YXNtLmNzdHJUb0pzKHMyKTsgczMgPSBzMyAmJiB3YXNtLmNzdHJUb0pzKHMzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHBWLCBpQ29kZSwgczAsIHMxLCBzMiwgczMpIHx8IDA7XG4gICAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICAgIHJldHVybiBlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFwiKlwiXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19zZXRfYXV4ZGF0YVwiLCB1bmRlZmluZWQsIFtcbiAgICAgIFwic3FsaXRlM19jb250ZXh0KlwiLCBcImludFwiLCBcIipcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogJ3hEZXN0cm95QXV4RGF0YScsXG4gICAgICAgIHNpZ25hdHVyZTogJ3YoKiknLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpPT5hcmd2WzBdXG4gICAgICB9KVxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfc2h1dGRvd25cIiwgdW5kZWZpbmVkXSxcbiAgICBbXCJzcWxpdGUzX3NvdXJjZWlkXCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfc3FsXCIsIFwic3RyaW5nXCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX3N0YXR1c1wiLCBcImludFwiLCBcImludFwiLCBcIipcIiwgXCIqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfc3RlcFwiLCBcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19zdG10X2lzZXhwbGFpblwiLCBcImludFwiLCBbXCJzcWxpdGUzX3N0bXQqXCJdXSxcbiAgICBbXCJzcWxpdGUzX3N0bXRfcmVhZG9ubHlcIiwgXCJpbnRcIiwgW1wic3FsaXRlM19zdG10KlwiXV0sXG4gICAgW1wic3FsaXRlM19zdG10X3N0YXR1c1wiLCBcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19zdHJnbG9iXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM19zdHJpY21wXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfc3RybGlrZVwiLCBcImludFwiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiLFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfc3RybmljbXBcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGFcIiwgXCJpbnRcIixcbiAgICAgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiLFxuICAgICBcIioqXCIsIFwiKipcIiwgXCIqXCIsIFwiKlwiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM190b3RhbF9jaGFuZ2VzXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM190cmFjZV92MlwiLCBcImludFwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsIFwiaW50XCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6ICdzcWxpdGUzX3RyYWNlX3YyOjpjYWxsYmFjaycsXG4gICAgICAgIHNpZ25hdHVyZTogJ2koaXBwcCknLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndixhcmdJbmRleCk9PmFyZ3ZbMF1cbiAgICAgIH0pLFxuICAgICAgXCIqXCJcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX3R4bl9zdGF0ZVwiLCBcImludFwiLCBbXCJzcWxpdGUzKlwiLFwic3RyaW5nXCJdXSxcbiAgICBcbiAgICBbXCJzcWxpdGUzX3VyaV9ib29sZWFuXCIsIFwiaW50XCIsIFwic3FsaXRlM19maWxlbmFtZVwiLCBcInN0cmluZ1wiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3VyaV9rZXlcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzX2ZpbGVuYW1lXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfdXJpX3BhcmFtZXRlclwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTNfZmlsZW5hbWVcIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM191c2VyX2RhdGFcIixcInZvaWQqXCIsIFwic3FsaXRlM19jb250ZXh0KlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2Jsb2JcIiwgXCIqXCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9ieXRlc1wiLFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9kb3VibGVcIixcImY2NFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfZHVwXCIsIFwic3FsaXRlM192YWx1ZSpcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2ZyZWVcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfZnJvbWJpbmRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2ludFwiLFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9ub2NoYW5nZVwiLCBcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlXCIsIFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9wb2ludGVyXCIsIFwiKlwiLCBcInNxbGl0ZTNfdmFsdWUqXCIsIFwic3RyaW5nOnN0YXRpY1wiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX3N1YnR5cGVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX3RleHRcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX3R5cGVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Zmc19maW5kXCIsIFwiKlwiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX3Zmc19yZWdpc3RlclwiLCBcImludFwiLCBcInNxbGl0ZTNfdmZzKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Zmc191bnJlZ2lzdGVyXCIsIFwiaW50XCIsIFwic3FsaXRlM192ZnMqXCJdXG4gIF07XG5cbiAgaWYoZmFsc2UgJiYgd2FzbS5jb21waWxlT3B0aW9uVXNlZCgnU1FMSVRFX0VOQUJMRV9OT1JNQUxJWkUnKSl7XG4gICAgXG4gICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFtcInNxbGl0ZTNfbm9ybWFsaXplZF9zcWxcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzX3N0bXQqXCJdKTtcbiAgfVxuXG4gIGlmKHdhc20uZXhwb3J0cy5zcWxpdGUzX2FjdGl2YXRlX3NlZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLnB1c2goXG4gICAgICBbXCJzcWxpdGUzX2tleVwiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiaW50XCJdLFxuICAgICAgW1wic3FsaXRlM19rZXlfdjJcIixcImludFwiLFwic3FsaXRlMypcIixcInN0cmluZ1wiLFwiKlwiLFwiaW50XCJdLFxuICAgICAgW1wic3FsaXRlM19yZWtleVwiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiaW50XCJdLFxuICAgICAgW1wic3FsaXRlM19yZWtleV92MlwiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiKlwiLCBcImludFwiXSxcbiAgICAgIFtcInNxbGl0ZTNfYWN0aXZhdGVfc2VlXCIsIHVuZGVmaW5lZCwgXCJzdHJpbmdcIl1cbiAgICApO1xuICB9XG4gIFxuICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0ID0gW1xuICAgIFtcInNxbGl0ZTNfYmluZF9pbnQ2NFwiLFwiaW50XCIsIFtcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIiwgXCJpNjRcIl1dLFxuICAgIFtcInNxbGl0ZTNfY2hhbmdlczY0XCIsXCJpNjRcIiwgW1wic3FsaXRlMypcIl1dLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX2ludDY0XCIsXCJpNjRcIiwgW1wic3FsaXRlM19zdG10KlwiLCBcImludFwiXV0sXG4gICAgW1wic3FsaXRlM19jcmVhdGVfbW9kdWxlXCIsIFwiaW50XCIsXG4gICAgIFtcInNxbGl0ZTMqXCIsXCJzdHJpbmdcIixcInNxbGl0ZTNfbW9kdWxlKlwiLFwiKlwiXV0sXG4gICAgW1wic3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyXCIsIFwiaW50XCIsXG4gICAgIFtcInNxbGl0ZTMqXCIsXCJzdHJpbmdcIixcInNxbGl0ZTNfbW9kdWxlKlwiLFwiKlwiLFwiKlwiXV0sXG4gICAgW1wic3FsaXRlM19kZWNsYXJlX3Z0YWJcIiwgXCJpbnRcIiwgW1wic3FsaXRlMypcIiwgXCJzdHJpbmc6ZmxleGlibGVcIl1dLFxuICAgIFtcInNxbGl0ZTNfZGVzZXJpYWxpemVcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcIipcIiwgXCJpNjRcIiwgXCJpNjRcIiwgXCJpbnRcIl1cbiAgICAsXG4gICAgW1wic3FsaXRlM19kcm9wX21vZHVsZXNcIiwgXCJpbnRcIiwgW1wic3FsaXRlMypcIiwgXCIqKlwiXV0sXG4gICAgW1wic3FsaXRlM19sYXN0X2luc2VydF9yb3dpZFwiLCBcImk2NFwiLCBbXCJzcWxpdGUzKlwiXV0sXG4gICAgW1wic3FsaXRlM19tYWxsb2M2NFwiLCBcIipcIixcImk2NFwiXSxcbiAgICBbXCJzcWxpdGUzX21zaXplXCIsIFwiaTY0XCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uXCIsIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsXCJzdHJpbmdcIixcImludFwiXV0sXG4gICAgW1wic3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19wcmV1cGRhdGVfY291bnRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ByZXVwZGF0ZV9kZXB0aFwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfcHJldXBkYXRlX2hvb2tcIiwgXCIqXCIsIFtcbiAgICAgIFwic3FsaXRlMypcIixcbiAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snLFxuICAgICAgICBzaWduYXR1cmU6IFwidihwcGlwcGpqKVwiLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndik9PmFyZ3ZbMF0sXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIHJldHVybiAocCxkYixvcCx6RGIselRibCxpS2V5MSxpS2V5Mik9PntcbiAgICAgICAgICAgIGNhbGxiYWNrKHAsIGRiLCBvcCwgd2FzbS5jc3RyVG9Kcyh6RGIpLCB3YXNtLmNzdHJUb0pzKHpUYmwpLFxuICAgICAgICAgICAgICAgICAgICAgaUtleTEsIGlLZXkyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFwiKlwiXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19wcmV1cGRhdGVfbmV3XCIsIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsIFwiaW50XCIsIFwiKipcIl1dLFxuICAgIFtcInNxbGl0ZTNfcHJldXBkYXRlX29sZFwiLCBcImludFwiLCBbXCJzcWxpdGUzKlwiLCBcImludFwiLCBcIioqXCJdXSxcbiAgICBbXCJzcWxpdGUzX3JlYWxsb2M2NFwiLCBcIipcIixcIipcIiwgXCJpNjRcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfaW50NjRcIiwgdW5kZWZpbmVkLCBcIipcIiwgXCJpNjRcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NFwiLCBcImludFwiLCBcIipcIiwgXCJpNjRcIl0sXG4gICAgW1wic3FsaXRlM19zZXJpYWxpemVcIixcIipcIiwgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcIipcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19zZXRfbGFzdF9pbnNlcnRfcm93aWRcIiwgdW5kZWZpbmVkLCBbXCJzcWxpdGUzKlwiLCBcImk2NFwiXV0sXG4gICAgW1wic3FsaXRlM19zdGF0dXM2NFwiLCBcImludFwiLCBcImludFwiLCBcIipcIiwgXCIqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfdG90YWxfY2hhbmdlczY0XCIsIFwiaTY0XCIsIFtcInNxbGl0ZTMqXCJdXSxcbiAgICBbXCJzcWxpdGUzX3VwZGF0ZV9ob29rXCIsIFwiKlwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6ICdzcWxpdGUzX3VwZGF0ZV9ob29rJyxcbiAgICAgICAgc2lnbmF0dXJlOiBcInYoaWlwcGopXCIsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2KT0+YXJndlswXSxcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgcmV0dXJuIChwLG9wLHowLHoxLHJvd2lkKT0+e1xuICAgICAgICAgICAgY2FsbGJhY2socCwgb3AsIHdhc20uY3N0clRvSnMoejApLCB3YXNtLmNzdHJUb0pzKHoxKSwgcm93aWQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgXCIqXCJcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX3VyaV9pbnQ2NFwiLCBcImk2NFwiLCBbXCJzcWxpdGUzX2ZpbGVuYW1lXCIsIFwic3RyaW5nXCIsIFwiaTY0XCJdXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2ludDY0XCIsXCJpNjRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Z0YWJfY29sbGF0aW9uXCIsXCJzdHJpbmdcIixcInNxbGl0ZTNfaW5kZXhfaW5mbypcIixcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Z0YWJfZGlzdGluY3RcIixcImludFwiLCBcInNxbGl0ZTNfaW5kZXhfaW5mbypcIl0sXG4gICAgW1wic3FsaXRlM192dGFiX2luXCIsXCJpbnRcIiwgXCJzcWxpdGUzX2luZGV4X2luZm8qXCIsIFwiaW50XCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfdnRhYl9pbl9maXJzdFwiLCBcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCIsIFwiKipcIl0sXG4gICAgW1wic3FsaXRlM192dGFiX2luX25leHRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiLCBcIioqXCJdLFxuICAgIFxuICAgIFtcInNxbGl0ZTNfdnRhYl9ub2NoYW5nZVwiLFwiaW50XCIsIFwic3FsaXRlM19jb250ZXh0KlwiXSxcbiAgICBbXCJzcWxpdGUzX3Z0YWJfb25fY29uZmxpY3RcIixcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfdnRhYl9yaHNfdmFsdWVcIixcImludFwiLCBcInNxbGl0ZTNfaW5kZXhfaW5mbypcIiwgXCJpbnRcIiwgXCIqKlwiXVxuICBdO1xuXG4gIFxuICBpZih3YXNtLmJpZ0ludEVuYWJsZWQgJiYgISF3YXNtLmV4cG9ydHMuc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCl7XG4gICAgXG4gICAgXG4gICAgY29uc3QgX19pcHNQcm94eSA9IHtcbiAgICAgIHNpZ25hdHVyZTogJ2kocHMpJyxcbiAgICAgIGNhbGxQcm94eTooY2FsbGJhY2spPT57XG4gICAgICAgIHJldHVybiAocCxzKT0+e1xuICAgICAgICAgIHRyeXtyZXR1cm4gY2FsbGJhY2socCwgd2FzbS5jc3RyVG9KcyhzKSkgfCAwfVxuICAgICAgICAgIGNhdGNoKGUpe3JldHVybiBlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1J9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5pbnQ2NC5wdXNoKC4uLltcbiAgICAgIFsnc3FsaXRlM2NoYW5nZWdyb3VwX2FkZCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludCcsICd2b2lkKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZScsIHVuZGVmaW5lZCwgWydzcWxpdGUzX2NoYW5nZWdyb3VwKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZWdyb3VwX25ldycsICdpbnQnLCBbJyoqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0JywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2Vncm91cConLCAnaW50KicsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4T3V0cHV0Jywgc2lnbmF0dXJlOiAnaShwcGkpJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHknLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlMyonLCAnaW50JywgJ3ZvaWQqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJywgYmluZFNjb3BlOiAndHJhbnNpZW50JywgLi4uX19pcHNQcm94eVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4Q29uZmxpY3QnLCBzaWduYXR1cmU6ICdpKHBpcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hGaWx0ZXInLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLCAuLi5fX2lwc1Byb3h5XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsIHNpZ25hdHVyZTogJ2kocGlwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTMqJywgJ2ludCcsICd2b2lkKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneEZpbHRlcicsIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsIC4uLl9faXBzUHJveHlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneENvbmZsaWN0Jywgc2lnbmF0dXJlOiAnaShwaXApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJywgJyoqJywgJ2ludConLCAnaW50J1xuXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTMqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hGaWx0ZXInLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLCAuLi5fX2lwc1Byb3h5XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsIHNpZ25hdHVyZTogJ2kocGlwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsICcqKicsICdpbnQqJywgJ2ludCdcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdCcsICdpbnQnLCBbJ2ludCcsJ3ZvaWQqJywgJ2ludCcsICd2b2lkKicsICdpbnQqJywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXRBJywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXRCJywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4T3V0cHV0Jywgc2lnbmF0dXJlOiAnaShwcGkpJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICdpbnQnLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHMnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICdpbnQqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2ludmVydCcsICdpbnQnLCBbJ2ludCcsICd2b2lkKicsICdpbnQqJywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4SW5wdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hPdXRwdXQnLCBzaWduYXR1cmU6ICdpKHBwaSknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9uZXcnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICdpbnQnLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X29sZCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgJ2ludCcsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9vcCcsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICcqKicsICdpbnQqJywgJ2ludConLCdpbnQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfcGsnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICcqKicsICdpbnQqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0JywgJ2ludCcsIFsnKionLCAnaW50JywgJyonXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybScsICdpbnQnLCBbXG4gICAgICAgICcqKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjInLCAnaW50JywgWycqKicsICdpbnQnLCAnKicsICdpbnQnXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybScsICdpbnQnLCBbXG4gICAgICAgICcqKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJywgJ2ludCdcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9hdHRhY2gnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ3N0cmluZyddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0JywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdpbnQqJywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc2l6ZScsICdpNjQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hPdXRwdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY29uZmlnJywgJ2ludCcsIFsnaW50JywgJ3ZvaWQqJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jcmVhdGUnLCAnaW50JywgWydzcWxpdGUzKicsICdzdHJpbmcnLCAnKionXV0sXG4gICAgICBcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fZGlmZicsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnc3RyaW5nJywgJ3N0cmluZycsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fZW5hYmxlJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdpbnQnXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2luZGlyZWN0JywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdpbnQnXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHknLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZCcsICdpNjQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ2ludCcsICd2b2lkKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJyonLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlM19zZXNzaW9uKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneE91dHB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXInLCB1bmRlZmluZWQsIFtcbiAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hGaWx0ZXInLCAuLi5fX2lwc1Byb3h5LFxuICAgICAgICAgIGNvbnRleHRLZXk6IChhcmd2LGFyZ0luZGV4KT0+YXJndlswXVxuICAgICAgICB9KSxcbiAgICAgICAgJyonXG4gICAgICBdXVxuICAgIF0pO1xuICB9XG5cbiAgXG4gIHdhc20uYmluZGluZ1NpZ25hdHVyZXMud2FzbSA9IFtcbiAgICBbXCJzcWxpdGUzX3dhc21fZGJfcmVzZXRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX3dhc21fZGJfdmZzXCIsIFwic3FsaXRlM192ZnMqXCIsIFwic3FsaXRlMypcIixcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlXCIsIFwiaW50XCIsXG4gICAgIFwic3FsaXRlM192ZnMqXCIsXCJzdHJpbmdcIixcIipcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsXCIqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfd2FzbV92ZnNfdW5saW5rXCIsIFwiaW50XCIsIFwic3FsaXRlM192ZnMqXCIsXCJzdHJpbmdcIl1cbiAgXTtcblxuICBcbiAgc3FsaXRlMy5TdHJ1Y3RCaW5kZXIgPSBnbG9iYWxUaGlzLkphY2N3YWJ5dCh7XG4gICAgaGVhcDogMCA/IHdhc20ubWVtb3J5IDogd2FzbS5oZWFwOHUsXG4gICAgYWxsb2M6IHdhc20uYWxsb2MsXG4gICAgZGVhbGxvYzogd2FzbS5kZWFsbG9jLFxuICAgIGJpZ0ludEVuYWJsZWQ6IHdhc20uYmlnSW50RW5hYmxlZCxcbiAgICBtZW1iZXJQcmVmaXg6ICAnJCdcbiAgfSk7XG4gIGRlbGV0ZSBnbG9iYWxUaGlzLkphY2N3YWJ5dDtcblxuICB7XG5cbiAgICBcbiAgICBjb25zdCBfX3hTdHJpbmcgPSB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3N0cmluZycpO1xuICAgIHdhc20ueFdyYXAuYXJnQWRhcHRlcihcbiAgICAgICdzdHJpbmc6ZmxleGlibGUnLCAodik9Pl9feFN0cmluZyh1dGlsLmZsZXhpYmxlU3RyaW5nKHYpKVxuICAgICk7XG5cbiAgICBcbiAgICB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoXG4gICAgICAnc3RyaW5nOnN0YXRpYycsXG4gICAgICBmdW5jdGlvbih2KXtcbiAgICAgICAgaWYod2FzbS5pc1B0cih2KSkgcmV0dXJuIHY7XG4gICAgICAgIHYgPSAnJyt2O1xuICAgICAgICBsZXQgcmMgPSB0aGlzW3ZdO1xuICAgICAgICByZXR1cm4gcmMgfHwgKHRoaXNbdl0gPSB3YXNtLmFsbG9jQ1N0cmluZyh2KSk7XG4gICAgICB9LmJpbmQoT2JqZWN0LmNyZWF0ZShudWxsKSlcbiAgICApO1xuXG4gICAgXG4gICAgY29uc3QgX194QXJnUHRyID0gd2FzbS54V3JhcC5hcmdBZGFwdGVyKCcqJyk7XG4gICAgY29uc3QgbmlsVHlwZSA9IGZ1bmN0aW9uKCl7fTtcbiAgICB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3NxbGl0ZTNfZmlsZW5hbWUnLCBfX3hBcmdQdHIpXG4gICAgKCdzcWxpdGUzX2NvbnRleHQqJywgX194QXJnUHRyKVxuICAgICgnc3FsaXRlM192YWx1ZSonLCBfX3hBcmdQdHIpXG4gICAgKCd2b2lkKicsIF9feEFyZ1B0cilcbiAgICAoJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgX194QXJnUHRyKVxuICAgICgnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCBfX3hBcmdQdHIpXG4gICAgXG4gICAgKCdzcWxpdGUzX3Nlc3Npb24qJywgX194QXJnUHRyKVxuICAgICgnc3FsaXRlM19zdG10KicsICh2KT0+XG4gICAgICBfX3hBcmdQdHIoKHYgaW5zdGFuY2VvZiAoc3FsaXRlMz8ub28xPy5TdG10IHx8IG5pbFR5cGUpKVxuICAgICAgICAgICA/IHYucG9pbnRlciA6IHYpKVxuICAgICgnc3FsaXRlMyonLCAodik9PlxuICAgICAgX194QXJnUHRyKCh2IGluc3RhbmNlb2YgKHNxbGl0ZTM/Lm9vMT8uREIgfHwgbmlsVHlwZSkpXG4gICAgICAgICAgID8gdi5wb2ludGVyIDogdikpXG4gICAgKCdzcWxpdGUzX2luZGV4X2luZm8qJywgKHYpPT5cbiAgICAgIF9feEFyZ1B0cigodiBpbnN0YW5jZW9mIChjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mbyB8fCBuaWxUeXBlKSlcbiAgICAgICAgICAgPyB2LnBvaW50ZXIgOiB2KSlcbiAgICAoJ3NxbGl0ZTNfbW9kdWxlKicsICh2KT0+XG4gICAgICBfX3hBcmdQdHIoKHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX21vZHVsZSB8fCBuaWxUeXBlKSlcbiAgICAgICAgICAgPyB2LnBvaW50ZXIgOiB2KSlcbiAgICBcbiAgICAoJ3NxbGl0ZTNfdmZzKicsICh2KT0+e1xuICAgICAgaWYoJ3N0cmluZyc9PT10eXBlb2Ygdil7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX3Zmc19maW5kKHYpXG4gICAgICAgICAgfHwgc3FsaXRlMy5TUUxpdGUzRXJyb3IudG9zcyhcbiAgICAgICAgICAgIGNhcGkuU1FMSVRFX05PVEZPVU5ELFxuICAgICAgICAgICAgXCJVbmtub3duIHNxbGl0ZTNfdmZzIG5hbWU6XCIsIHZcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9feEFyZ1B0cigodiBpbnN0YW5jZW9mIChjYXBpLnNxbGl0ZTNfdmZzIHx8IG5pbFR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICA/IHYucG9pbnRlciA6IHYpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgX194UmNQdHIgPSB3YXNtLnhXcmFwLnJlc3VsdEFkYXB0ZXIoJyonKTtcbiAgICB3YXNtLnhXcmFwLnJlc3VsdEFkYXB0ZXIoJ3NxbGl0ZTMqJywgX194UmNQdHIpXG4gICAgKCdzcWxpdGUzX2NvbnRleHQqJywgX194UmNQdHIpXG4gICAgKCdzcWxpdGUzX3N0bXQqJywgX194UmNQdHIpXG4gICAgKCdzcWxpdGUzX3ZhbHVlKicsIF9feFJjUHRyKVxuICAgICgnc3FsaXRlM192ZnMqJywgX194UmNQdHIpXG4gICAgKCd2b2lkKicsIF9feFJjUHRyKTtcblxuICAgIFxuICAgIGlmKDAgPT09IHdhc20uZXhwb3J0cy5zcWxpdGUzX3N0ZXAubGVuZ3RoKXtcbiAgICAgIFxuICAgICAgd2FzbS54V3JhcC5kb0FyZ2NDaGVjayA9IGZhbHNlO1xuICAgICAgc3FsaXRlMy5jb25maWcud2FybihcbiAgICAgICAgXCJEaXNhYmxpbmcgc3FsaXRlMy53YXNtLnhXcmFwLmRvQXJnY0NoZWNrIGR1ZSB0byBlbnZpcm9ubWVudGFsIHF1aXJrcy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGUgb2Ygd2FzbS5iaW5kaW5nU2lnbmF0dXJlcyl7XG4gICAgICBjYXBpW2VbMF1dID0gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKTtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGUgb2Ygd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy53YXNtKXtcbiAgICAgIHdhc21bZVswXV0gPSB3YXNtLnhXcmFwLmFwcGx5KG51bGwsIGUpO1xuICAgIH1cblxuICAgIFxuICAgIGNvbnN0IGZJNjREaXNhYmxlZCA9IGZ1bmN0aW9uKGZuYW1lKXtcbiAgICAgIHJldHVybiAoKT0+dG9zcyhmbmFtZStcIigpIGlzIHVuYXZhaWxhYmxlIGR1ZSB0byBsYWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJvZiBCaWdJbnQgc3VwcG9ydCBpbiB0aGlzIGJ1aWxkLlwiKTtcbiAgICB9O1xuICAgIGZvcihjb25zdCBlIG9mIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQpe1xuICAgICAgY2FwaVtlWzBdXSA9IHdhc20uYmlnSW50RW5hYmxlZFxuICAgICAgICA/IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSlcbiAgICAgICAgOiBmSTY0RGlzYWJsZWQoZVswXSk7XG4gICAgfVxuXG4gICAgXG4gICAgZGVsZXRlIHdhc20uYmluZGluZ1NpZ25hdHVyZXM7XG5cbiAgICBpZih3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2RiX2Vycm9yKXtcbiAgICAgIGNvbnN0IF9fZGJfZXJyID0gd2FzbS54V3JhcChcbiAgICAgICAgJ3NxbGl0ZTNfd2FzbV9kYl9lcnJvcicsICdpbnQnLCAnc3FsaXRlMyonLCAnaW50JywgJ3N0cmluZydcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yID0gZnVuY3Rpb24ocERiLCByZXN1bHRDb2RlLCBtZXNzYWdlKXtcbiAgICAgICAgaWYocmVzdWx0Q29kZSBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3Ipe1xuICAgICAgICAgIHJlc3VsdENvZGUgPSBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgICAgICBtZXNzYWdlID0gMCA7XG4gICAgICAgIH1lbHNlIGlmKHJlc3VsdENvZGUgaW5zdGFuY2VvZiBFcnJvcil7XG4gICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJycrcmVzdWx0Q29kZTtcbiAgICAgICAgICByZXN1bHRDb2RlID0gKHJlc3VsdENvZGUucmVzdWx0Q29kZSB8fCBjYXBpLlNRTElURV9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBEYiA/IF9fZGJfZXJyKHBEYiwgcmVzdWx0Q29kZSwgbWVzc2FnZSkgOiByZXN1bHRDb2RlO1xuICAgICAgfTtcbiAgICB9ZWxzZXtcbiAgICAgIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yID0gZnVuY3Rpb24ocERiLGVyckNvZGUsbXNnKXtcbiAgICAgICAgY29uc29sZS53YXJuKFwic3FsaXRlM193YXNtX2RiX2Vycm9yKCkgaXMgbm90IGV4cG9ydGVkLlwiLGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBlcnJDb2RlO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgY29uc3QgY0pzb24gPSB3YXNtLnhDYWxsKCdzcWxpdGUzX3dhc21fZW51bV9qc29uJyk7XG4gICAgaWYoIWNKc29uKXtcbiAgICAgIHRvc3MoXCJNYWludGVuYW5jZSByZXF1aXJlZDogaW5jcmVhc2Ugc3FsaXRlM193YXNtX2VudW1fanNvbigpJ3NcIixcbiAgICAgICAgICAgXCJzdGF0aWMgYnVmZmVyIHNpemUhXCIpO1xuICAgIH1cbiAgICBcbiAgICB3YXNtLmN0eXBlID0gSlNPTi5wYXJzZSh3YXNtLmNzdHJUb0pzKGNKc29uKSk7XG4gICAgXG4gICAgY29uc3QgZGVmaW5lR3JvdXBzID0gWydhY2Nlc3MnLCAnYXV0aG9yaXplcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdibG9iRmluYWxpemVycycsICdjaGFuZ2VzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnJywgJ2RhdGFUeXBlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYkNvbmZpZycsICdkYlN0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdlbmNvZGluZ3MnLCAnZmNudGwnLCAnZmxvY2snLCAnaW9DYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnbGltaXRzJywgJ29wZW5GbGFncycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdwcmVwYXJlRmxhZ3MnLCAncmVzdWx0Q29kZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnc3FsaXRlM1N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdzdG10U3RhdHVzJywgJ3N5bmNGbGFncycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICd0cmFjZScsICd0eG5TdGF0ZScsICd1ZGZGbGFncycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICd2ZXJzaW9uJyBdO1xuICAgIGlmKHdhc20uYmlnSW50RW5hYmxlZCl7XG4gICAgICBkZWZpbmVHcm91cHMucHVzaCgnc2VyaWFsaXplJywgJ3Nlc3Npb24nLCAndnRhYicpO1xuICAgIH1cbiAgICBmb3IoY29uc3QgdCBvZiBkZWZpbmVHcm91cHMpe1xuICAgICAgZm9yKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMod2FzbS5jdHlwZVt0XSkpe1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGNhcGlbZVswXV0gPSBlWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZighd2FzbS5mdW5jdGlvbkVudHJ5KGNhcGkuU1FMSVRFX1dBU01fREVBTExPQykpe1xuICAgICAgdG9zcyhcIkludGVybmFsIGVycm9yOiBjYW5ub3QgcmVzb2x2ZSBleHBvcnRlZCBmdW5jdGlvblwiLFxuICAgICAgICAgICBcImVudHJ5IFNRTElURV9XQVNNX0RFQUxMT0MgKD09XCIrY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DK1wiKS5cIik7XG4gICAgfVxuICAgIGNvbnN0IF9fcmNNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvcihjb25zdCB0IG9mIFsncmVzdWx0Q29kZXMnXSl7XG4gICAgICBmb3IoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh3YXNtLmN0eXBlW3RdKSl7XG4gICAgICAgIF9fcmNNYXBbZVsxXV0gPSBlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyID0gKHJjKT0+X19yY01hcFtyY107XG4gICAgXG4gICAgY29uc3Qgbm90VGhlc2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgICAgXG4gICAgICBXYXNtVGVzdFN0cnVjdDogdHJ1ZSxcbiAgICAgIFxuICAgICAgc3FsaXRlM19rdnZmc19tZXRob2RzOiAhdXRpbC5pc1VJVGhyZWFkKCksXG4gICAgICBcbiAgICAgIHNxbGl0ZTNfaW5kZXhfaW5mbzogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgIHNxbGl0ZTNfaW5kZXhfY29uc3RyYWludDogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgIHNxbGl0ZTNfaW5kZXhfb3JkZXJieTogIXdhc20uYmlnSW50RW5hYmxlZCxcbiAgICAgIHNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZTogIXdhc20uYmlnSW50RW5hYmxlZFxuICAgIH0pO1xuICAgIGZvcihjb25zdCBzIG9mIHdhc20uY3R5cGUuc3RydWN0cyl7XG4gICAgICBpZighbm90VGhlc2Vbcy5uYW1lXSl7XG4gICAgICAgIGNhcGlbcy5uYW1lXSA9IHNxbGl0ZTMuU3RydWN0QmluZGVyKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mbyl7XG4gICAgICBcbiAgICAgIGZvcihjb25zdCBrIG9mIFsnc3FsaXRlM19pbmRleF9jb25zdHJhaW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAnc3FsaXRlM19pbmRleF9vcmRlcmJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAnc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlJ10pe1xuICAgICAgICBjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mb1trXSA9IGNhcGlba107XG4gICAgICAgIGRlbGV0ZSBjYXBpW2tdO1xuICAgICAgfVxuICAgICAgY2FwaS5zcWxpdGUzX3Z0YWJfY29uZmlnID0gd2FzbS54V3JhcChcbiAgICAgICAgJ3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZycsJ2ludCcsW1xuICAgICAgICAgICdzcWxpdGUzKicsICdpbnQnLCAnaW50J11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgXG4gIGNvbnN0IF9fZGJBcmdjTWlzbWF0Y2ggPSAocERiLGYsbik9PntcbiAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IocERiLCBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYrXCIoKSByZXF1aXJlcyBcIituK1wiIGFyZ3VtZW50XCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgxPT09bj9cIlwiOidzJykrXCIuXCIpO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2VyckVuY29kaW5nID0gKHBEYik9PntcbiAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICBwRGIsIGNhcGkuU1FMSVRFX0ZPUk1BVCwgXCJTUUxJVEVfVVRGOCBpcyB0aGUgb25seSBzdXBwb3J0ZWQgZW5jb2RpbmcuXCJcbiAgICApO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2FyZ1BEYiA9IChwRGIpPT53YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoJ3NxbGl0ZTMqJykocERiKTtcbiAgY29uc3QgX19hcmdTdHIgPSAoc3RyKT0+d2FzbS5pc1B0cihzdHIpID8gd2FzbS5jc3RyVG9KcyhzdHIpIDogc3RyO1xuICBjb25zdCBfX2RiQ2xlYW51cE1hcCA9IGZ1bmN0aW9uKFxuICAgIHBEYiwgbW9kZVxuICApe1xuICAgIHBEYiA9IF9fYXJnUERiKHBEYik7XG4gICAgbGV0IG0gPSB0aGlzLmRiTWFwLmdldChwRGIpO1xuICAgIGlmKCFtb2RlKXtcbiAgICAgIHRoaXMuZGJNYXAuZGVsZXRlKHBEYik7XG4gICAgICByZXR1cm4gbTtcbiAgICB9ZWxzZSBpZighbSAmJiBtb2RlPjApe1xuICAgICAgdGhpcy5kYk1hcC5zZXQocERiLCAobSA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH0uYmluZChPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgIGRiTWFwOiBuZXcgTWFwXG4gIH0pKTtcblxuICBfX2RiQ2xlYW51cE1hcC5hZGRDb2xsYXRpb24gPSBmdW5jdGlvbihwRGIsIG5hbWUpe1xuICAgIGNvbnN0IG0gPSBfX2RiQ2xlYW51cE1hcChwRGIsIDEpO1xuICAgIGlmKCFtLmNvbGxhdGlvbikgbS5jb2xsYXRpb24gPSBuZXcgU2V0O1xuICAgIG0uY29sbGF0aW9uLmFkZChfX2FyZ1N0cihuYW1lKS50b0xvd2VyQ2FzZSgpKTtcbiAgfTtcblxuICBfX2RiQ2xlYW51cE1hcC5fYWRkVURGID0gZnVuY3Rpb24ocERiLCBuYW1lLCBhcml0eSwgbWFwKXtcbiAgICBcbiAgICBuYW1lID0gX19hcmdTdHIobmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgdSA9IG1hcC5nZXQobmFtZSk7XG4gICAgaWYoIXUpIG1hcC5zZXQobmFtZSwgKHUgPSBuZXcgU2V0KSk7XG4gICAgdS5hZGQoKGFyaXR5PDApID8gLTEgOiBhcml0eSk7XG4gIH07XG5cbiAgX19kYkNsZWFudXBNYXAuYWRkRnVuY3Rpb24gPSBmdW5jdGlvbihwRGIsIG5hbWUsIGFyaXR5KXtcbiAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAxKTtcbiAgICBpZighbS51ZGYpIG0udWRmID0gbmV3IE1hcDtcbiAgICB0aGlzLl9hZGRVREYocERiLCBuYW1lLCBhcml0eSwgbS51ZGYpO1xuICB9O1xuXG4gIF9fZGJDbGVhbnVwTWFwLmFkZFdpbmRvd0Z1bmMgPSBmdW5jdGlvbihwRGIsIG5hbWUsIGFyaXR5KXtcbiAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAxKTtcbiAgICBpZighbS53dWRmKSBtLnd1ZGYgPSBuZXcgTWFwO1xuICAgIHRoaXMuX2FkZFVERihwRGIsIG5hbWUsIGFyaXR5LCBtLnd1ZGYpO1xuICB9O1xuXG4gIFxuICBfX2RiQ2xlYW51cE1hcC5jbGVhbnVwID0gZnVuY3Rpb24ocERiKXtcbiAgICBwRGIgPSBfX2FyZ1BEYihwRGIpO1xuICAgIFxuICAgIFxuICAgIGNvbnN0IGNsb3NlQXJncyA9IFtwRGJdO1xuICAgIGZvcihjb25zdCBuYW1lIG9mIFtcbiAgICAgICdzcWxpdGUzX2J1c3lfaGFuZGxlcicsXG4gICAgICAnc3FsaXRlM19jb21taXRfaG9vaycsXG4gICAgICAnc3FsaXRlM19wcmV1cGRhdGVfaG9vaycsXG4gICAgICAnc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyJyxcbiAgICAgICdzcWxpdGUzX3JvbGxiYWNrX2hvb2snLFxuICAgICAgJ3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXInLFxuICAgICAgJ3NxbGl0ZTNfdHJhY2VfdjInLFxuICAgICAgJ3NxbGl0ZTNfdXBkYXRlX2hvb2snXG4gICAgXSkge1xuICAgICAgY29uc3QgeCA9IHdhc20uZXhwb3J0c1tuYW1lXTtcbiAgICAgIGNsb3NlQXJncy5sZW5ndGggPSB4Lmxlbmd0aFxuICAgICAgO1xuICAgICAgdHJ5eyBjYXBpW25hbWVdKC4uLmNsb3NlQXJncykgfVxuICAgICAgY2F0Y2goZSl7XG4gICAgICAgIGNvbnNvbGUud2FybihcImNsb3NlLXRpbWUgY2FsbCBvZlwiLG5hbWUrXCIoXCIsY2xvc2VBcmdzLFwiKSB0aHJldzpcIixlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMCk7XG4gICAgaWYoIW0pIHJldHVybjtcbiAgICBpZihtLmNvbGxhdGlvbil7XG4gICAgICBmb3IoY29uc3QgbmFtZSBvZiBtLmNvbGxhdGlvbil7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MihcbiAgICAgICAgICAgIHBEYiwgbmFtZSwgY2FwaS5TUUxJVEVfVVRGOCwgMCwgMCwgMFxuICAgICAgICAgICk7XG4gICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIG0uY29sbGF0aW9uO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCAyOyArK2kpeyBcbiAgICAgIGNvbnN0IGZtYXAgPSBpID8gbS53dWRmIDogbS51ZGY7XG4gICAgICBpZighZm1hcCkgY29udGludWU7XG4gICAgICBjb25zdCBmdW5jID0gaVxuICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblxuICAgICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyO1xuICAgICAgZm9yKGNvbnN0IGUgb2YgZm1hcCl7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBlWzBdLCBhcml0aWVzID0gZVsxXTtcbiAgICAgICAgY29uc3QgZmFyZ3MgPSBbcERiLCBuYW1lLCAwLCBjYXBpLlNRTElURV9VVEY4LCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgaWYoaSkgZmFyZ3MucHVzaCgwKTtcbiAgICAgICAgZm9yKGNvbnN0IGFyaXR5IG9mIGFyaXRpZXMpe1xuICAgICAgICAgIHRyeXsgZmFyZ3NbMl0gPSBhcml0eTsgZnVuYy5hcHBseShudWxsLCBmYXJncyk7IH1cbiAgICAgICAgICBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgYXJpdGllcy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgZm1hcC5jbGVhcigpO1xuICAgIH1cbiAgICBkZWxldGUgbS51ZGY7XG4gICAgZGVsZXRlIG0ud3VkZjtcbiAgfTtcblxuICB7XG4gICAgY29uc3QgX19zcWxpdGUzQ2xvc2VWMiA9IHdhc20ueFdyYXAoXCJzcWxpdGUzX2Nsb3NlX3YyXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIik7XG4gICAgY2FwaS5zcWxpdGUzX2Nsb3NlX3YyID0gZnVuY3Rpb24ocERiKXtcbiAgICAgIGlmKDEhPT1hcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2Nsb3NlX3YyJywgMSk7XG4gICAgICBpZihwRGIpe1xuICAgICAgICB0cnl7X19kYkNsZWFudXBNYXAuY2xlYW51cChwRGIpfSBjYXRjaChlKXt9XG4gICAgICB9XG4gICAgICByZXR1cm4gX19zcWxpdGUzQ2xvc2VWMihwRGIpO1xuICAgIH07XG4gIH1cblxuICBpZihjYXBpLnNxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlcil7XG4gICAgY29uc3QgX19zcWxpdGUzU2Vzc2lvbkRlbGV0ZSA9IHdhc20ueFdyYXAoXG4gICAgICAnc3FsaXRlM3Nlc3Npb25fZGVsZXRlJywgdW5kZWZpbmVkLCBbJ3NxbGl0ZTNfc2Vzc2lvbionXVxuICAgICk7XG4gICAgY2FwaS5zcWxpdGUzc2Vzc2lvbl9kZWxldGUgPSBmdW5jdGlvbihwU2Vzc2lvbil7XG4gICAgICBpZigxIT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZScsIDEpO1xuICAgICAgICBcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYocFNlc3Npb24pe1xuICAgICAgICBcbiAgICAgICAgY2FwaS5zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIocFNlc3Npb24sIDAsIDApO1xuICAgICAgfVxuICAgICAgX19zcWxpdGUzU2Vzc2lvbkRlbGV0ZShwU2Vzc2lvbik7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBcbiAgICBjb25zdCBjb250ZXh0S2V5ID0gKGFyZ3YsYXJnSW5kZXgpPT57XG4gICAgICByZXR1cm4gJ2FyZ3ZbJythcmdJbmRleCsnXTonK2FyZ3ZbMF0rXG4gICAgICAgICc6Jyt3YXNtLmNzdHJUb0pzKGFyZ3ZbMV0pLnRvTG93ZXJDYXNlKClcbiAgICB9O1xuICAgIGNvbnN0IF9fc3FsaXRlM0NyZWF0ZUNvbGxhdGlvblYyID0gd2FzbS54V3JhcChcbiAgICAgICdzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlMyonLCAnc3RyaW5nJywgJ2ludCcsICcqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIFxuICAgICAgICAgIG5hbWU6ICd4Q29tcGFyZScsIHNpZ25hdHVyZTogJ2kocGlwaXApJywgY29udGV4dEtleVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIFxuICAgICAgICAgIG5hbWU6ICd4RGVzdHJveScsIHNpZ25hdHVyZTogJ3YocCknLCBjb250ZXh0S2V5XG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgKTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyID0gZnVuY3Rpb24ocERiLHpOYW1lLGVUZXh0UmVwLHBBcmcseENvbXBhcmUseERlc3Ryb3kpe1xuICAgICAgaWYoNiE9PWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MicsIDYpO1xuICAgICAgZWxzZSBpZiggMCA9PT0gKGVUZXh0UmVwICYgMHhmKSApe1xuICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgfWVsc2UgaWYoIGNhcGkuU1FMSVRFX1VURjggIT09IChlVGV4dFJlcCAmIDB4ZikgKXtcbiAgICAgICAgcmV0dXJuIF9fZXJyRW5jb2RpbmcocERiKTtcbiAgICAgIH1cbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVDb2xsYXRpb25WMihwRGIsIHpOYW1lLCBlVGV4dFJlcCwgcEFyZywgeENvbXBhcmUsIHhEZXN0cm95KTtcbiAgICAgICAgaWYoMD09PXJjICYmIHhDb21wYXJlIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZENvbGxhdGlvbihwRGIsIHpOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihwRGIsIGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiA9IChwRGIsek5hbWUsZVRleHRSZXAscEFyZyx4Q29tcGFyZSk9PntcbiAgICAgIHJldHVybiAoNT09PWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgID8gY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIocERiLHpOYW1lLGVUZXh0UmVwLHBBcmcseENvbXBhcmUsMClcbiAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYiwgJ3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbicsIDUpO1xuICAgIH07XG5cbiAgfVxuXG4gIHtcbiAgICBcbiAgICBjb25zdCBjb250ZXh0S2V5ID0gZnVuY3Rpb24oYXJndixhcmdJbmRleCl7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBhcmd2WzBdXG4gICAgICAgICAgKyc6JysoYXJndlsyXSA8IDAgPyAtMSA6IGFyZ3ZbMl0pXG4gICAgICAgICAgKyc6JythcmdJbmRleFxuICAgICAgICAgICsnOicrd2FzbS5jc3RyVG9Kcyhhcmd2WzFdKS50b0xvd2VyQ2FzZSgpXG4gICAgICApXG4gICAgfTtcblxuICAgIFxuICAgIGNvbnN0IF9fY2ZQcm94eSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgeEludmVyc2VBbmRTdGVwOiB7XG4gICAgICAgIHNpZ25hdHVyZTondihwaXApJywgY29udGV4dEtleSxcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgcmV0dXJuIChwQ3R4LCBhcmdjLCBwQXJndik9PntcbiAgICAgICAgICAgIHRyeXsgY2FsbGJhY2socEN0eCwgLi4uY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcyhhcmdjLCBwQXJndikpIH1cbiAgICAgICAgICAgIGNhdGNoKGUpeyBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzKHBDdHgsIGUpIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeEZpbmFsQW5kVmFsdWU6IHtcbiAgICAgICAgc2lnbmF0dXJlOid2KHApJywgY29udGV4dEtleSxcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgcmV0dXJuIChwQ3R4KT0+e1xuICAgICAgICAgICAgdHJ5eyBjYXBpLnNxbGl0ZTNfcmVzdWx0X2pzKHBDdHgsIGNhbGxiYWNrKHBDdHgpKSB9XG4gICAgICAgICAgICBjYXRjaChlKXsgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCBlKSB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHhGdW5jOiB7XG4gICAgICAgIHNpZ25hdHVyZTondihwaXApJywgY29udGV4dEtleSxcbiAgICAgICAgY2FsbFByb3h5OiAoY2FsbGJhY2spPT57XG4gICAgICAgICAgcmV0dXJuIChwQ3R4LCBhcmdjLCBwQXJndik9PntcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcyhcbiAgICAgICAgICAgICAgICBwQ3R4LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBDdHgsIC4uLmNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanMoYXJnYywgcEFyZ3YpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeERlc3Ryb3k6IHtcbiAgICAgICAgc2lnbmF0dXJlOid2KHApJywgY29udGV4dEtleSxcbiAgICAgICAgXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIHJldHVybiAocFZvaWQpPT57XG4gICAgICAgICAgICB0cnl7IGNhbGxiYWNrKHBWb2lkKSB9XG4gICAgICAgICAgICBjYXRjaChlKXsgY29uc29sZS5lcnJvcihcIlVERiB4RGVzdHJveSBtZXRob2QgdGhyZXc6XCIsZSkgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IF9fc3FsaXRlM0NyZWF0ZUZ1bmN0aW9uID0gd2FzbS54V3JhcChcbiAgICAgIFwic3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjJcIiwgXCJpbnRcIiwgW1xuICAgICAgICBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiaW50XCIsXG4gICAgICAgIFwiaW50XCIsIFwiKlwiLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hGdW5jJywgLi4uX19jZlByb3h5LnhGdW5jfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneFN0ZXAnLCAuLi5fX2NmUHJveHkueEludmVyc2VBbmRTdGVwfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneEZpbmFsJywgLi4uX19jZlByb3h5LnhGaW5hbEFuZFZhbHVlfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneERlc3Ryb3knLCAuLi5fX2NmUHJveHkueERlc3Ryb3l9KVxuICAgICAgXVxuICAgICk7XG5cbiAgICBjb25zdCBfX3NxbGl0ZTNDcmVhdGVXaW5kb3dGdW5jdGlvbiA9IHdhc20ueFdyYXAoXG4gICAgICBcInNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblwiLCBcImludFwiLCBbXG4gICAgICAgIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIixcbiAgICAgICAgXCJpbnRcIiwgXCIqXCIsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneFN0ZXAnLCAuLi5fX2NmUHJveHkueEludmVyc2VBbmRTdGVwfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneEZpbmFsJywgLi4uX19jZlByb3h5LnhGaW5hbEFuZFZhbHVlfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneFZhbHVlJywgLi4uX19jZlByb3h5LnhGaW5hbEFuZFZhbHVlfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneEludmVyc2UnLCAuLi5fX2NmUHJveHkueEludmVyc2VBbmRTdGVwfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtuYW1lOiAneERlc3Ryb3knLCAuLi5fX2NmUHJveHkueERlc3Ryb3l9KVxuICAgICAgXVxuICAgICk7XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyID0gZnVuY3Rpb24gZihcbiAgICAgIHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLCBwQXBwLFxuICAgICAgeEZ1bmMsICAgXG4gICAgICB4U3RlcCwgICBcbiAgICAgIHhGaW5hbCwgIFxuICAgICAgeERlc3Ryb3kgXG4gICAgKXtcbiAgICAgIGlmKCBmLmxlbmd0aCE9PWFyZ3VtZW50cy5sZW5ndGggKXtcbiAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLFwic3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjJcIixmLmxlbmd0aCk7XG4gICAgICB9ZWxzZSBpZiggMCA9PT0gKGVUZXh0UmVwICYgMHhmKSApe1xuICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgfWVsc2UgaWYoIGNhcGkuU1FMSVRFX1VURjggIT09IChlVGV4dFJlcCAmIDB4ZikgKXtcbiAgICAgICAgcmV0dXJuIF9fZXJyRW5jb2RpbmcocERiKTtcbiAgICAgIH1cbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVGdW5jdGlvbihwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwQXBwLCB4RnVuYywgeFN0ZXAsIHhGaW5hbCwgeERlc3Ryb3kpO1xuICAgICAgICBpZigwPT09cmMgJiYgKHhGdW5jIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8fCB4U3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfHwgeEZpbmFsIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8fCB4RGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkRnVuY3Rpb24ocERiLCBmdW5jTmFtZSwgbkFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBjb25zb2xlLmVycm9yKFwic3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIoKSBzZXR1cCB0aHJldzpcIixlKTtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKHBEYiwgZSwgXCJDcmVhdGlvbiBvZiBVREYgdGhyZXc6IFwiK2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uID0gZnVuY3Rpb24gZihcbiAgICAgIHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLCBwQXBwLFxuICAgICAgeEZ1bmMsIHhTdGVwLCB4RmluYWxcbiAgICApe1xuICAgICAgcmV0dXJuIChmLmxlbmd0aD09PWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgID8gY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MihwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBBcHAsIHhGdW5jLCB4U3RlcCwgeEZpbmFsLCAwKVxuICAgICAgICA6IF9fZGJBcmdjTWlzbWF0Y2gocERiLFwic3FsaXRlM19jcmVhdGVfZnVuY3Rpb25cIixmLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uID0gZnVuY3Rpb24gZihcbiAgICAgIHBEYiwgZnVuY05hbWUsIG5BcmcsIGVUZXh0UmVwLCBwQXBwLFxuICAgICAgeFN0ZXAsICAgXG4gICAgICB4RmluYWwsICBcbiAgICAgIHhWYWx1ZSwgIFxuICAgICAgeEludmVyc2UsXG4gICAgICB4RGVzdHJveSBcbiAgICApe1xuICAgICAgaWYoIGYubGVuZ3RoIT09YXJndW1lbnRzLmxlbmd0aCApe1xuICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsXCJzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb25cIixmLmxlbmd0aCk7XG4gICAgICB9ZWxzZSBpZiggMCA9PT0gKGVUZXh0UmVwICYgMHhmKSApe1xuICAgICAgICBlVGV4dFJlcCB8PSBjYXBpLlNRTElURV9VVEY4O1xuICAgICAgfWVsc2UgaWYoIGNhcGkuU1FMSVRFX1VURjggIT09IChlVGV4dFJlcCAmIDB4ZikgKXtcbiAgICAgICAgcmV0dXJuIF9fZXJyRW5jb2RpbmcocERiKTtcbiAgICAgIH1cbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgcmMgPSBfX3NxbGl0ZTNDcmVhdGVXaW5kb3dGdW5jdGlvbihwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwQXBwLCB4U3RlcCwgeEZpbmFsLCB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeEludmVyc2UsIHhEZXN0cm95KTtcbiAgICAgICAgaWYoMD09PXJjICYmICh4U3RlcCBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfHwgeEZpbmFsIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8fCB4VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHx8IHhJbnZlcnNlIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8fCB4RGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgICAgICAgX19kYkNsZWFudXBNYXAuYWRkV2luZG93RnVuYyhwRGIsIGZ1bmNOYW1lLCBuQXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24oKSBzZXR1cCB0aHJldzpcIixlKTtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKHBEYiwgZSwgXCJDcmVhdGlvbiBvZiBVREYgdGhyZXc6IFwiK2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mi51ZGZTZXRSZXN1bHQgPVxuICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbi51ZGZTZXRSZXN1bHQgPVxuICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmU2V0UmVzdWx0ID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcztcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIudWRmQ29udmVydEFyZ3MgPVxuICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbi51ZGZDb252ZXJ0QXJncyA9XG4gICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbi51ZGZDb252ZXJ0QXJncyA9IGNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanM7XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyLnVkZlNldEVycm9yID1cbiAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmU2V0RXJyb3IgPVxuICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmU2V0RXJyb3IgPSBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yX2pzO1xuXG4gIH07XG5cbiAge1xuXG4gICAgXG4gICAgY29uc3QgX19mbGV4aVN0cmluZyA9ICh2LG4pPT57XG4gICAgICBpZignc3RyaW5nJz09PXR5cGVvZiB2KXtcbiAgICAgICAgbiA9IC0xO1xuICAgICAgfWVsc2UgaWYodXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KHYpKXtcbiAgICAgICAgbiA9IHYuYnl0ZUxlbmd0aDtcbiAgICAgICAgdiA9IHV0aWwudHlwZWRBcnJheVRvU3RyaW5nKFxuICAgICAgICAgICh2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpID8gbmV3IFVpbnQ4QXJyYXkodikgOiB2XG4gICAgICAgICk7XG4gICAgICB9ZWxzZSBpZihBcnJheS5pc0FycmF5KHYpKXtcbiAgICAgICAgdiA9IHYuam9pbihcIlwiKTtcbiAgICAgICAgbiA9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt2LCBuXTtcbiAgICB9O1xuXG4gICAgXG4gICAgY29uc3QgX19wcmVwYXJlID0ge1xuICAgICAgXG4gICAgICBiYXNpYzogd2FzbS54V3JhcCgnc3FsaXRlM19wcmVwYXJlX3YzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW50XCIsIFwiKipcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIqKlwiXSksXG4gICAgICBcbiAgICAgIGZ1bGw6IHdhc20ueFdyYXAoJ3NxbGl0ZTNfcHJlcGFyZV92MycsXG4gICAgICAgICAgICAgICAgICAgICAgIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsIFwiKlwiLCBcImludFwiLCBcImludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKipcIiwgXCIqKlwiXSlcbiAgICB9O1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjMgPSBmdW5jdGlvbiBmKHBEYiwgc3FsLCBzcWxMZW4sIHByZXBGbGFncywgcHBTdG10LCBwelRhaWwpe1xuICAgICAgaWYoZi5sZW5ndGghPT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLFwic3FsaXRlM19wcmVwYXJlX3YzXCIsZi5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3QgW3hTcWwsIHhTcWxMZW5dID0gX19mbGV4aVN0cmluZyhzcWwsIHNxbExlbik7XG4gICAgICBzd2l0Y2godHlwZW9mIHhTcWwpe1xuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBfX3ByZXBhcmUuYmFzaWMocERiLCB4U3FsLCB4U3FsTGVuLCBwcmVwRmxhZ3MsIHBwU3RtdCwgbnVsbCk7XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIF9fcHJlcGFyZS5mdWxsKHBEYiwgeFNxbCwgeFNxbExlbiwgcHJlcEZsYWdzLCBwcFN0bXQsIHB6VGFpbCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgICAgcERiLCBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICAgIFwiSW52YWxpZCBTUUwgYXJndW1lbnQgdHlwZSBmb3Igc3FsaXRlM19wcmVwYXJlX3YyL3YzKCkuXCJcbiAgICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyID0gZnVuY3Rpb24gZihwRGIsIHNxbCwgc3FsTGVuLCBwcFN0bXQsIHB6VGFpbCl7XG4gICAgICByZXR1cm4gKGYubGVuZ3RoPT09YXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgPyBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyhwRGIsIHNxbCwgc3FsTGVuLCAwLCBwcFN0bXQsIHB6VGFpbClcbiAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYixcInNxbGl0ZTNfcHJlcGFyZV92MlwiLGYubGVuZ3RoKTtcbiAgICB9O1xuXG4gIH1cblxuICB7XG4gICAgY29uc3QgX19iaW5kVGV4dCA9IHdhc20ueFdyYXAoXCJzcWxpdGUzX2JpbmRfdGV4dFwiLCBcImludFwiLCBbXG4gICAgICBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIiwgXCIqXCJcbiAgICBdKTtcbiAgICBjb25zdCBfX2JpbmRCbG9iID0gd2FzbS54V3JhcChcInNxbGl0ZTNfYmluZF9ibG9iXCIsIFwiaW50XCIsIFtcbiAgICAgIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiLCBcIipcIiwgXCJpbnRcIiwgXCIqXCJcbiAgICBdKTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19iaW5kX3RleHQgPSBmdW5jdGlvbiBmKHBTdG10LCBpQ29sLCB0ZXh0LCBuVGV4dCwgeERlc3Ryb3kpe1xuICAgICAgaWYoZi5sZW5ndGghPT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3FsaXRlM19iaW5kX3RleHRcIiwgZi5sZW5ndGgpO1xuICAgICAgfWVsc2UgaWYod2FzbS5pc1B0cih0ZXh0KSB8fCBudWxsPT09dGV4dCl7XG4gICAgICAgIHJldHVybiBfX2JpbmRUZXh0KHBTdG10LCBpQ29sLCB0ZXh0LCBuVGV4dCwgeERlc3Ryb3kpO1xuICAgICAgfWVsc2UgaWYodGV4dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtcbiAgICAgICAgdGV4dCA9IG5ldyBVaW50OEFycmF5KHRleHQpO1xuICAgICAgfWVsc2UgaWYoQXJyYXkuaXNBcnJheShwTWVtKSl7XG4gICAgICAgIHRleHQgPSBwTWVtLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgbGV0IHAsIG47XG4gICAgICB0cnl7XG4gICAgICAgIGlmKHV0aWwuaXNTUUxhYmxlVHlwZWRBcnJheSh0ZXh0KSl7XG4gICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSh0ZXh0KTtcbiAgICAgICAgICBuID0gdGV4dC5ieXRlTGVuZ3RoO1xuICAgICAgICB9ZWxzZSBpZignc3RyaW5nJz09PXR5cGVvZiB0ZXh0KXtcbiAgICAgICAgICBbcCwgbl0gPSB3YXNtLmFsbG9jQ1N0cmluZyh0ZXh0KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksIGNhcGkuU1FMSVRFX01JU1VTRSxcbiAgICAgICAgICAgIFwiSW52YWxpZCAzcmQgYXJndW1lbnQgdHlwZSBmb3Igc3FsaXRlM19iaW5kX3RleHQoKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYmluZFRleHQocFN0bXQsIGlDb2wsIHAsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHdhc20uZGVhbGxvYyhwKTtcbiAgICAgICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLCBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19iaW5kX2Jsb2IgPSBmdW5jdGlvbiBmKHBTdG10LCBpQ29sLCBwTWVtLCBuTWVtLCB4RGVzdHJveSl7XG4gICAgICBpZihmLmxlbmd0aCE9PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcWxpdGUzX2JpbmRfYmxvYlwiLCBmLmxlbmd0aCk7XG4gICAgICB9ZWxzZSBpZih3YXNtLmlzUHRyKHBNZW0pIHx8IG51bGw9PT1wTWVtKXtcbiAgICAgICAgcmV0dXJuIF9fYmluZEJsb2IocFN0bXQsIGlDb2wsIHBNZW0sIG5NZW0sIHhEZXN0cm95KTtcbiAgICAgIH1lbHNlIGlmKHBNZW0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7XG4gICAgICAgIHBNZW0gPSBuZXcgVWludDhBcnJheShwTWVtKTtcbiAgICAgIH1lbHNlIGlmKEFycmF5LmlzQXJyYXkocE1lbSkpe1xuICAgICAgICBwTWVtID0gcE1lbS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGxldCBwLCBuO1xuICAgICAgdHJ5e1xuICAgICAgICBpZih1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHBNZW0pKXtcbiAgICAgICAgICBwID0gd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KHBNZW0pO1xuICAgICAgICAgIG4gPSBuTWVtPj0wID8gbk1lbSA6IHBNZW0uYnl0ZUxlbmd0aDtcbiAgICAgICAgfWVsc2UgaWYoJ3N0cmluZyc9PT10eXBlb2YgcE1lbSl7XG4gICAgICAgICAgW3AsIG5dID0gd2FzbS5hbGxvY0NTdHJpbmcocE1lbSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLCBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICBcIkludmFsaWQgM3JkIGFyZ3VtZW50IHR5cGUgZm9yIHNxbGl0ZTNfYmluZF9ibG9iKCkuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2JpbmRCbG9iKHBTdG10LCBpQ29sLCBwLCBuLCBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICB3YXNtLmRlYWxsb2MocCk7XG4gICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSwgZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgfVxuXG4gIHtcbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY29uZmlnID0gZnVuY3Rpb24ob3AsIC4uLmFyZ3Mpe1xuICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aDwyKSByZXR1cm4gY2FwaS5TUUxJVEVfTUlTVVNFO1xuICAgICAgc3dpdGNoKG9wKXtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19DT1ZFUklOR19JTkRFWF9TQ0FOOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NRU1TVEFUVVM6XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU01BTExfTUFMTE9DOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TT1JURVJSRUZfU0laRTogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU1RNVEpSTkxfU1BJTEw6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1VSSTpcbiAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2NvbmZpZ19pKG9wLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19MT09LQVNJREU6IFxuICAgICAgICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fY29uZmlnX2lpKG9wLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NRU1EQl9NQVhTSVpFOiBcbiAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2NvbmZpZ19qKG9wLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRNQUxMT0M6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0dFVE1VVEVYOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEUyOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRQQ0FDSEU6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0hFQVA6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX0xPRzogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUFMTE9DOlxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01NQVBfU0laRTogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTVVMVElUSFJFQUQ6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01VVEVYOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQUdFQ0FDSEU6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRTI6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRTogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUENBQ0hFX0hEUlNaOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QTUFTWjogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU0VSSUFMSVpFRDogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU0lOR0xFVEhSRUFEOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19TUUxMT0c6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1dJTjMyX0hFQVBTSVpFOiBcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PVEZPVU5EO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgY29uc3QgX19hdXRvRXh0RnB0ciA9IG5ldyBTZXQ7XG5cbiAgICBjYXBpLnNxbGl0ZTNfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbihmUHRyKXtcbiAgICAgIGlmKCBmUHRyIGluc3RhbmNlb2YgRnVuY3Rpb24gKXtcbiAgICAgICAgZlB0ciA9IHdhc20uaW5zdGFsbEZ1bmN0aW9uKCdpKHBwcCknLCBmUHRyKTtcbiAgICAgIH1lbHNlIGlmKCAxIT09YXJndW1lbnRzLmxlbmd0aCB8fCAhd2FzbS5pc1B0cihmUHRyKSApe1xuICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTUlTVVNFO1xuICAgICAgfVxuICAgICAgY29uc3QgcmMgPSB3YXNtLmV4cG9ydHMuc3FsaXRlM19hdXRvX2V4dGVuc2lvbihmUHRyKTtcbiAgICAgIGlmKCBmUHRyIT09YXJndW1lbnRzWzBdICl7XG4gICAgICAgIGlmKDA9PT1yYykgX19hdXRvRXh0RnB0ci5hZGQoZlB0cik7XG4gICAgICAgIGVsc2Ugd2FzbS51bmluc3RhbGxGdW5jdGlvbihmUHRyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYztcbiAgICB9O1xuXG4gICAgY2FwaS5zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbiA9IGZ1bmN0aW9uKGZQdHIpe1xuICAgICA7XG4gICAgICBpZighZlB0ciB8fCAxIT09YXJndW1lbnRzLmxlbmd0aCB8fCAhd2FzbS5pc1B0cihmUHRyKSkgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfY2FuY2VsX2F1dG9fZXh0ZW5zaW9uKGZQdHIpO1xuICAgICAgXG4gICAgfTtcblxuICAgIGNhcGkuc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiA9IGZ1bmN0aW9uKCl7XG4gICAgICB3YXNtLmV4cG9ydHMuc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbigpO1xuICAgICAgZm9yKGNvbnN0IGZwIG9mIF9fYXV0b0V4dEZwdHIpIHdhc20udW5pbnN0YWxsRnVuY3Rpb24oZnApO1xuICAgICAgX19hdXRvRXh0RnB0ci5jbGVhcigpO1xuICAgIH07XG4gIH1cblxuICBjb25zdCBwS3Z2ZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoXCJrdnZmc1wiKTtcbiAgaWYoIHBLdnZmcyApe1xuICAgIGlmKHV0aWwuaXNVSVRocmVhZCgpKXtcbiAgICAgIGNvbnN0IGt2dmZzTWV0aG9kcyA9IG5ldyBjYXBpLnNxbGl0ZTNfa3Z2ZnNfbWV0aG9kcyhcbiAgICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzKClcbiAgICAgICk7XG4gICAgICBkZWxldGUgY2FwaS5zcWxpdGUzX2t2dmZzX21ldGhvZHM7XG5cbiAgICAgIGNvbnN0IGt2dmZzTWFrZUtleSA9IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2ssXG4gICAgICAgICAgICBwc3RhY2sgPSB3YXNtLnBzdGFjaztcblxuICAgICAgY29uc3Qga3Z2ZnNTdG9yYWdlID0gKHpDbGFzcyk9PlxuICAgICAgICAgICAgKCgxMTU9PT13YXNtLnBlZWsoekNsYXNzKSlcbiAgICAgICAgICAgICA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKTtcblxuICAgICAgXG4gICAgICBjb25zdCBrdnZmc0ltcGxzID0ge1xuICAgICAgICB4UmVhZDogKHpDbGFzcywgektleSwgekJ1ZiwgbkJ1Zik9PntcbiAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyLFxuICAgICAgICAgICAgICAgIGFzdGFjayA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHpYS2V5ID0ga3Z2ZnNNYWtlS2V5KHpDbGFzcyx6S2V5KTtcbiAgICAgICAgICAgIGlmKCF6WEtleSkgcmV0dXJuIC0zO1xuICAgICAgICAgICAgY29uc3QgaktleSA9IHdhc20uY3N0clRvSnMoelhLZXkpO1xuICAgICAgICAgICAgY29uc3QgalYgPSBrdnZmc1N0b3JhZ2UoekNsYXNzKS5nZXRJdGVtKGpLZXkpO1xuICAgICAgICAgICAgaWYoIWpWKSByZXR1cm4gLTE7XG4gICAgICAgICAgICBjb25zdCBuViA9IGpWLmxlbmd0aCA7XG4gICAgICAgICAgICBpZihuQnVmPD0wKSByZXR1cm4gblY7XG4gICAgICAgICAgICBlbHNlIGlmKDE9PT1uQnVmKXtcbiAgICAgICAgICAgICAgd2FzbS5wb2tlKHpCdWYsIDApO1xuICAgICAgICAgICAgICByZXR1cm4gblY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB6ViA9IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKGpWKTtcbiAgICAgICAgICAgIGlmKG5CdWYgPiBuViArIDEpIG5CdWYgPSBuViArIDE7XG4gICAgICAgICAgICB3YXNtLmhlYXA4dSgpLmNvcHlXaXRoaW4oekJ1ZiwgelYsIHpWICsgbkJ1ZiAtIDEpO1xuICAgICAgICAgICAgd2FzbS5wb2tlKHpCdWYgKyBuQnVmIC0gMSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbkJ1ZiAtIDE7XG4gICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImt2c3RvcmFnZVJlYWQoKVwiLGUpO1xuICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgIH1maW5hbGx5e1xuICAgICAgICAgICAgcHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChhc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeFdyaXRlOiAoekNsYXNzLCB6S2V5LCB6RGF0YSk9PntcbiAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB6WEtleSA9IGt2dmZzTWFrZUtleSh6Q2xhc3MsektleSk7XG4gICAgICAgICAgICBpZighelhLZXkpIHJldHVybiAxO1xuICAgICAgICAgICAgY29uc3QgaktleSA9IHdhc20uY3N0clRvSnMoelhLZXkpO1xuICAgICAgICAgICAga3Z2ZnNTdG9yYWdlKHpDbGFzcykuc2V0SXRlbShqS2V5LCB3YXNtLmNzdHJUb0pzKHpEYXRhKSk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwia3ZzdG9yYWdlV3JpdGUoKVwiLGUpO1xuICAgICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPRVJSO1xuICAgICAgICAgIH1maW5hbGx5e1xuICAgICAgICAgICAgcHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeERlbGV0ZTogKHpDbGFzcywgektleSk9PntcbiAgICAgICAgICBjb25zdCBzdGFjayA9IHBzdGFjay5wb2ludGVyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB6WEtleSA9IGt2dmZzTWFrZUtleSh6Q2xhc3MsektleSk7XG4gICAgICAgICAgICBpZighelhLZXkpIHJldHVybiAxO1xuICAgICAgICAgICAga3Z2ZnNTdG9yYWdlKHpDbGFzcykucmVtb3ZlSXRlbSh3YXNtLmNzdHJUb0pzKHpYS2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwia3ZzdG9yYWdlRGVsZXRlKClcIixlKTtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUjtcbiAgICAgICAgICB9ZmluYWxseXtcbiAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IoY29uc3QgayBvZiBPYmplY3Qua2V5cyhrdnZmc0ltcGxzKSl7XG4gICAgICAgIGt2dmZzTWV0aG9kc1trdnZmc01ldGhvZHMubWVtYmVyS2V5KGspXSA9XG4gICAgICAgICAgd2FzbS5pbnN0YWxsRnVuY3Rpb24oXG4gICAgICAgICAgICBrdnZmc01ldGhvZHMubWVtYmVyU2lnbmF0dXJlKGspLFxuICAgICAgICAgICAga3Z2ZnNJbXBsc1trXVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICBcbiAgICAgIGNhcGkuc3FsaXRlM192ZnNfdW5yZWdpc3RlcihwS3Z2ZnMpO1xuICAgIH1cbiAgfVxuXG4gIHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIud2Fybk9uVXNlID0gdHJ1ZTtcbn0pO1xuXG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbihzcWxpdGUzKXtcbiAgc3FsaXRlMy52ZXJzaW9uID0ge1wibGliVmVyc2lvblwiOiBcIjMuNDUuMlwiLCBcImxpYlZlcnNpb25OdW1iZXJcIjogMzA0NTAwMiwgXCJzb3VyY2VJZFwiOiBcIjIwMjQtMDMtMTIgMTE6MDY6MjMgZDhjZDZkNDliNDZhMzk1YjEzOTU1Mzg3ZDA1ZTllMWEyYTQ3ZTU0ZmI5OWYzYzliNTk4MzViYmVmYWQ2YWY3N1wiLFwiZG93bmxvYWRWZXJzaW9uXCI6IDM0NTAyMDB9O1xufSk7XG5cblxuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oc3FsaXRlMyl7XG4gIGNvbnN0IHRvc3MgPSAoLi4uYXJncyk9Pnt0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpfTtcbiAgY29uc3QgdG9zczMgPSAoLi4uYXJncyk9Pnt0aHJvdyBuZXcgc3FsaXRlMy5TUUxpdGUzRXJyb3IoLi4uYXJncyl9O1xuXG4gIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGksIHdhc20gPSBzcWxpdGUzLndhc20sIHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gIFxuXG4gIFxuICBjb25zdCBfX3B0ck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIFxuICBjb25zdCBfX3N0bXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gIFxuICBjb25zdCBnZXRPd25PcHRpb24gPSAob3B0cywgcCwgZGZsdCk9PntcbiAgICBjb25zdCBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcHRzLHApO1xuICAgIHJldHVybiBkID8gZC52YWx1ZSA6IGRmbHQ7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGNoZWNrU3FsaXRlM1JjID0gZnVuY3Rpb24oZGJQdHIsIHNxbGl0ZVJlc3VsdENvZGUpe1xuICAgIGlmKHNxbGl0ZVJlc3VsdENvZGUpe1xuICAgICAgaWYoZGJQdHIgaW5zdGFuY2VvZiBEQikgZGJQdHIgPSBkYlB0ci5wb2ludGVyO1xuICAgICAgdG9zczMoXG4gICAgICAgIHNxbGl0ZVJlc3VsdENvZGUsXG4gICAgICAgIFwic3FsaXRlMyByZXN1bHQgY29kZVwiLHNxbGl0ZVJlc3VsdENvZGUrXCI6XCIsXG4gICAgICAgIChkYlB0clxuICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfZXJybXNnKGRiUHRyKVxuICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfZXJyc3RyKHNxbGl0ZVJlc3VsdENvZGUpKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19kYlRyYWNlVG9Db25zb2xlID1cbiAgICAgICAgd2FzbS5pbnN0YWxsRnVuY3Rpb24oJ2koaXBwcCknLCBmdW5jdGlvbih0LGMscCx4KXtcbiAgICAgICAgICBpZihjYXBpLlNRTElURV9UUkFDRV9TVE1UPT09dCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU1FMIFRSQUNFICNcIisoKyt0aGlzLmNvdW50ZXIpKycgdmlhIHNxbGl0ZTNAJytjKyc6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc20uY3N0clRvSnMoeCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHtjb3VudGVyOiAwfSkpO1xuXG4gIFxuICBjb25zdCBfX3Zmc1Bvc3RPcGVuU3FsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBcbiAgY29uc3QgZGJDdG9ySGVscGVyID0gZnVuY3Rpb24gY3RvciguLi5hcmdzKXtcbiAgICBpZighY3Rvci5fbmFtZTJ2ZnMpe1xuICAgICAgXG4gICAgICBjdG9yLl9uYW1lMnZmcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBjb25zdCBpc1dvcmtlclRocmVhZCA9ICgnZnVuY3Rpb24nPT09dHlwZW9mIGltcG9ydFNjcmlwdHMpXG4gICAgICAgICAgICA/IChuKT0+dG9zczMoXCJUaGUgVkZTIGZvclwiLG4sXCJpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgbWFpbiB3aW5kb3cgdGhyZWFkLlwiKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgIGN0b3IuX25hbWUydmZzWyc6bG9jYWxTdG9yYWdlOiddID0ge1xuICAgICAgICB2ZnM6ICdrdnZmcycsIGZpbGVuYW1lOiBpc1dvcmtlclRocmVhZCB8fCAoKCk9Pidsb2NhbCcpXG4gICAgICB9O1xuICAgICAgY3Rvci5fbmFtZTJ2ZnNbJzpzZXNzaW9uU3RvcmFnZTonXSA9IHtcbiAgICAgICAgdmZzOiAna3Z2ZnMnLCBmaWxlbmFtZTogaXNXb3JrZXJUaHJlYWQgfHwgKCgpPT4nc2Vzc2lvbicpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcHQgPSBjdG9yLm5vcm1hbGl6ZUFyZ3MoLi4uYXJncyk7XG4gICAgbGV0IGZuID0gb3B0LmZpbGVuYW1lLCB2ZnNOYW1lID0gb3B0LnZmcywgZmxhZ3NTdHIgPSBvcHQuZmxhZ3M7XG4gICAgaWYoKCdzdHJpbmcnIT09dHlwZW9mIGZuICYmICdudW1iZXInIT09dHlwZW9mIGZuKVxuICAgICAgIHx8ICdzdHJpbmcnIT09dHlwZW9mIGZsYWdzU3RyXG4gICAgICAgfHwgKHZmc05hbWUgJiYgKCdzdHJpbmcnIT09dHlwZW9mIHZmc05hbWUgJiYgJ251bWJlcichPT10eXBlb2YgdmZzTmFtZSkpKXtcbiAgICAgIHNxbGl0ZTMuY29uZmlnLmVycm9yKFwiSW52YWxpZCBEQiBjdG9yIGFyZ3NcIixvcHQsYXJndW1lbnRzKTtcbiAgICAgIHRvc3MzKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIERCIGNvbnN0cnVjdG9yLlwiKTtcbiAgICB9XG4gICAgbGV0IGZuSnMgPSAoJ251bWJlcic9PT10eXBlb2YgZm4pID8gd2FzbS5jc3RyVG9KcyhmbikgOiBmbjtcbiAgICBjb25zdCB2ZnNDaGVjayA9IGN0b3IuX25hbWUydmZzW2ZuSnNdO1xuICAgIGlmKHZmc0NoZWNrKXtcbiAgICAgIHZmc05hbWUgPSB2ZnNDaGVjay52ZnM7XG4gICAgICBmbiA9IGZuSnMgPSB2ZnNDaGVjay5maWxlbmFtZShmbkpzKTtcbiAgICB9XG4gICAgbGV0IHBEYiwgb2ZsYWdzID0gMDtcbiAgICBpZiggZmxhZ3NTdHIuaW5kZXhPZignYycpPj0wICl7XG4gICAgICBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9DUkVBVEUgfCBjYXBpLlNRTElURV9PUEVOX1JFQURXUklURTtcbiAgICB9XG4gICAgaWYoIGZsYWdzU3RyLmluZGV4T2YoJ3cnKT49MCApIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX1JFQURXUklURTtcbiAgICBpZiggMD09PW9mbGFncyApIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX1JFQURPTkxZO1xuICAgIG9mbGFncyB8PSBjYXBpLlNRTElURV9PUEVOX0VYUkVTQ09ERTtcbiAgICBjb25zdCBzdGFjayA9IHdhc20ucHN0YWNrLnBvaW50ZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBQdHIgPSB3YXNtLnBzdGFjay5hbGxvY1B0cigpIDtcbiAgICAgIGxldCByYyA9IGNhcGkuc3FsaXRlM19vcGVuX3YyKGZuLCBwUHRyLCBvZmxhZ3MsIHZmc05hbWUgfHwgMCk7XG4gICAgICBwRGIgPSB3YXNtLnBlZWtQdHIocFB0cik7XG4gICAgICBjaGVja1NxbGl0ZTNSYyhwRGIsIHJjKTtcbiAgICAgIGNhcGkuc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMocERiLCAxKTtcbiAgICAgIGlmKGZsYWdzU3RyLmluZGV4T2YoJ3QnKT49MCl7XG4gICAgICAgIGNhcGkuc3FsaXRlM190cmFjZV92MihwRGIsIGNhcGkuU1FMSVRFX1RSQUNFX1NUTVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RiVHJhY2VUb0NvbnNvbGUsIHBEYik7XG4gICAgICB9XG4gICAgfWNhdGNoKCBlICl7XG4gICAgICBpZiggcERiICkgY2FwaS5zcWxpdGUzX2Nsb3NlX3YyKHBEYik7XG4gICAgICB0aHJvdyBlO1xuICAgIH1maW5hbGx5e1xuICAgICAgd2FzbS5wc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgfVxuICAgIHRoaXMuZmlsZW5hbWUgPSBmbkpzO1xuICAgIF9fcHRyTWFwLnNldCh0aGlzLCBwRGIpO1xuICAgIF9fc3RtdE1hcC5zZXQodGhpcywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgdHJ5e1xuICAgICAgXG4gICAgICBjb25zdCBwVmZzID0gY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhwRGIpO1xuICAgICAgaWYoIXBWZnMpIHRvc3MzKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBnZXQgVkZTIGZvciBuZXcgZGIgaGFuZGxlLlwiKTtcbiAgICAgIGNvbnN0IHBvc3RJbml0U3FsID0gX192ZnNQb3N0T3BlblNxbFtwVmZzXTtcbiAgICAgIGlmKHBvc3RJbml0U3FsIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICBwb3N0SW5pdFNxbCh0aGlzLCBzcWxpdGUzKTtcbiAgICAgIH1lbHNlIGlmKHBvc3RJbml0U3FsKXtcbiAgICAgICAgY2hlY2tTcWxpdGUzUmMoXG4gICAgICAgICAgcERiLCBjYXBpLnNxbGl0ZTNfZXhlYyhwRGIsIHBvc3RJbml0U3FsLCAwLCAwLCAwKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1jYXRjaChlKXtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIFxuICBkYkN0b3JIZWxwZXIuc2V0VmZzUG9zdE9wZW5TcWwgPSBmdW5jdGlvbihwVmZzLCBzcWwpe1xuICAgIF9fdmZzUG9zdE9wZW5TcWxbcFZmc10gPSBzcWw7XG4gIH07XG5cbiAgXG4gIGRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzID0gZnVuY3Rpb24oZmlsZW5hbWU9JzptZW1vcnk6JyxmbGFncyA9ICdjJyx2ZnMgPSBudWxsKXtcbiAgICBjb25zdCBhcmcgPSB7fTtcbiAgICBpZigxPT09YXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gJiYgJ29iamVjdCc9PT10eXBlb2YgYXJndW1lbnRzWzBdKXtcbiAgICAgIE9iamVjdC5hc3NpZ24oYXJnLCBhcmd1bWVudHNbMF0pO1xuICAgICAgaWYodW5kZWZpbmVkPT09YXJnLmZsYWdzKSBhcmcuZmxhZ3MgPSAnYyc7XG4gICAgICBpZih1bmRlZmluZWQ9PT1hcmcudmZzKSBhcmcudmZzID0gbnVsbDtcbiAgICAgIGlmKHVuZGVmaW5lZD09PWFyZy5maWxlbmFtZSkgYXJnLmZpbGVuYW1lID0gJzptZW1vcnk6JztcbiAgICB9ZWxzZXtcbiAgICAgIGFyZy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgYXJnLmZsYWdzID0gZmxhZ3M7XG4gICAgICBhcmcudmZzID0gdmZzO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9O1xuICBcbiAgY29uc3QgREIgPSBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICBkYkN0b3JIZWxwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG4gIERCLmRiQ3RvckhlbHBlciA9IGRiQ3RvckhlbHBlcjtcblxuICBcbiAgY29uc3QgQmluZFR5cGVzID0ge1xuICAgIG51bGw6IDEsXG4gICAgbnVtYmVyOiAyLFxuICAgIHN0cmluZzogMyxcbiAgICBib29sZWFuOiA0LFxuICAgIGJsb2I6IDVcbiAgfTtcbiAgQmluZFR5cGVzWyd1bmRlZmluZWQnXSA9PSBCaW5kVHlwZXMubnVsbDtcbiAgaWYod2FzbS5iaWdJbnRFbmFibGVkKXtcbiAgICBCaW5kVHlwZXMuYmlnaW50ID0gQmluZFR5cGVzLm51bWJlcjtcbiAgfVxuXG4gIFxuICBjb25zdCBTdG10ID0gZnVuY3Rpb24oKXtcbiAgICBpZihCaW5kVHlwZXMhPT1hcmd1bWVudHNbMl0pe1xuICAgICAgdG9zczMoY2FwaS5TUUxJVEVfTUlTVVNFLCBcIkRvIG5vdCBjYWxsIHRoZSBTdG10IGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBVc2UgREIucHJlcGFyZSgpLlwiKTtcbiAgICB9XG4gICAgdGhpcy5kYiA9IGFyZ3VtZW50c1swXTtcbiAgICBfX3B0ck1hcC5zZXQodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICB0aGlzLnBhcmFtZXRlckNvdW50ID0gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50KHRoaXMucG9pbnRlcik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGFmZmlybURiT3BlbiA9IGZ1bmN0aW9uKGRiKXtcbiAgICBpZighZGIucG9pbnRlcikgdG9zczMoXCJEQiBoYXMgYmVlbiBjbG9zZWQuXCIpO1xuICAgIHJldHVybiBkYjtcbiAgfTtcblxuICBcbiAgY29uc3QgYWZmaXJtQ29sSW5kZXggPSBmdW5jdGlvbihzdG10LG5keCl7XG4gICAgaWYoKG5keCAhPT0gKG5keHwwKSkgfHwgbmR4PDAgfHwgbmR4Pj1zdG10LmNvbHVtbkNvdW50KXtcbiAgICAgIHRvc3MzKFwiQ29sdW1uIGluZGV4XCIsbmR4LFwiaXMgb3V0IG9mIHJhbmdlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXQ7XG4gIH07XG5cbiAgXG4gIGNvbnN0IHBhcnNlRXhlY0FyZ3MgPSBmdW5jdGlvbihkYiwgYXJncyl7XG4gICAgY29uc3Qgb3V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBvdXQub3B0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYoJ3N0cmluZyc9PT10eXBlb2YgYXJnc1swXSB8fCB1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkoYXJnc1swXSkpe1xuICAgICAgICAgICAgb3V0LnNxbCA9IGFyZ3NbMF07XG4gICAgICAgICAgfWVsc2UgaWYoQXJyYXkuaXNBcnJheShhcmdzWzBdKSl7XG4gICAgICAgICAgICBvdXQuc3FsID0gYXJnc1swXTtcbiAgICAgICAgICB9ZWxzZSBpZihhcmdzWzBdICYmICdvYmplY3QnPT09dHlwZW9mIGFyZ3NbMF0pe1xuICAgICAgICAgICAgb3V0Lm9wdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICBvdXQuc3FsID0gb3V0Lm9wdC5zcWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgb3V0LnNxbCA9IGFyZ3NbMF07XG4gICAgICAgICAgb3V0Lm9wdCA9IGFyZ3NbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHRvc3MzKFwiSW52YWxpZCBhcmd1bWVudCBjb3VudCBmb3IgZXhlYygpLlwiKTtcbiAgICB9O1xuICAgIG91dC5zcWwgPSB1dGlsLmZsZXhpYmxlU3RyaW5nKG91dC5zcWwpO1xuICAgIGlmKCdzdHJpbmcnIT09dHlwZW9mIG91dC5zcWwpe1xuICAgICAgdG9zczMoXCJNaXNzaW5nIFNRTCBhcmd1bWVudCBvciB1bnN1cHBvcnRlZCBTUUwgdmFsdWUgdHlwZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IG9wdCA9IG91dC5vcHQ7XG4gICAgc3dpdGNoKG9wdC5yZXR1cm5WYWx1ZSl7XG4gICAgICAgIGNhc2UgJ3Jlc3VsdFJvd3MnOlxuICAgICAgICAgIGlmKCFvcHQucmVzdWx0Um93cykgb3B0LnJlc3VsdFJvd3MgPSBbXTtcbiAgICAgICAgICBvdXQucmV0dXJuVmFsID0gKCk9Pm9wdC5yZXN1bHRSb3dzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzYXZlU3FsJzpcbiAgICAgICAgICBpZighb3B0LnNhdmVTcWwpIG9wdC5zYXZlU3FsID0gW107XG4gICAgICAgICAgb3V0LnJldHVyblZhbCA9ICgpPT5vcHQuc2F2ZVNxbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ3RoaXMnOlxuICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKT0+ZGI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdG9zczMoXCJJbnZhbGlkIHJldHVyblZhbHVlIHZhbHVlOlwiLG9wdC5yZXR1cm5WYWx1ZSk7XG4gICAgfVxuICAgIGlmKCFvcHQuY2FsbGJhY2sgJiYgIW9wdC5yZXR1cm5WYWx1ZSAmJiB1bmRlZmluZWQhPT1vcHQucm93TW9kZSl7XG4gICAgICBpZighb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICBvdXQucmV0dXJuVmFsID0gKCk9Pm9wdC5yZXN1bHRSb3dzO1xuICAgIH1cbiAgICBpZihvcHQuY2FsbGJhY2sgfHwgb3B0LnJlc3VsdFJvd3Mpe1xuICAgICAgc3dpdGNoKCh1bmRlZmluZWQ9PT1vcHQucm93TW9kZSlcbiAgICAgICAgICAgICA/ICdhcnJheScgOiBvcHQucm93TW9kZSkge1xuICAgICAgICAgIGNhc2UgJ29iamVjdCc6IG91dC5jYkFyZyA9IChzdG10KT0+c3RtdC5nZXQoT2JqZWN0LmNyZWF0ZShudWxsKSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FycmF5Jzogb3V0LmNiQXJnID0gKHN0bXQpPT5zdG10LmdldChbXSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N0bXQnOlxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShvcHQucmVzdWx0Um93cykpe1xuICAgICAgICAgICAgICB0b3NzMyhcImV4ZWMoKTogaW52YWxpZCByb3dNb2RlIGZvciBhIHJlc3VsdFJvd3MgYXJyYXk6IG11c3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiZSBvbmUgb2YgJ2FycmF5JywgJ29iamVjdCcsXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYSByZXN1bHQgY29sdW1uIG51bWJlciwgb3IgY29sdW1uIG5hbWUgcmVmZXJlbmNlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KT0+c3RtdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZih1dGlsLmlzSW50MzIob3B0LnJvd01vZGUpKXtcbiAgICAgICAgICAgICAgb3V0LmNiQXJnID0gKHN0bXQpPT5zdG10LmdldChvcHQucm93TW9kZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfWVsc2UgaWYoJ3N0cmluZyc9PT10eXBlb2Ygb3B0LnJvd01vZGVcbiAgICAgICAgICAgICAgICAgICAgICYmIG9wdC5yb3dNb2RlLmxlbmd0aD4xXG4gICAgICAgICAgICAgICAgICAgICAmJiAnJCc9PT1vcHQucm93TW9kZVswXSl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCAkY29sTmFtZSA9IG9wdC5yb3dNb2RlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgb3V0LmNiQXJnID0gKHN0bXQpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmMgPSBzdG10LmdldChPYmplY3QuY3JlYXRlKG51bGwpKVskY29sTmFtZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuICh1bmRlZmluZWQ9PT1yYylcbiAgICAgICAgICAgICAgICAgID8gdG9zczMoY2FwaS5TUUxJVEVfTk9URk9VTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhlYygpOiB1bmtub3duIHJlc3VsdCBjb2x1bW46XCIsJGNvbE5hbWUpXG4gICAgICAgICAgICAgICAgICA6IHJjO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvc3MzKFwiSW52YWxpZCByb3dNb2RlOlwiLG9wdC5yb3dNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICBcbiAgY29uc3QgX19zZWxlY3RGaXJzdFJvdyA9IChkYiwgc3FsLCBiaW5kLCAuLi5nZXRBcmdzKT0+e1xuICAgIGNvbnN0IHN0bXQgPSBkYi5wcmVwYXJlKHNxbCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJjID0gc3RtdC5iaW5kKGJpbmQpLnN0ZXAoKSA/IHN0bXQuZ2V0KC4uLmdldEFyZ3MpIDogdW5kZWZpbmVkO1xuICAgICAgc3RtdC5yZXNldCgpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH1maW5hbGx5e1xuICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY29uc3QgX19zZWxlY3RBbGwgPVxuICAgICAgICAoZGIsIHNxbCwgYmluZCwgcm93TW9kZSk9PmRiLmV4ZWMoe1xuICAgICAgICAgIHNxbCwgYmluZCwgcm93TW9kZSwgcmV0dXJuVmFsdWU6ICdyZXN1bHRSb3dzJ1xuICAgICAgICB9KTtcblxuICBcbiAgREIuY2hlY2tSYyA9IChkYixyZXN1bHRDb2RlKT0+Y2hlY2tTcWxpdGUzUmMoZGIscmVzdWx0Q29kZSk7XG5cbiAgREIucHJvdG90eXBlID0ge1xuICAgIFxuICAgIGlzT3BlbjogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiAhIXRoaXMucG9pbnRlcjtcbiAgICB9LFxuICAgIFxuICAgIGFmZmlybU9wZW46IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gYWZmaXJtRGJPcGVuKHRoaXMpO1xuICAgIH0sXG4gICAgXG4gICAgY2xvc2U6IGZ1bmN0aW9uKCl7XG4gICAgICBpZih0aGlzLnBvaW50ZXIpe1xuICAgICAgICBpZih0aGlzLm9uY2xvc2UgJiYgKHRoaXMub25jbG9zZS5iZWZvcmUgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgICAgICAgIHRyeXt0aGlzLm9uY2xvc2UuYmVmb3JlKHRoaXMpfVxuICAgICAgICAgIGNhdGNoKGUpe31cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwRGIgPSB0aGlzLnBvaW50ZXI7XG4gICAgICAgIE9iamVjdC5rZXlzKF9fc3RtdE1hcC5nZXQodGhpcykpLmZvckVhY2goKGsscyk9PntcbiAgICAgICAgICBpZihzICYmIHMucG9pbnRlcil7XG4gICAgICAgICAgICB0cnl7cy5maW5hbGl6ZSgpfVxuICAgICAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF9fcHRyTWFwLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgX19zdG10TWFwLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgY2FwaS5zcWxpdGUzX2Nsb3NlX3YyKHBEYik7XG4gICAgICAgIGlmKHRoaXMub25jbG9zZSAmJiAodGhpcy5vbmNsb3NlLmFmdGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICAgICAgICB0cnl7dGhpcy5vbmNsb3NlLmFmdGVyKHRoaXMpfVxuICAgICAgICAgIGNhdGNoKGUpe31cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5maWxlbmFtZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGNoYW5nZXM6IGZ1bmN0aW9uKHRvdGFsPWZhbHNlLHNpeHR5Rm91cj1mYWxzZSl7XG4gICAgICBjb25zdCBwID0gYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXI7XG4gICAgICBpZih0b3RhbCl7XG4gICAgICAgIHJldHVybiBzaXh0eUZvdXJcbiAgICAgICAgICA/IGNhcGkuc3FsaXRlM190b3RhbF9jaGFuZ2VzNjQocClcbiAgICAgICAgICA6IGNhcGkuc3FsaXRlM190b3RhbF9jaGFuZ2VzKHApO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBzaXh0eUZvdXJcbiAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jaGFuZ2VzNjQocClcbiAgICAgICAgICA6IGNhcGkuc3FsaXRlM19jaGFuZ2VzKHApO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZGJGaWxlbmFtZTogZnVuY3Rpb24oZGJOYW1lPSdtYWluJyl7XG4gICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2RiX2ZpbGVuYW1lKGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyLCBkYk5hbWUpO1xuICAgIH0sXG4gICAgXG4gICAgZGJOYW1lOiBmdW5jdGlvbihkYk51bWJlcj0wKXtcbiAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfZGJfbmFtZShhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlciwgZGJOdW1iZXIpO1xuICAgIH0sXG4gICAgXG4gICAgZGJWZnNOYW1lOiBmdW5jdGlvbihkYk5hbWU9MCl7XG4gICAgICBsZXQgcmM7XG4gICAgICBjb25zdCBwVmZzID0gY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhcbiAgICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXIsIGRiTmFtZVxuICAgICAgKTtcbiAgICAgIGlmKHBWZnMpe1xuICAgICAgICBjb25zdCB2ID0gbmV3IGNhcGkuc3FsaXRlM192ZnMocFZmcyk7XG4gICAgICAgIHRyeXsgcmMgPSB3YXNtLmNzdHJUb0pzKHYuJHpOYW1lKSB9XG4gICAgICAgIGZpbmFsbHkgeyB2LmRpc3Bvc2UoKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcbiAgICBcbiAgICBwcmVwYXJlOiBmdW5jdGlvbihzcWwpe1xuICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpO1xuICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgbGV0IHBwU3RtdCwgcFN0bXQ7XG4gICAgICB0cnl7XG4gICAgICAgIHBwU3RtdCA9IHdhc20ucHN0YWNrLmFsbG9jKDgpO1xuICAgICAgICBEQi5jaGVja1JjKHRoaXMsIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YyKHRoaXMucG9pbnRlciwgc3FsLCAtMSwgcHBTdG10LCBudWxsKSk7XG4gICAgICAgIHBTdG10ID0gd2FzbS5wZWVrUHRyKHBwU3RtdCk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5wc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICB9XG4gICAgICBpZighcFN0bXQpIHRvc3MzKFwiQ2Fubm90IHByZXBhcmUgZW1wdHkgU1FMLlwiKTtcbiAgICAgIGNvbnN0IHN0bXQgPSBuZXcgU3RtdCh0aGlzLCBwU3RtdCwgQmluZFR5cGVzKTtcbiAgICAgIF9fc3RtdE1hcC5nZXQodGhpcylbcFN0bXRdID0gc3RtdDtcbiAgICAgIHJldHVybiBzdG10O1xuICAgIH0sXG4gICAgXG4gICAgZXhlYzogZnVuY3Rpb24oKXtcbiAgICAgIGFmZmlybURiT3Blbih0aGlzKTtcbiAgICAgIGNvbnN0IGFyZyA9IHBhcnNlRXhlY0FyZ3ModGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmKCFhcmcuc3FsKXtcbiAgICAgICAgcmV0dXJuIHRvc3MzKFwiZXhlYygpIHJlcXVpcmVzIGFuIFNRTCBzdHJpbmcuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0ID0gYXJnLm9wdDtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0LmNhbGxiYWNrO1xuICAgICAgY29uc3QgcmVzdWx0Um93cyA9XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG9wdC5yZXN1bHRSb3dzKSA/IG9wdC5yZXN1bHRSb3dzIDogdW5kZWZpbmVkO1xuICAgICAgbGV0IHN0bXQ7XG4gICAgICBsZXQgYmluZCA9IG9wdC5iaW5kO1xuICAgICAgbGV0IGV2YWxGaXJzdFJlc3VsdCA9ICEhKFxuICAgICAgICBhcmcuY2JBcmcgfHwgb3B0LmNvbHVtbk5hbWVzIHx8IHJlc3VsdFJvd3NcbiAgICAgICkgO1xuICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgY29uc3Qgc2F2ZVNxbCA9IEFycmF5LmlzQXJyYXkob3B0LnNhdmVTcWwpID8gb3B0LnNhdmVTcWwgOiB1bmRlZmluZWQ7XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IGlzVEEgPSB1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkoYXJnLnNxbClcbiAgICAgICAgO1xuICAgICAgICBcbiAgICAgICAgbGV0IHNxbEJ5dGVMZW4gPSBpc1RBID8gYXJnLnNxbC5ieXRlTGVuZ3RoIDogd2FzbS5qc3RybGVuKGFyZy5zcWwpO1xuICAgICAgICBjb25zdCBwcFN0bXQgID0gd2FzbS5zY29wZWRBbGxvYyhcbiAgICAgICAgICBcbiAgICAgICAgICAoMiAqIHdhc20ucHRyU2l6ZW9mKSArIChzcWxCeXRlTGVuICsgMSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcHpUYWlsID0gcHBTdG10ICsgd2FzbS5wdHJTaXplb2YgO1xuICAgICAgICBsZXQgcFNxbCA9IHB6VGFpbCArIHdhc20ucHRyU2l6ZW9mO1xuICAgICAgICBjb25zdCBwU3FsRW5kID0gcFNxbCArIHNxbEJ5dGVMZW47XG4gICAgICAgIGlmKGlzVEEpIHdhc20uaGVhcDgoKS5zZXQoYXJnLnNxbCwgcFNxbCk7XG4gICAgICAgIGVsc2Ugd2FzbS5qc3RyY3B5KGFyZy5zcWwsIHdhc20uaGVhcDgoKSwgcFNxbCwgc3FsQnl0ZUxlbiwgZmFsc2UpO1xuICAgICAgICB3YXNtLnBva2UocFNxbCArIHNxbEJ5dGVMZW4sIDApO1xuICAgICAgICB3aGlsZShwU3FsICYmIHdhc20ucGVlayhwU3FsLCAnaTgnKVxuICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICB3YXNtLnBva2VQdHIoW3BwU3RtdCwgcHpUYWlsXSwgMCk7XG4gICAgICAgICAgREIuY2hlY2tSYyh0aGlzLCBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MyhcbiAgICAgICAgICAgIHRoaXMucG9pbnRlciwgcFNxbCwgc3FsQnl0ZUxlbiwgMCwgcHBTdG10LCBwelRhaWxcbiAgICAgICAgICApKTtcbiAgICAgICAgICBjb25zdCBwU3RtdCA9IHdhc20ucGVla1B0cihwcFN0bXQpO1xuICAgICAgICAgIHBTcWwgPSB3YXNtLnBlZWtQdHIocHpUYWlsKTtcbiAgICAgICAgICBzcWxCeXRlTGVuID0gcFNxbEVuZCAtIHBTcWw7XG4gICAgICAgICAgaWYoIXBTdG10KSBjb250aW51ZTtcbiAgICAgICAgICBpZihzYXZlU3FsKSBzYXZlU3FsLnB1c2goY2FwaS5zcWxpdGUzX3NxbChwU3RtdCkudHJpbSgpKTtcbiAgICAgICAgICBzdG10ID0gbmV3IFN0bXQodGhpcywgcFN0bXQsIEJpbmRUeXBlcyk7XG4gICAgICAgICAgaWYoYmluZCAmJiBzdG10LnBhcmFtZXRlckNvdW50KXtcbiAgICAgICAgICAgIHN0bXQuYmluZChiaW5kKTtcbiAgICAgICAgICAgIGJpbmQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihldmFsRmlyc3RSZXN1bHQgJiYgc3RtdC5jb2x1bW5Db3VudCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBnb3RDb2xOYW1lcyA9IEFycmF5LmlzQXJyYXkoXG4gICAgICAgICAgICAgIG9wdC5jb2x1bW5OYW1lc1xuICAgICAgICAgICAgICApID8gMCA6IDE7XG4gICAgICAgICAgICBldmFsRmlyc3RSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKGFyZy5jYkFyZyB8fCByZXN1bHRSb3dzKXtcbiAgICAgICAgICAgICAgZm9yKDsgc3RtdC5zdGVwKCk7IHN0bXQuX2xvY2tlZEJ5RXhlYyA9IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBpZigwPT09Z290Q29sTmFtZXMrKykgc3RtdC5nZXRDb2x1bW5OYW1lcyhvcHQuY29sdW1uTmFtZXMpO1xuICAgICAgICAgICAgICAgIHN0bXQuX2xvY2tlZEJ5RXhlYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gYXJnLmNiQXJnKHN0bXQpO1xuICAgICAgICAgICAgICAgIGlmKHJlc3VsdFJvd3MpIHJlc3VsdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrICYmIGZhbHNlID09PSBjYWxsYmFjay5jYWxsKG9wdCwgcm93LCBzdG10KSl7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RtdC5fbG9ja2VkQnlFeGVjID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZigwPT09Z290Q29sTmFtZXMpe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc3RtdC5nZXRDb2x1bW5OYW1lcyhvcHQuY29sdW1uTmFtZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgc3RtdC5zdGVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0bXQucmVzZXQoXG4gICAgICAgICAgICApLmZpbmFsaXplKCk7XG4gICAgICAgICAgc3RtdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1maW5hbGx5e1xuICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHN0YWNrKTtcbiAgICAgICAgaWYoc3RtdCl7XG4gICAgICAgICAgZGVsZXRlIHN0bXQuX2xvY2tlZEJ5RXhlYztcbiAgICAgICAgICBzdG10LmZpbmFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmcucmV0dXJuVmFsKCk7XG4gICAgfSxcblxuICAgIFxuICAgIGNyZWF0ZUZ1bmN0aW9uOiBmdW5jdGlvbiBmKG5hbWUsIHhGdW5jLCBvcHQpe1xuICAgICAgY29uc3QgaXNGdW5jID0gKGYpPT4oZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcbiAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICBjYXNlIDE6IFxuICAgICAgICAgICAgb3B0ID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSBvcHQubmFtZTtcbiAgICAgICAgICAgIHhGdW5jID0gb3B0LnhGdW5jIHx8IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IFxuICAgICAgICAgICAgaWYoIWlzRnVuYyh4RnVuYykpe1xuICAgICAgICAgICAgICBvcHQgPSB4RnVuYztcbiAgICAgICAgICAgICAgeEZ1bmMgPSBvcHQueEZ1bmMgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzogXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmKCFvcHQpIG9wdCA9IHt9O1xuICAgICAgaWYoJ3N0cmluZycgIT09IHR5cGVvZiBuYW1lKXtcbiAgICAgICAgdG9zczMoXCJJbnZhbGlkIGFyZ3VtZW50czogbWlzc2luZyBmdW5jdGlvbiBuYW1lLlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCB4U3RlcCA9IG9wdC54U3RlcCB8fCAwO1xuICAgICAgbGV0IHhGaW5hbCA9IG9wdC54RmluYWwgfHwgMDtcbiAgICAgIGNvbnN0IHhWYWx1ZSA9IG9wdC54VmFsdWUgfHwgMDtcbiAgICAgIGNvbnN0IHhJbnZlcnNlID0gb3B0LnhJbnZlcnNlIHx8IDA7XG4gICAgICBsZXQgaXNXaW5kb3cgPSB1bmRlZmluZWQ7XG4gICAgICBpZihpc0Z1bmMoeEZ1bmMpKXtcbiAgICAgICAgaXNXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgaWYoaXNGdW5jKHhTdGVwKSB8fCBpc0Z1bmMoeEZpbmFsKSl7XG4gICAgICAgICAgdG9zczMoXCJBbWJpZ3VvdXMgYXJndW1lbnRzOiBzY2FsYXIgb3IgYWdncmVnYXRlP1wiKTtcbiAgICAgICAgfVxuICAgICAgICB4U3RlcCA9IHhGaW5hbCA9IG51bGw7XG4gICAgICB9ZWxzZSBpZihpc0Z1bmMoeFN0ZXApKXtcbiAgICAgICAgaWYoIWlzRnVuYyh4RmluYWwpKXtcbiAgICAgICAgICB0b3NzMyhcIk1pc3NpbmcgeEZpbmFsKCkgY2FsbGJhY2sgZm9yIGFnZ3JlZ2F0ZSBvciB3aW5kb3cgVURGLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB4RnVuYyA9IG51bGw7XG4gICAgICB9ZWxzZSBpZihpc0Z1bmMoeEZpbmFsKSl7XG4gICAgICAgIHRvc3MzKFwiTWlzc2luZyB4U3RlcCgpIGNhbGxiYWNrIGZvciBhZ2dyZWdhdGUgb3Igd2luZG93IFVERi5cIik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdG9zczMoXCJNaXNzaW5nIGZ1bmN0aW9uLXR5cGUgcHJvcGVydGllcy5cIik7XG4gICAgICB9XG4gICAgICBpZihmYWxzZSA9PT0gaXNXaW5kb3cpe1xuICAgICAgICBpZihpc0Z1bmMoeFZhbHVlKSB8fCBpc0Z1bmMoeEludmVyc2UpKXtcbiAgICAgICAgICB0b3NzMyhcInhWYWx1ZSBhbmQgeEludmVyc2UgYXJlIG5vdCBwZXJtaXR0ZWQgZm9yIG5vbi13aW5kb3cgVURGcy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmKGlzRnVuYyh4VmFsdWUpKXtcbiAgICAgICAgaWYoIWlzRnVuYyh4SW52ZXJzZSkpe1xuICAgICAgICAgIHRvc3MzKFwieEludmVyc2UgbXVzdCBiZSBwcm92aWRlZCBpZiB4VmFsdWUgaXMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlzV2luZG93ID0gdHJ1ZTtcbiAgICAgIH1lbHNlIGlmKGlzRnVuYyh4SW52ZXJzZSkpe1xuICAgICAgICB0b3NzMyhcInhWYWx1ZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHhJbnZlcnNlIGlzLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBBcHAgPSBvcHQucEFwcDtcbiAgICAgIGlmKHVuZGVmaW5lZCE9PXBBcHAgJiZcbiAgICAgICAgIG51bGwhPT1wQXBwICYmXG4gICAgICAgICAoKCdudW1iZXInIT09dHlwZW9mIHBBcHApIHx8ICF1dGlsLmlzSW50MzIocEFwcCkpKXtcbiAgICAgICAgdG9zczMoXCJJbnZhbGlkIHZhbHVlIGZvciBwQXBwIHByb3BlcnR5LiBNdXN0IGJlIGEgbGVnYWwgV0FTTSBwb2ludGVyIHZhbHVlLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhEZXN0cm95ID0gb3B0LnhEZXN0cm95IHx8IDA7XG4gICAgICBpZih4RGVzdHJveSAmJiAhaXNGdW5jKHhEZXN0cm95KSl7XG4gICAgICAgIHRvc3MzKFwieERlc3Ryb3kgcHJvcGVydHkgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBmRmxhZ3MgPSAwIDtcbiAgICAgIGlmKGdldE93bk9wdGlvbihvcHQsICdkZXRlcm1pbmlzdGljJykpIGZGbGFncyB8PSBjYXBpLlNRTElURV9ERVRFUk1JTklTVElDO1xuICAgICAgaWYoZ2V0T3duT3B0aW9uKG9wdCwgJ2RpcmVjdE9ubHknKSkgZkZsYWdzIHw9IGNhcGkuU1FMSVRFX0RJUkVDVE9OTFk7XG4gICAgICBpZihnZXRPd25PcHRpb24ob3B0LCAnaW5ub2N1b3VzJykpIGZGbGFncyB8PSBjYXBpLlNRTElURV9JTk5PQ1VPVVM7XG4gICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgeEFyaXR5ID0geEZ1bmMgfHwgeFN0ZXA7XG4gICAgICBjb25zdCBhcml0eSA9IGdldE93bk9wdGlvbihvcHQsICdhcml0eScpO1xuICAgICAgY29uc3QgYXJpdHlBcmcgPSAoJ251bWJlcic9PT10eXBlb2YgYXJpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXJpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHhBcml0eS5sZW5ndGggPyB4QXJpdHkubGVuZ3RoLTEgOiAwKSk7XG4gICAgICBsZXQgcmM7XG4gICAgICBpZiggaXNXaW5kb3cgKXtcbiAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbihcbiAgICAgICAgICB0aGlzLnBvaW50ZXIsIG5hbWUsIGFyaXR5QXJnLFxuICAgICAgICAgIGNhcGkuU1FMSVRFX1VURjggfCBmRmxhZ3MsIHBBcHAgfHwgMCxcbiAgICAgICAgICB4U3RlcCwgeEZpbmFsLCB4VmFsdWUsIHhJbnZlcnNlLCB4RGVzdHJveSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyKFxuICAgICAgICAgIHRoaXMucG9pbnRlciwgbmFtZSwgYXJpdHlBcmcsXG4gICAgICAgICAgY2FwaS5TUUxJVEVfVVRGOCB8IGZGbGFncywgcEFwcCB8fCAwLFxuICAgICAgICAgIHhGdW5jLCB4U3RlcCwgeEZpbmFsLCB4RGVzdHJveSk7XG4gICAgICB9XG4gICAgICBEQi5jaGVja1JjKHRoaXMsIHJjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgc2VsZWN0VmFsdWU6IGZ1bmN0aW9uKHNxbCxiaW5kLGFzVHlwZSl7XG4gICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIDAsIGFzVHlwZSk7XG4gICAgfSxcblxuICAgIFxuICAgIHNlbGVjdFZhbHVlczogZnVuY3Rpb24oc3FsLGJpbmQsYXNUeXBlKXtcbiAgICAgIGNvbnN0IHN0bXQgPSB0aGlzLnByZXBhcmUoc3FsKSwgcmMgPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0bXQuYmluZChiaW5kKTtcbiAgICAgICAgd2hpbGUoc3RtdC5zdGVwKCkpIHJjLnB1c2goc3RtdC5nZXQoMCxhc1R5cGUpKTtcbiAgICAgICAgc3RtdC5yZXNldCgpO1xuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIHN0bXQuZmluYWxpemUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuXG4gICAgXG4gICAgc2VsZWN0QXJyYXk6IGZ1bmN0aW9uKHNxbCxiaW5kKXtcbiAgICAgIHJldHVybiBfX3NlbGVjdEZpcnN0Um93KHRoaXMsIHNxbCwgYmluZCwgW10pO1xuICAgIH0sXG5cbiAgICBcbiAgICBzZWxlY3RPYmplY3Q6IGZ1bmN0aW9uKHNxbCxiaW5kKXtcbiAgICAgIHJldHVybiBfX3NlbGVjdEZpcnN0Um93KHRoaXMsIHNxbCwgYmluZCwge30pO1xuICAgIH0sXG5cbiAgICBcbiAgICBzZWxlY3RBcnJheXM6IGZ1bmN0aW9uKHNxbCxiaW5kKXtcbiAgICAgIHJldHVybiBfX3NlbGVjdEFsbCh0aGlzLCBzcWwsIGJpbmQsICdhcnJheScpO1xuICAgIH0sXG5cbiAgICBcbiAgICBzZWxlY3RPYmplY3RzOiBmdW5jdGlvbihzcWwsYmluZCl7XG4gICAgICByZXR1cm4gX19zZWxlY3RBbGwodGhpcywgc3FsLCBiaW5kLCAnb2JqZWN0Jyk7XG4gICAgfSxcblxuICAgIFxuICAgIG9wZW5TdGF0ZW1lbnRDb3VudDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50ZXIgPyBPYmplY3Qua2V5cyhfX3N0bXRNYXAuZ2V0KHRoaXMpKS5sZW5ndGggOiAwO1xuICAgIH0sXG5cbiAgICBcbiAgICB0cmFuc2FjdGlvbjogZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgICAgbGV0IG9wZW5lciA9ICdCRUdJTic7XG4gICAgICBpZihhcmd1bWVudHMubGVuZ3RoPjEpe1xuICAgICAgICBpZigvW15hLXpBLVpdLy50ZXN0KGFyZ3VtZW50c1swXSkpe1xuICAgICAgICAgIHRvc3MzKGNhcGkuU1FMSVRFX01JU1VTRSwgXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBCRUdJTiBxdWFsaWZpZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIG9wZW5lciArPSAnICcrYXJndW1lbnRzWzBdO1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICAgIGFmZmlybURiT3Blbih0aGlzKS5leGVjKG9wZW5lcik7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByYyA9IGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICB0aGlzLmV4ZWMoXCJDT01NSVRcIik7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgdGhpcy5leGVjKFwiUk9MTEJBQ0tcIik7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIFxuICAgIHNhdmVwb2ludDogZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgICAgYWZmaXJtRGJPcGVuKHRoaXMpLmV4ZWMoXCJTQVZFUE9JTlQgb28xXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmMgPSBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgdGhpcy5leGVjKFwiUkVMRUFTRSBvbzFcIik7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgdGhpcy5leGVjKFwiUk9MTEJBQ0sgdG8gU0FWRVBPSU5UIG9vMTsgUkVMRUFTRSBTQVZFUE9JTlQgb28xXCIpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcbiAgICBjaGVja1JjOiBmdW5jdGlvbihyZXN1bHRDb2RlKXtcbiAgICAgIHJldHVybiBjaGVja1NxbGl0ZTNSYyh0aGlzLCByZXN1bHRDb2RlKTtcbiAgICB9XG4gIH07XG5cblxuICBcbiAgY29uc3QgYWZmaXJtU3RtdE9wZW4gPSBmdW5jdGlvbihzdG10KXtcbiAgICBpZighc3RtdC5wb2ludGVyKSB0b3NzMyhcIlN0bXQgaGFzIGJlZW4gY2xvc2VkLlwiKTtcbiAgICByZXR1cm4gc3RtdDtcbiAgfTtcblxuICBcbiAgY29uc3QgaXNTdXBwb3J0ZWRCaW5kVHlwZSA9IGZ1bmN0aW9uKHYpe1xuICAgIGxldCB0ID0gQmluZFR5cGVzWyhudWxsPT09dnx8dW5kZWZpbmVkPT09dikgPyAnbnVsbCcgOiB0eXBlb2Ygdl07XG4gICAgc3dpdGNoKHQpe1xuICAgICAgICBjYXNlIEJpbmRUeXBlcy5ib29sZWFuOlxuICAgICAgICBjYXNlIEJpbmRUeXBlcy5udWxsOlxuICAgICAgICBjYXNlIEJpbmRUeXBlcy5udW1iZXI6XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLnN0cmluZzpcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMuYmlnaW50OlxuICAgICAgICAgIGlmKHdhc20uYmlnSW50RW5hYmxlZCkgcmV0dXJuIHQ7XG4gICAgICAgICAgXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodikgPyBCaW5kVHlwZXMuYmxvYiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNvbnN0IGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlID0gZnVuY3Rpb24odil7XG4gICAgXG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkQmluZFR5cGUodikgfHwgdG9zczMoXCJVbnN1cHBvcnRlZCBiaW5kKCkgYXJndW1lbnQgdHlwZTpcIix0eXBlb2Ygdik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGFmZmlybVBhcmFtSW5kZXggPSBmdW5jdGlvbihzdG10LGtleSl7XG4gICAgY29uc3QgbiA9ICgnbnVtYmVyJz09PXR5cGVvZiBrZXkpXG4gICAgICAgICAgPyBrZXkgOiBjYXBpLnNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXgoc3RtdC5wb2ludGVyLCBrZXkpO1xuICAgIGlmKDA9PT1uIHx8ICF1dGlsLmlzSW50MzIobikpe1xuICAgICAgdG9zczMoXCJJbnZhbGlkIGJpbmQoKSBwYXJhbWV0ZXIgbmFtZTogXCIra2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZihuPDEgfHwgbj5zdG10LnBhcmFtZXRlckNvdW50KSB0b3NzMyhcIkJpbmQgaW5kZXhcIixrZXksXCJpcyBvdXQgb2YgcmFuZ2UuXCIpO1xuICAgIHJldHVybiBuO1xuICB9O1xuXG4gIFxuICBjb25zdCBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMgPSBmdW5jdGlvbihzdG10LGN1cnJlbnRPcE5hbWUpe1xuICAgIGlmKHN0bXQuX2xvY2tlZEJ5RXhlYyl7XG4gICAgICB0b3NzMyhcIk9wZXJhdGlvbiBpcyBpbGxlZ2FsIHdoZW4gc3RhdGVtZW50IGlzIGxvY2tlZDpcIixjdXJyZW50T3BOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXQ7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGJpbmRPbmUgPSBmdW5jdGlvbiBmKHN0bXQsbmR4LGJpbmRUeXBlLHZhbCl7XG4gICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKGFmZmlybVN0bXRPcGVuKHN0bXQpLCAnYmluZCgpJyk7XG4gICAgaWYoIWYuXyl7XG4gICAgICBmLl90b29CaWdJbnQgPSAodik9PnRvc3MzKFxuICAgICAgICBcIkJpZ0ludCB2YWx1ZSBpcyB0b28gYmlnIHRvIHN0b3JlIHdpdGhvdXQgcHJlY2lzaW9uIGxvc3M6XCIsIHZcbiAgICAgICk7XG4gICAgICBmLl8gPSB7XG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24oc3RtdCwgbmR4LCB2YWwsIGFzQmxvYil7XG4gICAgICAgICAgY29uc3QgW3BTdHIsIG5dID0gd2FzbS5hbGxvY0NTdHJpbmcodmFsLCB0cnVlKTtcbiAgICAgICAgICBjb25zdCBmID0gYXNCbG9iID8gY2FwaS5zcWxpdGUzX2JpbmRfYmxvYiA6IGNhcGkuc3FsaXRlM19iaW5kX3RleHQ7XG4gICAgICAgICAgcmV0dXJuIGYoc3RtdC5wb2ludGVyLCBuZHgsIHBTdHIsIG4sIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKHZhbCk7XG4gICAgbmR4ID0gYWZmaXJtUGFyYW1JbmRleChzdG10LG5keCk7XG4gICAgbGV0IHJjID0gMDtcbiAgICBzd2l0Y2goKG51bGw9PT12YWwgfHwgdW5kZWZpbmVkPT09dmFsKSA/IEJpbmRUeXBlcy5udWxsIDogYmluZFR5cGUpe1xuICAgICAgICBjYXNlIEJpbmRUeXBlcy5udWxsOlxuICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfbnVsbChzdG10LnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLnN0cmluZzpcbiAgICAgICAgICByYyA9IGYuXy5zdHJpbmcoc3RtdCwgbmR4LCB2YWwsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVtYmVyOiB7XG4gICAgICAgICAgbGV0IG07XG4gICAgICAgICAgaWYodXRpbC5pc0ludDMyKHZhbCkpIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQ7XG4gICAgICAgICAgZWxzZSBpZignYmlnaW50Jz09PXR5cGVvZiB2YWwpe1xuICAgICAgICAgICAgaWYoIXV0aWwuYmlnSW50Rml0czY0KHZhbCkpe1xuICAgICAgICAgICAgICBmLl90b29CaWdJbnQodmFsKTtcbiAgICAgICAgICAgIH1lbHNlIGlmKHdhc20uYmlnSW50RW5hYmxlZCl7XG4gICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQ2NDtcbiAgICAgICAgICAgIH1lbHNlIGlmKHV0aWwuYmlnSW50Rml0c0RvdWJsZSh2YWwpKXtcbiAgICAgICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9kb3VibGU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgZi5fdG9vQmlnSW50KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2V7IFxuICAgICAgICAgICAgdmFsID0gTnVtYmVyKHZhbCk7XG4gICAgICAgICAgICBpZih3YXNtLmJpZ0ludEVuYWJsZWQgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWwpKXtcbiAgICAgICAgICAgICAgbSA9IGNhcGkuc3FsaXRlM19iaW5kX2ludDY0O1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9kb3VibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJjID0gbShzdG10LnBvaW50ZXIsIG5keCwgdmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEJpbmRUeXBlcy5ib29sZWFuOlxuICAgICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50KHN0bXQucG9pbnRlciwgbmR4LCB2YWwgPyAxIDogMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLmJsb2I6IHtcbiAgICAgICAgICBpZignc3RyaW5nJz09PXR5cGVvZiB2YWwpe1xuICAgICAgICAgICAgcmMgPSBmLl8uc3RyaW5nKHN0bXQsIG5keCwgdmFsLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1lbHNlIGlmKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtcbiAgICAgICAgICAgIHZhbCA9IG5ldyBVaW50OEFycmF5KHZhbCk7XG4gICAgICAgICAgfWVsc2UgaWYoIXV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkodmFsKSl7XG4gICAgICAgICAgICB0b3NzMyhcIkJpbmRpbmcgYSB2YWx1ZSBhcyBhIGJsb2IgcmVxdWlyZXNcIixcbiAgICAgICAgICAgICAgICAgIFwidGhhdCBpdCBiZSBhIHN0cmluZywgVWludDhBcnJheSwgSW50OEFycmF5LCBvciBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBCbG9iID0gd2FzbS5hbGxvYyh2YWwuYnl0ZUxlbmd0aCB8fCAxKTtcbiAgICAgICAgICB3YXNtLmhlYXA4KCkuc2V0KHZhbC5ieXRlTGVuZ3RoID8gdmFsIDogWzBdLCBwQmxvYilcbiAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX2Jsb2Ioc3RtdC5wb2ludGVyLCBuZHgsIHBCbG9iLCB2YWwuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXCJVbnN1cHBvcnRlZCBiaW5kKCkgYXJndW1lbnQgdHlwZTpcIix2YWwpO1xuICAgICAgICAgIHRvc3MzKFwiVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6IFwiKyh0eXBlb2YgdmFsKSk7XG4gICAgfVxuICAgIGlmKHJjKSBEQi5jaGVja1JjKHN0bXQuZGIucG9pbnRlciwgcmMpO1xuICAgIHN0bXQuX21heUdldCA9IGZhbHNlO1xuICAgIHJldHVybiBzdG10O1xuICB9O1xuXG4gIFN0bXQucHJvdG90eXBlID0ge1xuICAgIFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgaWYodGhpcy5wb2ludGVyKXtcbiAgICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKHRoaXMsJ2ZpbmFsaXplKCknKTtcbiAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfZmluYWxpemUodGhpcy5wb2ludGVyKTtcbiAgICAgICAgZGVsZXRlIF9fc3RtdE1hcC5nZXQodGhpcy5kYilbdGhpcy5wb2ludGVyXTtcbiAgICAgICAgX19wdHJNYXAuZGVsZXRlKHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWF5R2V0O1xuICAgICAgICBkZWxldGUgdGhpcy5wYXJhbWV0ZXJDb3VudDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xvY2tlZEJ5RXhlYztcbiAgICAgICAgZGVsZXRlIHRoaXMuZGI7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGNsZWFyQmluZGluZ3M6IGZ1bmN0aW9uKCl7XG4gICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWMoYWZmaXJtU3RtdE9wZW4odGhpcyksICdjbGVhckJpbmRpbmdzKCknKVxuICAgICAgY2FwaS5zcWxpdGUzX2NsZWFyX2JpbmRpbmdzKHRoaXMucG9pbnRlcik7XG4gICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKGFsc29DbGVhckJpbmRzKXtcbiAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyh0aGlzLCdyZXNldCgpJyk7XG4gICAgICBpZihhbHNvQ2xlYXJCaW5kcykgdGhpcy5jbGVhckJpbmRpbmdzKCk7XG4gICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19yZXNldChhZmZpcm1TdG10T3Blbih0aGlzKS5wb2ludGVyKTtcbiAgICAgIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgY2hlY2tTcWxpdGUzUmModGhpcy5kYiwgcmMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBcbiAgICBiaW5kOiBmdW5jdGlvbigpe1xuICAgICAgYWZmaXJtU3RtdE9wZW4odGhpcyk7XG4gICAgICBsZXQgbmR4LCBhcmc7XG4gICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgY2FzZSAxOiBuZHggPSAxOyBhcmcgPSBhcmd1bWVudHNbMF07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogbmR4ID0gYXJndW1lbnRzWzBdOyBhcmcgPSBhcmd1bWVudHNbMV07IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHRvc3MzKFwiSW52YWxpZCBiaW5kKCkgYXJndW1lbnRzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmKHVuZGVmaW5lZD09PWFyZyl7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1lbHNlIGlmKCF0aGlzLnBhcmFtZXRlckNvdW50KXtcbiAgICAgICAgdG9zczMoXCJUaGlzIHN0YXRlbWVudCBoYXMgbm8gYmluZGFibGUgcGFyYW1ldGVycy5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgIGlmKG51bGw9PT1hcmcpe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBCaW5kVHlwZXMubnVsbCwgYXJnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheShhcmcpKXtcbiAgICAgICAgXG4gICAgICAgIGlmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICB0b3NzMyhcIldoZW4gYmluZGluZyBhbiBhcnJheSwgYW4gaW5kZXggYXJndW1lbnQgaXMgbm90IHBlcm1pdHRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXJnLmZvckVhY2goKHYsaSk9PmJpbmRPbmUodGhpcywgaSsxLCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZSh2KSwgdikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1lbHNlIGlmKGFyZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtcbiAgICAgICAgYXJnID0gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcbiAgICAgIH1cbiAgICAgIGlmKCdvYmplY3QnPT09dHlwZW9mIGFyZ1xuICAgICAgICAgICAgICAmJiAhdXRpbC5pc0JpbmRhYmxlVHlwZWRBcnJheShhcmcpKXtcbiAgICAgICAgXG4gICAgICAgIGlmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICB0b3NzMyhcIldoZW4gYmluZGluZyBhbiBvYmplY3QsIGFuIGluZGV4IGFyZ3VtZW50IGlzIG5vdCBwZXJtaXR0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGFyZylcbiAgICAgICAgICAuZm9yRWFjaChrPT5iaW5kT25lKHRoaXMsIGssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmdba10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnW2tdKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBiaW5kT25lKHRoaXMsIG5keCwgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUoYXJnKSwgYXJnKTtcbiAgICAgIH1cbiAgICAgIHRvc3MzKFwiU2hvdWxkIG5vdCByZWFjaCB0aGlzIHBvaW50LlwiKTtcbiAgICB9LFxuICAgIFxuICAgIGJpbmRBc0Jsb2I6IGZ1bmN0aW9uKG5keCxhcmcpe1xuICAgICAgYWZmaXJtU3RtdE9wZW4odGhpcyk7XG4gICAgICBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgIGFyZyA9IG5keDtcbiAgICAgICAgbmR4ID0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZShhcmcpO1xuICAgICAgaWYoQmluZFR5cGVzLnN0cmluZyAhPT0gdCAmJiBCaW5kVHlwZXMuYmxvYiAhPT0gdFxuICAgICAgICAgJiYgQmluZFR5cGVzLm51bGwgIT09IHQpe1xuICAgICAgICB0b3NzMyhcIkludmFsaWQgdmFsdWUgdHlwZSBmb3IgYmluZEFzQmxvYigpXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmRPbmUodGhpcywgbmR4LCBCaW5kVHlwZXMuYmxvYiwgYXJnKTtcbiAgICB9LFxuICAgIFxuICAgIHN0ZXA6IGZ1bmN0aW9uKCl7XG4gICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWModGhpcywgJ3N0ZXAoKScpO1xuICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfc3RlcChhZmZpcm1TdG10T3Blbih0aGlzKS5wb2ludGVyKTtcbiAgICAgIHN3aXRjaChyYyl7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9ET05FOiByZXR1cm4gdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9ST1c6IHJldHVybiB0aGlzLl9tYXlHZXQgPSB0cnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXCJzcWxpdGUzX3N0ZXAoKSByYz1cIixyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfanNfcmNfc3RyKHJjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIlNRTCA9XCIsIGNhcGkuc3FsaXRlM19zcWwodGhpcy5wb2ludGVyKSk7XG4gICAgICAgICAgICBEQi5jaGVja1JjKHRoaXMuZGIucG9pbnRlciwgcmMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RlcFJlc2V0OiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xuICAgIH0sXG4gICAgXG4gICAgc3RlcEZpbmFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCByYyA9IHRoaXMuc3RlcCgpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1maW5hbGx5e1xuICAgICAgICB0cnl7dGhpcy5maW5hbGl6ZSgpfVxuICAgICAgICBjYXRjaChlKXt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBnZXQ6IGZ1bmN0aW9uKG5keCxhc1R5cGUpe1xuICAgICAgaWYoIWFmZmlybVN0bXRPcGVuKHRoaXMpLl9tYXlHZXQpe1xuICAgICAgICB0b3NzMyhcIlN0bXQuc3RlcCgpIGhhcyBub3QgKHJlY2VudGx5KSByZXR1cm5lZCB0cnVlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmKEFycmF5LmlzQXJyYXkobmR4KSl7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgIHdoaWxlKGk8bil7XG4gICAgICAgICAgbmR4W2ldID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmR4O1xuICAgICAgfWVsc2UgaWYobmR4ICYmICdvYmplY3QnPT09dHlwZW9mIG5keCl7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICAgIHdoaWxlKGk8bil7XG4gICAgICAgICAgbmR4W2NhcGkuc3FsaXRlM19jb2x1bW5fbmFtZSh0aGlzLnBvaW50ZXIsaSldID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmR4O1xuICAgICAgfVxuICAgICAgYWZmaXJtQ29sSW5kZXgodGhpcywgbmR4KTtcbiAgICAgIHN3aXRjaCh1bmRlZmluZWQ9PT1hc1R5cGVcbiAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19jb2x1bW5fdHlwZSh0aGlzLnBvaW50ZXIsIG5keClcbiAgICAgICAgICAgICA6IGFzVHlwZSl7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9OVUxMOiByZXR1cm4gbnVsbDtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0lOVEVHRVI6e1xuICAgICAgICAgICAgaWYod2FzbS5iaWdJbnRFbmFibGVkKXtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2ludDY0KHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgaWYocmM+PU51bWJlci5NSU5fU0FGRV9JTlRFR0VSICYmIHJjPD1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihyYykudmFsdWVPZigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByYztcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBjb25zdCByYyA9IGNhcGkuc3FsaXRlM19jb2x1bW5fZG91YmxlKHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICAgICAgaWYocmM+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgcmM8TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRvc3MzKFwiSW50ZWdlciBpcyBvdXQgb2YgcmFuZ2UgZm9yIEpTIGludGVnZXIgcmFuZ2U6IFwiK3JjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuaXNJbnQzMihyYykgPyAocmMgfCAwKSA6IHJjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0ZMT0FUOlxuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fZG91YmxlKHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX1RFWFQ6XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl90ZXh0KHRoaXMucG9pbnRlciwgbmR4KTtcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0JMT0I6IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2J5dGVzKHRoaXMucG9pbnRlciwgbmR4KSxcbiAgICAgICAgICAgICAgICAgIHB0ciA9IGNhcGkuc3FsaXRlM19jb2x1bW5fYmxvYih0aGlzLnBvaW50ZXIsIG5keCksXG4gICAgICAgICAgICAgICAgICByYyA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihuKSByYy5zZXQod2FzbS5oZWFwOHUoKS5zbGljZShwdHIsIHB0cituKSwgMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKG4gJiYgdGhpcy5kYi5fYmxvYlhmZXIgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB0aGlzLmRiLl9ibG9iWGZlci5wdXNoKHJjLmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHRvc3MzKFwiRG9uJ3Qga25vdyBob3cgdG8gdHJhbnNsYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlIG9mIHJlc3VsdCBjb2x1bW4gI1wiK25keCtcIi5cIik7XG4gICAgICB9XG4gICAgICB0b3NzMyhcIk5vdCByZWFjaGVkLlwiKTtcbiAgICB9LFxuICAgIFxuICAgIGdldEludDogZnVuY3Rpb24obmR4KXtyZXR1cm4gdGhpcy5nZXQobmR4LGNhcGkuU1FMSVRFX0lOVEVHRVIpfSxcbiAgICBcbiAgICBnZXRGbG9hdDogZnVuY3Rpb24obmR4KXtyZXR1cm4gdGhpcy5nZXQobmR4LGNhcGkuU1FMSVRFX0ZMT0FUKX0sXG4gICAgXG4gICAgZ2V0U3RyaW5nOiBmdW5jdGlvbihuZHgpe3JldHVybiB0aGlzLmdldChuZHgsY2FwaS5TUUxJVEVfVEVYVCl9LFxuICAgIFxuICAgIGdldEJsb2I6IGZ1bmN0aW9uKG5keCl7cmV0dXJuIHRoaXMuZ2V0KG5keCxjYXBpLlNRTElURV9CTE9CKX0sXG4gICAgXG4gICAgZ2V0SlNPTjogZnVuY3Rpb24obmR4KXtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmdldChuZHgsIGNhcGkuU1FMSVRFX1NUUklORyk7XG4gICAgICByZXR1cm4gbnVsbD09PXMgPyBzIDogSlNPTi5wYXJzZShzKTtcbiAgICB9LFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIGdldENvbHVtbk5hbWU6IGZ1bmN0aW9uKG5keCl7XG4gICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl9uYW1lKFxuICAgICAgICBhZmZpcm1Db2xJbmRleChhZmZpcm1TdG10T3Blbih0aGlzKSxuZHgpLnBvaW50ZXIsIG5keFxuICAgICAgKTtcbiAgICB9LFxuICAgIFxuICAgIGdldENvbHVtbk5hbWVzOiBmdW5jdGlvbih0Z3Q9W10pe1xuICAgICAgYWZmaXJtQ29sSW5kZXgoYWZmaXJtU3RtdE9wZW4odGhpcyksMCk7XG4gICAgICBjb25zdCBuID0gdGhpcy5jb2x1bW5Db3VudDtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBuOyArK2kpe1xuICAgICAgICB0Z3QucHVzaChjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUodGhpcy5wb2ludGVyLCBpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGd0O1xuICAgIH0sXG4gICAgXG4gICAgZ2V0UGFyYW1JbmRleDogZnVuY3Rpb24obmFtZSl7XG4gICAgICByZXR1cm4gKGFmZmlybVN0bXRPcGVuKHRoaXMpLnBhcmFtZXRlckNvdW50XG4gICAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4KHRoaXMucG9pbnRlciwgbmFtZSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgY29uc3QgcHJvcCA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIF9fcHRyTWFwLmdldCh0aGlzKX0sXG4gICAgICBzZXQ6ICgpPT50b3NzMyhcIlRoZSBwb2ludGVyIHByb3BlcnR5IGlzIHJlYWQtb25seS5cIilcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0bXQucHJvdG90eXBlLCAncG9pbnRlcicsIHByb3ApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEQi5wcm90b3R5cGUsICdwb2ludGVyJywgcHJvcCk7XG4gIH1cbiAgXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG10LnByb3RvdHlwZSwgJ2NvbHVtbkNvdW50Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24oKXtyZXR1cm4gY2FwaS5zcWxpdGUzX2NvbHVtbl9jb3VudCh0aGlzLnBvaW50ZXIpfSxcbiAgICBzZXQ6ICgpPT50b3NzMyhcIlRoZSBjb2x1bW5Db3VudCBwcm9wZXJ0eSBpcyByZWFkLW9ubHkuXCIpXG4gIH0pO1xuXG4gIFxuICBzcWxpdGUzLm9vMSA9IHtcbiAgICBEQixcbiAgICBTdG10XG4gIH07XG5cbiAgaWYodXRpbC5pc1VJVGhyZWFkKCkpe1xuICAgIFxuICAgIHNxbGl0ZTMub28xLkpzU3RvcmFnZURiID0gZnVuY3Rpb24oc3RvcmFnZU5hbWU9J3Nlc3Npb24nKXtcbiAgICAgIGlmKCdzZXNzaW9uJyE9PXN0b3JhZ2VOYW1lICYmICdsb2NhbCchPT1zdG9yYWdlTmFtZSl7XG4gICAgICAgIHRvc3MzKFwiSnNTdG9yYWdlRGIgZGIgbmFtZSBtdXN0IGJlIG9uZSBvZiAnc2Vzc2lvbicgb3IgJ2xvY2FsJy5cIik7XG4gICAgICB9XG4gICAgICBkYkN0b3JIZWxwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgIGZpbGVuYW1lOiBzdG9yYWdlTmFtZSxcbiAgICAgICAgZmxhZ3M6ICdjJyxcbiAgICAgICAgdmZzOiBcImt2dmZzXCJcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgamRiID0gc3FsaXRlMy5vbzEuSnNTdG9yYWdlRGI7XG4gICAgamRiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoREIucHJvdG90eXBlKTtcbiAgICBcbiAgICBqZGIuY2xlYXJTdG9yYWdlID0gY2FwaS5zcWxpdGUzX2pzX2t2dmZzX2NsZWFyO1xuICAgIFxuICAgIGpkYi5wcm90b3R5cGUuY2xlYXJTdG9yYWdlID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBqZGIuY2xlYXJTdG9yYWdlKGFmZmlybURiT3Blbih0aGlzKS5maWxlbmFtZSk7XG4gICAgfTtcbiAgICBcbiAgICBqZGIuc3RvcmFnZVNpemUgPSBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfc2l6ZTtcbiAgICBcbiAgICBqZGIucHJvdG90eXBlLnN0b3JhZ2VTaXplID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBqZGIuc3RvcmFnZVNpemUoYWZmaXJtRGJPcGVuKHRoaXMpLmZpbGVuYW1lKTtcbiAgICB9O1xuICB9XG5cbn0pO1xuXG5cblxuXG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbihzcWxpdGUzKXtcbnNxbGl0ZTMuaW5pdFdvcmtlcjFBUEkgPSBmdW5jdGlvbigpe1xuICAndXNlIHN0cmljdCc7XG4gIGNvbnN0IHRvc3MgPSAoLi4uYXJncyk9Pnt0aHJvdyBuZXcgRXJyb3IoYXJncy5qb2luKCcgJykpfTtcbiAgaWYoIShnbG9iYWxUaGlzLldvcmtlckdsb2JhbFNjb3BlIGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICB0b3NzKFwiaW5pdFdvcmtlcjFBUEkoKSBtdXN0IGJlIHJ1biBmcm9tIGEgV29ya2VyIHRocmVhZC5cIik7XG4gIH1cbiAgY29uc3Qgc3FsaXRlMyA9IHRoaXMuc3FsaXRlMyB8fCB0b3NzKFwiTWlzc2luZyB0aGlzLnNxbGl0ZTMgb2JqZWN0LlwiKTtcbiAgY29uc3QgREIgPSBzcWxpdGUzLm9vMS5EQjtcblxuICBcbiAgY29uc3QgZ2V0RGJJZCA9IGZ1bmN0aW9uKGRiKXtcbiAgICBsZXQgaWQgPSB3U3RhdGUuaWRNYXAuZ2V0KGRiKTtcbiAgICBpZihpZCkgcmV0dXJuIGlkO1xuICAgIGlkID0gJ2RiIycrKCsrd1N0YXRlLmlkU2VxKSsnQCcrZGIucG9pbnRlcjtcbiAgICBcbiAgICB3U3RhdGUuaWRNYXAuc2V0KGRiLCBpZCk7XG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIFxuICBjb25zdCB3U3RhdGUgPSB7XG4gICAgXG4gICAgZGJMaXN0OiBbXSxcbiAgICBcbiAgICBpZFNlcTogMCxcbiAgICBcbiAgICBpZE1hcDogbmV3IFdlYWtNYXAsXG4gICAgXG4gICAgeGZlcjogW10sXG4gICAgb3BlbjogZnVuY3Rpb24ob3B0KXtcbiAgICAgIGNvbnN0IGRiID0gbmV3IERCKG9wdCk7XG4gICAgICB0aGlzLmRic1tnZXREYklkKGRiKV0gPSBkYjtcbiAgICAgIGlmKHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpPDApIHRoaXMuZGJMaXN0LnB1c2goZGIpO1xuICAgICAgcmV0dXJuIGRiO1xuICAgIH0sXG4gICAgY2xvc2U6IGZ1bmN0aW9uKGRiLGFsc29Vbmxpbmspe1xuICAgICAgaWYoZGIpe1xuICAgICAgICBkZWxldGUgdGhpcy5kYnNbZ2V0RGJJZChkYildO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGRiLmZpbGVuYW1lO1xuICAgICAgICBjb25zdCBwVmZzID0gc3FsaXRlMy53YXNtLnNxbGl0ZTNfd2FzbV9kYl92ZnMoZGIucG9pbnRlciwgMCk7XG4gICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgIGNvbnN0IGRkTmR4ID0gdGhpcy5kYkxpc3QuaW5kZXhPZihkYik7XG4gICAgICAgIGlmKGRkTmR4Pj0wKSB0aGlzLmRiTGlzdC5zcGxpY2UoZGROZHgsIDEpO1xuICAgICAgICBpZihhbHNvVW5saW5rICYmIGZpbGVuYW1lICYmIHBWZnMpe1xuICAgICAgICAgIHNxbGl0ZTMud2FzbS5zcWxpdGUzX3dhc21fdmZzX3VubGluayhwVmZzLCBmaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHBvc3Q6IGZ1bmN0aW9uKG1zZyx4ZmVyTGlzdCl7XG4gICAgICBpZih4ZmVyTGlzdCAmJiB4ZmVyTGlzdC5sZW5ndGgpe1xuICAgICAgICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKCBtc2csIEFycmF5LmZyb20oeGZlckxpc3QpICk7XG4gICAgICAgIHhmZXJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZGJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIFxuICAgIGdldERiOiBmdW5jdGlvbihpZCxyZXF1aXJlPXRydWUpe1xuICAgICAgcmV0dXJuIHRoaXMuZGJzW2lkXVxuICAgICAgICB8fCAocmVxdWlyZSA/IHRvc3MoXCJVbmtub3duIChvciBjbG9zZWQpIERCIElEOlwiLGlkKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjb25zdCBhZmZpcm1EYk9wZW4gPSBmdW5jdGlvbihkYiA9IHdTdGF0ZS5kYkxpc3RbMF0pe1xuICAgIHJldHVybiAoZGIgJiYgZGIucG9pbnRlcikgPyBkYiA6IHRvc3MoXCJEQiBpcyBub3Qgb3BlbmVkLlwiKTtcbiAgfTtcblxuICBcbiAgY29uc3QgZ2V0TXNnRGIgPSBmdW5jdGlvbihtc2dEYXRhLGFmZmlybUV4aXN0cz10cnVlKXtcbiAgICBjb25zdCBkYiA9IHdTdGF0ZS5nZXREYihtc2dEYXRhLmRiSWQsZmFsc2UpIHx8IHdTdGF0ZS5kYkxpc3RbMF07XG4gICAgcmV0dXJuIGFmZmlybUV4aXN0cyA/IGFmZmlybURiT3BlbihkYikgOiBkYjtcbiAgfTtcblxuICBjb25zdCBnZXREZWZhdWx0RGJJZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHdTdGF0ZS5kYkxpc3RbMF0gJiYgZ2V0RGJJZCh3U3RhdGUuZGJMaXN0WzBdKTtcbiAgfTtcblxuICBjb25zdCBndWVzc1ZmcyA9IGZ1bmN0aW9uKGZpbGVuYW1lKXtcbiAgICBjb25zdCBtID0gL15maWxlOi4rKHZmcz0oXFx3KykpLy5leGVjKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gc3FsaXRlMy5jYXBpLnNxbGl0ZTNfdmZzX2ZpbmQobSA/IG1bMl0gOiAwKTtcbiAgfTtcblxuICBjb25zdCBpc1NwZWNpYWxEYkZpbGVuYW1lID0gKG4pPT57XG4gICAgcmV0dXJuIFwiXCI9PT1uIHx8ICc6Jz09PW5bMF07XG4gIH07XG5cbiAgXG4gIGNvbnN0IHdNc2dIYW5kbGVyID0ge1xuICAgIG9wZW46IGZ1bmN0aW9uKGV2KXtcbiAgICAgIGNvbnN0IG9hcmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYXJncyA9IChldi5hcmdzIHx8IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgaWYoYXJncy5zaW11bGF0ZUVycm9yKXsgXG4gICAgICAgIHRvc3MoXCJUaHJvd2luZyBiZWNhdXNlIG9mIHNpbXVsYXRlRXJyb3IgZmxhZy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBsZXQgYnl0ZUFycmF5LCBwVmZzO1xuICAgICAgb2FyZ3MudmZzID0gYXJncy52ZnM7XG4gICAgICBpZihpc1NwZWNpYWxEYkZpbGVuYW1lKGFyZ3MuZmlsZW5hbWUpKXtcbiAgICAgICAgb2FyZ3MuZmlsZW5hbWUgPSBhcmdzLmZpbGVuYW1lIHx8IFwiXCI7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgb2FyZ3MuZmlsZW5hbWUgPSBhcmdzLmZpbGVuYW1lO1xuICAgICAgICBieXRlQXJyYXkgPSBhcmdzLmJ5dGVBcnJheTtcbiAgICAgICAgaWYoYnl0ZUFycmF5KSBwVmZzID0gZ3Vlc3NWZnMoYXJncy5maWxlbmFtZSk7XG4gICAgICB9XG4gICAgICBpZihwVmZzKXtcbiAgICAgICAgXG4gICAgICAgIGxldCBwTWVtO1xuICAgICAgICB0cnl7XG4gICAgICAgICAgcE1lbSA9IHNxbGl0ZTMud2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5KGJ5dGVBcnJheSk7XG4gICAgICAgICAgY29uc3QgcmMgPSBzcWxpdGUzLndhc20uc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZShcbiAgICAgICAgICAgIHBWZnMsIG9hcmdzLmZpbGVuYW1lLCBwTWVtLCBieXRlQXJyYXkuYnl0ZUxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYocmMpIHNxbGl0ZTMuU1FMaXRlM0Vycm9yLnRvc3MocmMpO1xuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgdGhyb3cgbmV3IHNxbGl0ZTMuU1FMaXRlM0Vycm9yKFxuICAgICAgICAgICAgZS5uYW1lKycgY3JlYXRpbmcgJythcmdzLmZpbGVuYW1lK1wiOiBcIitlLm1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgY2F1c2U6IGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9ZmluYWxseXtcbiAgICAgICAgICBpZihwTWVtKSBzcWxpdGUzLndhc20uZGVhbGxvYyhwTWVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZGIgPSB3U3RhdGUub3BlbihvYXJncyk7XG4gICAgICByYy5maWxlbmFtZSA9IGRiLmZpbGVuYW1lO1xuICAgICAgcmMucGVyc2lzdGVudCA9ICEhc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfZGJfdXNlc192ZnMoZGIucG9pbnRlciwgXCJvcGZzXCIpO1xuICAgICAgcmMuZGJJZCA9IGdldERiSWQoZGIpO1xuICAgICAgcmMudmZzID0gZGIuZGJWZnNOYW1lKCk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcblxuICAgIGNsb3NlOiBmdW5jdGlvbihldil7XG4gICAgICBjb25zdCBkYiA9IGdldE1zZ0RiKGV2LGZhbHNlKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBmaWxlbmFtZTogZGIgJiYgZGIuZmlsZW5hbWVcbiAgICAgIH07XG4gICAgICBpZihkYil7XG4gICAgICAgIGNvbnN0IGRvVW5saW5rID0gKChldi5hcmdzICYmICdvYmplY3QnPT09dHlwZW9mIGV2LmFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyAhIWV2LmFyZ3MudW5saW5rIDogZmFsc2UpO1xuICAgICAgICB3U3RhdGUuY2xvc2UoZGIsIGRvVW5saW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuXG4gICAgZXhlYzogZnVuY3Rpb24oZXYpe1xuICAgICAgY29uc3QgcmMgPSAoXG4gICAgICAgICdzdHJpbmcnPT09dHlwZW9mIGV2LmFyZ3NcbiAgICAgICkgPyB7c3FsOiBldi5hcmdzfSA6IChldi5hcmdzIHx8IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgaWYoJ3N0bXQnPT09cmMucm93TW9kZSl7XG4gICAgICAgIHRvc3MoXCJJbnZhbGlkIHJvd01vZGUgZm9yICdleGVjJzogc3RtdCBtb2RlXCIsXG4gICAgICAgICAgICAgXCJkb2VzIG5vdCB3b3JrIGluIHRoZSBXb3JrZXIgQVBJLlwiKTtcbiAgICAgIH1lbHNlIGlmKCFyYy5zcWwpe1xuICAgICAgICB0b3NzKFwiJ2V4ZWMnIHJlcXVpcmVzIGlucHV0IFNRTC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkYiA9IGdldE1zZ0RiKGV2KTtcbiAgICAgIGlmKHJjLmNhbGxiYWNrIHx8IEFycmF5LmlzQXJyYXkocmMucmVzdWx0Um93cykpe1xuICAgICAgICBcbiAgICAgICAgZGIuX2Jsb2JYZmVyID0gd1N0YXRlLnhmZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB0aGVDYWxsYmFjayA9IHJjLmNhbGxiYWNrO1xuICAgICAgbGV0IHJvd051bWJlciA9IDA7XG4gICAgICBjb25zdCBoYWRDb2xOYW1lcyA9ICEhcmMuY29sdW1uTmFtZXM7XG4gICAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIHRoZUNhbGxiYWNrKXtcbiAgICAgICAgaWYoIWhhZENvbE5hbWVzKSByYy5jb2x1bW5OYW1lcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgcmMuY2FsbGJhY2sgPSBmdW5jdGlvbihyb3csc3RtdCl7XG4gICAgICAgICAgd1N0YXRlLnBvc3Qoe1xuICAgICAgICAgICAgdHlwZTogdGhlQ2FsbGJhY2ssXG4gICAgICAgICAgICBjb2x1bW5OYW1lczogcmMuY29sdW1uTmFtZXMsXG4gICAgICAgICAgICByb3dOdW1iZXI6ICsrcm93TnVtYmVyLFxuICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICB9LCB3U3RhdGUueGZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZUNvdW50ID0gISFyYy5jb3VudENoYW5nZXNcbiAgICAgICAgICAgICAgPyBkYi5jaGFuZ2VzKHRydWUsKDY0PT09cmMuY291bnRDaGFuZ2VzKSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGRiLmV4ZWMocmMpO1xuICAgICAgICBpZih1bmRlZmluZWQgIT09IGNoYW5nZUNvdW50KXtcbiAgICAgICAgICByYy5jaGFuZ2VDb3VudCA9IGRiLmNoYW5nZXModHJ1ZSw2ND09PXJjLmNvdW50Q2hhbmdlcykgLSBjaGFuZ2VDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZihyYy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgICByYy5jYWxsYmFjayA9IHRoZUNhbGxiYWNrO1xuICAgICAgICAgIFxuICAgICAgICAgIHdTdGF0ZS5wb3N0KHtcbiAgICAgICAgICAgIHR5cGU6IHRoZUNhbGxiYWNrLFxuICAgICAgICAgICAgY29sdW1uTmFtZXM6IHJjLmNvbHVtbk5hbWVzLFxuICAgICAgICAgICAgcm93TnVtYmVyOiBudWxsICxcbiAgICAgICAgICAgIHJvdzogdW5kZWZpbmVkIFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgZGVsZXRlIGRiLl9ibG9iWGZlcjtcbiAgICAgICAgaWYocmMuY2FsbGJhY2spIHJjLmNhbGxiYWNrID0gdGhlQ2FsbGJhY2s7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcblxuICAgICdjb25maWctZ2V0JzogZnVuY3Rpb24oKXtcbiAgICAgIGNvbnN0IHJjID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgc3JjID0gc3FsaXRlMy5jb25maWc7XG4gICAgICBbXG4gICAgICAgICdiaWdJbnRFbmFibGVkJ1xuICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKGspe1xuICAgICAgICBpZihPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgaykpIHJjW2tdID0gc3JjW2tdO1xuICAgICAgfSk7XG4gICAgICByYy52ZXJzaW9uID0gc3FsaXRlMy52ZXJzaW9uO1xuICAgICAgcmMudmZzTGlzdCA9IHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2pzX3Zmc19saXN0KCk7XG4gICAgICByYy5vcGZzRW5hYmxlZCA9ICEhc3FsaXRlMy5vcGZzO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH0sXG5cbiAgICBcbiAgICBleHBvcnQ6IGZ1bmN0aW9uKGV2KXtcbiAgICAgIGNvbnN0IGRiID0gZ2V0TXNnRGIoZXYpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgIGJ5dGVBcnJheTogc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfZGJfZXhwb3J0KGRiLnBvaW50ZXIpLFxuICAgICAgICBmaWxlbmFtZTogZGIuZmlsZW5hbWUsXG4gICAgICAgIG1pbWV0eXBlOiAnYXBwbGljYXRpb24veC1zcWxpdGUzJ1xuICAgICAgfTtcbiAgICAgIHdTdGF0ZS54ZmVyLnB1c2gocmVzcG9uc2UuYnl0ZUFycmF5LmJ1ZmZlcik7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcblxuICAgIHRvc3M6IGZ1bmN0aW9uKGV2KXtcbiAgICAgIHRvc3MoXCJUZXN0aW5nIHdvcmtlciBleGNlcHRpb25cIik7XG4gICAgfSxcblxuICAgICdvcGZzLXRyZWUnOiBhc3luYyBmdW5jdGlvbihldil7XG4gICAgICBpZighc3FsaXRlMy5vcGZzKSB0b3NzKFwiT1BGUyBzdXBwb3J0IGlzIHVuYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc3FsaXRlMy5vcGZzLnRyZWVMaXN0KCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICB9O1xuXG4gIGdsb2JhbFRoaXMub25tZXNzYWdlID0gYXN5bmMgZnVuY3Rpb24oZXYpe1xuICAgIGV2ID0gZXYuZGF0YTtcbiAgICBsZXQgcmVzdWx0LCBkYklkID0gZXYuZGJJZCwgZXZUeXBlID0gZXYudHlwZTtcbiAgICBjb25zdCBhcnJpdmFsVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBpZih3TXNnSGFuZGxlci5oYXNPd25Qcm9wZXJ0eShldlR5cGUpICYmXG4gICAgICAgICB3TXNnSGFuZGxlcltldlR5cGVdIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB3TXNnSGFuZGxlcltldlR5cGVdKGV2KTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0b3NzKFwiVW5rbm93biBkYiB3b3JrZXIgbWVzc2FnZSB0eXBlOlwiLGV2LnR5cGUpO1xuICAgICAgfVxuICAgIH1jYXRjaChlcnIpe1xuICAgICAgZXZUeXBlID0gJ2Vycm9yJztcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb3BlcmF0aW9uOiBldi50eXBlLFxuICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgZXJyb3JDbGFzczogZXJyLm5hbWUsXG4gICAgICAgIGlucHV0OiBldlxuICAgICAgfTtcbiAgICAgIGlmKGVyci5zdGFjayl7XG4gICAgICAgIHJlc3VsdC5zdGFjayA9ICgnc3RyaW5nJz09PXR5cGVvZiBlcnIuc3RhY2spXG4gICAgICAgICAgPyBlcnIuc3RhY2suc3BsaXQoL1xcblxccyovKSA6IGVyci5zdGFjaztcbiAgICAgIH1cbiAgICAgIGlmKDApIHNxbGl0ZTMuY29uZmlnLndhcm4oXCJXb3JrZXIgaXMgcHJvcGFnYXRpbmcgYW4gZXhjZXB0aW9uIHRvIG1haW4gdGhyZWFkLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlJlcG9ydGluZyBpdCBfaGVyZV8gZm9yIHRoZSBzdGFjayB0cmFjZTpcIixlcnIscmVzdWx0KTtcbiAgICB9XG4gICAgaWYoIWRiSWQpe1xuICAgICAgZGJJZCA9IHJlc3VsdC5kYklkXG4gICAgICAgIHx8IGdldERlZmF1bHREYklkKCk7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIHdTdGF0ZS5wb3N0KHtcbiAgICAgIHR5cGU6IGV2VHlwZSxcbiAgICAgIGRiSWQ6IGRiSWQsXG4gICAgICBtZXNzYWdlSWQ6IGV2Lm1lc3NhZ2VJZCxcbiAgICAgIHdvcmtlclJlY2VpdmVkVGltZTogYXJyaXZhbFRpbWUsXG4gICAgICB3b3JrZXJSZXNwb25kVGltZTogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICBkZXBhcnR1cmVUaW1lOiBldi5kZXBhcnR1cmVUaW1lLFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICB9LCB3U3RhdGUueGZlcik7XG4gIH07XG4gIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2Uoe3R5cGU6J3NxbGl0ZTMtYXBpJyxyZXN1bHQ6J3dvcmtlcjEtcmVhZHknfSk7XG59LmJpbmQoe3NxbGl0ZTN9KTtcbn0pO1xuXG5cblxuXG5cbid1c2Ugc3RyaWN0Jztcbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbihzcWxpdGUzKXtcbiAgY29uc3Qgd2FzbSA9IHNxbGl0ZTMud2FzbSwgY2FwaSA9IHNxbGl0ZTMuY2FwaSwgdG9zcyA9IHNxbGl0ZTMudXRpbC50b3NzMztcbiAgY29uc3QgdmZzID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgdnRhYiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgY29uc3QgU3RydWN0QmluZGVyID0gc3FsaXRlMy5TdHJ1Y3RCaW5kZXJcbiAgO1xuICBzcWxpdGUzLnZmcyA9IHZmcztcbiAgc3FsaXRlMy52dGFiID0gdnRhYjtcblxuICBjb25zdCBzaWkgPSBjYXBpLnNxbGl0ZTNfaW5kZXhfaW5mbztcbiAgXG4gIHNpaS5wcm90b3R5cGUubnRoQ29uc3RyYWludCA9IGZ1bmN0aW9uKG4sIGFzUHRyPWZhbHNlKXtcbiAgICBpZihuPDAgfHwgbj49dGhpcy4kbkNvbnN0cmFpbnQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwdHIgPSB0aGlzLiRhQ29uc3RyYWludCArIChcbiAgICAgIHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQuc3RydWN0SW5mby5zaXplb2YgKiBuXG4gICAgKTtcbiAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludChwdHIpO1xuICB9O1xuXG4gIFxuICBzaWkucHJvdG90eXBlLm50aENvbnN0cmFpbnRVc2FnZSA9IGZ1bmN0aW9uKG4sIGFzUHRyPWZhbHNlKXtcbiAgICBpZihuPDAgfHwgbj49dGhpcy4kbkNvbnN0cmFpbnQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwdHIgPSB0aGlzLiRhQ29uc3RyYWludFVzYWdlICsgKFxuICAgICAgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZS5zdHJ1Y3RJbmZvLnNpemVvZiAqIG5cbiAgICApO1xuICAgIHJldHVybiBhc1B0ciA/IHB0ciA6IG5ldyBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50X3VzYWdlKHB0cik7XG4gIH07XG5cbiAgXG4gIHNpaS5wcm90b3R5cGUubnRoT3JkZXJCeSA9IGZ1bmN0aW9uKG4sIGFzUHRyPWZhbHNlKXtcbiAgICBpZihuPDAgfHwgbj49dGhpcy4kbk9yZGVyQnkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwdHIgPSB0aGlzLiRhT3JkZXJCeSArIChcbiAgICAgIHNpaS5zcWxpdGUzX2luZGV4X29yZGVyYnkuc3RydWN0SW5mby5zaXplb2YgKiBuXG4gICAgKTtcbiAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfb3JkZXJieShwdHIpO1xuICB9O1xuXG4gIFxuICBjb25zdCBpbnN0YWxsTWV0aG9kID0gZnVuY3Rpb24gY2FsbGVlKFxuICAgIHRndCwgbmFtZSwgZnVuYywgYXBwbHlBcmdjQ2hlY2sgPSBjYWxsZWUuaW5zdGFsbE1ldGhvZEFyZ2NDaGVja1xuICApe1xuICAgIGlmKCEodGd0IGluc3RhbmNlb2YgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUpKXtcbiAgICAgIHRvc3MoXCJVc2FnZSBlcnJvcjogdGFyZ2V0IG9iamVjdCBpcy1ub3QtYSBTdHJ1Y3RUeXBlLlwiKTtcbiAgICB9ZWxzZSBpZighKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgIXdhc20uaXNQdHIoZnVuYykpe1xuICAgICAgdG9zcyhcIlVzYWdlIGVycnJvcjogZXhwZWN0aW5nIGEgRnVuY3Rpb24gb3IgV0FTTSBwb2ludGVyIHRvIG9uZS5cIik7XG4gICAgfVxuICAgIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgIHJldHVybiAobixmKT0+Y2FsbGVlKHRndCwgbiwgZiwgYXBwbHlBcmdjQ2hlY2spO1xuICAgIH1cbiAgICBpZighY2FsbGVlLmFyZ2NQcm94eSl7XG4gICAgICBjYWxsZWUuYXJnY1Byb3h5ID0gZnVuY3Rpb24odGd0LCBmdW5jTmFtZSwgZnVuYyxzaWcpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICAgICAgaWYoZnVuYy5sZW5ndGghPT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRvc3MoXCJBcmd1bWVudCBtaXNtYXRjaCBmb3JcIixcbiAgICAgICAgICAgICAgICAgdGd0LnN0cnVjdEluZm8ubmFtZStcIjo6XCIrZnVuY05hbWVcbiAgICAgICAgICAgICAgICAgK1wiOiBOYXRpdmUgc2lnbmF0dXJlIGlzOlwiLHNpZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBjYWxsZWUucmVtb3ZlRnVuY0xpc3QgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZih0aGlzLm9uZGlzcG9zZS5fX3JlbW92ZUZ1bmNMaXN0KXtcbiAgICAgICAgICB0aGlzLm9uZGlzcG9zZS5fX3JlbW92ZUZ1bmNMaXN0LmZvckVhY2goXG4gICAgICAgICAgICAodixuZHgpPT57XG4gICAgICAgICAgICAgIGlmKCdudW1iZXInPT09dHlwZW9mIHYpe1xuICAgICAgICAgICAgICAgIHRyeXt3YXNtLnVuaW5zdGFsbEZ1bmN0aW9uKHYpfVxuICAgICAgICAgICAgICAgIGNhdGNoKGUpe31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm9uZGlzcG9zZS5fX3JlbW92ZUZ1bmNMaXN0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzaWdOID0gdGd0Lm1lbWJlclNpZ25hdHVyZShuYW1lKTtcbiAgICBpZihzaWdOLmxlbmd0aDwyKXtcbiAgICAgIHRvc3MoXCJNZW1iZXJcIixuYW1lLFwiZG9lcyBub3QgaGF2ZSBhIGZ1bmN0aW9uIHBvaW50ZXIgc2lnbmF0dXJlOlwiLHNpZ04pO1xuICAgIH1cbiAgICBjb25zdCBtZW1LZXkgPSB0Z3QubWVtYmVyS2V5KG5hbWUpO1xuICAgIGNvbnN0IGZQcm94eSA9IChhcHBseUFyZ2NDaGVjayAmJiAhd2FzbS5pc1B0cihmdW5jKSlcbiAgICBcbiAgICAgICAgICA/IGNhbGxlZS5hcmdjUHJveHkodGd0LCBtZW1LZXksIGZ1bmMsIHNpZ04pXG4gICAgICAgICAgOiBmdW5jO1xuICAgIGlmKHdhc20uaXNQdHIoZlByb3h5KSl7XG4gICAgICBpZihmUHJveHkgJiYgIXdhc20uZnVuY3Rpb25FbnRyeShmUHJveHkpKXtcbiAgICAgICAgdG9zcyhcIlBvaW50ZXJcIixmUHJveHksXCJpcyBub3QgYSBXQVNNIGZ1bmN0aW9uIHRhYmxlIGVudHJ5LlwiKTtcbiAgICAgIH1cbiAgICAgIHRndFttZW1LZXldID0gZlByb3h5O1xuICAgIH1lbHNle1xuICAgICAgY29uc3QgcEZ1bmMgPSB3YXNtLmluc3RhbGxGdW5jdGlvbihmUHJveHksIHRndC5tZW1iZXJTaWduYXR1cmUobmFtZSwgdHJ1ZSkpO1xuICAgICAgdGd0W21lbUtleV0gPSBwRnVuYztcbiAgICAgIGlmKCF0Z3Qub25kaXNwb3NlIHx8ICF0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3Qpe1xuICAgICAgICB0Z3QuYWRkT25EaXNwb3NlKCdvbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCBoYW5kbGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWUucmVtb3ZlRnVuY0xpc3QpO1xuICAgICAgICB0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRndC5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdC5wdXNoKG1lbUtleSwgcEZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gKG4sZik9PmNhbGxlZSh0Z3QsIG4sIGYsIGFwcGx5QXJnY0NoZWNrKTtcbiAgfTtcbiAgaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrID0gZmFsc2U7XG5cbiAgXG4gIGNvbnN0IGluc3RhbGxNZXRob2RzID0gZnVuY3Rpb24oXG4gICAgc3RydWN0SW5zdGFuY2UsIG1ldGhvZHMsIGFwcGx5QXJnY0NoZWNrID0gaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrXG4gICl7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBNYXAgO1xuICAgIGZvcihjb25zdCBrIG9mIE9iamVjdC5rZXlzKG1ldGhvZHMpKXtcbiAgICAgIGNvbnN0IG0gPSBtZXRob2RzW2tdO1xuICAgICAgY29uc3QgcHJpb3IgPSBzZWVuLmdldChtKTtcbiAgICAgIGlmKHByaW9yKXtcbiAgICAgICAgY29uc3QgbWtleSA9IHN0cnVjdEluc3RhbmNlLm1lbWJlcktleShrKTtcbiAgICAgICAgc3RydWN0SW5zdGFuY2VbbWtleV0gPSBzdHJ1Y3RJbnN0YW5jZVtzdHJ1Y3RJbnN0YW5jZS5tZW1iZXJLZXkocHJpb3IpXTtcbiAgICAgIH1lbHNle1xuICAgICAgICBpbnN0YWxsTWV0aG9kKHN0cnVjdEluc3RhbmNlLCBrLCBtLCBhcHBseUFyZ2NDaGVjayk7XG4gICAgICAgIHNlZW4uc2V0KG0sIGspO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RydWN0SW5zdGFuY2U7XG4gIH07XG5cbiAgXG4gIFN0cnVjdEJpbmRlci5TdHJ1Y3RUeXBlLnByb3RvdHlwZS5pbnN0YWxsTWV0aG9kID0gZnVuY3Rpb24gY2FsbGVlKFxuICAgIG5hbWUsIGZ1bmMsIGFwcGx5QXJnY0NoZWNrID0gaW5zdGFsbE1ldGhvZC5pbnN0YWxsTWV0aG9kQXJnY0NoZWNrXG4gICl7XG4gICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiBuYW1lICYmICdvYmplY3QnPT09dHlwZW9mIG5hbWUpXG4gICAgICA/IGluc3RhbGxNZXRob2RzKHRoaXMsIC4uLmFyZ3VtZW50cylcbiAgICAgIDogaW5zdGFsbE1ldGhvZCh0aGlzLCAuLi5hcmd1bWVudHMpO1xuICB9O1xuXG4gIFxuICBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZS5wcm90b3R5cGUuaW5zdGFsbE1ldGhvZHMgPSBmdW5jdGlvbihcbiAgICBtZXRob2RzLCBhcHBseUFyZ2NDaGVjayA9IGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVja1xuICApe1xuICAgIHJldHVybiBpbnN0YWxsTWV0aG9kcyh0aGlzLCBtZXRob2RzLCBhcHBseUFyZ2NDaGVjayk7XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM192ZnMucHJvdG90eXBlLnJlZ2lzdGVyVmZzID0gZnVuY3Rpb24oYXNEZWZhdWx0PWZhbHNlKXtcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBzcWxpdGUzLmNhcGkuc3FsaXRlM192ZnMpKXtcbiAgICAgIHRvc3MoXCJFeHBlY3RpbmcgYSBzcWxpdGUzX3Zmcy10eXBlIGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfdmZzX3JlZ2lzdGVyKHRoaXMsIGFzRGVmYXVsdCA/IDEgOiAwKTtcbiAgICBpZihyYyl7XG4gICAgICB0b3NzKFwic3FsaXRlM192ZnNfcmVnaXN0ZXIoXCIsdGhpcyxcIikgZmFpbGVkIHdpdGggcmNcIixyYyk7XG4gICAgfVxuICAgIGlmKHRoaXMucG9pbnRlciAhPT0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKHRoaXMuJHpOYW1lKSl7XG4gICAgICB0b3NzKFwiQlVHOiBzcWxpdGUzX3Zmc19maW5kKHZmcy4kek5hbWUpIGZhaWxlZCBmb3IganVzdC1pbnN0YWxsZWQgVkZTXCIsXG4gICAgICAgICAgIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBcbiAgdmZzLmluc3RhbGxWZnMgPSBmdW5jdGlvbihvcHQpe1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgcHJvcExpc3QgPSBbJ2lvJywndmZzJ107XG4gICAgZm9yKGNvbnN0IGtleSBvZiBwcm9wTGlzdCl7XG4gICAgICBjb25zdCBvID0gb3B0W2tleV07XG4gICAgICBpZihvKXtcbiAgICAgICAgKytjb3VudDtcbiAgICAgICAgaW5zdGFsbE1ldGhvZHMoby5zdHJ1Y3QsIG8ubWV0aG9kcywgISFvLmFwcGx5QXJnY0NoZWNrKTtcbiAgICAgICAgaWYoJ3Zmcyc9PT1rZXkpe1xuICAgICAgICAgIGlmKCFvLnN0cnVjdC4kek5hbWUgJiYgJ3N0cmluZyc9PT10eXBlb2Ygby5uYW1lKXtcbiAgICAgICAgICAgIG8uc3RydWN0LmFkZE9uRGlzcG9zZShcbiAgICAgICAgICAgICAgby5zdHJ1Y3QuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcoby5uYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgby5zdHJ1Y3QucmVnaXN0ZXJWZnMoISFvLmFzRGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYoIWNvdW50KSB0b3NzKFwiTWlzdXNlOiBpbnN0YWxsVmZzKCkgb3B0aW9ucyBvYmplY3QgcmVxdWlyZXMgYXQgbGVhc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJvbmUgb2Y6XCIsIHByb3BMaXN0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBcbiAgY29uc3QgX194V3JhcEZhY3RvcnkgPSBmdW5jdGlvbihtZXRob2ROYW1lLFN0cnVjdFR5cGUpe1xuICAgIHJldHVybiBmdW5jdGlvbihwdHIscmVtb3ZlTWFwcGluZz1mYWxzZSl7XG4gICAgICBpZigwPT09YXJndW1lbnRzLmxlbmd0aCkgcHRyID0gbmV3IFN0cnVjdFR5cGU7XG4gICAgICBpZihwdHIgaW5zdGFuY2VvZiBTdHJ1Y3RUeXBlKXtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0KHB0ci5wb2ludGVyLCBwdHIpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgfWVsc2UgaWYoIXdhc20uaXNQdHIocHRyKSl7XG4gICAgICAgIHNxbGl0ZTMuU1FMaXRlM0Vycm9yLnRvc3MoXCJJbnZhbGlkIGFyZ3VtZW50IHRvXCIsbWV0aG9kTmFtZStcIigpXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHJjID0gdGhpcy5nZXQocHRyKTtcbiAgICAgIGlmKHJlbW92ZU1hcHBpbmcpIHRoaXMuZGVsZXRlKHB0cik7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfS5iaW5kKG5ldyBNYXApO1xuICB9O1xuXG4gIFxuICBjb25zdCBTdHJ1Y3RQdHJNYXBwZXIgPSBmdW5jdGlvbihuYW1lLCBTdHJ1Y3RUeXBlKXtcbiAgICBjb25zdCBfX3hXcmFwID0gX194V3JhcEZhY3RvcnkobmFtZSxTdHJ1Y3RUeXBlKTtcbiAgICBcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICAgIFxuICAgICAgU3RydWN0VHlwZSxcbiAgICAgIFxuICAgICAgY3JlYXRlOiAocHBPdXQpPT57XG4gICAgICAgIGNvbnN0IHJjID0gX194V3JhcCgpO1xuICAgICAgICB3YXNtLnBva2VQdHIocHBPdXQsIHJjLnBvaW50ZXIpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBnZXQ6IChwQ09iaik9Pl9feFdyYXAocENPYmopLFxuICAgICAgXG4gICAgICB1bmdldDogKHBDT2JqKT0+X194V3JhcChwQ09iaix0cnVlKSxcbiAgICAgIFxuICAgICAgZGlzcG9zZTogKHBDT2JqKT0+e1xuICAgICAgICBjb25zdCBvID0gX194V3JhcChwQ09iaix0cnVlKTtcbiAgICAgICAgaWYobykgby5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgXG4gIHZ0YWIueFZ0YWIgPSBTdHJ1Y3RQdHJNYXBwZXIoJ3hWdGFiJywgY2FwaS5zcWxpdGUzX3Z0YWIpO1xuXG4gIFxuICB2dGFiLnhDdXJzb3IgPSBTdHJ1Y3RQdHJNYXBwZXIoJ3hDdXJzb3InLCBjYXBpLnNxbGl0ZTNfdnRhYl9jdXJzb3IpO1xuXG4gIFxuICB2dGFiLnhJbmRleEluZm8gPSAocElkeEluZm8pPT5uZXcgY2FwaS5zcWxpdGUzX2luZGV4X2luZm8ocElkeEluZm8pO1xuXG4gIFxuICBcblxuICBcbiAgdnRhYi54RXJyb3IgPSBmdW5jdGlvbiBmKG1ldGhvZE5hbWUsIGVyciwgZGVmYXVsdFJjKXtcbiAgICBpZihmLmVycm9yUmVwb3J0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICB0cnl7Zi5lcnJvclJlcG9ydGVyKFwic3FsaXRlM19tb2R1bGU6OlwiK21ldGhvZE5hbWUrXCIoKTogXCIrZXJyLm1lc3NhZ2UpO31cbiAgICAgIGNhdGNoKGUpe31cbiAgICB9XG4gICAgbGV0IHJjO1xuICAgIGlmKGVyciBpbnN0YW5jZW9mIHNxbGl0ZTMuV2FzbUFsbG9jRXJyb3IpIHJjID0gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoPjIpIHJjID0gZGVmYXVsdFJjO1xuICAgIGVsc2UgaWYoZXJyIGluc3RhbmNlb2Ygc3FsaXRlMy5TUUxpdGUzRXJyb3IpIHJjID0gZXJyLnJlc3VsdENvZGU7XG4gICAgcmV0dXJuIHJjIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICB9O1xuICB2dGFiLnhFcnJvci5lcnJvclJlcG9ydGVyID0gMSA/IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSA6IGZhbHNlO1xuXG4gIFxuICBcblxuICBcbiAgdnRhYi54Um93aWQgPSAocHBSb3dpZDY0LCB2YWx1ZSk9Pndhc20ucG9rZShwcFJvd2lkNjQsIHZhbHVlLCAnaTY0Jyk7XG5cbiAgXG4gIHZ0YWIuc2V0dXBNb2R1bGUgPSBmdW5jdGlvbihvcHQpe1xuICAgIGxldCBjcmVhdGVkTW9kID0gZmFsc2U7XG4gICAgY29uc3QgbW9kID0gKHRoaXMgaW5zdGFuY2VvZiBjYXBpLnNxbGl0ZTNfbW9kdWxlKVxuICAgICAgICAgID8gdGhpcyA6IChvcHQuc3RydWN0IHx8IChjcmVhdGVkTW9kID0gbmV3IGNhcGkuc3FsaXRlM19tb2R1bGUoKSkpO1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IG1ldGhvZHMgPSBvcHQubWV0aG9kcyB8fCB0b3NzKFwiTWlzc2luZyAnbWV0aG9kcycgb2JqZWN0LlwiKTtcbiAgICAgIGZvcihjb25zdCBlIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB4Q29ubmVjdDogJ3hDcmVhdGUnLCB4RGlzY29ubmVjdDogJ3hEZXN0cm95J1xuICAgICAgfSkpe1xuICAgICAgICBcbiAgICAgICAgY29uc3QgayA9IGVbMF0sIHYgPSBlWzFdO1xuICAgICAgICBpZih0cnVlID09PSBtZXRob2RzW2tdKSBtZXRob2RzW2tdID0gbWV0aG9kc1t2XTtcbiAgICAgICAgZWxzZSBpZih0cnVlID09PSBtZXRob2RzW3ZdKSBtZXRob2RzW3ZdID0gbWV0aG9kc1trXTtcbiAgICAgIH1cbiAgICAgIGlmKG9wdC5jYXRjaEV4Y2VwdGlvbnMpe1xuICAgICAgICBjb25zdCBmd3JhcCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGZ1bmMpe1xuICAgICAgICAgIGlmKFsneENvbm5lY3QnLCd4Q3JlYXRlJ10uaW5kZXhPZihtZXRob2ROYW1lKSA+PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwRGIsIHBBdXgsIGFyZ2MsIGFyZ3YsIHBwVnRhYiwgcHpFcnIpe1xuICAgICAgICAgICAgICB0cnl7cmV0dXJuIGZ1bmMoLi4uYXJndW1lbnRzKSB8fCAwfVxuICAgICAgICAgICAgICBjYXRjaChlKXtcbiAgICAgICAgICAgICAgICBpZighKGUgaW5zdGFuY2VvZiBzcWxpdGUzLldhc21BbGxvY0Vycm9yKSl7XG4gICAgICAgICAgICAgICAgICB3YXNtLmRlYWxsb2Mod2FzbS5wZWVrUHRyKHB6RXJyKSk7XG4gICAgICAgICAgICAgICAgICB3YXNtLnBva2VQdHIocHpFcnIsIHdhc20uYWxsb2NDU3RyaW5nKGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdnRhYi54RXJyb3IobWV0aG9kTmFtZSwgZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICAgICAgICAgIHRyeXtyZXR1cm4gZnVuYyguLi5hcmdzKSB8fCAwfVxuICAgICAgICAgICAgICBjYXRjaChlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdnRhYi54RXJyb3IobWV0aG9kTmFtZSwgZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtbmFtZXMgPSBbXG4gICAgICAgICAgJ3hDcmVhdGUnLCAneENvbm5lY3QnLCAneEJlc3RJbmRleCcsICd4RGlzY29ubmVjdCcsXG4gICAgICAgICAgJ3hEZXN0cm95JywgJ3hPcGVuJywgJ3hDbG9zZScsICd4RmlsdGVyJywgJ3hOZXh0JyxcbiAgICAgICAgICAneEVvZicsICd4Q29sdW1uJywgJ3hSb3dpZCcsICd4VXBkYXRlJyxcbiAgICAgICAgICAneEJlZ2luJywgJ3hTeW5jJywgJ3hDb21taXQnLCAneFJvbGxiYWNrJyxcbiAgICAgICAgICAneEZpbmRGdW5jdGlvbicsICd4UmVuYW1lJywgJ3hTYXZlcG9pbnQnLCAneFJlbGVhc2UnLFxuICAgICAgICAgICd4Um9sbGJhY2tUbycsICd4U2hhZG93TmFtZSdcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVtZXRob2RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yKGNvbnN0IGsgb2YgbW5hbWVzKXtcbiAgICAgICAgICBjb25zdCBtID0gbWV0aG9kc1trXTtcbiAgICAgICAgICBpZighKG0gaW5zdGFuY2VvZiBGdW5jdGlvbikpIGNvbnRpbnVlO1xuICAgICAgICAgIGVsc2UgaWYoJ3hDb25uZWN0Jz09PWsgJiYgbWV0aG9kcy54Q3JlYXRlPT09bSl7XG4gICAgICAgICAgICByZW1ldGhvZHNba10gPSBtZXRob2RzLnhDcmVhdGU7XG4gICAgICAgICAgfWVsc2UgaWYoJ3hDcmVhdGUnPT09ayAmJiBtZXRob2RzLnhDb25uZWN0PT09bSl7XG4gICAgICAgICAgICByZW1ldGhvZHNba10gPSBtZXRob2RzLnhDb25uZWN0O1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmVtZXRob2RzW2tdID0gZndyYXAoaywgbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc3RhbGxNZXRob2RzKG1vZCwgcmVtZXRob2RzLCBmYWxzZSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpbnN0YWxsTWV0aG9kcyhcbiAgICAgICAgICBtb2QsIG1ldGhvZHMsICEhb3B0LmFwcGx5QXJnY0NoZWNrXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZigwPT09bW9kLiRpVmVyc2lvbil7XG4gICAgICAgIGxldCB2O1xuICAgICAgICBpZignbnVtYmVyJz09PXR5cGVvZiBvcHQuaVZlcnNpb24pIHYgPSBvcHQuaVZlcnNpb247XG4gICAgICAgIGVsc2UgaWYobW9kLiR4U2hhZG93TmFtZSkgdiA9IDM7XG4gICAgICAgIGVsc2UgaWYobW9kLiR4U2F2ZVBvaW50IHx8IG1vZC4keFJlbGVhc2UgfHwgbW9kLiR4Um9sbGJhY2tUbykgdiA9IDI7XG4gICAgICAgIGVsc2UgdiA9IDE7XG4gICAgICAgIG1vZC4kaVZlcnNpb24gPSB2O1xuICAgICAgfVxuICAgIH1jYXRjaChlKXtcbiAgICAgIGlmKGNyZWF0ZWRNb2QpIGNyZWF0ZWRNb2QuZGlzcG9zZSgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZDtcbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX21vZHVsZS5wcm90b3R5cGUuc2V0dXBNb2R1bGUgPSBmdW5jdGlvbihvcHQpe1xuICAgIHJldHVybiB2dGFiLnNldHVwTW9kdWxlLmNhbGwodGhpcywgb3B0KTtcbiAgfTtcbn0pO1xuXG5cblxuJ3VzZSBzdHJpY3QnO1xuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uKHNxbGl0ZTMpe1xuXG5jb25zdCBpbnN0YWxsT3Bmc1ZmcyA9IGZ1bmN0aW9uIGNhbGxlZShvcHRpb25zKXtcbiAgaWYoIWdsb2JhbFRoaXMuU2hhcmVkQXJyYXlCdWZmZXJcbiAgICB8fCAhZ2xvYmFsVGhpcy5BdG9taWNzKXtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoXCJDYW5ub3QgaW5zdGFsbCBPUEZTOiBNaXNzaW5nIFNoYXJlZEFycmF5QnVmZmVyIGFuZC9vciBBdG9taWNzLiBcIitcbiAgICAgICAgICAgICAgICBcIlRoZSBzZXJ2ZXIgbXVzdCBlbWl0IHRoZSBDT09QL0NPRVAgcmVzcG9uc2UgaGVhZGVycyB0byBlbmFibGUgdGhvc2UuIFwiK1xuICAgICAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vc3FsaXRlLm9yZy93YXNtL2RvYy90cnVuay9wZXJzaXN0ZW5jZS5tZCNjb29wLWNvZXBcIilcbiAgICApO1xuICB9ZWxzZSBpZigndW5kZWZpbmVkJz09PXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSl7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKFwiVGhlIE9QRlMgc3FsaXRlM192ZnMgY2Fubm90IHJ1biBpbiB0aGUgbWFpbiB0aHJlYWQgXCIrXG4gICAgICAgICAgICAgICAgXCJiZWNhdXNlIGl0IHJlcXVpcmVzIEF0b21pY3Mud2FpdCgpLlwiKVxuICAgICk7XG4gIH1lbHNlIGlmKCFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgfHxcbiAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8fFxuICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSB8fFxuICAgICAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSB8fFxuICAgICAgICAgICAhbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3Rvcnkpe1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgIG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgT1BGUyBBUElzLlwiKVxuICAgICk7XG4gIH1cbiAgaWYoIW9wdGlvbnMgfHwgJ29iamVjdCchPT10eXBlb2Ygb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTChnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYpLnNlYXJjaFBhcmFtcztcbiAgaWYodXJsUGFyYW1zLmhhcygnb3Bmcy1kaXNhYmxlJykpe1xuICAgIFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3FsaXRlMyk7XG4gIH1cbiAgaWYodW5kZWZpbmVkPT09b3B0aW9ucy52ZXJib3NlKXtcbiAgICBvcHRpb25zLnZlcmJvc2UgPSB1cmxQYXJhbXMuaGFzKCdvcGZzLXZlcmJvc2UnKVxuICAgICAgPyAoK3VybFBhcmFtcy5nZXQoJ29wZnMtdmVyYm9zZScpIHx8IDIpIDogMTtcbiAgfVxuICBpZih1bmRlZmluZWQ9PT1vcHRpb25zLnNhbml0eUNoZWNrcyl7XG4gICAgb3B0aW9ucy5zYW5pdHlDaGVja3MgPSB1cmxQYXJhbXMuaGFzKCdvcGZzLXNhbml0eS1jaGVjaycpO1xuICB9XG4gIGlmKHVuZGVmaW5lZD09PW9wdGlvbnMucHJveHlVcmkpe1xuICAgIG9wdGlvbnMucHJveHlVcmkgPSBjYWxsZWUuZGVmYXVsdFByb3h5VXJpO1xuICB9XG5cbiAgXG5cbiAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMucHJveHlVcmkpe1xuICAgIG9wdGlvbnMucHJveHlVcmkgPSBvcHRpb25zLnByb3h5VXJpKCk7XG4gIH1cbiAgY29uc3QgdGhlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHByb21pc2VSZXNvbHZlXywgcHJvbWlzZVJlamVjdF8pe1xuICAgIGNvbnN0IGxvZ2dlcnMgPSBbXG4gICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcixcbiAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4sXG4gICAgICBzcWxpdGUzLmNvbmZpZy5sb2dcbiAgICBdO1xuICAgIGNvbnN0IGxvZ0ltcGwgPSAobGV2ZWwsLi4uYXJncyk9PntcbiAgICAgIGlmKG9wdGlvbnMudmVyYm9zZT5sZXZlbCkgbG9nZ2Vyc1tsZXZlbF0oXCJPUEZTIHN5bmNlcjpcIiwuLi5hcmdzKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvZyA9ICAgICguLi5hcmdzKT0+bG9nSW1wbCgyLCAuLi5hcmdzKTtcbiAgICBjb25zdCB3YXJuID0gICAoLi4uYXJncyk9PmxvZ0ltcGwoMSwgLi4uYXJncyk7XG4gICAgY29uc3QgZXJyb3IgPSAgKC4uLmFyZ3MpPT5sb2dJbXBsKDAsIC4uLmFyZ3MpO1xuICAgIGNvbnN0IHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zcztcbiAgICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpO1xuICAgIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gICAgY29uc3Qgd2FzbSA9IHNxbGl0ZTMud2FzbTtcbiAgICBjb25zdCBzcWxpdGUzX3ZmcyA9IGNhcGkuc3FsaXRlM192ZnM7XG4gICAgY29uc3Qgc3FsaXRlM19maWxlID0gY2FwaS5zcWxpdGUzX2ZpbGU7XG4gICAgY29uc3Qgc3FsaXRlM19pb19tZXRob2RzID0gY2FwaS5zcWxpdGUzX2lvX21ldGhvZHM7XG4gICAgXG4gICAgY29uc3Qgb3Bmc1V0aWwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgXG4gICAgY29uc3QgdGhpc1RocmVhZEhhc09QRlMgPSAoKT0+e1xuICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSAmJlxuICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSAmJlxuICAgICAgICBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlICYmXG4gICAgICAgIG5hdmlnYXRvcj8uc3RvcmFnZT8uZ2V0RGlyZWN0b3J5O1xuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC5tZXRyaWNzID0ge1xuICAgICAgZHVtcDogZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGssIG4gPSAwLCB0ID0gMCwgdyA9IDA7XG4gICAgICAgIGZvcihrIGluIHN0YXRlLm9wSWRzKXtcbiAgICAgICAgICBjb25zdCBtID0gbWV0cmljc1trXTtcbiAgICAgICAgICBuICs9IG0uY291bnQ7XG4gICAgICAgICAgdCArPSBtLnRpbWU7XG4gICAgICAgICAgdyArPSBtLndhaXQ7XG4gICAgICAgICAgbS5hdmdUaW1lID0gKG0uY291bnQgJiYgbS50aW1lKSA/IChtLnRpbWUgLyBtLmNvdW50KSA6IDA7XG4gICAgICAgICAgbS5hdmdXYWl0ID0gKG0uY291bnQgJiYgbS53YWl0KSA/IChtLndhaXQgLyBtLmNvdW50KSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3FsaXRlMy5jb25maWcubG9nKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRyaWNzIGZvclwiLGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZixcIjpcIixtZXRyaWNzLFxuICAgICAgICAgICAgICAgICAgICBcIlxcblRvdGFsIG9mXCIsbixcIm9wKHMpIGZvclwiLHQsXG4gICAgICAgICAgICAgICAgICAgIFwibXMgKGluY2wuIFwiK3crXCIgbXMgb2Ygd2FpdGluZyBvbiB0aGUgYXN5bmMgc2lkZSlcIik7XG4gICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyhcIlNlcmlhbGl6YXRpb24gbWV0cmljczpcIixtZXRyaWNzLnMxMW4pO1xuICAgICAgICBXLnBvc3RNZXNzYWdlKHt0eXBlOidvcGZzLWFzeW5jLW1ldHJpY3MnfSk7XG4gICAgICB9LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBrO1xuICAgICAgICBjb25zdCByID0gKG0pPT4obS5jb3VudCA9IG0udGltZSA9IG0ud2FpdCA9IDApO1xuICAgICAgICBmb3IoayBpbiBzdGF0ZS5vcElkcyl7XG4gICAgICAgICAgcihtZXRyaWNzW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHMgPSBtZXRyaWNzLnMxMW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBzID0gcy5zZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBzLmNvdW50ID0gcy50aW1lID0gMDtcbiAgICAgICAgcyA9IG1ldHJpY3MuczExbi5kZXNlcmlhbGl6ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHMuY291bnQgPSBzLnRpbWUgPSAwO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb3Bmc0lvTWV0aG9kcyA9IG5ldyBzcWxpdGUzX2lvX21ldGhvZHMoKTtcbiAgICBjb25zdCBvcGZzVmZzID0gbmV3IHNxbGl0ZTNfdmZzKClcbiAgICAgICAgICAuYWRkT25EaXNwb3NlKCAoKT0+b3Bmc0lvTWV0aG9kcy5kaXNwb3NlKCkpO1xuICAgIGxldCBwcm9taXNlV2FzUmVqZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvbWlzZVJlamVjdCA9IChlcnIpPT57XG4gICAgICBwcm9taXNlV2FzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgb3Bmc1Zmcy5kaXNwb3NlKCk7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlamVjdF8oZXJyKTtcbiAgICB9O1xuICAgIGNvbnN0IHByb21pc2VSZXNvbHZlID0gKCk9PntcbiAgICAgIHByb21pc2VXYXNSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlXyhzcWxpdGUzKTtcbiAgICB9O1xuICAgIGNvbnN0IFcgPVxuICAgIG5ldyBXb3JrZXIob3B0aW9ucy5wcm94eVVyaSk7XG4gICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgXG4gICAgICBpZih1bmRlZmluZWQ9PT1wcm9taXNlV2FzUmVqZWN0ZWQpe1xuICAgICAgICBwcm9taXNlUmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcIlRpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgT1BGUyBhc3luYyBwcm94eSB3b3JrZXIuXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgNDAwMCk7XG4gICAgVy5fb3JpZ2luYWxPbkVycm9yID0gVy5vbmVycm9yIDtcbiAgICBXLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICAgICAgXG4gICAgICBcbiAgICAgIGVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIE9QRlMgYXN5bmNlcjpcIixlcnIpO1xuICAgICAgcHJvbWlzZVJlamVjdChuZXcgRXJyb3IoXCJMb2FkaW5nIE9QRlMgYXN5bmMgV29ya2VyIGZhaWxlZCBmb3IgdW5rbm93biByZWFzb25zLlwiKSk7XG4gICAgfTtcbiAgICBjb25zdCBwRFZmcyA9IGNhcGkuc3FsaXRlM192ZnNfZmluZChudWxsKTtcbiAgICBjb25zdCBkVmZzID0gcERWZnNcbiAgICAgICAgICA/IG5ldyBzcWxpdGUzX3ZmcyhwRFZmcylcbiAgICAgICAgICA6IG51bGwgO1xuICAgIG9wZnNJb01ldGhvZHMuJGlWZXJzaW9uID0gMTtcbiAgICBvcGZzVmZzLiRpVmVyc2lvbiA9IDI7XG4gICAgb3Bmc1Zmcy4kc3pPc0ZpbGUgPSBjYXBpLnNxbGl0ZTNfZmlsZS5zdHJ1Y3RJbmZvLnNpemVvZjtcbiAgICBvcGZzVmZzLiRteFBhdGhuYW1lID0gMTAyNDtcbiAgICBvcGZzVmZzLiR6TmFtZSA9IHdhc20uYWxsb2NDU3RyaW5nKFwib3Bmc1wiKTtcbiAgICBcbiAgICBvcGZzVmZzLiR4RGxPcGVuID0gb3Bmc1Zmcy4keERsRXJyb3IgPSBvcGZzVmZzLiR4RGxTeW0gPSBvcGZzVmZzLiR4RGxDbG9zZSA9IG51bGw7XG4gICAgb3Bmc1Zmcy5hZGRPbkRpc3Bvc2UoXG4gICAgICAnJHpOYW1lJywgb3Bmc1Zmcy4kek5hbWUsXG4gICAgICAnY2xlYW51cCBkZWZhdWx0IFZGUyB3cmFwcGVyJywgKCk9PihkVmZzID8gZFZmcy5kaXNwb3NlKCkgOiBudWxsKVxuICAgICk7XG4gICAgXG4gICAgXG4gICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHN0YXRlLnZlcmJvc2UgPSBvcHRpb25zLnZlcmJvc2U7XG4gICAgc3RhdGUubGl0dGxlRW5kaWFuID0gKCgpPT57XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICBuZXcgRGF0YVZpZXcoYnVmZmVyKS5zZXRJbnQxNigwLCAyNTYsIHRydWUgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlcilbMF0gPT09IDI1NjtcbiAgICB9KSgpO1xuICAgIFxuICAgIHN0YXRlLmFzeW5jSWRsZVdhaXRUaW1lID0gMTUwO1xuXG4gICAgXG4gICAgc3RhdGUuYXN5bmNTMTFuRXhjZXB0aW9ucyA9IDE7XG4gICAgXG4gICAgc3RhdGUuZmlsZUJ1ZmZlclNpemUgPSAxMDI0ICogNjQ7XG4gICAgc3RhdGUuc2FiUzExbk9mZnNldCA9IHN0YXRlLmZpbGVCdWZmZXJTaXplO1xuICAgIFxuICAgIHN0YXRlLnNhYlMxMW5TaXplID0gb3Bmc1Zmcy4kbXhQYXRobmFtZSAqIDI7XG4gICAgXG4gICAgc3RhdGUuc2FiSU8gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoXG4gICAgICBzdGF0ZS5maWxlQnVmZmVyU2l6ZVxuICAgICAgKyBzdGF0ZS5zYWJTMTFuU2l6ZVxuICAgICk7XG4gICAgc3RhdGUub3BJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IG1ldHJpY3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHtcbiAgICAgIFxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgXG4gICAgICBzdGF0ZS5vcElkcy53aGljaE9wID0gaSsrO1xuICAgICAgXG4gICAgICBzdGF0ZS5vcElkcy5yYyA9IGkrKztcbiAgICAgIFxuICAgICAgc3RhdGUub3BJZHMueEFjY2VzcyA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhDbG9zZSA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhEZWxldGUgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54RGVsZXRlTm9XYWl0ID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueEZpbGVTaXplID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueExvY2sgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54T3BlbiA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhSZWFkID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueFNsZWVwID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueFN5bmMgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54VHJ1bmNhdGUgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54VW5sb2NrID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueFdyaXRlID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMubWtkaXIgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkc1snb3Bmcy1hc3luYy1tZXRyaWNzJ10gPSBpKys7XG4gICAgICBzdGF0ZS5vcElkc1snb3Bmcy1hc3luYy1zaHV0ZG93biddID0gaSsrO1xuICAgICAgXG4gICAgICBzdGF0ZS5vcElkcy5yZXRyeSA9IGkrKztcbiAgICAgIHN0YXRlLnNhYk9QID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKFxuICAgICAgICBpICogNCk7XG4gICAgICBvcGZzVXRpbC5tZXRyaWNzLnJlc2V0KCk7XG4gICAgfVxuICAgIFxuICAgIHN0YXRlLnNxM0NvZGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBbXG4gICAgICAnU1FMSVRFX0FDQ0VTU19FWElTVFMnLFxuICAgICAgJ1NRTElURV9BQ0NFU1NfUkVBRFdSSVRFJyxcbiAgICAgICdTUUxJVEVfQlVTWScsXG4gICAgICAnU1FMSVRFX0VSUk9SJyxcbiAgICAgICdTUUxJVEVfSU9FUlInLFxuICAgICAgJ1NRTElURV9JT0VSUl9BQ0NFU1MnLFxuICAgICAgJ1NRTElURV9JT0VSUl9DTE9TRScsXG4gICAgICAnU1FMSVRFX0lPRVJSX0RFTEVURScsXG4gICAgICAnU1FMSVRFX0lPRVJSX0ZTWU5DJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfTE9DSycsXG4gICAgICAnU1FMSVRFX0lPRVJSX1JFQUQnLFxuICAgICAgJ1NRTElURV9JT0VSUl9TSE9SVF9SRUFEJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfVFJVTkNBVEUnLFxuICAgICAgJ1NRTElURV9JT0VSUl9VTkxPQ0snLFxuICAgICAgJ1NRTElURV9JT0VSUl9XUklURScsXG4gICAgICAnU1FMSVRFX0xPQ0tfRVhDTFVTSVZFJyxcbiAgICAgICdTUUxJVEVfTE9DS19OT05FJyxcbiAgICAgICdTUUxJVEVfTE9DS19QRU5ESU5HJyxcbiAgICAgICdTUUxJVEVfTE9DS19SRVNFUlZFRCcsXG4gICAgICAnU1FMSVRFX0xPQ0tfU0hBUkVEJyxcbiAgICAgICdTUUxJVEVfTE9DS0VEJyxcbiAgICAgICdTUUxJVEVfTUlTVVNFJyxcbiAgICAgICdTUUxJVEVfTk9URk9VTkQnLFxuICAgICAgJ1NRTElURV9PUEVOX0NSRUFURScsXG4gICAgICAnU1FMSVRFX09QRU5fREVMRVRFT05DTE9TRScsXG4gICAgICAnU1FMSVRFX09QRU5fTUFJTl9EQicsXG4gICAgICAnU1FMSVRFX09QRU5fUkVBRE9OTFknXG4gICAgXS5mb3JFYWNoKChrKT0+e1xuICAgICAgaWYodW5kZWZpbmVkID09PSAoc3RhdGUuc3EzQ29kZXNba10gPSBjYXBpW2tdKSl7XG4gICAgICAgIHRvc3MoXCJNYWludGVuYW5jZSByZXF1aXJlZDogbm90IGZvdW5kOlwiLGspO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN0YXRlLm9wZnNGbGFncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgICBcbiAgICAgIE9QRlNfVU5MT0NLX0FTQVA6IDB4MDEsXG4gICAgICBcbiAgICAgIGRlZmF1bHRVbmxvY2tBc2FwOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgXG4gICAgY29uc3Qgb3BSdW4gPSAob3AsLi4uYXJncyk9PntcbiAgICAgIGNvbnN0IG9wTmR4ID0gc3RhdGUub3BJZHNbb3BdIHx8IHRvc3MoXCJJbnZhbGlkIG9wIElEOlwiLG9wKTtcbiAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKC4uLmFyZ3MpO1xuICAgICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJjLCAtMSk7XG4gICAgICBBdG9taWNzLnN0b3JlKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMud2hpY2hPcCwgb3BOZHgpO1xuICAgICAgQXRvbWljcy5ub3RpZnkoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy53aGljaE9wKVxuICAgICAgO1xuICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgQXRvbWljcy53YWl0KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMsIC0xKVxuICAgICAgO1xuICAgICAgY29uc3QgcmMgPSBBdG9taWNzLmxvYWQoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYyk7XG4gICAgICBtZXRyaWNzW29wXS53YWl0ICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdDtcbiAgICAgIGlmKHJjICYmIHN0YXRlLmFzeW5jUzExbkV4Y2VwdGlvbnMpe1xuICAgICAgICBjb25zdCBlcnIgPSBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplKCk7XG4gICAgICAgIGlmKGVycikgZXJyb3Iob3ArXCIoKSBhc3luYyBlcnJvcjpcIiwuLi5lcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJjO1xuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC5kZWJ1ZyA9IHtcbiAgICAgIGFzeW5jU2h1dGRvd246ICgpPT57XG4gICAgICAgIHdhcm4oXCJTaHV0dGluZyBkb3duIE9QRlMgYXN5bmMgbGlzdGVuZXIuIFRoZSBPUEZTIFZGUyB3aWxsIG5vIGxvbmdlciB3b3JrLlwiKTtcbiAgICAgICAgb3BSdW4oJ29wZnMtYXN5bmMtc2h1dGRvd24nKTtcbiAgICAgIH0sXG4gICAgICBhc3luY1Jlc3RhcnQ6ICgpPT57XG4gICAgICAgIHdhcm4oXCJBdHRlbXB0aW5nIHRvIHJlc3RhcnQgT1BGUyBWRlMgYXN5bmMgbGlzdGVuZXIuIE1pZ2h0IHdvcmssIG1pZ2h0IG5vdC5cIik7XG4gICAgICAgIFcucG9zdE1lc3NhZ2Uoe3R5cGU6ICdvcGZzLWFzeW5jLXJlc3RhcnQnfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGluaXRTMTFuID0gKCk9PntcbiAgICAgIFxuICAgICAgaWYoc3RhdGUuczExbikgcmV0dXJuIHN0YXRlLnMxMW47XG4gICAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpLFxuICAgICAgICAgICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JyksXG4gICAgICAgICAgICB2aWV3VTggPSBuZXcgVWludDhBcnJheShzdGF0ZS5zYWJJTywgc3RhdGUuc2FiUzExbk9mZnNldCwgc3RhdGUuc2FiUzExblNpemUpLFxuICAgICAgICAgICAgdmlld0RWID0gbmV3IERhdGFWaWV3KHN0YXRlLnNhYklPLCBzdGF0ZS5zYWJTMTFuT2Zmc2V0LCBzdGF0ZS5zYWJTMTFuU2l6ZSk7XG4gICAgICBzdGF0ZS5zMTFuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIFxuICAgICAgY29uc3QgVHlwZUlkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBUeXBlSWRzLm51bWJlciAgPSB7IGlkOiAxLCBzaXplOiA4LCBnZXR0ZXI6ICdnZXRGbG9hdDY0Jywgc2V0dGVyOiAnc2V0RmxvYXQ2NCcgfTtcbiAgICAgIFR5cGVJZHMuYmlnaW50ICA9IHsgaWQ6IDIsIHNpemU6IDgsIGdldHRlcjogJ2dldEJpZ0ludDY0Jywgc2V0dGVyOiAnc2V0QmlnSW50NjQnIH07XG4gICAgICBUeXBlSWRzLmJvb2xlYW4gPSB7IGlkOiAzLCBzaXplOiA0LCBnZXR0ZXI6ICdnZXRJbnQzMicsIHNldHRlcjogJ3NldEludDMyJyB9O1xuICAgICAgVHlwZUlkcy5zdHJpbmcgPSAgeyBpZDogNCB9O1xuXG4gICAgICBjb25zdCBnZXRUeXBlSWQgPSAodik9PihcbiAgICAgICAgVHlwZUlkc1t0eXBlb2Ygdl1cbiAgICAgICAgICB8fCB0b3NzKFwiTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IHRoaXMgdmFsdWUgdHlwZSBjYW5ub3QgYmUgc2VyaWFsaXplZC5cIix2KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGdldFR5cGVJZEJ5SWQgPSAodGlkKT0+e1xuICAgICAgICBzd2l0Y2godGlkKXtcbiAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5udW1iZXIuaWQ6IHJldHVybiBUeXBlSWRzLm51bWJlcjtcbiAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5iaWdpbnQuaWQ6IHJldHVybiBUeXBlSWRzLmJpZ2ludDtcbiAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5ib29sZWFuLmlkOiByZXR1cm4gVHlwZUlkcy5ib29sZWFuO1xuICAgICAgICAgICAgY2FzZSBUeXBlSWRzLnN0cmluZy5pZDogcmV0dXJuIFR5cGVJZHMuc3RyaW5nO1xuICAgICAgICAgICAgZGVmYXVsdDogdG9zcyhcIkludmFsaWQgdHlwZSBJRDpcIix0aWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBcbiAgICAgIHN0YXRlLnMxMW4uZGVzZXJpYWxpemUgPSBmdW5jdGlvbihjbGVhcj1mYWxzZSl7XG4gICAgICAgICsrbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplLmNvdW50O1xuICAgICAgICBjb25zdCB0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IGFyZ2MgPSB2aWV3VThbMF07XG4gICAgICAgIGNvbnN0IHJjID0gYXJnYyA/IFtdIDogbnVsbDtcbiAgICAgICAgaWYoYXJnYyl7XG4gICAgICAgICAgY29uc3QgdHlwZUlkcyA9IFtdO1xuICAgICAgICAgIGxldCBvZmZzZXQgPSAxLCBpLCBuLCB2O1xuICAgICAgICAgIGZvcihpID0gMDsgaSA8IGFyZ2M7ICsraSwgKytvZmZzZXQpe1xuICAgICAgICAgICAgdHlwZUlkcy5wdXNoKGdldFR5cGVJZEJ5SWQodmlld1U4W29mZnNldF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgYXJnYzsgKytpKXtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0eXBlSWRzW2ldO1xuICAgICAgICAgICAgaWYodC5nZXR0ZXIpe1xuICAgICAgICAgICAgICB2ID0gdmlld0RWW3QuZ2V0dGVyXShvZmZzZXQsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgIG9mZnNldCArPSB0LnNpemU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgbiA9IHZpZXdEVi5nZXRJbnQzMihvZmZzZXQsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB2ID0gdGV4dERlY29kZXIuZGVjb2RlKHZpZXdVOC5zbGljZShvZmZzZXQsIG9mZnNldCtuKSk7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmMucHVzaCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoY2xlYXIpIHZpZXdVOFswXSA9IDA7XG4gICAgICAgIFxuICAgICAgICBtZXRyaWNzLnMxMW4uZGVzZXJpYWxpemUudGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH07XG5cbiAgICAgIFxuICAgICAgc3RhdGUuczExbi5zZXJpYWxpemUgPSBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICArK21ldHJpY3MuczExbi5zZXJpYWxpemUuY291bnQ7XG4gICAgICAgIGlmKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0eXBlSWRzID0gW107XG4gICAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAxO1xuICAgICAgICAgIHZpZXdVOFswXSA9IGFyZ3MubGVuZ3RoICYgMHhmZiA7XG4gICAgICAgICAgZm9yKDsgaSA8IGFyZ3MubGVuZ3RoOyArK2ksICsrb2Zmc2V0KXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHlwZUlkcy5wdXNoKGdldFR5cGVJZChhcmdzW2ldKSk7XG4gICAgICAgICAgICB2aWV3VThbb2Zmc2V0XSA9IHR5cGVJZHNbaV0uaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcihpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgdCA9IHR5cGVJZHNbaV07XG4gICAgICAgICAgICBpZih0LnNldHRlcil7XG4gICAgICAgICAgICAgIHZpZXdEVlt0LnNldHRlcl0ob2Zmc2V0LCBhcmdzW2ldLCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gdC5zaXplO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGNvbnN0IHMgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYXJnc1tpXSk7XG4gICAgICAgICAgICAgIHZpZXdEVi5zZXRJbnQzMihvZmZzZXQsIHMuYnl0ZUxlbmd0aCwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIHZpZXdVOC5zZXQocywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IHMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHZpZXdVOFswXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbWV0cmljcy5zMTFuLnNlcmlhbGl6ZS50aW1lICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc3RhdGUuczExbjtcbiAgICB9O1xuXG4gICAgXG4gICAgY29uc3QgcmFuZG9tRmlsZW5hbWUgPSBmdW5jdGlvbiBmKGxlbj0xNil7XG4gICAgICBpZighZi5fY2hhcnMpe1xuICAgICAgICBmLl9jaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIitcbiAgICAgICAgICBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIrXG4gICAgICAgICAgXCIwMTIzNDY3ODlcIjtcbiAgICAgICAgZi5fbiA9IGYuX2NoYXJzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciggOyBpIDwgbGVuOyArK2kpe1xuICAgICAgICBjb25zdCBuZHggPSBNYXRoLnJhbmRvbSgpICogKGYuX24gKiA2NCkgJSBmLl9uIHwgMDtcbiAgICAgICAgYVtpXSA9IGYuX2NoYXJzW25keF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYS5qb2luKFwiXCIpO1xuICAgICAgXG4gICAgfTtcblxuICAgIFxuICAgIGNvbnN0IF9fb3BlbkZpbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGNvbnN0IG9wVGltZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG9wVGltZXIub3AgPSB1bmRlZmluZWQ7XG4gICAgb3BUaW1lci5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtVGltZVN0YXJ0ID0gKG9wKT0+e1xuICAgICAgb3BUaW1lci5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgb3BUaW1lci5vcCA9IG9wO1xuICAgICAgKyttZXRyaWNzW29wXS5jb3VudDtcbiAgICB9O1xuICAgIGNvbnN0IG1UaW1lRW5kID0gKCk9PihcbiAgICAgIG1ldHJpY3Nbb3BUaW1lci5vcF0udGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIG9wVGltZXIuc3RhcnRcbiAgICApO1xuXG4gICAgXG4gICAgY29uc3QgaW9TeW5jV3JhcHBlcnMgPSB7XG4gICAgICB4Q2hlY2tSZXNlcnZlZExvY2s6IGZ1bmN0aW9uKHBGaWxlLHBPdXQpe1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZiA9IF9fb3BlbkZpbGVzW3BGaWxlXTtcbiAgICAgICAgd2FzbS5wb2tlKHBPdXQsIGYubG9ja1R5cGUgPyAxIDogMCwgJ2kzMicpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICB4Q2xvc2U6IGZ1bmN0aW9uKHBGaWxlKXtcbiAgICAgICAgbVRpbWVTdGFydCgneENsb3NlJyk7XG4gICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgIGlmKGYpe1xuICAgICAgICAgIGRlbGV0ZSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgICAgcmMgPSBvcFJ1bigneENsb3NlJywgcEZpbGUpO1xuICAgICAgICAgIGlmKGYuc3EzRmlsZSkgZi5zcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeERldmljZUNoYXJhY3RlcmlzdGljczogZnVuY3Rpb24ocEZpbGUpe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICAgIH0sXG4gICAgICB4RmlsZUNvbnRyb2w6IGZ1bmN0aW9uKHBGaWxlLCBvcElkLCBwQXJnKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjYXBpLlNRTElURV9OT1RGT1VORDtcbiAgICAgIH0sXG4gICAgICB4RmlsZVNpemU6IGZ1bmN0aW9uKHBGaWxlLHBTejY0KXtcbiAgICAgICAgbVRpbWVTdGFydCgneEZpbGVTaXplJyk7XG4gICAgICAgIGxldCByYyA9IG9wUnVuKCd4RmlsZVNpemUnLCBwRmlsZSk7XG4gICAgICAgIGlmKDA9PXJjKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3ogPSBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplKClbMF07XG4gICAgICAgICAgICB3YXNtLnBva2UocFN6NjQsIHN6LCAnaTY0Jyk7XG4gICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkIGVycm9yIHJlYWRpbmcgeEZpbGVTaXplKCkgcmVzdWx0OlwiLGUpO1xuICAgICAgICAgICAgcmMgPSBzdGF0ZS5zcTNDb2Rlcy5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4TG9jazogZnVuY3Rpb24ocEZpbGUsbG9ja1R5cGUpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4TG9jaycpO1xuICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICBcbiAgICAgICAgaWYoICFmLmxvY2tUeXBlICkge1xuICAgICAgICAgIHJjID0gb3BSdW4oJ3hMb2NrJywgcEZpbGUsIGxvY2tUeXBlKTtcbiAgICAgICAgICBpZiggMD09PXJjICkgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBmLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhSZWFkOiBmdW5jdGlvbihwRmlsZSxwRGVzdCxuLG9mZnNldDY0KXtcbiAgICAgICAgbVRpbWVTdGFydCgneFJlYWQnKTtcbiAgICAgICAgY29uc3QgZiA9IF9fb3BlbkZpbGVzW3BGaWxlXTtcbiAgICAgICAgbGV0IHJjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJjID0gb3BSdW4oJ3hSZWFkJyxwRmlsZSwgbiwgTnVtYmVyKG9mZnNldDY0KSk7XG4gICAgICAgICAgaWYoMD09PXJjIHx8IGNhcGkuU1FMSVRFX0lPRVJSX1NIT1JUX1JFQUQ9PT1yYyl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHdhc20uaGVhcDh1KCkuc2V0KGYuc2FiVmlldy5zdWJhcnJheSgwLCBuKSwgcERlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIGVycm9yKFwieFJlYWQoXCIsYXJndW1lbnRzLFwiKSBmYWlsZWQ6XCIsZSxmKTtcbiAgICAgICAgICByYyA9IGNhcGkuU1FMSVRFX0lPRVJSX1JFQUQ7XG4gICAgICAgIH1cbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhTeW5jOiBmdW5jdGlvbihwRmlsZSxmbGFncyl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hTeW5jJyk7XG4gICAgICAgICsrbWV0cmljcy54U3luYy5jb3VudDtcbiAgICAgICAgY29uc3QgcmMgPSBvcFJ1bigneFN5bmMnLCBwRmlsZSwgZmxhZ3MpO1xuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeFRydW5jYXRlOiBmdW5jdGlvbihwRmlsZSxzejY0KXtcbiAgICAgICAgbVRpbWVTdGFydCgneFRydW5jYXRlJyk7XG4gICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hUcnVuY2F0ZScsIHBGaWxlLCBOdW1iZXIoc3o2NCkpO1xuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeFVubG9jazogZnVuY3Rpb24ocEZpbGUsbG9ja1R5cGUpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4VW5sb2NrJyk7XG4gICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgIGxldCByYyA9IDA7XG4gICAgICAgIGlmKCBjYXBpLlNRTElURV9MT0NLX05PTkUgPT09IGxvY2tUeXBlXG4gICAgICAgICAgJiYgZi5sb2NrVHlwZSApe1xuICAgICAgICAgIHJjID0gb3BSdW4oJ3hVbmxvY2snLCBwRmlsZSwgbG9ja1R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCAwPT09cmMgKSBmLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4V3JpdGU6IGZ1bmN0aW9uKHBGaWxlLHBTcmMsbixvZmZzZXQ2NCl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hXcml0ZScpO1xuICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICBsZXQgcmM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZi5zYWJWaWV3LnNldCh3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBTcmMsIHBTcmMrbikpO1xuICAgICAgICAgIHJjID0gb3BSdW4oJ3hXcml0ZScsIHBGaWxlLCBuLCBOdW1iZXIob2Zmc2V0NjQpKTtcbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIGVycm9yKFwieFdyaXRlKFwiLGFyZ3VtZW50cyxcIikgZmFpbGVkOlwiLGUsZik7XG4gICAgICAgICAgcmMgPSBjYXBpLlNRTElURV9JT0VSUl9XUklURTtcbiAgICAgICAgfVxuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIGNvbnN0IHZmc1N5bmNXcmFwcGVycyA9IHtcbiAgICAgIHhBY2Nlc3M6IGZ1bmN0aW9uKHBWZnMsek5hbWUsZmxhZ3MscE91dCl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hBY2Nlc3MnKTtcbiAgICAgICAgY29uc3QgcmMgPSBvcFJ1bigneEFjY2VzcycsIHdhc20uY3N0clRvSnMoek5hbWUpKTtcbiAgICAgICAgd2FzbS5wb2tlKCBwT3V0LCAocmMgPyAwIDogMSksICdpMzInICk7XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIHhDdXJyZW50VGltZTogZnVuY3Rpb24ocFZmcyxwT3V0KXtcbiAgICAgICAgXG4gICAgICAgIHdhc20ucG9rZShwT3V0LCAyNDQwNTg3LjUgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkvODY0MDAwMDApLFxuICAgICAgICAgICAgICAgICAgJ2RvdWJsZScpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24ocFZmcyxwT3V0KXtcbiAgICAgICAgd2FzbS5wb2tlKHBPdXQsICgyNDQwNTg3LjUgKiA4NjQwMDAwMCkgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICdpNjQnKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgeERlbGV0ZTogZnVuY3Rpb24ocFZmcywgek5hbWUsIGRvU3luY0Rpcil7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hEZWxldGUnKTtcbiAgICAgICAgY29uc3QgcmMgPSBvcFJ1bigneERlbGV0ZScsIHdhc20uY3N0clRvSnMoek5hbWUpLCBkb1N5bmNEaXIsIGZhbHNlKTtcbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhGdWxsUGF0aG5hbWU6IGZ1bmN0aW9uKHBWZnMsek5hbWUsbk91dCxwT3V0KXtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGkgPSB3YXNtLmNzdHJuY3B5KHBPdXQsIHpOYW1lLCBuT3V0KTtcbiAgICAgICAgcmV0dXJuIGk8bk91dCA/IDAgOiBjYXBpLlNRTElURV9DQU5UT1BFTlxuICAgICAgICA7XG4gICAgICB9LFxuICAgICAgeEdldExhc3RFcnJvcjogZnVuY3Rpb24ocFZmcyxuT3V0LHBPdXQpe1xuICAgICAgICBcbiAgICAgICAgd2FybihcIk9QRlMgeEdldExhc3RFcnJvcigpIGhhcyBub3RoaW5nIHNlbnNpYmxlIHRvIHJldHVybi5cIik7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgeE9wZW46IGZ1bmN0aW9uIGYocFZmcywgek5hbWUsIHBGaWxlLCBmbGFncywgcE91dEZsYWdzKXtcbiAgICAgICAgbVRpbWVTdGFydCgneE9wZW4nKTtcbiAgICAgICAgbGV0IG9wZnNGbGFncyA9IDA7XG4gICAgICAgIGlmKDA9PT16TmFtZSl7XG4gICAgICAgICAgek5hbWUgPSByYW5kb21GaWxlbmFtZSgpO1xuICAgICAgICB9ZWxzZSBpZignbnVtYmVyJz09PXR5cGVvZiB6TmFtZSl7XG4gICAgICAgICAgaWYoY2FwaS5zcWxpdGUzX3VyaV9ib29sZWFuKHpOYW1lLCBcIm9wZnMtdW5sb2NrLWFzYXBcIiwgMCkpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBvcGZzRmxhZ3MgfD0gc3RhdGUub3Bmc0ZsYWdzLk9QRlNfVU5MT0NLX0FTQVA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHpOYW1lID0gd2FzbS5jc3RyVG9Kcyh6TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmaC5maWQgPSBwRmlsZTtcbiAgICAgICAgZmguZmlsZW5hbWUgPSB6TmFtZTtcbiAgICAgICAgZmguc2FiID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKHN0YXRlLmZpbGVCdWZmZXJTaXplKTtcbiAgICAgICAgZmguZmxhZ3MgPSBmbGFncztcbiAgICAgICAgY29uc3QgcmMgPSBvcFJ1bigneE9wZW4nLCBwRmlsZSwgek5hbWUsIGZsYWdzLCBvcGZzRmxhZ3MpO1xuICAgICAgICBpZighcmMpe1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKGZoLnJlYWRPbmx5KXtcbiAgICAgICAgICAgIHdhc20ucG9rZShwT3V0RmxhZ3MsIGNhcGkuU1FMSVRFX09QRU5fUkVBRE9OTFksICdpMzInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX19vcGVuRmlsZXNbcEZpbGVdID0gZmg7XG4gICAgICAgICAgZmguc2FiVmlldyA9IHN0YXRlLnNhYkZpbGVCdWZWaWV3O1xuICAgICAgICAgIGZoLnNxM0ZpbGUgPSBuZXcgc3FsaXRlM19maWxlKHBGaWxlKTtcbiAgICAgICAgICBmaC5zcTNGaWxlLiRwTWV0aG9kcyA9IG9wZnNJb01ldGhvZHMucG9pbnRlcjtcbiAgICAgICAgICBmaC5sb2NrVHlwZSA9IGNhcGkuU1FMSVRFX0xPQ0tfTk9ORTtcbiAgICAgICAgfVxuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmKGRWZnMpe1xuICAgICAgb3Bmc1Zmcy4keFJhbmRvbW5lc3MgPSBkVmZzLiR4UmFuZG9tbmVzcztcbiAgICAgIG9wZnNWZnMuJHhTbGVlcCA9IGRWZnMuJHhTbGVlcDtcbiAgICB9XG4gICAgaWYoIW9wZnNWZnMuJHhSYW5kb21uZXNzKXtcbiAgICAgIFxuICAgICAgdmZzU3luY1dyYXBwZXJzLnhSYW5kb21uZXNzID0gZnVuY3Rpb24ocFZmcywgbk91dCwgcE91dCl7XG4gICAgICAgIGNvbnN0IGhlYXAgPSB3YXNtLmhlYXA4dSgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvcig7IGkgPCBuT3V0OyArK2kpIGhlYXBbcE91dCArIGldID0gKE1hdGgucmFuZG9tKCkqMjU1MDAwKSAmIDB4RkY7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYoIW9wZnNWZnMuJHhTbGVlcCl7XG4gICAgICBcbiAgICAgIHZmc1N5bmNXcmFwcGVycy54U2xlZXAgPSBmdW5jdGlvbihwVmZzLG1zKXtcbiAgICAgICAgQXRvbWljcy53YWl0KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMueFNsZWVwLCAwLCBtcyk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBcbiAgICBvcGZzVXRpbC5nZXRSZXNvbHZlZFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSxzcGxpdEl0KXtcbiAgICAgIGNvbnN0IHAgPSBuZXcgVVJMKGZpbGVuYW1lLCBcImZpbGU6Ly9pcnJlbGV2YW50XCIpLnBhdGhuYW1lO1xuICAgICAgcmV0dXJuIHNwbGl0SXQgPyBwLnNwbGl0KCcvJykuZmlsdGVyKCh2KT0+ISF2KSA6IHA7XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lID0gYXN5bmMgZnVuY3Rpb24gZihhYnNGaWxlbmFtZSwgY3JlYXRlRGlycyA9IGZhbHNlKXtcbiAgICAgIGNvbnN0IHBhdGggPSBvcGZzVXRpbC5nZXRSZXNvbHZlZFBhdGgoYWJzRmlsZW5hbWUsIHRydWUpO1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLnBvcCgpO1xuICAgICAgbGV0IGRoID0gb3Bmc1V0aWwucm9vdERpcmVjdG9yeTtcbiAgICAgIGZvcihjb25zdCBkaXJOYW1lIG9mIHBhdGgpe1xuICAgICAgICBpZihkaXJOYW1lKXtcbiAgICAgICAgICBkaCA9IGF3YWl0IGRoLmdldERpcmVjdG9yeUhhbmRsZShkaXJOYW1lLCB7Y3JlYXRlOiAhIWNyZWF0ZURpcnN9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtkaCwgZmlsZW5hbWVdO1xuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC5ta2RpciA9IGFzeW5jIGZ1bmN0aW9uKGFic0Rpck5hbWUpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoYWJzRGlyTmFtZStcIi9maWxlcGFydFwiLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBvcGZzVXRpbC5lbnRyeUV4aXN0cyA9IGFzeW5jIGZ1bmN0aW9uKGZzRW50cnlOYW1lKXtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtkaCwgZm5dID0gYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoZnNFbnRyeU5hbWUpO1xuICAgICAgICBhd2FpdCBkaC5nZXRGaWxlSGFuZGxlKGZuKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwucmFuZG9tRmlsZW5hbWUgPSByYW5kb21GaWxlbmFtZTtcblxuICAgIFxuICAgIG9wZnNVdGlsLnJlZ2lzdGVyVmZzID0gKGFzRGVmYXVsdD1mYWxzZSk9PntcbiAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM192ZnNfcmVnaXN0ZXIoXG4gICAgICAgIG9wZnNWZnMucG9pbnRlciwgYXNEZWZhdWx0ID8gMSA6IDBcbiAgICAgICk7XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLnRyZWVMaXN0ID0gYXN5bmMgZnVuY3Rpb24oKXtcbiAgICAgIGNvbnN0IGRvRGlyID0gYXN5bmMgZnVuY3Rpb24gY2FsbGVlKGRpckhhbmRsZSx0Z3Qpe1xuICAgICAgICB0Z3QubmFtZSA9IGRpckhhbmRsZS5uYW1lO1xuICAgICAgICB0Z3QuZGlycyA9IFtdO1xuICAgICAgICB0Z3QuZmlsZXMgPSBbXTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBoYW5kbGUgb2YgZGlySGFuZGxlLnZhbHVlcygpKXtcbiAgICAgICAgICBpZignZGlyZWN0b3J5JyA9PT0gaGFuZGxlLmtpbmQpe1xuICAgICAgICAgICAgY29uc3Qgc3ViRGlyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHRndC5kaXJzLnB1c2goc3ViRGlyKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxlZShoYW5kbGUsIHN1YkRpcik7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0Z3QuZmlsZXMucHVzaChoYW5kbGUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgcm9vdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBhd2FpdCBkb0RpcihvcGZzVXRpbC5yb290RGlyZWN0b3J5LCByb290KTtcbiAgICAgIHJldHVybiByb290O1xuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC5ybWZyID0gYXN5bmMgZnVuY3Rpb24oKXtcbiAgICAgIGNvbnN0IGRpciA9IG9wZnNVdGlsLnJvb3REaXJlY3RvcnksIG9wdCA9IHtyZWN1cnNlOiB0cnVlfTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgaGFuZGxlIG9mIGRpci52YWx1ZXMoKSl7XG4gICAgICAgIGRpci5yZW1vdmVFbnRyeShoYW5kbGUubmFtZSwgb3B0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwudW5saW5rID0gYXN5bmMgZnVuY3Rpb24oZnNFbnRyeU5hbWUsIHJlY3Vyc2l2ZSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93T25FcnJvciA9IGZhbHNlKXtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoRGlyLCBmaWxlbmFtZVBhcnRdID1cbiAgICAgICAgICAgICAgYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoZnNFbnRyeU5hbWUsIGZhbHNlKTtcbiAgICAgICAgYXdhaXQgaERpci5yZW1vdmVFbnRyeShmaWxlbmFtZVBhcnQsIHtyZWN1cnNpdmV9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGlmKHRocm93T25FcnJvcil7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5saW5rKFwiLGFyZ3VtZW50c1swXSxcIikgZmFpbGVkOiBcIitlLm1lc3NhZ2Use1xuICAgICAgICAgICAgY2F1c2U6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLnRyYXZlcnNlID0gYXN5bmMgZnVuY3Rpb24ob3B0KXtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHQgPSB7XG4gICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgZGlyZWN0b3J5OiBvcGZzVXRpbC5yb290RGlyZWN0b3J5XG4gICAgICB9O1xuICAgICAgaWYoJ2Z1bmN0aW9uJz09PXR5cGVvZiBvcHQpe1xuICAgICAgICBvcHQgPSB7Y2FsbGJhY2s6b3B0fTtcbiAgICAgIH1cbiAgICAgIG9wdCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdCwgb3B0fHx7fSk7XG4gICAgICBjb25zdCBkb0RpciA9IGFzeW5jIGZ1bmN0aW9uIGNhbGxlZShkaXJIYW5kbGUsIGRlcHRoKXtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBoYW5kbGUgb2YgZGlySGFuZGxlLnZhbHVlcygpKXtcbiAgICAgICAgICBpZihmYWxzZSA9PT0gb3B0LmNhbGxiYWNrKGhhbmRsZSwgZGlySGFuZGxlLCBkZXB0aCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBlbHNlIGlmKG9wdC5yZWN1cnNpdmUgJiYgJ2RpcmVjdG9yeScgPT09IGhhbmRsZS5raW5kKXtcbiAgICAgICAgICAgIGlmKGZhbHNlID09PSBhd2FpdCBjYWxsZWUoaGFuZGxlLCBkZXB0aCArIDEpKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkb0RpcihvcHQuZGlyZWN0b3J5LCAwKTtcbiAgICB9O1xuXG4gICAgXG4gICAgY29uc3QgaW1wb3J0RGJDaHVua2VkID0gYXN5bmMgZnVuY3Rpb24oZmlsZW5hbWUsIGNhbGxiYWNrKXtcbiAgICAgIGNvbnN0IFtoRGlyLCBmbmFtZVBhcnRdID0gYXdhaXQgb3Bmc1V0aWwuZ2V0RGlyRm9yRmlsZW5hbWUoZmlsZW5hbWUsIHRydWUpO1xuICAgICAgY29uc3QgaEZpbGUgPSBhd2FpdCBoRGlyLmdldEZpbGVIYW5kbGUoZm5hbWVQYXJ0LCB7Y3JlYXRlOnRydWV9KTtcbiAgICAgIGxldCBzYWggPSBhd2FpdCBoRmlsZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICBsZXQgbldyb3RlID0gMCwgY2h1bmssIGNoZWNrZWRIZWFkZXIgPSBmYWxzZSwgZXJyID0gZmFsc2U7XG4gICAgICB0cnl7XG4gICAgICAgIHNhaC50cnVuY2F0ZSgwKTtcbiAgICAgICAgd2hpbGUoIHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkgKXtcbiAgICAgICAgICBpZihjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICBpZiggMD09PW5Xcm90ZSAmJiBjaHVuay5ieXRlTGVuZ3RoPj0xNSApe1xuICAgICAgICAgICAgdXRpbC5hZmZpcm1EYkhlYWRlcihjaHVuayk7XG4gICAgICAgICAgICBjaGVja2VkSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FoLndyaXRlKGNodW5rLCB7YXQ6IG5Xcm90ZX0pO1xuICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmKCBuV3JvdGUgPCA1MTIgfHwgMCE9PW5Xcm90ZSAlIDUxMiApe1xuICAgICAgICAgIHRvc3MoXCJJbnB1dCBzaXplXCIsbldyb3RlLFwiaXMgbm90IGNvcnJlY3QgZm9yIGFuIFNRTGl0ZSBkYXRhYmFzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoICFjaGVja2VkSGVhZGVyICl7XG4gICAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuICAgICAgICAgIHNhaC5yZWFkKCBoZWFkZXIsIHthdDogMH0gKTtcbiAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKCBoZWFkZXIgKTtcbiAgICAgICAgfVxuICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsMV0pLCB7YXQ6IDE4fSk7XG4gICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgICBzYWggPSB1bmRlZmluZWQ7XG4gICAgICAgIGF3YWl0IGhEaXIucmVtb3ZlRW50cnkoIGZuYW1lUGFydCApLmNhdGNoKCgpPT57fSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9ZmluYWxseSB7XG4gICAgICAgIGlmKCBzYWggKSBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwuaW1wb3J0RGIgPSBhc3luYyBmdW5jdGlvbihmaWxlbmFtZSwgYnl0ZXMpe1xuICAgICAgaWYoIGJ5dGVzIGluc3RhbmNlb2YgRnVuY3Rpb24gKXtcbiAgICAgICAgcmV0dXJuIGltcG9ydERiQ2h1bmtlZChmaWxlbmFtZSwgYnl0ZXMpO1xuICAgICAgfVxuICAgICAgaWYoYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICB1dGlsLmFmZmlybUlzRGIoYnl0ZXMpO1xuICAgICAgY29uc3QgbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICBjb25zdCBbaERpciwgZm5hbWVQYXJ0XSA9IGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKGZpbGVuYW1lLCB0cnVlKTtcbiAgICAgIGxldCBzYWgsIGVyciwgbldyb3RlID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge2NyZWF0ZTp0cnVlfSk7XG4gICAgICAgIHNhaCA9IGF3YWl0IGhGaWxlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgc2FoLnRydW5jYXRlKDApO1xuICAgICAgICBuV3JvdGUgPSBzYWgud3JpdGUoYnl0ZXMsIHthdDogMH0pO1xuICAgICAgICBpZihuV3JvdGUgIT0gbil7XG4gICAgICAgICAgdG9zcyhcIkV4cGVjdGVkIHRvIHdyaXRlIFwiK24rXCIgYnl0ZXMgYnV0IHdyb3RlIFwiK25Xcm90ZStcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLDFdKSwge2F0OiAxOH0pIDtcbiAgICAgICAgcmV0dXJuIG5Xcm90ZTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgaWYoIHNhaCApeyBhd2FpdCBzYWguY2xvc2UoKTsgc2FoID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIGF3YWl0IGhEaXIucmVtb3ZlRW50cnkoIGZuYW1lUGFydCApLmNhdGNoKCgpPT57fSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgaWYoIHNhaCApIGF3YWl0IHNhaC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZihzcWxpdGUzLm9vMSl7XG4gICAgICBjb25zdCBPcGZzRGIgPSBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgY29uc3Qgb3B0ID0gc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLm5vcm1hbGl6ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgIG9wdC52ZnMgPSBvcGZzVmZzLiR6TmFtZTtcbiAgICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICAgIH07XG4gICAgICBPcGZzRGIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzcWxpdGUzLm9vMS5EQi5wcm90b3R5cGUpO1xuICAgICAgc3FsaXRlMy5vbzEuT3Bmc0RiID0gT3Bmc0RiO1xuICAgICAgT3Bmc0RiLmltcG9ydERiID0gb3Bmc1V0aWwuaW1wb3J0RGI7XG4gICAgICBzcWxpdGUzLm9vMS5EQi5kYkN0b3JIZWxwZXIuc2V0VmZzUG9zdE9wZW5TcWwoXG4gICAgICAgIG9wZnNWZnMucG9pbnRlcixcbiAgICAgICAgZnVuY3Rpb24ob28xRGIsIHNxbGl0ZTMpe1xuICAgICAgICAgIFxuICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2J1c3lfdGltZW91dChvbzFEYiwgMTAwMDApO1xuICAgICAgICAgIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2V4ZWMob28xRGIsIFtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXCJwcmFnbWEgam91cm5hbF9tb2RlPURFTEVURTtcIixcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXCJwcmFnbWEgY2FjaGVfc2l6ZT0tMTYzODQ7XCJcbiAgICAgICAgICBdLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzYW5pdHlDaGVjayA9IGZ1bmN0aW9uKCl7XG4gICAgICBjb25zdCBzY29wZSA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICBjb25zdCBzcTNGaWxlID0gbmV3IHNxbGl0ZTNfZmlsZSgpO1xuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCBmaWQgPSBzcTNGaWxlLnBvaW50ZXI7XG4gICAgICAgIGNvbnN0IG9wZW5GbGFncyA9IGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFXG4gICAgICAgICAgICAgIHwgY2FwaS5TUUxJVEVfT1BFTl9SRUFEV1JJVEVcbiAgICAgICAgXG4gICAgICAgICAgICAgIHwgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCO1xuICAgICAgICBjb25zdCBwT3V0ID0gd2FzbS5zY29wZWRBbGxvYyg4KTtcbiAgICAgICAgY29uc3QgZGJGaWxlID0gXCIvc2FuaXR5L2NoZWNrL2ZpbGVcIityYW5kb21GaWxlbmFtZSg4KTtcbiAgICAgICAgY29uc3QgekRiRmlsZSA9IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKGRiRmlsZSk7XG4gICAgICAgIGxldCByYztcbiAgICAgICAgc3RhdGUuczExbi5zZXJpYWxpemUoXCJUaGlzIGlzIMOkIHN0cmluZy5cIik7XG4gICAgICAgIHJjID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpO1xuICAgICAgICBsb2coXCJkZXNlcmlhbGl6ZSgpIHNheXM6XCIscmMpO1xuICAgICAgICBpZihcIlRoaXMgaXMgw6Qgc3RyaW5nLlwiIT09cmNbMF0pIHRvc3MoXCJTdHJpbmcgZDEzbiBlcnJvci5cIik7XG4gICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgIHJjID0gd2FzbS5wZWVrKHBPdXQsJ2kzMicpO1xuICAgICAgICBsb2coXCJ4QWNjZXNzKFwiLGRiRmlsZSxcIikgZXhpc3RzID89XCIscmMpO1xuICAgICAgICByYyA9IHZmc1N5bmNXcmFwcGVycy54T3BlbihvcGZzVmZzLnBvaW50ZXIsIHpEYkZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZCwgb3BlbkZsYWdzLCBwT3V0KTtcbiAgICAgICAgbG9nKFwib3BlbiByYyA9XCIscmMsXCJzdGF0ZS5zYWJPUFZpZXdbeE9wZW5dID1cIixcbiAgICAgICAgICAgIHN0YXRlLnNhYk9QVmlld1tzdGF0ZS5vcElkcy54T3Blbl0pO1xuICAgICAgICBpZigwIT09cmMpe1xuICAgICAgICAgIGVycm9yKFwib3BlbiBmYWlsZWQgd2l0aCBjb2RlXCIscmMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2ZnNTeW5jV3JhcHBlcnMueEFjY2VzcyhvcGZzVmZzLnBvaW50ZXIsIHpEYkZpbGUsIDAsIHBPdXQpO1xuICAgICAgICByYyA9IHdhc20ucGVlayhwT3V0LCdpMzInKTtcbiAgICAgICAgaWYoIXJjKSB0b3NzKFwieEFjY2VzcygpIGZhaWxlZCB0byBkZXRlY3QgZmlsZS5cIik7XG4gICAgICAgIHJjID0gaW9TeW5jV3JhcHBlcnMueFN5bmMoc3EzRmlsZS5wb2ludGVyLCAwKTtcbiAgICAgICAgaWYocmMpIHRvc3MoJ3N5bmMgZmFpbGVkIHcvIHJjJyxyYyk7XG4gICAgICAgIHJjID0gaW9TeW5jV3JhcHBlcnMueFRydW5jYXRlKHNxM0ZpbGUucG9pbnRlciwgMTAyNCk7XG4gICAgICAgIGlmKHJjKSB0b3NzKCd0cnVuY2F0ZSBmYWlsZWQgdy8gcmMnLHJjKTtcbiAgICAgICAgd2FzbS5wb2tlKHBPdXQsMCwnaTY0Jyk7XG4gICAgICAgIHJjID0gaW9TeW5jV3JhcHBlcnMueEZpbGVTaXplKHNxM0ZpbGUucG9pbnRlciwgcE91dCk7XG4gICAgICAgIGlmKHJjKSB0b3NzKCd4RmlsZVNpemUgZmFpbGVkIHcvIHJjJyxyYyk7XG4gICAgICAgIGxvZyhcInhGaWxlU2l6ZSBzYXlzOlwiLHdhc20ucGVlayhwT3V0LCAnaTY0JykpO1xuICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhXcml0ZShzcTNGaWxlLnBvaW50ZXIsIHpEYkZpbGUsIDEwLCAxKTtcbiAgICAgICAgaWYocmMpIHRvc3MoXCJ4V3JpdGUoKSBmYWlsZWQhXCIpO1xuICAgICAgICBjb25zdCByZWFkQnVmID0gd2FzbS5zY29wZWRBbGxvYygxNik7XG4gICAgICAgIHJjID0gaW9TeW5jV3JhcHBlcnMueFJlYWQoc3EzRmlsZS5wb2ludGVyLCByZWFkQnVmLCA2LCAyKTtcbiAgICAgICAgd2FzbS5wb2tlKHJlYWRCdWYrNiwwKTtcbiAgICAgICAgbGV0IGpSZWFkID0gd2FzbS5jc3RyVG9KcyhyZWFkQnVmKTtcbiAgICAgICAgbG9nKFwieFJlYWQoKSBnb3Q6XCIsalJlYWQpO1xuICAgICAgICBpZihcInNhbml0eVwiIT09alJlYWQpIHRvc3MoXCJVbmV4cGVjdGVkIHhSZWFkKCkgdmFsdWUuXCIpO1xuICAgICAgICBpZih2ZnNTeW5jV3JhcHBlcnMueFNsZWVwKXtcbiAgICAgICAgICBsb2coXCJ4U2xlZXAoKWluZyBiZWZvcmUgY2xvc2UoKWluZy4uLlwiKTtcbiAgICAgICAgICB2ZnNTeW5jV3JhcHBlcnMueFNsZWVwKG9wZnNWZnMucG9pbnRlciwyMDAwKTtcbiAgICAgICAgICBsb2coXCJ3YWtpbmcgdXAgZnJvbSB4U2xlZXAoKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhDbG9zZShmaWQpO1xuICAgICAgICBsb2coXCJ4Q2xvc2UgcmMgPVwiLHJjLFwic2FiT1BWaWV3ID1cIixzdGF0ZS5zYWJPUFZpZXcpO1xuICAgICAgICBsb2coXCJEZWxldGluZyBmaWxlOlwiLGRiRmlsZSk7XG4gICAgICAgIHZmc1N5bmNXcmFwcGVycy54RGVsZXRlKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMHgxMjM0KTtcbiAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhBY2Nlc3Mob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAwLCBwT3V0KTtcbiAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwnaTMyJyk7XG4gICAgICAgIGlmKHJjKSB0b3NzKFwiRXhwZWN0aW5nIDAgZnJvbSB4QWNjZXNzKFwiLGRiRmlsZSxcIikgYWZ0ZXIgeERlbGV0ZSgpLlwiKTtcbiAgICAgICAgd2FybihcIkVuZCBvZiBPUEZTIHNhbml0eSBjaGVja3MuXCIpO1xuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIHNxM0ZpbGUuZGlzcG9zZSgpO1xuICAgICAgICB3YXNtLnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVy5vbm1lc3NhZ2UgPSBmdW5jdGlvbih7ZGF0YX0pe1xuICAgICAgXG4gICAgICBzd2l0Y2goZGF0YS50eXBlKXtcbiAgICAgICAgICBjYXNlICdvcGZzLXVuYXZhaWxhYmxlJzpcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcHJvbWlzZVJlamVjdChuZXcgRXJyb3IoZGF0YS5wYXlsb2FkLmpvaW4oJyAnKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3Bmcy1hc3luYy1sb2FkZWQnOlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBXLnBvc3RNZXNzYWdlKHt0eXBlOiAnb3Bmcy1hc3luYy1pbml0JyxhcmdzOiBzdGF0ZX0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3Bmcy1hc3luYy1pbml0ZWQnOiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRydWU9PT1wcm9taXNlV2FzUmVqZWN0ZWQpe1xuICAgICAgICAgICAgICBicmVhayA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICAgICAgICAgICAgICBpbzoge3N0cnVjdDogb3Bmc0lvTWV0aG9kcywgbWV0aG9kczogaW9TeW5jV3JhcHBlcnN9LFxuICAgICAgICAgICAgICAgIHZmczoge3N0cnVjdDogb3Bmc1ZmcywgbWV0aG9kczogdmZzU3luY1dyYXBwZXJzfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc3RhdGUuc2FiT1BWaWV3ID0gbmV3IEludDMyQXJyYXkoc3RhdGUuc2FiT1ApO1xuICAgICAgICAgICAgICBzdGF0ZS5zYWJGaWxlQnVmVmlldyA9IG5ldyBVaW50OEFycmF5KHN0YXRlLnNhYklPLCAwLCBzdGF0ZS5maWxlQnVmZmVyU2l6ZSk7XG4gICAgICAgICAgICAgIHN0YXRlLnNhYlMxMW5WaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUuc2FiSU8sIHN0YXRlLnNhYlMxMW5PZmZzZXQsIHN0YXRlLnNhYlMxMW5TaXplKTtcbiAgICAgICAgICAgICAgaW5pdFMxMW4oKTtcbiAgICAgICAgICAgICAgaWYob3B0aW9ucy5zYW5pdHlDaGVja3Mpe1xuICAgICAgICAgICAgICAgIHdhcm4oXCJSdW5uaW5nIHNhbml0eSBjaGVja3MgYmVjYXVzZSBvZiBvcGZzLXNhbml0eS1jaGVjayBVUkwgYXJnLi4uXCIpO1xuICAgICAgICAgICAgICAgIHNhbml0eUNoZWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYodGhpc1RocmVhZEhhc09QRlMoKSl7XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCkudGhlbigoZCk9PntcbiAgICAgICAgICAgICAgICAgIFcub25lcnJvciA9IFcuX29yaWdpbmFsT25FcnJvcjtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBXLl9vcmlnaW5hbE9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICBzcWxpdGUzLm9wZnMgPSBvcGZzVXRpbDtcbiAgICAgICAgICAgICAgICAgIG9wZnNVdGlsLnJvb3REaXJlY3RvcnkgPSBkO1xuICAgICAgICAgICAgICAgICAgbG9nKFwiRW5kIG9mIE9QRlMgc3FsaXRlM192ZnMgc2V0dXAuXCIsIG9wZnNWZnMpO1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChwcm9taXNlUmVqZWN0KTtcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgICBlcnJvcihlKTtcbiAgICAgICAgICAgICAgcHJvbWlzZVJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtZXNzYWdlIGZyb20gdGhlIE9QRlMgYXN5bmMgd29ya2VyOiBcIiArXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgIHByb21pc2VSZWplY3QobmV3IEVycm9yKGVyck1zZykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gdGhlUHJvbWlzZTtcbn07XG5pbnN0YWxsT3Bmc1Zmcy5kZWZhdWx0UHJveHlVcmkgPVxuICBcInNxbGl0ZTMtb3Bmcy1hc3luYy1wcm94eS5qc1wiO1xuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVyc0FzeW5jLnB1c2goYXN5bmMgKHNxbGl0ZTMpPT57XG4gIHRyeXtcbiAgICBsZXQgcHJveHlKcyA9IGluc3RhbGxPcGZzVmZzLmRlZmF1bHRQcm94eVVyaTtcbiAgICBpZihzcWxpdGUzLnNjcmlwdEluZm8uc3FsaXRlM0Rpcil7XG4gICAgICBpbnN0YWxsT3Bmc1Zmcy5kZWZhdWx0UHJveHlVcmkgPVxuICAgICAgICBzcWxpdGUzLnNjcmlwdEluZm8uc3FsaXRlM0RpciArIHByb3h5SnM7XG4gICAgICBcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbGxPcGZzVmZzKCkuY2F0Y2goKGUpPT57XG4gICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFwiSWdub3JpbmcgaW5hYmlsaXR5IHRvIGluc3RhbGwgT1BGUyBzcWxpdGUzX3ZmczpcIixlLm1lc3NhZ2UpO1xuICAgIH0pO1xuICB9Y2F0Y2goZSl7XG4gICAgc3FsaXRlMy5jb25maWcuZXJyb3IoXCJpbnN0YWxsT3Bmc1ZmcygpIGV4Y2VwdGlvbjpcIixlKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbn0pO1xufSk7XG5cblxuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oc3FsaXRlMyl7XG4gICd1c2Ugc3RyaWN0JztcbiAgY29uc3QgdG9zcyA9IHNxbGl0ZTMudXRpbC50b3NzO1xuICBjb25zdCB0b3NzMyA9IHNxbGl0ZTMudXRpbC50b3NzMztcbiAgY29uc3QgaW5pdFByb21pc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaTtcbiAgY29uc3QgdXRpbCA9IHNxbGl0ZTMudXRpbDtcbiAgY29uc3Qgd2FzbSA9IHNxbGl0ZTMud2FzbTtcbiAgXG4gIGNvbnN0IFNFQ1RPUl9TSVpFID0gNDA5NjtcbiAgY29uc3QgSEVBREVSX01BWF9QQVRIX1NJWkUgPSA1MTI7XG4gIGNvbnN0IEhFQURFUl9GTEFHU19TSVpFID0gNDtcbiAgY29uc3QgSEVBREVSX0RJR0VTVF9TSVpFID0gODtcbiAgY29uc3QgSEVBREVSX0NPUlBVU19TSVpFID0gSEVBREVSX01BWF9QQVRIX1NJWkUgKyBIRUFERVJfRkxBR1NfU0laRTtcbiAgY29uc3QgSEVBREVSX09GRlNFVF9GTEFHUyA9IEhFQURFUl9NQVhfUEFUSF9TSVpFO1xuICBjb25zdCBIRUFERVJfT0ZGU0VUX0RJR0VTVCA9IEhFQURFUl9DT1JQVVNfU0laRTtcbiAgY29uc3QgSEVBREVSX09GRlNFVF9EQVRBID0gU0VDVE9SX1NJWkU7XG4gIFxuICBjb25zdCBQRVJTSVNURU5UX0ZJTEVfVFlQRVMgPVxuICAgICAgICBjYXBpLlNRTElURV9PUEVOX01BSU5fREIgfFxuICAgICAgICBjYXBpLlNRTElURV9PUEVOX01BSU5fSk9VUk5BTCB8XG4gICAgICAgIGNhcGkuU1FMSVRFX09QRU5fU1VQRVJfSk9VUk5BTCB8XG4gICAgICAgIGNhcGkuU1FMSVRFX09QRU5fV0FMIDtcblxuICBcbiAgY29uc3QgT1BBUVVFX0RJUl9OQU1FID0gXCIub3BhcXVlXCI7XG5cbiAgXG4gIGNvbnN0IGdldFJhbmRvbU5hbWUgPSAoKT0+TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICBjb25zdCBvcHRpb25EZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgbmFtZTogJ29wZnMtc2FocG9vbCcsXG4gICAgZGlyZWN0b3J5OiB1bmRlZmluZWQgLFxuICAgIGluaXRpYWxDYXBhY2l0eTogNixcbiAgICBjbGVhck9uSW5pdDogZmFsc2UsXG4gICAgXG4gICAgdmVyYm9zaXR5OiAyXG4gIH0pO1xuXG4gIFxuICBjb25zdCBsb2dnZXJzID0gW1xuICAgIHNxbGl0ZTMuY29uZmlnLmVycm9yLFxuICAgIHNxbGl0ZTMuY29uZmlnLndhcm4sXG4gICAgc3FsaXRlMy5jb25maWcubG9nXG4gIF07XG4gIGNvbnN0IGxvZyA9IHNxbGl0ZTMuY29uZmlnLmxvZztcbiAgY29uc3Qgd2FybiA9IHNxbGl0ZTMuY29uZmlnLndhcm47XG4gIGNvbnN0IGVycm9yID0gc3FsaXRlMy5jb25maWcuZXJyb3I7XG5cbiAgXG4gIGNvbnN0IF9fbWFwVmZzVG9Qb29sID0gbmV3IE1hcCgpO1xuICBjb25zdCBnZXRQb29sRm9yVmZzID0gKHBWZnMpPT5fX21hcFZmc1RvUG9vbC5nZXQocFZmcyk7XG4gIGNvbnN0IHNldFBvb2xGb3JWZnMgPSAocFZmcyxwb29sKT0+e1xuICAgIGlmKHBvb2wpIF9fbWFwVmZzVG9Qb29sLnNldChwVmZzLCBwb29sKTtcbiAgICBlbHNlIF9fbWFwVmZzVG9Qb29sLmRlbGV0ZShwVmZzKTtcbiAgfTtcbiAgXG4gIGNvbnN0IF9fbWFwU3FsaXRlM0ZpbGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGdldFBvb2xGb3JQRmlsZSA9IChwRmlsZSk9Pl9fbWFwU3FsaXRlM0ZpbGUuZ2V0KHBGaWxlKTtcbiAgY29uc3Qgc2V0UG9vbEZvclBGaWxlID0gKHBGaWxlLHBvb2wpPT57XG4gICAgaWYocG9vbCkgX19tYXBTcWxpdGUzRmlsZS5zZXQocEZpbGUsIHBvb2wpO1xuICAgIGVsc2UgX19tYXBTcWxpdGUzRmlsZS5kZWxldGUocEZpbGUpO1xuICB9O1xuXG4gIFxuICBjb25zdCBpb01ldGhvZHMgPSB7XG4gICAgeENoZWNrUmVzZXJ2ZWRMb2NrOiBmdW5jdGlvbihwRmlsZSxwT3V0KXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coJ3hDaGVja1Jlc2VydmVkTG9jaycpO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgd2FzbS5wb2tlMzIocE91dCwgMSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhDbG9zZTogZnVuY3Rpb24ocEZpbGUpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBpZihmaWxlKSB7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICBwb29sLmxvZyhgeENsb3NlICR7ZmlsZS5wYXRofWApO1xuICAgICAgICAgIHBvb2wubWFwUzNGaWxlVG9PRmlsZShwRmlsZSwgZmFsc2UpO1xuICAgICAgICAgIGZpbGUuc2FoLmZsdXNoKCk7XG4gICAgICAgICAgaWYoZmlsZS5mbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fREVMRVRFT05DTE9TRSl7XG4gICAgICAgICAgICBwb29sLmRlbGV0ZVBhdGgoZmlsZS5wYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeERldmljZUNoYXJhY3RlcmlzdGljczogZnVuY3Rpb24ocEZpbGUpe1xuICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPQ0FQX1VOREVMRVRBQkxFX1dIRU5fT1BFTjtcbiAgICB9LFxuICAgIHhGaWxlQ29udHJvbDogZnVuY3Rpb24ocEZpbGUsIG9wSWQsIHBBcmcpe1xuICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX05PVEZPVU5EO1xuICAgIH0sXG4gICAgeEZpbGVTaXplOiBmdW5jdGlvbihwRmlsZSxwU3o2NCl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKGB4RmlsZVNpemVgKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIGNvbnN0IHNpemUgPSBmaWxlLnNhaC5nZXRTaXplKCkgLSBIRUFERVJfT0ZGU0VUX0RBVEE7XG4gICAgICBcbiAgICAgIHdhc20ucG9rZTY0KHBTejY0LCBCaWdJbnQoc2l6ZSkpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4TG9jazogZnVuY3Rpb24ocEZpbGUsbG9ja1R5cGUpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZyhgeExvY2sgJHtsb2NrVHlwZX1gKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIGZpbGUubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeFJlYWQ6IGZ1bmN0aW9uKHBGaWxlLHBEZXN0LG4sb2Zmc2V0NjQpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZyhgeFJlYWQgJHtmaWxlLnBhdGh9ICR7bn0gQCAke29mZnNldDY0fWApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgblJlYWQgPSBmaWxlLnNhaC5yZWFkKFxuICAgICAgICAgIHdhc20uaGVhcDh1KCkuc3ViYXJyYXkocERlc3QsIHBEZXN0K24pLFxuICAgICAgICAgIHthdDogSEVBREVSX09GRlNFVF9EQVRBICsgTnVtYmVyKG9mZnNldDY0KX1cbiAgICAgICAgKTtcbiAgICAgICAgaWYoblJlYWQgPCBuKXtcbiAgICAgICAgICB3YXNtLmhlYXA4dSgpLmZpbGwoMCwgcERlc3QgKyBuUmVhZCwgcERlc3QgKyBuKTtcbiAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlJfU0hPUlRfUkVBRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeFNlY3RvclNpemU6IGZ1bmN0aW9uKHBGaWxlKXtcbiAgICAgIHJldHVybiBTRUNUT1JfU0laRTtcbiAgICB9LFxuICAgIHhTeW5jOiBmdW5jdGlvbihwRmlsZSxmbGFncyl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKGB4U3luYyAke2ZsYWdzfWApO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgXG4gICAgICB0cnl7XG4gICAgICAgIGZpbGUuc2FoLmZsdXNoKCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICB9XG4gICAgfSxcbiAgICB4VHJ1bmNhdGU6IGZ1bmN0aW9uKHBGaWxlLHN6NjQpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZyhgeFRydW5jYXRlICR7c3o2NH1gKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIFxuICAgICAgdHJ5e1xuICAgICAgICBmaWxlLnNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEgKyBOdW1iZXIoc3o2NCkpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeFVubG9jazogZnVuY3Rpb24ocEZpbGUsbG9ja1R5cGUpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZygneFVubG9jaycpO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgZmlsZS5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4V3JpdGU6IGZ1bmN0aW9uKHBGaWxlLHBTcmMsbixvZmZzZXQ2NCl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKGB4V3JpdGUgJHtmaWxlLnBhdGh9ICR7bn0gJHtvZmZzZXQ2NH1gKTtcbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgbkJ5dGVzID0gZmlsZS5zYWgud3JpdGUoXG4gICAgICAgICAgd2FzbS5oZWFwOHUoKS5zdWJhcnJheShwU3JjLCBwU3JjK24pLFxuICAgICAgICAgIHsgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIE51bWJlcihvZmZzZXQ2NCkgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbj09PW5CeXRlcyA/IDAgOiB0b3NzKFwiVW5rbm93biB3cml0ZSgpIGZhaWx1cmUuXCIpO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICByZXR1cm4gcG9vbC5zdG9yZUVycihlLCBjYXBpLlNRTElURV9JT0VSUik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG9wZnNJb01ldGhvZHMgPSBuZXcgY2FwaS5zcWxpdGUzX2lvX21ldGhvZHMoKTtcbiAgb3Bmc0lvTWV0aG9kcy4kaVZlcnNpb24gPSAxO1xuICBzcWxpdGUzLnZmcy5pbnN0YWxsVmZzKHtcbiAgICBpbzoge3N0cnVjdDogb3Bmc0lvTWV0aG9kcywgbWV0aG9kczogaW9NZXRob2RzfVxuICB9KTtcblxuICBcbiAgY29uc3QgdmZzTWV0aG9kcyA9IHtcbiAgICB4QWNjZXNzOiBmdW5jdGlvbihwVmZzLHpOYW1lLGZsYWdzLHBPdXQpe1xuICAgICAgXG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBvb2wuZ2V0UGF0aCh6TmFtZSk7XG4gICAgICAgIHdhc20ucG9rZTMyKHBPdXQsIHBvb2wuaGFzRmlsZW5hbWUobmFtZSkgPyAxIDogMCk7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIFxuICAgICAgICB3YXNtLnBva2UzMihwT3V0LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeEN1cnJlbnRUaW1lOiBmdW5jdGlvbihwVmZzLHBPdXQpe1xuICAgICAgd2FzbS5wb2tlKHBPdXQsIDI0NDA1ODcuNSArIChuZXcgRGF0ZSgpLmdldFRpbWUoKS84NjQwMDAwMCksXG4gICAgICAgICAgICAgICAgJ2RvdWJsZScpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4Q3VycmVudFRpbWVJbnQ2NDogZnVuY3Rpb24ocFZmcyxwT3V0KXtcbiAgICAgIHdhc20ucG9rZShwT3V0LCAoMjQ0MDU4Ny41ICogODY0MDAwMDApICsgbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgJ2k2NCcpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4RGVsZXRlOiBmdW5jdGlvbihwVmZzLCB6TmFtZSwgZG9TeW5jRGlyKXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgcG9vbC5sb2coYHhEZWxldGUgJHt3YXNtLmNzdHJUb0pzKHpOYW1lKX1gKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIHRyeXtcbiAgICAgICAgcG9vbC5kZWxldGVQYXRoKHBvb2wuZ2V0UGF0aCh6TmFtZSkpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcG9vbC5zdG9yZUVycihlKTtcbiAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPRVJSX0RFTEVURTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHhGdWxsUGF0aG5hbWU6IGZ1bmN0aW9uKHBWZnMsek5hbWUsbk91dCxwT3V0KXtcbiAgICAgIFxuICAgICAgXG4gICAgICBjb25zdCBpID0gd2FzbS5jc3RybmNweShwT3V0LCB6TmFtZSwgbk91dCk7XG4gICAgICByZXR1cm4gaTxuT3V0ID8gMCA6IGNhcGkuU1FMSVRFX0NBTlRPUEVOO1xuICAgIH0sXG4gICAgeEdldExhc3RFcnJvcjogZnVuY3Rpb24ocFZmcyxuT3V0LHBPdXQpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICBjb25zdCBlID0gcG9vbC5wb3BFcnIoKTtcbiAgICAgIHBvb2wubG9nKGB4R2V0TGFzdEVycm9yICR7bk91dH0gZSA9YCxlKTtcbiAgICAgIGlmKGUpe1xuICAgICAgICBjb25zdCBzY29wZSA9IHdhc20uc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICBjb25zdCBbY01zZywgbl0gPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhlLm1lc3NhZ2UsIHRydWUpO1xuICAgICAgICAgIHdhc20uY3N0cm5jcHkocE91dCwgY01zZywgbk91dCk7XG4gICAgICAgICAgaWYobiA+IG5PdXQpIHdhc20ucG9rZTgocE91dCArIG5PdXQgLSAxLCAwKTtcbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9OT01FTTtcbiAgICAgICAgfWZpbmFsbHl7XG4gICAgICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlID8gKGUuc3FsaXRlM1JjIHx8IGNhcGkuU1FMSVRFX0lPRVJSKSA6IDA7XG4gICAgfSxcbiAgICBcbiAgICB4T3BlbjogZnVuY3Rpb24gZihwVmZzLCB6TmFtZSwgcEZpbGUsIGZsYWdzLCBwT3V0RmxhZ3Mpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICB0cnl7XG4gICAgICAgIHBvb2wubG9nKGB4T3BlbiAke3dhc20uY3N0clRvSnMoek5hbWUpfSAke2ZsYWdzfWApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGF0aCA9ICh6TmFtZSAmJiB3YXNtLnBlZWs4KHpOYW1lKSlcbiAgICAgICAgICAgICAgPyBwb29sLmdldFBhdGgoek5hbWUpXG4gICAgICAgICAgICAgIDogZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICBsZXQgc2FoID0gcG9vbC5nZXRTQUhGb3JQYXRoKHBhdGgpO1xuICAgICAgICBpZighc2FoICYmIChmbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFKSkge1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKHBvb2wuZ2V0RmlsZUNvdW50KCkgPCBwb29sLmdldENhcGFjaXR5KCkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2FoID0gcG9vbC5uZXh0QXZhaWxhYmxlU0FIKCk7XG4gICAgICAgICAgICBwb29sLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgcGF0aCwgZmxhZ3MpO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0b3NzKCdTQUggcG9vbCBpcyBmdWxsLiBDYW5ub3QgY3JlYXRlIGZpbGUnLHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZighc2FoKXtcbiAgICAgICAgICB0b3NzKCdmaWxlIG5vdCBmb3VuZDonLHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgY29uc3QgZmlsZSA9IHtwYXRoLCBmbGFncywgc2FofTtcbiAgICAgICAgcG9vbC5tYXBTM0ZpbGVUb09GaWxlKHBGaWxlLCBmaWxlKTtcbiAgICAgICAgZmlsZS5sb2NrVHlwZSA9IGNhcGkuU1FMSVRFX0xPQ0tfTk9ORTtcbiAgICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBjYXBpLnNxbGl0ZTNfZmlsZShwRmlsZSk7XG4gICAgICAgIHNxM0ZpbGUuJHBNZXRob2RzID0gb3Bmc0lvTWV0aG9kcy5wb2ludGVyO1xuICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgd2FzbS5wb2tlMzIocE91dEZsYWdzLCBmbGFncyk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBwb29sLnN0b3JlRXJyKGUpO1xuICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfQ0FOVE9QRU47XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFxuICBjb25zdCBjcmVhdGVPcGZzVmZzID0gZnVuY3Rpb24odmZzTmFtZSl7XG4gICAgaWYoIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX3Zmc19maW5kKHZmc05hbWUpKXtcbiAgICAgIHRvc3MzKFwiVkZTIG5hbWUgaXMgYWxyZWFkeSByZWdpc3RlcmVkOlwiLCB2ZnNOYW1lKTtcbiAgICB9XG4gICAgY29uc3Qgb3Bmc1ZmcyA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKCk7XG4gICAgXG4gICAgY29uc3QgcERWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQobnVsbCk7XG4gICAgY29uc3QgZFZmcyA9IHBEVmZzXG4gICAgICAgICAgPyBuZXcgY2FwaS5zcWxpdGUzX3ZmcyhwRFZmcylcbiAgICAgICAgICA6IG51bGwgO1xuICAgIG9wZnNWZnMuJGlWZXJzaW9uID0gMjtcbiAgICBvcGZzVmZzLiRzek9zRmlsZSA9IGNhcGkuc3FsaXRlM19maWxlLnN0cnVjdEluZm8uc2l6ZW9mO1xuICAgIG9wZnNWZnMuJG14UGF0aG5hbWUgPSBIRUFERVJfTUFYX1BBVEhfU0laRTtcbiAgICBvcGZzVmZzLmFkZE9uRGlzcG9zZShcbiAgICAgIG9wZnNWZnMuJHpOYW1lID0gd2FzbS5hbGxvY0NTdHJpbmcodmZzTmFtZSksXG4gICAgICAoKT0+c2V0UG9vbEZvclZmcyhvcGZzVmZzLnBvaW50ZXIsIDApXG4gICAgKTtcblxuICAgIGlmKGRWZnMpe1xuICAgICAgXG4gICAgICBvcGZzVmZzLiR4UmFuZG9tbmVzcyA9IGRWZnMuJHhSYW5kb21uZXNzO1xuICAgICAgb3Bmc1Zmcy4keFNsZWVwID0gZFZmcy4keFNsZWVwO1xuICAgICAgZFZmcy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmKCFvcGZzVmZzLiR4UmFuZG9tbmVzcyAmJiAhdmZzTWV0aG9kcy54UmFuZG9tbmVzcyl7XG4gICAgICBcbiAgICAgIHZmc01ldGhvZHMueFJhbmRvbW5lc3MgPSBmdW5jdGlvbihwVmZzLCBuT3V0LCBwT3V0KXtcbiAgICAgICAgY29uc3QgaGVhcCA9IHdhc20uaGVhcDh1KCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yKDsgaSA8IG5PdXQ7ICsraSkgaGVhcFtwT3V0ICsgaV0gPSAoTWF0aC5yYW5kb20oKSoyNTUwMDApICYgMHhGRjtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZighb3Bmc1Zmcy4keFNsZWVwICYmICF2ZnNNZXRob2RzLnhTbGVlcCl7XG4gICAgICB2ZnNNZXRob2RzLnhTbGVlcCA9IChwVmZzLG1zKT0+MDtcbiAgICB9XG4gICAgc3FsaXRlMy52ZnMuaW5zdGFsbFZmcyh7XG4gICAgICB2ZnM6IHtzdHJ1Y3Q6IG9wZnNWZnMsIG1ldGhvZHM6IHZmc01ldGhvZHN9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9wZnNWZnM7XG4gIH07XG5cbiAgXG4gIGNsYXNzIE9wZnNTQUhQb29sIHtcbiAgICBcbiAgICB2ZnNEaXI7XG4gICAgXG4gICAgI2RoVmZzUm9vdDtcbiAgICBcbiAgICAjZGhPcGFxdWU7XG4gICAgXG4gICAgI2RoVmZzUGFyZW50O1xuICAgIFxuICAgICNtYXBTQUhUb05hbWUgPSBuZXcgTWFwKCk7XG4gICAgXG4gICAgI21hcEZpbGVuYW1lVG9TQUggPSBuZXcgTWFwKCk7XG4gICAgXG4gICAgI2F2YWlsYWJsZVNBSCA9IG5ldyBTZXQoKTtcbiAgICBcbiAgICAjbWFwUzNGaWxlVG9PRmlsZV8gPSBuZXcgTWFwKCk7XG5cbiAgICBcbiAgICBcblxuICAgIFxuICAgICNhcEJvZHkgPSBuZXcgVWludDhBcnJheShIRUFERVJfQ09SUFVTX1NJWkUpO1xuICAgIFxuICAgICNkdkJvZHk7XG5cbiAgICBcbiAgICAjY1ZmcztcblxuICAgIFxuICAgICN2ZXJib3NpdHk7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSl7XG4gICAgICB0aGlzLiN2ZXJib3NpdHkgPSBvcHRpb25zLnZlcmJvc2l0eSA/PyBvcHRpb25EZWZhdWx0cy52ZXJib3NpdHk7XG4gICAgICB0aGlzLnZmc05hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9uRGVmYXVsdHMubmFtZTtcbiAgICAgIHRoaXMuI2NWZnMgPSBjcmVhdGVPcGZzVmZzKHRoaXMudmZzTmFtZSk7XG4gICAgICBzZXRQb29sRm9yVmZzKHRoaXMuI2NWZnMucG9pbnRlciwgdGhpcyk7XG4gICAgICB0aGlzLnZmc0RpciA9IG9wdGlvbnMuZGlyZWN0b3J5IHx8IChcIi5cIit0aGlzLnZmc05hbWUpO1xuICAgICAgdGhpcy4jZHZCb2R5ID1cbiAgICAgICAgbmV3IERhdGFWaWV3KHRoaXMuI2FwQm9keS5idWZmZXIsIHRoaXMuI2FwQm9keS5ieXRlT2Zmc2V0KTtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IHRoaXNcbiAgICAgICAgLnJlc2V0KCEhKG9wdGlvbnMuY2xlYXJPbkluaXQgPz8gb3B0aW9uRGVmYXVsdHMuY2xlYXJPbkluaXQpKVxuICAgICAgICAudGhlbigoKT0+e1xuICAgICAgICAgIGlmKHRoaXMuJGVycm9yKSB0aHJvdyB0aGlzLiRlcnJvcjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDYXBhY2l0eSgpXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICA6IHRoaXMuYWRkQ2FwYWNpdHkob3B0aW9ucy5pbml0aWFsQ2FwYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBvcHRpb25EZWZhdWx0cy5pbml0aWFsQ2FwYWNpdHkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAjbG9nSW1wbChsZXZlbCwuLi5hcmdzKXtcbiAgICAgIGlmKHRoaXMuI3ZlcmJvc2l0eT5sZXZlbCkgbG9nZ2Vyc1tsZXZlbF0odGhpcy52ZnNOYW1lK1wiOlwiLC4uLmFyZ3MpO1xuICAgIH07XG4gICAgbG9nKC4uLmFyZ3Mpe3RoaXMuI2xvZ0ltcGwoMiwgLi4uYXJncyl9O1xuICAgIHdhcm4oLi4uYXJncyl7dGhpcy4jbG9nSW1wbCgxLCAuLi5hcmdzKX07XG4gICAgZXJyb3IoLi4uYXJncyl7dGhpcy4jbG9nSW1wbCgwLCAuLi5hcmdzKX07XG5cbiAgICBnZXRWZnMoKXtyZXR1cm4gdGhpcy4jY1Zmc31cblxuICAgIFxuICAgIGdldENhcGFjaXR5KCl7cmV0dXJuIHRoaXMuI21hcFNBSFRvTmFtZS5zaXplfVxuXG4gICAgXG4gICAgZ2V0RmlsZUNvdW50KCl7cmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2l6ZX1cblxuICAgIFxuICAgIGdldEZpbGVOYW1lcygpe1xuICAgICAgY29uc3QgcmMgPSBbXTtcbiAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmtleXMoKTtcbiAgICAgIGZvcihjb25zdCBuIG9mIGl0ZXIpIHJjLnB1c2gobik7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICAgIFxuICAgIGFzeW5jIGFkZENhcGFjaXR5KG4pe1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG47ICsraSl7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRSYW5kb21OYW1lKCk7XG4gICAgICAgIGNvbnN0IGggPSBhd2FpdCB0aGlzLiNkaE9wYXF1ZS5nZXRGaWxlSGFuZGxlKG5hbWUsIHtjcmVhdGU6dHJ1ZX0pO1xuICAgICAgICBjb25zdCBhaCA9IGF3YWl0IGguY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSgpO1xuICAgICAgICB0aGlzLiNtYXBTQUhUb05hbWUuc2V0KGFoLG5hbWUpO1xuICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKGFoLCAnJywgMCk7XG4gICAgICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FwYWNpdHkoKTtcbiAgICB9XG5cbiAgICBcbiAgICBhc3luYyByZWR1Y2VDYXBhY2l0eShuKXtcbiAgICAgIGxldCBuUm0gPSAwO1xuICAgICAgZm9yKGNvbnN0IGFoIG9mIEFycmF5LmZyb20odGhpcy4jYXZhaWxhYmxlU0FIKSl7XG4gICAgICAgIGlmKG5SbSA9PT0gbiB8fCB0aGlzLmdldEZpbGVDb3VudCgpID09PSB0aGlzLmdldENhcGFjaXR5KCkpe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLiNtYXBTQUhUb05hbWUuZ2V0KGFoKTtcbiAgICAgICAgXG4gICAgICAgIGFoLmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuI2RoT3BhcXVlLnJlbW92ZUVudHJ5KG5hbWUpO1xuICAgICAgICB0aGlzLiNtYXBTQUhUb05hbWUuZGVsZXRlKGFoKTtcbiAgICAgICAgdGhpcy4jYXZhaWxhYmxlU0FILmRlbGV0ZShhaCk7XG4gICAgICAgICsrblJtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5SbTtcbiAgICB9XG5cbiAgICBcbiAgICByZWxlYXNlQWNjZXNzSGFuZGxlcygpe1xuICAgICAgZm9yKGNvbnN0IGFoIG9mIHRoaXMuI21hcFNBSFRvTmFtZS5rZXlzKCkpIGFoLmNsb3NlKCk7XG4gICAgICB0aGlzLiNtYXBTQUhUb05hbWUuY2xlYXIoKTtcbiAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguY2xlYXIoKTtcbiAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5jbGVhcigpO1xuICAgIH1cblxuICAgIFxuICAgIGFzeW5jIGFjcXVpcmVBY2Nlc3NIYW5kbGVzKGNsZWFyRmlsZXMpe1xuICAgICAgY29uc3QgZmlsZXMgPSBbXTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgW25hbWUsaF0gb2YgdGhpcy4jZGhPcGFxdWUpe1xuICAgICAgICBpZignZmlsZSc9PT1oLmtpbmQpe1xuICAgICAgICAgIGZpbGVzLnB1c2goW25hbWUsaF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmlsZXMubWFwKGFzeW5jKFtuYW1lLGhdKT0+e1xuICAgICAgICB0cnl7XG4gICAgICAgICAgY29uc3QgYWggPSBhd2FpdCBoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKVxuICAgICAgICAgIHRoaXMuI21hcFNBSFRvTmFtZS5zZXQoYWgsIG5hbWUpO1xuICAgICAgICAgIGlmKGNsZWFyRmlsZXMpe1xuICAgICAgICAgICAgYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoYWgsICcnLCAwKTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldEFzc29jaWF0ZWRQYXRoKGFoKTtcbiAgICAgICAgICAgIGlmKHBhdGgpe1xuICAgICAgICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILnNldChwYXRoLCBhaCk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdGhpcy4jYXZhaWxhYmxlU0FILmFkZChhaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgdGhpcy5zdG9yZUVycihlKTtcbiAgICAgICAgICB0aGlzLnJlbGVhc2VBY2Nlc3NIYW5kbGVzKCk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIFxuICAgIGdldEFzc29jaWF0ZWRQYXRoKHNhaCl7XG4gICAgICBzYWgucmVhZCh0aGlzLiNhcEJvZHksIHthdDogMH0pO1xuICAgICAgXG4gICAgICBcbiAgICAgIGNvbnN0IGZsYWdzID0gdGhpcy4jZHZCb2R5LmdldFVpbnQzMihIRUFERVJfT0ZGU0VUX0ZMQUdTKTtcbiAgICAgIGlmKHRoaXMuI2FwQm9keVswXSAmJlxuICAgICAgICAgKChmbGFncyAmIGNhcGkuU1FMSVRFX09QRU5fREVMRVRFT05DTE9TRSkgfHxcbiAgICAgICAgICAoZmxhZ3MgJiBQRVJTSVNURU5UX0ZJTEVfVFlQRVMpPT09MCkpe1xuICAgICAgICB3YXJuKGBSZW1vdmluZyBmaWxlIHdpdGggdW5leHBlY3RlZCBmbGFncyAke2ZsYWdzLnRvU3RyaW5nKDE2KX1gLFxuICAgICAgICAgICAgIHRoaXMuI2FwQm9keSk7XG4gICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsZURpZ2VzdCA9IG5ldyBVaW50MzJBcnJheShIRUFERVJfRElHRVNUX1NJWkUgLyA0KTtcbiAgICAgIHNhaC5yZWFkKGZpbGVEaWdlc3QsIHthdDogSEVBREVSX09GRlNFVF9ESUdFU1R9KTtcbiAgICAgIGNvbnN0IGNvbXBEaWdlc3QgPSB0aGlzLmNvbXB1dGVEaWdlc3QodGhpcy4jYXBCb2R5KTtcbiAgICAgIGlmKGZpbGVEaWdlc3QuZXZlcnkoKHYsaSkgPT4gdj09PWNvbXBEaWdlc3RbaV0pKXtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhdGhCeXRlcyA9IHRoaXMuI2FwQm9keS5maW5kSW5kZXgoKHYpPT4wPT09dik7XG4gICAgICAgIGlmKDA9PT1wYXRoQnl0ZXMpe1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIHNhaC50cnVuY2F0ZShIRUFERVJfT0ZGU0VUX0RBVEEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoQnl0ZXNcbiAgICAgICAgICA/IHRleHREZWNvZGVyLmRlY29kZSh0aGlzLiNhcEJvZHkuc3ViYXJyYXkoMCxwYXRoQnl0ZXMpKVxuICAgICAgICAgIDogJyc7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgXG4gICAgICAgIHdhcm4oJ0Rpc2Fzc29jaWF0aW5nIGZpbGUgd2l0aCBiYWQgZGlnZXN0LicpO1xuICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgXG4gICAgc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBwYXRoLCBmbGFncyl7XG4gICAgICBjb25zdCBlbmMgPSB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHBhdGgsIHRoaXMuI2FwQm9keSk7XG4gICAgICBpZihIRUFERVJfTUFYX1BBVEhfU0laRSA8PSBlbmMud3JpdHRlbiArIDEpe1xuICAgICAgICB0b3NzKFwiUGF0aCB0b28gbG9uZzpcIixwYXRoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2FwQm9keS5maWxsKDAsIGVuYy53cml0dGVuLCBIRUFERVJfTUFYX1BBVEhfU0laRSk7XG4gICAgICB0aGlzLiNkdkJvZHkuc2V0VWludDMyKEhFQURFUl9PRkZTRVRfRkxBR1MsIGZsYWdzKTtcblxuICAgICAgY29uc3QgZGlnZXN0ID0gdGhpcy5jb21wdXRlRGlnZXN0KHRoaXMuI2FwQm9keSk7XG4gICAgICBzYWgud3JpdGUodGhpcy4jYXBCb2R5LCB7YXQ6IDB9KTtcbiAgICAgIHNhaC53cml0ZShkaWdlc3QsIHthdDogSEVBREVSX09GRlNFVF9ESUdFU1R9KTtcbiAgICAgIHNhaC5mbHVzaCgpO1xuXG4gICAgICBpZihwYXRoKXtcbiAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5zZXQocGF0aCwgc2FoKTtcbiAgICAgICAgdGhpcy4jYXZhaWxhYmxlU0FILmRlbGV0ZShzYWgpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIFxuICAgICAgICBzYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBKTtcbiAgICAgICAgdGhpcy4jYXZhaWxhYmxlU0FILmFkZChzYWgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFxuICAgIGNvbXB1dGVEaWdlc3QoYnl0ZUFycmF5KXtcbiAgICAgIGxldCBoMSA9IDB4ZGVhZGJlZWY7XG4gICAgICBsZXQgaDIgPSAweDQxYzZjZTU3O1xuICAgICAgZm9yKGNvbnN0IHYgb2YgYnl0ZUFycmF5KXtcbiAgICAgICAgaDEgPSAzMSAqIGgxICsgKHYgKiAzMDcpO1xuICAgICAgICBoMiA9IDMxICogaDIgKyAodiAqIDMwNyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KFtoMT4+PjAsIGgyPj4+MF0pO1xuICAgIH1cblxuICAgIFxuICAgIGFzeW5jIHJlc2V0KGNsZWFyRmlsZXMpe1xuICAgICAgYXdhaXQgdGhpcy5pc1JlYWR5O1xuICAgICAgbGV0IGggPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICAgIGxldCBwcmV2LCBwcmV2TmFtZTtcbiAgICAgIGZvcihjb25zdCBkIG9mIHRoaXMudmZzRGlyLnNwbGl0KCcvJykpe1xuICAgICAgICBpZihkKXtcbiAgICAgICAgICBwcmV2ID0gaDtcbiAgICAgICAgICBoID0gYXdhaXQgaC5nZXREaXJlY3RvcnlIYW5kbGUoZCx7Y3JlYXRlOnRydWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jZGhWZnNSb290ID0gaDtcbiAgICAgIHRoaXMuI2RoVmZzUGFyZW50ID0gcHJldjtcbiAgICAgIHRoaXMuI2RoT3BhcXVlID0gYXdhaXQgdGhpcy4jZGhWZnNSb290LmdldERpcmVjdG9yeUhhbmRsZShcbiAgICAgICAgT1BBUVVFX0RJUl9OQU1FLHtjcmVhdGU6dHJ1ZX1cbiAgICAgICk7XG4gICAgICB0aGlzLnJlbGVhc2VBY2Nlc3NIYW5kbGVzKCk7XG4gICAgICByZXR1cm4gdGhpcy5hY3F1aXJlQWNjZXNzSGFuZGxlcyhjbGVhckZpbGVzKTtcbiAgICB9XG5cbiAgICBcbiAgICBnZXRQYXRoKGFyZykge1xuICAgICAgaWYod2FzbS5pc1B0cihhcmcpKSBhcmcgPSB3YXNtLmNzdHJUb0pzKGFyZyk7XG4gICAgICByZXR1cm4gKChhcmcgaW5zdGFuY2VvZiBVUkwpXG4gICAgICAgICAgICAgID8gYXJnXG4gICAgICAgICAgICAgIDogbmV3IFVSTChhcmcsICdmaWxlOi8vbG9jYWxob3N0LycpKS5wYXRobmFtZTtcbiAgICB9XG5cbiAgICBcbiAgICBkZWxldGVQYXRoKHBhdGgpIHtcbiAgICAgIGNvbnN0IHNhaCA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KHBhdGgpO1xuICAgICAgaWYoc2FoKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmRlbGV0ZShwYXRoKTtcbiAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXNhaDtcbiAgICB9XG5cbiAgICBcbiAgICBzdG9yZUVycihlLGNvZGUpe1xuICAgICAgaWYoZSl7XG4gICAgICAgIGUuc3FsaXRlM1JjID0gY29kZSB8fCBjYXBpLlNRTElURV9JT0VSUjtcbiAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuJGVycm9yID0gZTtcbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBcbiAgICBwb3BFcnIoKXtcbiAgICAgIGNvbnN0IHJjID0gdGhpcy4kZXJyb3I7XG4gICAgICB0aGlzLiRlcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByYztcbiAgICB9XG5cbiAgICBcbiAgICBuZXh0QXZhaWxhYmxlU0FIKCl7XG4gICAgICBjb25zdCBbcmNdID0gdGhpcy4jYXZhaWxhYmxlU0FILmtleXMoKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9XG5cbiAgICBcbiAgICBnZXRPRmlsZUZvclMzRmlsZShwRmlsZSl7XG4gICAgICByZXR1cm4gdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uZ2V0KHBGaWxlKTtcbiAgICB9XG4gICAgXG4gICAgbWFwUzNGaWxlVG9PRmlsZShwRmlsZSxmaWxlKXtcbiAgICAgIGlmKGZpbGUpe1xuICAgICAgICB0aGlzLiNtYXBTM0ZpbGVUb09GaWxlXy5zZXQocEZpbGUsIGZpbGUpO1xuICAgICAgICBzZXRQb29sRm9yUEZpbGUocEZpbGUsIHRoaXMpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuI21hcFMzRmlsZVRvT0ZpbGVfLmRlbGV0ZShwRmlsZSk7XG4gICAgICAgIHNldFBvb2xGb3JQRmlsZShwRmlsZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFxuICAgIGhhc0ZpbGVuYW1lKG5hbWUpe1xuICAgICAgcmV0dXJuIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguaGFzKG5hbWUpXG4gICAgfVxuXG4gICAgXG4gICAgZ2V0U0FIRm9yUGF0aChwYXRoKXtcbiAgICAgIHJldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChwYXRoKTtcbiAgICB9XG5cbiAgICBcbiAgICBhc3luYyByZW1vdmVWZnMoKXtcbiAgICAgIGlmKCF0aGlzLiNjVmZzLnBvaW50ZXIgfHwgIXRoaXMuI2RoT3BhcXVlKSByZXR1cm4gZmFsc2U7XG4gICAgICBjYXBpLnNxbGl0ZTNfdmZzX3VucmVnaXN0ZXIodGhpcy4jY1Zmcy5wb2ludGVyKTtcbiAgICAgIHRoaXMuI2NWZnMuZGlzcG9zZSgpO1xuICAgICAgdHJ5e1xuICAgICAgICB0aGlzLnJlbGVhc2VBY2Nlc3NIYW5kbGVzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuI2RoVmZzUm9vdC5yZW1vdmVFbnRyeShPUEFRVUVfRElSX05BTUUsIHtyZWN1cnNpdmU6IHRydWV9KTtcbiAgICAgICAgdGhpcy4jZGhPcGFxdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGF3YWl0IHRoaXMuI2RoVmZzUGFyZW50LnJlbW92ZUVudHJ5KFxuICAgICAgICAgIHRoaXMuI2RoVmZzUm9vdC5uYW1lLCB7cmVjdXJzaXZlOiB0cnVlfVxuICAgICAgICApO1xuICAgICAgICB0aGlzLiNkaFZmc1Jvb3QgPSB0aGlzLiNkaFZmc1BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IodGhpcy52ZnNOYW1lLFwicmVtb3ZlVmZzKCkgZmFpbGVkOlwiLGUpO1xuICAgICAgICBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgXG4gICAgZXhwb3J0RmlsZShuYW1lKXtcbiAgICAgIGNvbnN0IHNhaCA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KG5hbWUpIHx8IHRvc3MoXCJGaWxlIG5vdCBmb3VuZDpcIixuYW1lKTtcbiAgICAgIGNvbnN0IG4gPSBzYWguZ2V0U2l6ZSgpIC0gSEVBREVSX09GRlNFVF9EQVRBO1xuICAgICAgY29uc3QgYiA9IG5ldyBVaW50OEFycmF5KG4+MCA/IG4gOiAwKTtcbiAgICAgIGlmKG4+MCl7XG4gICAgICAgIGNvbnN0IG5SZWFkID0gc2FoLnJlYWQoYiwge2F0OiBIRUFERVJfT0ZGU0VUX0RBVEF9KTtcbiAgICAgICAgaWYoblJlYWQgIT0gbil7XG4gICAgICAgICAgdG9zcyhcIkV4cGVjdGVkIHRvIHJlYWQgXCIrbitcIiBieXRlcyBidXQgcmVhZCBcIituUmVhZCtcIi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiO1xuICAgIH1cblxuICAgIFxuICAgIGFzeW5jIGltcG9ydERiQ2h1bmtlZChuYW1lLCBjYWxsYmFjayl7XG4gICAgICBjb25zdCBzYWggPSB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKVxuICAgICAgICAgICAgfHwgdGhpcy5uZXh0QXZhaWxhYmxlU0FIKClcbiAgICAgICAgICAgIHx8IHRvc3MoXCJObyBhdmFpbGFibGUgaGFuZGxlcyB0byBpbXBvcnQgdG8uXCIpO1xuICAgICAgc2FoLnRydW5jYXRlKDApO1xuICAgICAgbGV0IG5Xcm90ZSA9IDAsIGNodW5rLCBjaGVja2VkSGVhZGVyID0gZmFsc2UsIGVyciA9IGZhbHNlO1xuICAgICAgdHJ5e1xuICAgICAgICB3aGlsZSggdW5kZWZpbmVkICE9PSAoY2h1bmsgPSBhd2FpdCBjYWxsYmFjaygpKSApe1xuICAgICAgICAgIGlmKGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICAgIGlmKCAwPT09bldyb3RlICYmIGNodW5rLmJ5dGVMZW5ndGg+PTE1ICl7XG4gICAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKGNodW5rKTtcbiAgICAgICAgICAgIGNoZWNrZWRIZWFkZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzYWgud3JpdGUoY2h1bmssIHthdDogIEhFQURFUl9PRkZTRVRfREFUQSArIG5Xcm90ZX0pO1xuICAgICAgICAgIG5Xcm90ZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmKCBuV3JvdGUgPCA1MTIgfHwgMCE9PW5Xcm90ZSAlIDUxMiApe1xuICAgICAgICAgIHRvc3MoXCJJbnB1dCBzaXplXCIsbldyb3RlLFwiaXMgbm90IGNvcnJlY3QgZm9yIGFuIFNRTGl0ZSBkYXRhYmFzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoICFjaGVja2VkSGVhZGVyICl7XG4gICAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMjApO1xuICAgICAgICAgIHNhaC5yZWFkKCBoZWFkZXIsIHthdDogMH0gKTtcbiAgICAgICAgICB1dGlsLmFmZmlybURiSGVhZGVyKCBoZWFkZXIgKTtcbiAgICAgICAgfVxuICAgICAgICBzYWgud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzEsMV0pLCB7XG4gICAgICAgICAgYXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIDE4XG4gICAgICAgIH0pO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsIG5hbWUsIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQik7XG4gICAgICByZXR1cm4gbldyb3RlO1xuICAgIH1cblxuICAgIFxuICAgIGltcG9ydERiKG5hbWUsIGJ5dGVzKXtcbiAgICAgIGlmKCBieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICBlbHNlIGlmKCBieXRlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uICkgcmV0dXJuIHRoaXMuaW1wb3J0RGJDaHVua2VkKG5hbWUsIGJ5dGVzKTtcbiAgICAgIGNvbnN0IHNhaCA9IHRoaXMuI21hcEZpbGVuYW1lVG9TQUguZ2V0KG5hbWUpXG4gICAgICAgICAgICB8fCB0aGlzLm5leHRBdmFpbGFibGVTQUgoKVxuICAgICAgICAgICAgfHwgdG9zcyhcIk5vIGF2YWlsYWJsZSBoYW5kbGVzIHRvIGltcG9ydCB0by5cIik7XG4gICAgICBjb25zdCBuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgIGlmKG48NTEyIHx8IG4lNTEyIT0wKXtcbiAgICAgICAgdG9zcyhcIkJ5dGUgYXJyYXkgc2l6ZSBpcyBpbnZhbGlkIGZvciBhbiBTUUxpdGUgZGIuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVyID0gXCJTUUxpdGUgZm9ybWF0IDNcIjtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBoZWFkZXIubGVuZ3RoOyArK2kpe1xuICAgICAgICBpZiggaGVhZGVyLmNoYXJDb2RlQXQoaSkgIT09IGJ5dGVzW2ldICl7XG4gICAgICAgICAgdG9zcyhcIklucHV0IGRvZXMgbm90IGNvbnRhaW4gYW4gU1FMaXRlIGRhdGFiYXNlIGhlYWRlci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5Xcm90ZSA9IHNhaC53cml0ZShieXRlcywge2F0OiBIRUFERVJfT0ZGU0VUX0RBVEF9KTtcbiAgICAgIGlmKG5Xcm90ZSAhPSBuKXtcbiAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgdG9zcyhcIkV4cGVjdGVkIHRvIHdyaXRlIFwiK24rXCIgYnl0ZXMgYnV0IHdyb3RlIFwiK25Xcm90ZStcIi5cIik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLDFdKSwge2F0OiBIRUFERVJfT0ZGU0VUX0RBVEErMTh9XG4gICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsIG5hbWUsIGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbldyb3RlO1xuICAgIH1cblxuICB9O1xuXG5cbiAgXG4gIGNsYXNzIE9wZnNTQUhQb29sVXRpbCB7XG4gICAgXG4gICAgI3A7XG5cbiAgICBjb25zdHJ1Y3RvcihzYWhQb29sKXtcbiAgICAgIHRoaXMuI3AgPSBzYWhQb29sO1xuICAgICAgdGhpcy52ZnNOYW1lID0gc2FoUG9vbC52ZnNOYW1lO1xuICAgIH1cblxuICAgIGFzeW5jIGFkZENhcGFjaXR5KG4peyByZXR1cm4gdGhpcy4jcC5hZGRDYXBhY2l0eShuKSB9XG5cbiAgICBhc3luYyByZWR1Y2VDYXBhY2l0eShuKXsgcmV0dXJuIHRoaXMuI3AucmVkdWNlQ2FwYWNpdHkobikgfVxuXG4gICAgZ2V0Q2FwYWNpdHkoKXsgcmV0dXJuIHRoaXMuI3AuZ2V0Q2FwYWNpdHkodGhpcy4jcCkgfVxuXG4gICAgZ2V0RmlsZUNvdW50KCl7IHJldHVybiB0aGlzLiNwLmdldEZpbGVDb3VudCgpIH1cbiAgICBnZXRGaWxlTmFtZXMoKXsgcmV0dXJuIHRoaXMuI3AuZ2V0RmlsZU5hbWVzKCkgfVxuXG4gICAgYXN5bmMgcmVzZXJ2ZU1pbmltdW1DYXBhY2l0eShtaW4pe1xuICAgICAgY29uc3QgYyA9IHRoaXMuI3AuZ2V0Q2FwYWNpdHkoKTtcbiAgICAgIHJldHVybiAoYyA8IG1pbikgPyB0aGlzLiNwLmFkZENhcGFjaXR5KG1pbiAtIGMpIDogYztcbiAgICB9XG5cbiAgICBleHBvcnRGaWxlKG5hbWUpeyByZXR1cm4gdGhpcy4jcC5leHBvcnRGaWxlKG5hbWUpIH1cblxuICAgIGltcG9ydERiKG5hbWUsIGJ5dGVzKXsgcmV0dXJuIHRoaXMuI3AuaW1wb3J0RGIobmFtZSxieXRlcykgfVxuXG4gICAgYXN5bmMgd2lwZUZpbGVzKCl7IHJldHVybiB0aGlzLiNwLnJlc2V0KHRydWUpIH1cblxuICAgIHVubGluayhmaWxlbmFtZSl7IHJldHVybiB0aGlzLiNwLmRlbGV0ZVBhdGgoZmlsZW5hbWUpIH1cblxuICAgIGFzeW5jIHJlbW92ZVZmcygpeyByZXR1cm4gdGhpcy4jcC5yZW1vdmVWZnMoKSB9XG5cbiAgfTtcblxuICBcbiAgY29uc3QgYXBpVmVyc2lvbkNoZWNrID0gYXN5bmMgKCk9PntcbiAgICBjb25zdCBkaCA9IGF3YWl0IG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpO1xuICAgIGNvbnN0IGZuID0gJy5vcGZzLXNhaHBvb2wtc3luYy1jaGVjay0nK2dldFJhbmRvbU5hbWUoKTtcbiAgICBjb25zdCBmaCA9IGF3YWl0IGRoLmdldEZpbGVIYW5kbGUoZm4sIHsgY3JlYXRlOiB0cnVlIH0pO1xuICAgIGNvbnN0IGFoID0gYXdhaXQgZmguY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSgpO1xuICAgIGNvbnN0IGNsb3NlID0gYWguY2xvc2UoKTtcbiAgICBhd2FpdCBjbG9zZTtcbiAgICBhd2FpdCBkaC5yZW1vdmVFbnRyeShmbik7XG4gICAgaWYoY2xvc2U/LnRoZW4pe1xuICAgICAgdG9zcyhcIlRoZSBsb2NhbCBPUEZTIEFQSSBpcyB0b28gb2xkIGZvciBvcGZzLXNhaHBvb2w6XCIsXG4gICAgICAgICAgIFwiaXQgaGFzIGFuIGFzeW5jIEZpbGVTeXN0ZW1TeW5jQWNjZXNzSGFuZGxlLmNsb3NlKCkgbWV0aG9kLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgXG4gIGxldCBpbnN0YW5jZUNvdW50ZXIgPSAwO1xuXG4gIFxuICBzcWxpdGUzLmluc3RhbGxPcGZzU0FIUG9vbFZmcyA9IGFzeW5jIGZ1bmN0aW9uKG9wdGlvbnM9T2JqZWN0LmNyZWF0ZShudWxsKSl7XG4gICAgY29uc3QgdmZzTmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25EZWZhdWx0cy5uYW1lO1xuICAgIGlmKDAgJiYgMj09PSsraW5zdGFuY2VDb3VudGVyKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkp1c3QgdGVzdGluZyByZWplY3Rpb24uXCIpO1xuICAgIH1cbiAgICBpZihpbml0UHJvbWlzZXNbdmZzTmFtZV0pe1xuICAgICAgXG4gICAgICByZXR1cm4gaW5pdFByb21pc2VzW3Zmc05hbWVdO1xuICAgIH1cbiAgICBpZighZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSB8fFxuICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlIHx8XG4gICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUucHJvdG90eXBlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgfHxcbiAgICAgICAhbmF2aWdhdG9yPy5zdG9yYWdlPy5nZXREaXJlY3Rvcnkpe1xuICAgICAgcmV0dXJuIChpbml0UHJvbWlzZXNbdmZzTmFtZV0gPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIE9QRlMgQVBJcy5cIikpKTtcbiAgICB9XG5cbiAgICBcbiAgICByZXR1cm4gaW5pdFByb21pc2VzW3Zmc05hbWVdID0gYXBpVmVyc2lvbkNoZWNrKCkudGhlbihhc3luYyBmdW5jdGlvbigpe1xuICAgICAgaWYob3B0aW9ucy4kdGVzdFRocm93SW5Jbml0KXtcbiAgICAgICAgdGhyb3cgb3B0aW9ucy4kdGVzdFRocm93SW5Jbml0O1xuICAgICAgfVxuICAgICAgY29uc3QgdGhlUG9vbCA9IG5ldyBPcGZzU0FIUG9vbChvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGVQb29sLmlzUmVhZHkudGhlbihhc3luYygpPT57XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwb29sVXRpbCA9IG5ldyBPcGZzU0FIUG9vbFV0aWwodGhlUG9vbCk7XG4gICAgICAgIGlmKHNxbGl0ZTMub28xKXtcbiAgICAgICAgICBjb25zdCBvbzEgPSBzcWxpdGUzLm9vMTtcbiAgICAgICAgICBjb25zdCB0aGVWZnMgPSB0aGVQb29sLmdldFZmcygpO1xuICAgICAgICAgIGNvbnN0IE9wZnNTQUhQb29sRGIgPSBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IG9vMS5EQi5kYkN0b3JIZWxwZXIubm9ybWFsaXplQXJncyguLi5hcmdzKTtcbiAgICAgICAgICAgIG9wdC52ZnMgPSB0aGVWZnMuJHpOYW1lO1xuICAgICAgICAgICAgb28xLkRCLmRiQ3RvckhlbHBlci5jYWxsKHRoaXMsIG9wdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBPcGZzU0FIUG9vbERiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUob28xLkRCLnByb3RvdHlwZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgcG9vbFV0aWwuT3Bmc1NBSFBvb2xEYiA9IE9wZnNTQUhQb29sRGI7XG4gICAgICAgICAgb28xLkRCLmRiQ3RvckhlbHBlci5zZXRWZnNQb3N0T3BlblNxbChcbiAgICAgICAgICAgIHRoZVZmcy5wb2ludGVyLFxuICAgICAgICAgICAgZnVuY3Rpb24ob28xRGIsIHNxbGl0ZTMpe1xuICAgICAgICAgICAgICBzcWxpdGUzLmNhcGkuc3FsaXRlM19leGVjKG9vMURiLCBbXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXCJwcmFnbWEgam91cm5hbF9tb2RlPURFTEVURTtcIixcbiAgICAgICAgICAgICAgICBcInByYWdtYSBjYWNoZV9zaXplPS0xNjM4NDtcIlxuICAgICAgICAgICAgICBdLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoZVBvb2wubG9nKFwiVkZTIGluaXRpYWxpemVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHBvb2xVdGlsO1xuICAgICAgfSkuY2F0Y2goYXN5bmMgKGUpPT57XG4gICAgICAgIGF3YWl0IHRoZVBvb2wucmVtb3ZlVmZzKCkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgXG4gICAgICByZXR1cm4gaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfTtcbn0pO1xuXG5cblxuJ3VzZSBzdHJpY3QnO1xuaWYoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBNb2R1bGUpeyBcbiAgXG4gIGNvbnN0IFNBQkMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgIGV4cG9ydHM6ICgndW5kZWZpbmVkJz09PXR5cGVvZiB3YXNtRXhwb3J0cylcbiAgICAgICAgPyBNb2R1bGVbJ2FzbSddXG4gICAgICAgIDogd2FzbUV4cG9ydHMgICxcbiAgICAgIG1lbW9yeTogTW9kdWxlLndhc21NZW1vcnkgXG4gICAgfSxcbiAgICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgfHwge31cbiAgKTtcblxuICBcbiAgXG4gIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUNvbmZpZyA9IFNBQkM7XG4gIGxldCBzcWxpdGUzO1xuICB0cnl7XG4gICAgc3FsaXRlMyA9IGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcCgpO1xuICB9Y2F0Y2goZSl7XG4gICAgY29uc29sZS5lcnJvcihcInNxbGl0ZTNBcGlCb290c3RyYXAoKSBlcnJvcjpcIixlKTtcbiAgICB0aHJvdyBlO1xuICB9ZmluYWxseXtcbiAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwO1xuICAgIGRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWc7XG4gIH1cblxuICBNb2R1bGUuc3FsaXRlMyA9IHNxbGl0ZTMgO1xufWVsc2V7XG4gIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHJ1bm5pbmcgaW4gYW4gRW1zY3JpcHRlbiBtb2R1bGUgY29udGV4dCwgc29cIixcbiAgICAgICAgICAgICAgIFwiZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwKCkgaXMgX25vdF8gYmVpbmcgY2FsbGVkIGR1ZSB0byBsYWNrXCIsXG4gICAgICAgICAgICAgICBcIm9mIGNvbmZpZyBpbmZvIGZvciB0aGUgV0FTTSBlbnZpcm9ubWVudC5cIixcbiAgICAgICAgICAgICAgIFwiSXQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkuXCIpO1xufVxuXG5cblxuXG59KTtcblxuXG5cbiAgcmV0dXJuIHNxbGl0ZTNJbml0TW9kdWxlLnJlYWR5XG59XG4pO1xufSkoKTtcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gc3FsaXRlM0luaXRNb2R1bGU7XG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pXG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBzcWxpdGUzSW5pdE1vZHVsZTsgfSk7XG5lbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG4gIGV4cG9ydHNbXCJzcWxpdGUzSW5pdE1vZHVsZVwiXSA9IHNxbGl0ZTNJbml0TW9kdWxlO1xuXG5cblxuKGZ1bmN0aW9uKCl7XG4gIFxuICBjb25zdCBvcmlnaW5hbEluaXQgPSBzcWxpdGUzSW5pdE1vZHVsZTtcbiAgaWYoIW9yaWdpbmFsSW5pdCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGUgdG8gYmUgZGVmaW5lZCBieSB0aGUgRW1zY3JpcHRlbiBidWlsZC5cIik7XG4gIH1cbiAgXG4gIGNvbnN0IGluaXRNb2R1bGVTdGF0ZSA9IGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgbW9kdWxlU2NyaXB0OiBnbG9iYWxUaGlzPy5kb2N1bWVudD8uY3VycmVudFNjcmlwdCxcbiAgICBpc1dvcmtlcjogKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUpLFxuICAgIGxvY2F0aW9uOiBnbG9iYWxUaGlzLmxvY2F0aW9uLFxuICAgIHVybFBhcmFtczogIGdsb2JhbFRoaXM/LmxvY2F0aW9uPy5ocmVmXG4gICAgICA/IG5ldyBVUkwoZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmKS5zZWFyY2hQYXJhbXNcbiAgICAgIDogbmV3IFVSTFNlYXJjaFBhcmFtcygpXG4gIH0pO1xuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUgPVxuICAgIGluaXRNb2R1bGVTdGF0ZS51cmxQYXJhbXMuaGFzKCdzcWxpdGUzLmRlYnVnTW9kdWxlJylcbiAgICA/ICguLi5hcmdzKT0+Y29uc29sZS53YXJuKCdzcWxpdGUzLmRlYnVnTW9kdWxlOicsLi4uYXJncylcbiAgICA6ICgpPT57fTtcblxuICBpZihpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcygnc3FsaXRlMy5kaXInKSl7XG4gICAgaW5pdE1vZHVsZVN0YXRlLnNxbGl0ZTNEaXIgPSBpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmdldCgnc3FsaXRlMy5kaXInKSArJy8nO1xuICB9ZWxzZSBpZihpbml0TW9kdWxlU3RhdGUubW9kdWxlU2NyaXB0KXtcbiAgICBjb25zdCBsaSA9IGluaXRNb2R1bGVTdGF0ZS5tb2R1bGVTY3JpcHQuc3JjLnNwbGl0KCcvJyk7XG4gICAgbGkucG9wKCk7XG4gICAgaW5pdE1vZHVsZVN0YXRlLnNxbGl0ZTNEaXIgPSBsaS5qb2luKCcvJykgKyAnLyc7XG4gIH1cblxuICBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlID0gZnVuY3Rpb24gZmYoLi4uYXJncyl7XG4gICAgXG4gICAgcmV0dXJuIG9yaWdpbmFsSW5pdCguLi5hcmdzKS50aGVuKChFbXNjcmlwdGVuTW9kdWxlKT0+e1xuICAgICAgXG4gICAgICBjb25zdCBzID0gRW1zY3JpcHRlbk1vZHVsZS5zcWxpdGUzO1xuICAgICAgcy5zY3JpcHRJbmZvID0gaW5pdE1vZHVsZVN0YXRlO1xuICAgICAgXG4gICAgICBpZihmZi5fX2lzVW5kZXJUZXN0KSBzLl9faXNVbmRlclRlc3QgPSB0cnVlO1xuICAgICAgY29uc3QgZiA9IHMuYXN5bmNQb3N0SW5pdDtcbiAgICAgIGRlbGV0ZSBzLmFzeW5jUG9zdEluaXQ7XG4gICAgICByZXR1cm4gZigpO1xuICAgIH0pLmNhdGNoKChlKT0+e1xuICAgICAgY29uc29sZS5lcnJvcihcIkV4Y2VwdGlvbiBsb2FkaW5nIHNxbGl0ZTMgbW9kdWxlOlwiLGUpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfTtcbiAgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZS5yZWFkeSA9IG9yaWdpbmFsSW5pdC5yZWFkeTtcblxuICBpZihnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUubW9kdWxlU2NyaXB0KXtcbiAgICBjb25zdCBzaW0gPSBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGU7XG4gICAgbGV0IHNyYyA9IHNpbS5tb2R1bGVTY3JpcHQuc3JjLnNwbGl0KCcvJyk7XG4gICAgc3JjLnBvcCgpO1xuICAgIHNpbS5zY3JpcHREaXIgPSBzcmMuam9pbignLycpICsgJy8nO1xuICB9XG4gIGluaXRNb2R1bGVTdGF0ZS5kZWJ1Z01vZHVsZSgnc3FsaXRlM0luaXRNb2R1bGVTdGF0ZSA9Jyxpbml0TW9kdWxlU3RhdGUpO1xuICBpZigwKXtcbiAgICBjb25zb2xlLndhcm4oXCJSZXBsYWNlZCBzcWxpdGUzSW5pdE1vZHVsZSgpXCIpO1xuICAgIGNvbnNvbGUud2FybihcImdsb2JhbFRoaXMubG9jYXRpb24uaHJlZiA9XCIsZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmKTtcbiAgICBpZigndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGRvY3VtZW50KXtcbiAgICAgIGNvbnNvbGUud2FybihcImRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjID1cIixcbiAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjKTtcbiAgICB9XG4gIH1cblxuXG5cbiAgXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc3FsaXRlM0luaXRNb2R1bGU7XG4gIH1lbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpe1xuICAgIGV4cG9ydHNbXCJzcWxpdGUzSW5pdE1vZHVsZVwiXSA9IHNxbGl0ZTNJbml0TW9kdWxlO1xuICB9XG4gIFxuICByZXR1cm4gZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZSA7XG59KSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2h0dHBzX3Jhd19naXRoYWNrX2NvbV9kZW5pc19taWdkYWxfTElTU19tYWluX2luZGV4X2pzX2JiNmEzY2FlX187IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsInZhciB3ZWJwYWNrUXVldWVzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sKFwid2VicGFjayBxdWV1ZXNcIikgOiBcIl9fd2VicGFja19xdWV1ZXNfX1wiO1xudmFyIHdlYnBhY2tFeHBvcnRzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sKFwid2VicGFjayBleHBvcnRzXCIpIDogXCJfX3dlYnBhY2tfZXhwb3J0c19fXCI7XG52YXIgd2VicGFja0Vycm9yID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sKFwid2VicGFjayBlcnJvclwiKSA6IFwiX193ZWJwYWNrX2Vycm9yX19cIjtcbnZhciByZXNvbHZlUXVldWUgPSAocXVldWUpID0+IHtcblx0aWYocXVldWUgJiYgcXVldWUuZCA8IDEpIHtcblx0XHRxdWV1ZS5kID0gMTtcblx0XHRxdWV1ZS5mb3JFYWNoKChmbikgPT4gKGZuLnItLSkpO1xuXHRcdHF1ZXVlLmZvckVhY2goKGZuKSA9PiAoZm4uci0tID8gZm4ucisrIDogZm4oKSkpO1xuXHR9XG59XG52YXIgd3JhcERlcHMgPSAoZGVwcykgPT4gKGRlcHMubWFwKChkZXApID0+IHtcblx0aWYoZGVwICE9PSBudWxsICYmIHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpIHtcblx0XHRpZihkZXBbd2VicGFja1F1ZXVlc10pIHJldHVybiBkZXA7XG5cdFx0aWYoZGVwLnRoZW4pIHtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdFx0cXVldWUuZCA9IDA7XG5cdFx0XHRkZXAudGhlbigocikgPT4ge1xuXHRcdFx0XHRvYmpbd2VicGFja0V4cG9ydHNdID0gcjtcblx0XHRcdFx0cmVzb2x2ZVF1ZXVlKHF1ZXVlKTtcblx0XHRcdH0sIChlKSA9PiB7XG5cdFx0XHRcdG9ialt3ZWJwYWNrRXJyb3JdID0gZTtcblx0XHRcdFx0cmVzb2x2ZVF1ZXVlKHF1ZXVlKTtcblx0XHRcdH0pO1xuXHRcdFx0dmFyIG9iaiA9IHt9O1xuXHRcdFx0b2JqW3dlYnBhY2tRdWV1ZXNdID0gKGZuKSA9PiAoZm4ocXVldWUpKTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fVxuXHR9XG5cdHZhciByZXQgPSB7fTtcblx0cmV0W3dlYnBhY2tRdWV1ZXNdID0geCA9PiB7fTtcblx0cmV0W3dlYnBhY2tFeHBvcnRzXSA9IGRlcDtcblx0cmV0dXJuIHJldDtcbn0pKTtcbl9fd2VicGFja19yZXF1aXJlX18uYSA9IChtb2R1bGUsIGJvZHksIGhhc0F3YWl0KSA9PiB7XG5cdHZhciBxdWV1ZTtcblx0aGFzQXdhaXQgJiYgKChxdWV1ZSA9IFtdKS5kID0gLTEpO1xuXHR2YXIgZGVwUXVldWVzID0gbmV3IFNldCgpO1xuXHR2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzO1xuXHR2YXIgY3VycmVudERlcHM7XG5cdHZhciBvdXRlclJlc29sdmU7XG5cdHZhciByZWplY3Q7XG5cdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlaikgPT4ge1xuXHRcdHJlamVjdCA9IHJlajtcblx0XHRvdXRlclJlc29sdmUgPSByZXNvbHZlO1xuXHR9KTtcblx0cHJvbWlzZVt3ZWJwYWNrRXhwb3J0c10gPSBleHBvcnRzO1xuXHRwcm9taXNlW3dlYnBhY2tRdWV1ZXNdID0gKGZuKSA9PiAocXVldWUgJiYgZm4ocXVldWUpLCBkZXBRdWV1ZXMuZm9yRWFjaChmbiksIHByb21pc2VbXCJjYXRjaFwiXSh4ID0+IHt9KSk7XG5cdG1vZHVsZS5leHBvcnRzID0gcHJvbWlzZTtcblx0Ym9keSgoZGVwcykgPT4ge1xuXHRcdGN1cnJlbnREZXBzID0gd3JhcERlcHMoZGVwcyk7XG5cdFx0dmFyIGZuO1xuXHRcdHZhciBnZXRSZXN1bHQgPSAoKSA9PiAoY3VycmVudERlcHMubWFwKChkKSA9PiB7XG5cdFx0XHRpZihkW3dlYnBhY2tFcnJvcl0pIHRocm93IGRbd2VicGFja0Vycm9yXTtcblx0XHRcdHJldHVybiBkW3dlYnBhY2tFeHBvcnRzXTtcblx0XHR9KSlcblx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0XHRmbiA9ICgpID0+IChyZXNvbHZlKGdldFJlc3VsdCkpO1xuXHRcdFx0Zm4uciA9IDA7XG5cdFx0XHR2YXIgZm5RdWV1ZSA9IChxKSA9PiAocSAhPT0gcXVldWUgJiYgIWRlcFF1ZXVlcy5oYXMocSkgJiYgKGRlcFF1ZXVlcy5hZGQocSksIHEgJiYgIXEuZCAmJiAoZm4ucisrLCBxLnB1c2goZm4pKSkpO1xuXHRcdFx0Y3VycmVudERlcHMubWFwKChkZXApID0+IChkZXBbd2VicGFja1F1ZXVlc10oZm5RdWV1ZSkpKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gZm4uciA/IHByb21pc2UgOiBnZXRSZXN1bHQoKTtcblx0fSwgKGVycikgPT4gKChlcnIgPyByZWplY3QocHJvbWlzZVt3ZWJwYWNrRXJyb3JdID0gZXJyKSA6IG91dGVyUmVzb2x2ZShleHBvcnRzKSksIHJlc29sdmVRdWV1ZShxdWV1ZSkpKTtcblx0cXVldWUgJiYgcXVldWUuZCA8IDAgJiYgKHF1ZXVlLmQgPSAwKTtcbn07IiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIHVzZWQgJ21vZHVsZScgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3BhZ2VzL1IxLTAyL0NNL2luZGV4LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3BhZ2VzL1IxLTAyL0NNL2luZGV4LmNzc1wiKTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3BhZ2VzL1IxLTAyL0NNL2luZGV4Lm1kXCIpO1xuIiwiIl0sIm5hbWVzIjpbIlNoYWRvd0NmZyIsIl9fY3N0cl9ob3N0IiwiQ0FOX0hBVkVfU0hBRE9XIiwiX2Nhbkhhc1NoYWRvdyIsInRhZyIsImluY2x1ZGVzIiwiX2VsZW1lbnQydGFnbmFtZSIsIkxJU1MiLCJleHRlbmRzIiwicF9leHRlbmRzIiwiaG9zdCIsInBfaG9zdCIsImRlcGVuZGVuY2llcyIsInBfZGVwcyIsImF0dHJpYnV0ZXMiLCJwX2F0dHJzIiwicGFyYW1zIiwiY29udGVudCIsImNzcyIsInNoYWRvdyIsInBfc2hhZG93IiwiSFRNTEVsZW1lbnQiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImNhbkhhc1NoYWRvdyIsIkVycm9yIiwidW5kZWZpbmVkIiwicHVzaCIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJ0cmltIiwiUmVzcG9uc2UiLCJ0ZXh0IiwiTElTU0Jhc2UiLCJQYXJhbWV0ZXJzIiwic3R5bGVzaGVldHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJmZXRjaF9jc3MiLCJDU1NTdHlsZVNoZWV0IiwiSFRNTFN0eWxlRWxlbWVudCIsInNoZWV0Iiwic3R5bGUiLCJyZXBsYWNlIiwibWFwIiwiaWR4IiwiY29uc3RydWN0b3IiLCJhdHRycyIsInNldEF0dHJEZWZhdWx0IiwiYXR0ciIsInZhbHVlIiwic2V0UGFyYW0iLCJuYW1lIiwib25BdHRyQ2hhbmdlZCIsIl9uYW1lIiwiX29sZFZhbHVlIiwiX25ld1ZhbHVlIiwiaXNJbkRPTSIsIm9uRE9NQ29ubmVjdGVkIiwib25ET01EaXNjb25uZWN0ZWQiLCJleHRlbmRzTElTUyIsIkxpc3MiLCJwYXJhbWV0ZXJzIiwiYXNzaWduIiwiRXh0ZW5kZWRMSVNTIiwidCIsImlkIiwiYnVpbGRMSVNTSG9zdCIsIl9wYXJhbXMiLCJhbHJlYWR5RGVjbGFyZWRDU1MiLCJTZXQiLCJHRVQiLCJTeW1ib2wiLCJTRVQiLCJwcm9wZXJ0aWVzIiwiZnJvbUVudHJpZXMiLCJuIiwiZW51bWVyYWJsZSIsImdldCIsInNldCIsIkF0dHJpYnV0ZXMiLCJkYXRhIiwiZGVmYXVsdHMiLCJzZXR0ZXIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiTElTU0hvc3RCYXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpc0luaXQiLCJpbml0aWFsaXplIiwiYXBpIiwiaW5pdCIsIkxJU1NTeW5jIiwiZGlzY29ubmVjdGVkQ2FsbGJhY2siLCJjb25uZWN0ZWRDYWxsYmFjayIsImN1c3RvbUVsZW1lbnRzIiwidXBncmFkZSIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCJhZGRFdmVudExpc3RlbmVyIiwib25DbGlja0V2ZW50Iiwib2JzIiwiZ2V0QXR0cmlidXRlIiwiYWRvcHRlZFN0eWxlU2hlZXRzIiwic2hhcmVkQ1NTIiwiY3Nzc2VsZWN0b3IiLCJDU1NTZWxlY3RvciIsImhhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImh0bWxfc3R5bGVzaGVldHMiLCJydWxlIiwiY3NzUnVsZXMiLCJjc3NUZXh0IiwiaGVhZCIsImFwcGVuZCIsImFkZCIsInRlbXBsYXRlX2VsZW0iLCJzdHIiLCJfIiwibWF0Y2giLCJjaGlsZE5vZGVzIiwib2JqIiwiaGFzU2hhZG93IiwiZ2V0UGFydCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRQYXJ0cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJoYXNBdHRyaWJ1dGUiLCJ0YWdOYW1lIiwicmVtb3ZlQXR0cmlidXRlIiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsIl9ET01Db250ZW50TG9hZGVkIiwicmVhZHlTdGF0ZSIsImRlZmluZSIsInRhZ25hbWUiLCJDb21wb25lbnRDbGFzcyIsIkNsYXNzIiwiaHRtbHRhZyIsImFsbCIsIkxJU1NjbGFzcyIsIm9wdHMiLCJpbnNlcnRHbG9iYWxDU1NSdWxlcyIsImNzc19zdHlsZSIsInJlcGxhY2VTeW5jIiwiaW5zZXJ0UnVsZSIsIkRFTEVHQVRFRF9FVkVOVFMiLCJBTFJFQURZX1BST0NFU1NFRCIsImV2IiwiaGFuZGxlcnMiLCJ0eXBlIiwiZWxlbSIsImNvbXBvc2VkUGF0aCIsIlNoYWRvd1Jvb3QiLCJ3aW5kb3ciLCJ0YXJnZXQiLCJzZWxlY3RvciIsImhhbmRsZXIiLCJtYXRjaGVzIiwiaW5zZXJ0R2xvYmFsRGVsZWdhdGVkTGlzdGVuZXIiLCJldmVudF9uYW1lIiwiY2xvc2VzdCIsImVsZW1lbnQiLCJyZXN1bHQiLCJyb290IiwiZ2V0Um9vdE5vZGUiLCJidWlsZCIsInBhcmVudCIsImNsYXNzZXMiLCJjc3N2YXJzIiwibGlzdGVuZXJzIiwiQ3VzdG9tQ2xhc3MiLCJ3aGVuRGVmaW5lZCIsInRvTG93ZXJDYXNlIiwiY2xhc3NMaXN0Iiwic2V0UHJvcGVydHkiLCJ0b2dnbGVBdHRyaWJ1dGUiLCJkYXRhc2V0IiwicmVwbGFjZUNoaWxkcmVuIiwiZ2V0TElTUyIsImJ1aWxkU3luYyIsImluaXRpYWxpemVTeW5jIiwiZ2V0TElTU1N5bmMiLCJjYWxsYmFjayIsIndoZW5BbGxEZWZpbmVkIiwidGFnbmFtZXMiLCJpc0RlZmluZWQiLCJnZXROYW1lIiwiX2J1aWxkUVMiLCJ0YWduYW1lX29yX3BhcmVudCIsInFzIiwicXNvIiwicXNhIiwiZWxlbWVudHMiLCJwcm9taXNlcyIsInFzYyIsInJlcyIsInFzU3luYyIsInFzYVN5bmMiLCJxc2NTeW5jIiwiTElTU19BdXRvIiwibmF2aWdhdG9yIiwic2VydmljZVdvcmtlciIsInJlZ2lzdGVyIiwiY29udHJvbGxlciIsInNyYyIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwibXV0YXRpb24iLCJhZGRpdGlvbiIsImFkZGVkTm9kZXMiLCJFbGVtZW50Iiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJyZXNvdXJjZXMiLCJkZWZpbmVXZWJDb21wb25lbnQiLCJmaWxlcyIsImpzIiwia2xhc3MiLCJXZWJDb21wb25lbnQiLCJmaWxlbmFtZXMiLCJmaWxlIiwiZW5kc1dpdGgiLCJfaW1wb3J0IiwiX2ZldGNoVGV4dCIsImkiLCJDc3RtRXZlbnQiLCJDdXN0b21FdmVudCIsImFyZ3MiLCJkZXRhaWwiLCJmZXRjaFJlc291cmNlIiwicmVzb3VyY2UiLCJmZXRjaCIsInVyaSIsImlzTGlzc0F1dG8iLCJvcHRpb25zIiwiaGVhZGVycyIsInJlc3BvbnNlIiwic3RhdHVzIiwiZGVmYXVsdCIsImUiLCJjb25zb2xlIiwibG9nIiwiSFRNTENMQVNTX1JFR0VYIiwiZWxlbWVudE5hbWVMb29rdXBUYWJsZSIsImV4ZWMiLCJyZXF1aXJlIiwicyIsInNxbGl0ZTMiLCJvbzEiLCJqczJzcWwiLCJEQiIsImRlc2MiLCJmdWxsUmVzZXQiLCJjb2xzIiwiZW50cmllcyIsInNjaGVtYSIsImpvaW4iLCJjb25zdHJhaW50cyIsInZhbHVlcyIsImMiLCJyZXNldFRhYmxlIiwicmVzZXQiLCJyZXZlcnNlIiwiY2xlYXIiLCJuYW1lcyIsImtleXMiLCJ0YWJsZSIsInNxbCIsInR5cGVzIiwic3FsX3R5cGUiLCJmaW5kIiwidiIsInN0YXJ0c1dpdGgiLCJzdGFydF9wb3MiLCJlbmRfcG9zIiwidGFibGVfbmFtZSIsInNsaWNlIiwiZXhlY19vbmUiLCJzZWxlY3RPYmplY3RzIiwiZXhlY19tYW55IiwicmVzdWx0cyIsIndhcm4iLCJtZXNzYWdlIiwic3BsaXQiLCJkYjIiLCJVc2VycyIsIklEIiwiTm9tIiwiUHJlbm9tIiwiQWdlIiwiUHJvZHVpdHMiLCJEYXRlIiwiUmVmIiwiUSIsIlQxIiwiVDIiLCJzbmFtZSIsInBhdGgiLCJjaGlsZHJlbiIsInJvb3RfcGF0aCIsImhvc3RuYW1lIiwicGFnZXMiLCJtYWluIiwiaGVhZGVyIiwidGl0bGVzIiwiaHRyZWUiLCJodG1sIiwibGV2ZWwiLCJodHJlZV9jdXJzb3IiLCJ0aXRsZSIsInNlYXJjaEN1ckhlYWRlciIsInBvc2l0aW9uIiwib2Zmc2V0VG9wIiwiaGlkIiwiZ2V0VGl0bGVQcmVmaXgiLCJpbmRleE9mIiwibnVtIiwiYnVpbGRNZW51Iiwibm9kZXMiLCJtZW51IiwiaXRlbSIsInRleHRDb250ZW50IiwidXBkYXRlSGVhZGVyIiwibGFzdCIsInNjcm9sbFRvcCIsImN1cnNvciIsImhub2RlIiwiaCIsImhfaHRtbCIsImxpbmsiLCJlbXB0eSIsIm1ha2VfcGFnZV9ocmVmIiwicGF0aHByZWZpeCIsImhyZWYiLCJtYWtlX3BhZ2VfbWVudSIsInBhZ2UiLCJjdXJwYWdlIiwibW9kdWxlX2h0bWwiLCJ0eXBlX2h0bWwiLCJkZXNjX3R5cGUiLCJkZXNjMl9pZHgiLCJmaW5kSW5kZXgiLCJib2R5Iiwic2Vzc2lvbl9odG1sIiwicCIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImRvY3VtZW50RWxlbWVudCIsImlubmVyV2lkdGgiXSwic291cmNlUm9vdCI6IiJ9