import * as __WEBPACK_EXTERNAL_MODULE_https_raw_githack_com_denis_migdal_LISS_main_index_js_bb6a3cae__ from "https://raw.githack.com/denis-migdal/LISS/main/index.js";
/******/ var __webpack_modules__ = ({

/***/ "./src/pages/R1-02/CM/index.css":
/*!**************************************!*\
  !*** ./src/pages/R1-02/CM/index.css ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/pages/R1-02/CM/index.md":
/*!*************************************!*\
  !*** ./src/pages/R1-02/CM/index.md ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "pages/R1-02/CM/index.html");

/***/ }),

/***/ "./libs/LISS/index.ts":
/*!****************************!*\
  !*** ./libs/LISS/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CstmEvent: () => (/* binding */ CstmEvent),
/* harmony export */   LISS_Auto: () => (/* binding */ LISS_Auto),
/* harmony export */   ShadowCfg: () => (/* binding */ ShadowCfg),
/* harmony export */   "default": () => (/* binding */ LISS)
/* harmony export */ });
// ================================================
// =============== LISS exported types ============
// ================================================
var ShadowCfg;
(function(ShadowCfg) {
    ShadowCfg["NONE"] = "none";
    ShadowCfg["OPEN"] = "open";
    ShadowCfg["CLOSE"] = "closed";
})(ShadowCfg || (ShadowCfg = {}));
// ================================================
// =============== LISS Class =====================
// ================================================
let __cstr_host = null;
// https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow
const CAN_HAVE_SHADOW = [
    null,
    'article',
    'aside',
    'blockquote',
    'body',
    'div',
    'footer',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'main',
    'nav',
    'p',
    'section',
    'span'
];
function _canHasShadow(tag) {
    return CAN_HAVE_SHADOW.includes(_element2tagname(tag));
}
function LISS({ extends: p_extends, host: p_host, dependencies: p_deps, attributes: p_attrs, params, content, css, shadow: p_shadow } = {}) {
    //TODO merge prop if extends LISS...
    const host = p_host ?? HTMLElement;
    const _extends = p_extends ?? Object;
    const attributes = p_attrs ?? [];
    const dependencies = p_deps ? [
        ...p_deps
    ] : [];
    const canHasShadow = _canHasShadow(host);
    const shadow = p_shadow ?? (canHasShadow ? "closed" : "none");
    if (!canHasShadow && shadow !== "none") throw new Error(`Host element ${_element2tagname(host)} does not support ShadowRoot`);
    // CONTENT processing
    if (content !== undefined) {
        dependencies.push((async ()=>{
            content = await content;
            if (content instanceof HTMLTemplateElement) content = content.innerHTML;
            if (typeof content === "string") {
                content = content.trim(); // Never return a text node of whitespace as the result
                if (content === '') content = undefined;
            }
            if (content instanceof Response) content = await content.text();
            return LISSBase.Parameters.content = content;
        })());
    }
    // CSS processing
    let stylesheets = [];
    if (css !== undefined) {
        if (!Array.isArray(css)) css = [
            css
        ];
        stylesheets = new Array(css.length);
        const fetch_css = async (css)=>{
            css = await css;
            if (css instanceof CSSStyleSheet) return css;
            if (css instanceof HTMLStyleElement) return css.sheet;
            let style = new CSSStyleSheet();
            if (typeof css === "string") {
                await style.replace(css);
                return style;
            }
            //if( css instanceof Response )
            await style.replace(await css.text());
            return style;
        };
        dependencies.push(...css.map(async (css, idx)=>stylesheets[idx] = await fetch_css(css)));
    }
    // @ts-ignore
    class LISSBase extends _extends {
        #host;
        constructor(){
            super();
            // h4ck, okay because JS is monothreaded.
            if (__cstr_host === null) throw new Error("Please do not directly call this constructor");
            this.#host = __cstr_host;
            __cstr_host = null;
        }
        get host() {
            return this.#host;
        }
        get attrs() {
            return this.#host.attrs;
        }
        setAttrDefault(attr, value) {
            return this.#host.setAttrDefault(attr, value);
        }
        get params() {
            return this.#host.params;
        }
        setParam(name, value) {
            this.#host.params[name] = value;
        }
        get content() {
            return this.#host.content;
        }
        static Parameters = {
            host,
            dependencies,
            attributes,
            params,
            content,
            stylesheets,
            shadow
        };
        onAttrChanged(_name, _oldValue, _newValue) {}
        get isInDOM() {
            return this.#host.isInDOM;
        }
        onDOMConnected() {}
        onDOMDisconnected() {}
    }
    return LISSBase;
}
//TODO: other options...
function extendsLISS(Liss, parameters) {
    const attributes = [
        ...Liss.Parameters.attributes,
        ...parameters.attributes ?? []
    ];
    const dependencies = [
        ...Liss.Parameters.dependencies,
        ...parameters.dependencies ?? []
    ];
    const params = Object.assign({}, Liss.Parameters, {
        attributes,
        dependencies
    });
    if (parameters.shadow !== undefined) params.shadow = parameters.shadow;
    // @ts-ignore : because TS stupid
    class ExtendedLISS extends Liss {
        constructor(...t){
            // @ts-ignore : because TS stupid
            super(...t);
        }
        get attrs() {
            return super.attrs;
        }
        static Parameters = params;
    }
    return ExtendedLISS;
}
LISS.extendsLISS = extendsLISS;
// ================================================
// =============== LISSHost class =================
// ================================================
let id = 0;
function buildLISSHost(Liss, _params = {}) {
    const { host, attributes, content, stylesheets, shadow } = Liss.Parameters;
    const alreadyDeclaredCSS = new Set();
    const GET = Symbol('get');
    const SET = Symbol('set');
    const properties = Object.fromEntries(attributes.map((n)=>[
            n,
            {
                enumerable: true,
                get: function() {
                    return this[GET](n);
                },
                set: function(value) {
                    return this[SET](n, value);
                }
            }
        ]));
    class Attributes {
        #data;
        #defaults;
        #setter;
        [GET](name) {
            return this.#data[name] ?? this.#defaults[name] ?? null;
        }
        [SET](name, value) {
            return this.#setter(name, value); // required to get a clean object when doing {...attrs}
        }
        constructor(data, defaults, setter){
            this.#data = data;
            this.#defaults = defaults;
            this.#setter = setter;
            Object.defineProperties(this, properties);
        }
    }
    // @ts-ignore : because TS is stupid.
    class LISSHostBase extends host {
        #params;
        #id = ++id;
        constructor(params = {}){
            super();
            this.#params = Object.assign({}, Liss.Parameters.params, _params, params);
            this.#waitInit = new Promise((resolve)=>{
                if (this.isInit) return resolve(this.#API);
                this.#resolve = resolve;
            });
        }
        /**** public API *************/ get isInit() {
            return this.#API !== null;
        }
        initialize(params = {}) {
            if (this.isInit) throw new Error('Element already initialized!');
            Object.assign(this.#params, params);
            const api = this.init();
            if (this.#isInDOM) api.onDOMConnected();
            return api;
        }
        get LISSSync() {
            if (!this.isInit) throw new Error('Accessing API before WebComponent initialization!');
            return this.#API;
        }
        get LISS() {
            return this.#waitInit;
        }
        /*** init ***/ #waitInit;
        #resolve = null;
        #API = null;
        #isInDOM = false;
        get isInDOM() {
            return this.#isInDOM;
        }
        disconnectedCallback() {
            this.#isInDOM = false;
            this.#API.onDOMDisconnected();
        }
        connectedCallback() {
            this.#isInDOM = true;
            if (!this.isInit) this.init();
            this.#API.onDOMConnected();
        }
        init() {
            customElements.upgrade(this);
            // shadow
            this.#content = this;
            if (shadow !== 'none') {
                this.#content = this.attachShadow({
                    mode: shadow
                });
                //@ts-ignore
                this.#content.addEventListener('click', onClickEvent);
                //@ts-ignore
                this.#content.addEventListener('dblclick', onClickEvent);
            }
            // attrs
            for (let obs of attributes)this.#attributes[obs] = this.getAttribute(obs);
            // css
            if (shadow !== 'none') this.#content.adoptedStyleSheets.push(sharedCSS);
            if (stylesheets.length) {
                if (shadow !== 'none') this.#content.adoptedStyleSheets.push(...stylesheets);
                else {
                    const cssselector = this.CSSSelector;
                    // if not yet inserted :
                    if (!alreadyDeclaredCSS.has(cssselector)) {
                        let style = document.createElement('style');
                        style.setAttribute('for', cssselector);
                        let html_stylesheets = "";
                        for (let style of stylesheets)for (let rule of style.cssRules)html_stylesheets += rule.cssText + '\n';
                        style.innerHTML = html_stylesheets.replace(':host', `:is(${cssselector})`);
                        document.head.append(style);
                        alreadyDeclaredCSS.add(cssselector);
                    }
                }
            }
            // content
            if (content !== undefined) {
                let template_elem = document.createElement('template');
                let str = content.replace(/\$\{(.+?)\}/g, (_, match)=>this.getAttribute(match) ?? '');
                template_elem.innerHTML = str;
                this.#content.append(...template_elem.content.childNodes);
            }
            // build
            // h4ck, okay because JS is monothreaded.
            __cstr_host = this;
            let obj = new Liss();
            /*if( obj instanceof Promise)
	    		obj = await obj;*/ this.#API = obj;
            // default slot
            if (this.hasShadow && this.#content.childNodes.length === 0) this.#content.append(document.createElement('slot'));
            if (this.#resolve !== null) this.#resolve(this.#API);
            return this.#API;
        }
        get params() {
            return this.#params;
        }
        setParam(name, value) {
            if (this.isInit) return this.#API.setParam(name, value);
            this.#params[name] = value; // will be given to constructor.
        }
        /*** content ***/ #content = null;
        get content() {
            return this.#content;
        }
        getPart(name) {
            return this.hasShadow ? this.#content?.querySelector(`::part(${name})`) : this.#content?.querySelector(`[part="${name}"]`);
        }
        getParts(name) {
            return this.hasShadow ? this.#content?.querySelectorAll(`::part(${name})`) : this.#content?.querySelectorAll(`[part="${name}"]`);
        }
        get hasShadow() {
            return shadow !== 'none';
        }
        /*** CSS ***/ get CSSSelector() {
            if (this.hasShadow || !this.hasAttribute("is")) return this.tagName;
            return `${this.tagName}[is="${this.getAttribute("is")}"]`;
        }
        /*** attrs ***/ #attrs_flag = false;
        #attributes = {};
        #attributesDefaults = {};
        #attrs = new Attributes(this.#attributes, this.#attributesDefaults, (name, value)=>{
            this.#attributes[name] = value;
            this.#attrs_flag = true; // do not trigger onAttrsChanged.
            if (value === null) this.removeAttribute(name);
            else this.setAttribute(name, value);
        });
        setAttrDefault(name, value) {
            if (value === null) delete this.#attributesDefaults[name];
            else this.#attributesDefaults[name] = value;
        }
        get attrs() {
            return this.#attrs;
        }
        static observedAttributes = attributes;
        attributeChangedCallback(name, oldValue, newValue) {
            if (this.#attrs_flag) {
                this.#attrs_flag = false;
                return;
            }
            this.#attributes[name] = newValue;
            if (!this.isInit) return;
            if (this.#API.onAttrChanged(name, oldValue, newValue) === false) {
                this.#attrs[name] = oldValue; // revert the change.
            }
        }
    }
    return LISSHostBase;
}
// ================================================
// =============== LISS define ====================
// ================================================
const _DOMContentLoaded = new Promise((resolve)=>{
    if (document.readyState === "interactive" || document.readyState === "complete") return resolve();
    document.addEventListener('DOMContentLoaded', ()=>{
        resolve();
    }, true);
});
LISS.define = async function(tagname, ComponentClass, { dependencies, params } = {}) {
    dependencies ??= [];
    params ??= {};
    const Class = ComponentClass.Parameters.host;
    let LISSBase = ComponentClass;
    let htmltag = _element2tagname(Class) ?? undefined;
    await Promise.all([
        _DOMContentLoaded,
        ...dependencies,
        ...LISSBase.Parameters.dependencies
    ]);
    const LISSclass = buildLISSHost(ComponentClass, params);
    const opts = htmltag === undefined ? {} : {
        extends: htmltag
    };
    customElements.define(tagname, LISSclass, opts);
};
// ================================================
// =============== LISS ShadowRoot tools ==========
// ================================================
const sharedCSS = new CSSStyleSheet();
document.adoptedStyleSheets.push(sharedCSS);
LISS.insertGlobalCSSRules = function(css) {
    let css_style;
    if (css instanceof HTMLStyleElement) css_style = css.sheet;
    if (typeof css === "string") {
        css_style = new CSSStyleSheet();
        css_style.replaceSync(css);
    }
    for (let rule of css_style.cssRules)sharedCSS.insertRule(rule.cssText);
};
const DELEGATED_EVENTS = {
    "click": [],
    "dblclick": []
};
const ALREADY_PROCESSED = Symbol();
function onClickEvent(ev) {
    if (ev[ALREADY_PROCESSED] === true) return;
    ev[ALREADY_PROCESSED] = true;
    const handlers = DELEGATED_EVENTS[ev.type];
    for (let elem of ev.composedPath()){
        if (elem instanceof ShadowRoot || elem === document || elem === window) continue;
        var target = elem;
        for (let [selector, handler] of handlers){
            if (target.matches(selector)) handler(ev);
        }
    }
}
LISS.insertGlobalDelegatedListener = function(event_name, selector, handler) {
    DELEGATED_EVENTS[event_name].push([
        selector,
        handler
    ]);
};
document.addEventListener('click', onClickEvent);
document.addEventListener('dblclick', onClickEvent);
LISS.closest = function closest(selector, element) {
    while(true){
        var result = element.closest(selector);
        if (result !== null) return result;
        const root = element.getRootNode();
        if (!("host" in root)) return null;
        element = root.host;
    }
};
async function build(tagname, { params = {}, initialize = true, content = [], parent = undefined, id = undefined, classes = [], cssvars = {}, attrs = {}, data = {}, listeners = {} } = {}) {
    if (!initialize && parent === null) throw new Error("A parent must be given if initialize is false");
    let CustomClass = await customElements.whenDefined(tagname);
    let elem = new CustomClass(params);
    // Fix issue #2
    if (elem.tagName.toLowerCase() !== tagname) elem.setAttribute("is", tagname);
    if (id !== undefined) elem.id = id;
    if (classes.length > 0) elem.classList.add(...classes);
    for(let name in cssvars)elem.style.setProperty(`--${name}`, cssvars[name]);
    for(let name in attrs){
        let value = attrs[name];
        if (typeof value === "boolean") elem.toggleAttribute(name, value);
        else elem.setAttribute(name, value);
    }
    for(let name in data){
        let value = data[name];
        if (value === false) delete elem.dataset[name];
        else if (value === true) elem.dataset[name] = "";
        else elem.dataset[name] = value;
    }
    if (!Array.isArray(content)) content = [
        content
    ];
    elem.replaceChildren(...content);
    for(let name in listeners)elem.addEventListener(name, listeners[name]);
    if (parent !== undefined) parent.append(elem);
    if (!elem.isInit && initialize) return await LISS.initialize(elem);
    return await LISS.getLISS(elem);
}
LISS.build = build;
function buildSync(tagname, { params = {}, initialize = true, content = [], parent = undefined, id = undefined, classes = [], cssvars = {}, attrs = {}, data = {}, listeners = {} } = {}) {
    if (!initialize && parent === null) throw new Error("A parent must be given if initialize is false");
    let CustomClass = customElements.get(tagname);
    if (CustomClass === undefined) throw new Error(`${tagname} not defined`);
    let elem = new CustomClass(params);
    //TODO: factorize...
    // Fix issue #2
    if (elem.tagName.toLowerCase() !== tagname) elem.setAttribute("is", tagname);
    if (id !== undefined) elem.id = id;
    if (classes.length > 0) elem.classList.add(...classes);
    for(let name in cssvars)elem.style.setProperty(`--${name}`, cssvars[name]);
    for(let name in attrs){
        let value = attrs[name];
        if (typeof value === "boolean") elem.toggleAttribute(name, value);
        else elem.setAttribute(name, value);
    }
    for(let name in data){
        let value = data[name];
        if (value === false) delete elem.dataset[name];
        else if (value === true) elem.dataset[name] = "";
        else elem.dataset[name] = value;
    }
    if (!Array.isArray(content)) content = [
        content
    ];
    elem.replaceChildren(...content);
    for(let name in listeners)elem.addEventListener(name, listeners[name]);
    if (parent !== undefined) parent.append(elem);
    if (!elem.isInit && initialize) LISS.initializeSync(elem);
    return LISS.getLISSSync(elem);
}
LISS.buildSync = buildSync;
LISS.whenDefined = async function(tagname, callback) {
    await customElements.whenDefined(tagname);
    if (callback !== undefined) callback();
    return;
};
LISS.whenAllDefined = async function(tagnames, callback) {
    await Promise.all(tagnames.map((t)=>customElements.whenDefined(t)));
    if (callback !== undefined) callback();
};
LISS.isDefined = function(name) {
    return customElements.get(name);
};
LISS.selector = function(name) {
    if (name === undefined) return "";
    return `:is(${name}, [is="${name}"])`;
};
LISS.getLISS = async function(element) {
    await LISS.whenDefined(LISS.getName(element));
    return element.LISS; // ensure initialized.
};
LISS.getLISSSync = function(element) {
    const name = LISS.getName(element);
    if (!LISS.isDefined(name)) throw new Error(`${name} hasn't been defined yet.`);
    let host = element;
    if (!host.isInit) throw new Error("Instance hasn't been initialized yet.");
    return host.LISSSync;
};
LISS.initialize = async function(element) {
    await LISS.whenDefined(LISS.getName(element));
    return await element.initialize(); // ensure initialization.
};
LISS.initializeSync = function(element) {
    const name = LISS.getName(element);
    if (!LISS.isDefined(name)) throw new Error(`${name} not defined`);
    return element.initialize(); // ensure initialization.
};
LISS.getName = function(element) {
    const name = element.getAttribute('is') ?? element.tagName.toLowerCase();
    if (!name.includes('-')) throw new Error(`Element ${name} is not a WebComponent`);
    return name;
};
function _buildQS(selector, tagname_or_parent, parent = document) {
    if (tagname_or_parent !== undefined && typeof tagname_or_parent !== 'string') {
        parent = tagname_or_parent;
        tagname_or_parent = undefined;
    }
    return [
        `${selector}${LISS.selector(tagname_or_parent)}`,
        parent
    ];
}
async function qs(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    let result = await LISS.qso(selector, parent);
    if (result === null) throw new Error(`Element ${selector} not found`);
    return result;
}
LISS.qs = qs;
async function qso(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const element = parent.querySelector(selector);
    if (element === null) return null;
    return await LISS.getLISS(element);
}
LISS.qso = qso;
async function qsa(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const elements = parent.querySelectorAll(selector);
    let idx = 0;
    const promises = new Array(elements.length);
    for (let element of elements)promises[idx++] = LISS.getLISS(element);
    return await Promise.all(promises);
}
LISS.qsa = qsa;
async function qsc(selector, tagname_or_parent, element) {
    const res = _buildQS(selector, tagname_or_parent, element);
    const result = res[1].closest(res[0]);
    if (result === null) return null;
    return await LISS.getLISS(result);
}
LISS.qsc = qsc;
function qsSync(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const element = parent.querySelector(selector);
    if (element === null) throw new Error(`Element ${selector} not found`);
    return LISS.getLISSSync(element);
}
LISS.qsSync = qsSync;
function qsaSync(selector, tagname_or_parent, parent = document) {
    [selector, parent] = _buildQS(selector, tagname_or_parent, parent);
    const elements = parent.querySelectorAll(selector);
    let idx = 0;
    const result = new Array(elements.length);
    for (let element of elements)result[idx++] = LISS.getLISSSync(element);
    return result;
}
LISS.qsaSync = qsaSync;
function qscSync(selector, tagname_or_parent, element) {
    const res = _buildQS(selector, tagname_or_parent, element);
    const result = res[1].closest(res[0]);
    if (result === null) return null;
    return LISS.getLISSSync(result);
}
LISS.qscSync = qscSync;
// ================================================
// =============== LISS Auto ======================
// ================================================
class LISS_Auto extends LISS({
    attributes: [
        "src"
    ]
}) {
    #known_tag = new Set();
    #directory;
    #sw;
    constructor(){
        super();
        this.#sw = new Promise(async (resolve)=>{
            await navigator.serviceWorker.register(`./sw.js`);
            if (navigator.serviceWorker.controller) resolve();
            navigator.serviceWorker.addEventListener('controllerchange', ()=>{
                resolve();
            });
        });
        const src = this.attrs.src;
        if (src === null) throw new Error("src attribute is missing.");
        this.#directory = src[0] === '.' ? `${window.location.pathname}/${src}` : src;
        new MutationObserver((mutations)=>{
            for (let mutation of mutations)for (let addition of mutation.addedNodes)if (addition instanceof Element) this.#addTag(addition.tagName);
        }).observe(document, {
            childList: true,
            subtree: true
        });
        for (let elem of document.querySelectorAll("*"))this.#addTag(elem.tagName);
    }
    resources() {
        return [
            "index.js",
            "index.html",
            "index.css"
        ];
    }
    defineWebComponent(tagname, files, opts) {
        const js = files["index.js"];
        const content = files["index.html"];
        let klass = null;
        if (js !== undefined) klass = js(opts);
        else if (content !== undefined) klass = class WebComponent extends LISS(opts) {
        };
        if (klass === null) throw new Error(`Missing files for WebComponent ${tagname}.`);
        return LISS.define(tagname, klass);
    }
    async #addTag(tagname) {
        tagname = tagname.toLowerCase();
        if (tagname === 'liss-auto' || tagname === 'bliss-auto' || !tagname.includes('-') || this.#known_tag.has(tagname)) return;
        this.#known_tag.add(tagname);
        await this.#sw; // ensure SW is installed.
        const filenames = this.resources();
        const resources = await Promise.all(filenames.map((file)=>file.endsWith('.js') ? _import(`${this.#directory}/${tagname}/${file}`, true) : _fetchText(`${this.#directory}/${tagname}/${file}`, true)));
        const files = {};
        for(let i = 0; i < filenames.length; ++i)if (resources[i] !== undefined) files[filenames[i]] = resources[i];
        const content = files["index.html"];
        const css = files["index.css"];
        const opts = {
            ...content !== undefined && {
                content
            },
            ...css !== undefined && {
                css
            }
        };
        return this.defineWebComponent(tagname, files, opts);
    }
}
LISS.define("liss-auto", LISS_Auto);
class CstmEvent extends CustomEvent {
    get type() {
        return super.type;
    }
    constructor(type, args){
        super(type, {
            detail: args
        });
    }
}
// ================================================
// =============== LISS internal tools ============
// ================================================
async function fetchResource(resource) {
    resource = await resource;
    if (!(resource instanceof Response)) resource = await fetch(resource);
    return await resource.text();
}
async function _fetchText(uri, isLissAuto = false) {
    const options = isLissAuto ? {
        headers: {
            "liss-auto": "true"
        }
    } : {};
    const response = await fetch(uri, options);
    if (response.status !== 200) return undefined;
    if (isLissAuto && response.headers.get("status") === "404") return undefined;
    return await response.text();
}
async function _import(uri, isLissAuto = false) {
    // test for the module existance.
    if (isLissAuto && await _fetchText(uri, isLissAuto) === undefined) return undefined;
    try {
        return (await import(/* webpackIgnore: true */ uri)).default;
    } catch (e) {
        console.log(e);
        return undefined;
    }
}
// from https://stackoverflow.com/questions/51000461/html-element-tag-name-from-constructor
const HTMLCLASS_REGEX = /HTML(\w+)Element/;
const elementNameLookupTable = {
    'UList': 'ul',
    'TableCaption': 'caption',
    'TableCell': 'td',
    'TableCol': 'col',
    'TableRow': 'tr',
    'TableSection': 'tbody',
    'Quote': 'q',
    'Paragraph': 'p',
    'OList': 'ol',
    'Mod': 'ins',
    'Media': 'video',
    'Image': 'img',
    'Heading': 'h1',
    'Directory': 'dir',
    'DList': 'dl',
    'Anchor': 'a'
};
function _element2tagname(Class) {
    if (Class === HTMLElement) return null;
    let htmltag = HTMLCLASS_REGEX.exec(Class.name)[1];
    return elementNameLookupTable[htmltag] ?? htmltag.toLowerCase();
}


/***/ }),

/***/ "./src/pages/R1-02/CM/index.ts":
/*!*************************************!*\
  !*** ./src/pages/R1-02/CM/index.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../struct/sql-interactive.js */ "./src/struct/sql-interactive.js");
/* harmony import */ var _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../struct/sql-dym-table.js */ "./src/struct/sql-dym-table.js");
/* harmony import */ var _struct_anim_player_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../struct/anim-player.js */ "./src/struct/anim-player.js");
/* harmony import */ var _struct_menu_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../struct/menu.ts */ "./src/struct/menu.ts");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_0__, _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_1__]);
([_struct_sql_interactive_js__WEBPACK_IMPORTED_MODULE_0__, _struct_sql_dym_table_js__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);





__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/SQLite.ts":
/*!******************************!*\
  !*** ./src/struct/SQLite.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   db2: () => (/* binding */ db2)
/* harmony export */ });
/* harmony import */ var _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sqlite/sqlite3.js */ "./src/struct/sqlite/sqlite3.js");
/* harmony import */ var _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__);
//TODO: better (assets)

__webpack_require__(/*! ../pages/R1-02/CM/sqlite3.wasm */ "./src/pages/R1-02/CM/sqlite3.wasm");
//require("../../../struct/sqlite/sqlite3.wasm");

const sqlite3 = (await _sqlite_sqlite3_js__WEBPACK_IMPORTED_MODULE_0__()).sqlite3.oo1;
function js2sql(value) {
    if (value === null) return "NULL";
    if (typeof value === "number") return `${value}`;
    if (typeof value === "string") return `'${value}'`;
    throw new Error('???');
}
//TODO merge queries...
class DB {
    #desc;
    #db;
    constructor(name, desc){
        this.#desc = desc;
        // add t for tracing.
        this.#db = new sqlite3.DB(name, 'c');
        this.#db.exec('PRAGMA foreign_keys=ON;');
        this.fullReset();
    }
    #dropTable(name) {
        this.#db.exec(`drop table if exists ${name}`);
    }
    #createTable(name) {
        const desc = this.#desc[name];
        const cols = Object.entries(desc.schema).map(([name, type])=>`${name} ${type}`).join(", ");
        let constraints = "";
        if ("constraints" in desc) constraints = `, ${desc.constraints}`;
        this.#db.exec(`CREATE TABLE IF NOT EXISTS ${name}(${cols}${constraints}) STRICT;`);
        // Populate...
        const values = desc.entries.map((e)=>`(${e.map((c)=>js2sql(c)).join(', ')})`).join(", ");
        this.#db.exec(`INSERT INTO ${name} VALUES ${values};`);
    }
    resetTable(name) {
        this.#dropTable(name);
        this.#createTable(name);
    }
    #created_table = new Set();
    #updated_table = new Set();
    reset() {
        for (let name of [
            ...this.#created_table.values()
        ].reverse())this.#db.exec(`drop table if exists ${name};`);
        for(let name in this.#desc)if (this.#updated_table.has(name)) this.resetTable(name);
        this.#created_table.clear();
        this.#updated_table.clear();
    }
    fullReset() {
        for (let name of [
            ...this.#created_table.values()
        ].reverse())this.#db.exec(`drop table if exists ${name}`);
        const names = Object.keys(this.#desc);
        // required due to FK...
        for (let table of names.reverse())this.#dropTable(table);
        for (let table of names.reverse())this.#createTable(table);
        this.#created_table.clear();
        this.#updated_table.clear();
    }
    #isTableName(c) {
        return c !== " " && c !== ";" && c !== "\n";
    }
    #extractTableNameFromSQL(sql) {
        const types = [
            "CREATE TABLE IF NOT EXISTS ",
            "CREATE TABLE ",
            "ALTER TABLE ",
            "DROP TABLE ",
            "UPDATE ",
            "INSERT INTO ",
            "DELETE FROM "
        ];
        const sql_type = types.find((v)=>sql.startsWith(v));
        let start_pos = sql_type.length;
        while(!this.#isTableName(sql[start_pos]))++start_pos;
        let end_pos = start_pos;
        while(this.#isTableName(sql[end_pos]))++end_pos;
        const table_name = sql.slice(start_pos, end_pos);
        return [
            sql_type,
            table_name
        ];
    }
    exec_one(sql) {
        if (sql.startsWith("SELECT ")) return this.#db.selectObjects(sql);
        this.#db.exec(sql);
        const [type, name] = this.#extractTableNameFromSQL(sql);
        if (name in this.#desc) this.#updated_table.add(name);
        else this.#created_table.add(name);
        return null;
    }
    exec_many(sql) {
        let results = [];
        for(let i = 0; i < sql.length; ++i){
            try {
                results.push(this.exec_one(sql[i]));
            } catch (e) {
                console.warn(e);
                const message = "Error:" + e.message.split(':').slice(2).join(':');
                results.push(message);
                break;
            }
        }
        return results;
    }
}
const db2 = new DB("BDR1_CM", {
    Users: {
        schema: {
            ID: "INTEGER PRIMARY KEY AUTOINCREMENT",
            Nom: "TEXT",
            Prenom: "TEXT",
            Age: "INT"
        },
        entries: [
            [
                null,
                'Doe',
                'John',
                43
            ],
            [
                null,
                'Durant',
                'Paul',
                9
            ],
            [
                null,
                'Nescio',
                'Nomen',
                43
            ]
        ]
    },
    Produits: {
        schema: {
            Date: "TEXT",
            Ref: "TEXT",
            Q: "INT"
        },
        entries: [
            [
                '2023-01-01',
                'Gomme',
                10
            ],
            [
                '2023-02-23',
                'Gomme',
                9
            ],
            [
                '2023-06-13',
                'Gomme',
                24
            ],
            [
                '2023-01-01',
                'Crayon',
                20
            ],
            [
                '2023-02-23',
                'Crayon',
                18
            ],
            [
                '2023-06-13',
                'Crayon',
                50
            ]
        ]
    },
    T1: {
        schema: {
            ID: "INTEGER PRIMARY KEY AUTOINCREMENT",
            T1: "TEXT"
        },
        entries: [
            [
                null,
                '1'
            ],
            [
                null,
                '2'
            ],
            [
                null,
                '3'
            ]
        ]
    },
    T2: {
        schema: {
            ID: "INT",
            T2: "TEXT"
        },
        constraints: "FOREIGN KEY(ID) REFERENCES T1(ID)",
        entries: [
            [
                1,
                '1'
            ],
            [
                3,
                '2'
            ],
            [
                3,
                '3'
            ],
            [
                null,
                '4'
            ]
        ]
    }
});


__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./src/struct/content.ts":
/*!*******************************!*\
  !*** ./src/struct/content.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root_path: () => (/* binding */ root_path)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    {
        name: "R 1-01 Tableur et Reporting",
        sname: "R1-01 Tableur",
        path: "R1-01",
        children: [
            {
                name: "CM",
                path: "CM",
                children: [
                    "CM1",
                    "CM2"
                ]
            },
            {
                name: "TP",
                path: "TP",
                children: [
                    "TP1",
                    "TP2"
                ]
            }
        ]
    },
    {
        name: "R 1-02 Bases de Données Relationnelles 1",
        sname: "R1-02 BDR1",
        path: "R1-02",
        children: [
            "CM",
            {
                name: "Slides",
                path: "Slides",
                children: [
                    "CM1",
                    "CM2"
                ]
            },
            {
                name: "TP",
                path: "TP",
                children: [
                    "TP1",
                    "TP2",
                    "TP3",
                    "TP4",
                    "TP5"
                ]
            }
        ]
    },
    {
        name: "R 3-03 Technologies Web",
        sname: "R3-03 Web1",
        path: "R3-03",
        children: [
            {
                name: "CM",
                path: "CM",
                children: [
                    "CM1"
                ]
            }
        ]
    }
]);
const root_path = [
    "localhost",
    "127.0.0.1"
].includes(location.hostname) ? "/dist/dev/pages/" : "/Cours/dist/dev/pages/";


/***/ }),

/***/ "./src/struct/menu.ts":
/*!****************************!*\
  !*** ./src/struct/menu.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _content__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content */ "./src/struct/content.ts");

/*
window.addEventListener('beforeprint', () => {
  //...
});
*/ //TODO: links...
const main = document.querySelector("main");
const header = document.querySelector("header");
const titles = document.querySelectorAll("h1, h2, h3, h4");
const htree = {
    html: main,
    level: 0,
    parent: null,
    children: []
};
let htree_cursor = htree;
for (let title of titles){
    const level = +title.tagName.slice(1);
    while(level <= htree_cursor.level)htree_cursor = htree_cursor.parent;
    const elem = {
        html: title,
        level,
        children: [],
        parent: htree_cursor
    };
    htree_cursor.children.push(elem);
    htree_cursor = elem;
}
function searchCurHeader(htree, position) {
    const headers = htree.children;
    for(let i = headers.length - 1; i >= 0; --i)if (headers[i].html.offsetTop <= position + 32) return searchCurHeader(headers[i], position) ?? headers[i];
    return null;
}
const hid = [
    [],
    [
        "I",
        "II",
        "III",
        "IV"
    ],
    [
        "1",
        "2",
        "3",
        "5",
        "6",
        "7",
        "8",
        "9"
    ],
    [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h"
    ]
];
function getTitlePrefix(s) {
    if (s.level >= hid.length) return "";
    const idx = s.parent.children.indexOf(s);
    const num = hid[s.level][idx];
    return `${num}. `;
}
function buildMenu(nodes) {
    const menu = document.createElement("div");
    menu.classList.add("menu");
    menu.append(...nodes.map((s, idx)=>{
        const item = document.createElement("a");
        item.textContent = `${getTitlePrefix(s)}${s.html.textContent}`;
        item.setAttribute("href", `#${s.html.id}`);
        return item;
    }));
    return menu;
}
function updateHeader() {
    const last = searchCurHeader(htree, main.scrollTop);
    let headers = [];
    let cursor = last;
    while(cursor.html !== main){
        headers.push(cursor);
        cursor = cursor.parent;
    }
    const html = headers.reverse().map((hnode, i)=>{
        const h = hnode.html;
        const h_html = document.createElement("span");
        const link = document.createElement("a");
        link.textContent = `${getTitlePrefix(hnode)}${h.textContent}`;
        link.setAttribute('href', `#${h.id}`);
        const menu = buildMenu(hnode.parent.children);
        h_html.append(link, menu);
        return h_html;
    });
    if (last.children.length !== 0) {
        const empty = document.createElement("span");
        empty.append(buildMenu(last.children));
        html.push(empty);
    }
    function make_page_href(pathprefix, path, desc) {
        let href = `${pathprefix}${path}/`;
        while(desc.children?.length){
            desc = desc.children[0];
            href += `${desc.path ?? desc}/`;
        }
        return href;
    }
    function make_page_menu(pathprefix, path, pages) {
        const desc = pages.find((page)=>page === path || page.path === path);
        const html = document.createElement("span");
        {
            const link = document.createElement("a");
            link.textContent = desc.sname ?? desc.name ?? desc;
            link.setAttribute('href', make_page_href(pathprefix, path, desc));
            const menu = document.createElement("div");
            menu.classList.add("menu");
            menu.append(...pages.map((page)=>{
                const item = document.createElement("a");
                item.textContent = page.name ?? page;
                item.setAttribute("href", make_page_href(pathprefix, page.path ?? page, page));
                return item;
            }));
            html.append(link, menu);
        }
        return html;
    }
    let curpage = window.location.pathname.slice(_content__WEBPACK_IMPORTED_MODULE_0__.root_path.length).split('/');
    const module_html = make_page_menu(_content__WEBPACK_IMPORTED_MODULE_0__.root_path, curpage[0], _content__WEBPACK_IMPORTED_MODULE_0__["default"]);
    const desc = _content__WEBPACK_IMPORTED_MODULE_0__["default"].find((page)=>page.path === curpage[0]);
    const type_html = make_page_menu(_content__WEBPACK_IMPORTED_MODULE_0__.root_path + curpage[0] + "/", curpage[1], desc.children);
    const desc_type = desc.children.find((page)=>(page?.path ?? page) === curpage[1]);
    if (typeof desc_type !== "string") {
        // title num
        const desc2_idx = desc_type.children.findIndex((page)=>page?.path ?? page === curpage[2]);
        document.body.style.setProperty("--header_start_id", `${desc2_idx}`);
        // menu
        const session_html = make_page_menu(_content__WEBPACK_IMPORTED_MODULE_0__.root_path + curpage[0] + "/" + curpage[1] + "/", curpage[2], desc_type.children);
        html[0] = session_html;
    }
    header.replaceChildren(module_html, type_html, ...html);
}
main.addEventListener('scroll', updateHeader);
updateHeader();


/***/ }),

/***/ "./src/struct/anim-player.js":
/*!***********************************!*\
  !*** ./src/struct/anim-player.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https://raw.githack.com/denis-migdal/LISS/main/index.js */ "https://raw.githack.com/denis-migdal/LISS/main/index.js");



const content = `<span class="reset">[Reset]</span><span class="prev">[Prev]</span><span class="play">[Play/Pause]</span><span class="next">[Next]</span>`;

const css = `
`;

const styles = [...document.querySelectorAll('style')].map(s => {
    let style = new CSSStyleSheet();
    style.replaceSync(s.textContent);
    return style;
});

class AnimPlayer extends (0,https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    content,
    css: [css, ...styles],
    attributes: ["speed"]
}) {

    constructor() {
        super();

        this.id = null;
        this.stepID = 0;

        this.content.querySelector(".prev" ).addEventListener("click", () => this.prev());
        this.content.querySelector(".next" ).addEventListener("click", () => this.next());
        this.content.querySelector(".play" ).addEventListener("click", () => this.play());
        this.content.querySelector(".reset").addEventListener("click", () => this.reset());
    }

    nextStep() {
        ++this.stepID;
        this.host.dispatchEvent( new CustomEvent("step", {detail: this.stepID}) );
    }


    cancelAutoPlay() {

        if(this.id === null)
            return false;

        clearInterval(this.id);
        this.id = null;
        return true;
    }

    prev() {
        const newStepID = this.stepID - 1;
        this.reset();
        while(this.stepID !== newStepID)
            this.nextStep();
    }
    next() {
        this.cancelAutoPlay();
        this.nextStep();
    }
    reset() {
        this.cancelAutoPlay();
        this.stepID = 0;
        this.host.dispatchEvent( new CustomEvent("reset") );
    }
    play() {

        if( this.cancelAutoPlay() )
            return;
        this.id = setInterval( () => this.nextStep(), +(this.attrs.speed ?? 500) );
    }
}

https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].define("anim-player", AnimPlayer)

/***/ }),

/***/ "./src/struct/sql-dym-table.js":
/*!*************************************!*\
  !*** ./src/struct/sql-dym-table.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! https://raw.githack.com/denis-migdal/LISS/main/index.js */ "https://raw.githack.com/denis-migdal/LISS/main/index.js");
/* harmony import */ var _SQLite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SQLite */ "./src/struct/SQLite.ts");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_SQLite__WEBPACK_IMPORTED_MODULE_1__]);
_SQLite__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];




const CSS =
`:host {
    display: inline-block;
}

:host table {
    border-collapse: collapse;

    & caption {
        font-weight: bold;
        font-size: 20px;
        line-height: 26px;
        font-style: italic;
    }
    
    & .highlight {
        background-color: #8B8000;
        print-color-adjust: exact;
    }

    /* TODO: make style adoptable through LISS... */
    .high_1 {
        background-color: red;
    }
    .high_2 {
        background-color: blue;
    }
    .high_3 {
        background-color: green;
    }
    .high_null {
        background-color: orange;
    }
    .hide {
        display: none;
    }
    .cur {
        border : 4px solid yellow;
        opacity: 0.5;
    }
    .lowlight {
        opacity: 0.25;
    }

    & td, & th {
        padding: 5px 10px;
        text-align: left;
    }

    & td {
        font-size: 16px;
        line-height: 22px;
    }

    & th {
        font-size: 20px;
        line-height: 26px;
    }
    
    & > tbody > tr + tr > td {
        border-top: 1px solid;
    }
}`;

class SQLDymTable extends (0,https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    attributes: ["table", "header", "cols"],
    css: CSS
}) {
    constructor() {
        super();

        let cols = this.attrs.cols ?? "*";

        this.exec(`SELECT ${cols} FROM ${this.attrs.table};`)
    }

    get nbRows() {
        return this.rows.length;
    }
    getRow(rowid) {
        return this.rows[rowid];
    }

    exec(query) {

        this.data = _SQLite__WEBPACK_IMPORTED_MODULE_1__.db2.exec_one(query);

        const table = document.createElement('table');

        const caption = document.createElement('caption');

        if( this.attrs.header === null)
            caption.textContent = `Table ${this.attrs.table} :`;
        else
            caption.textContent = this.attrs.header;

        //TODO: colgroup (for highlight).

        const colgroup = document.createElement('colgroup');
        const thead = document.createElement('thead');
        const trhead = document.createElement('tr');

        this.cols = {};

        const colnames =  Object.keys(this.data[0]);
        for(let colname of colnames) {
            const col = document.createElement('col');
            //col.classList.add('highlight');
            colgroup.append(col);

            this.cols[colname] = col;

            const th = document.createElement('th');
            th.textContent = colname;
            trhead.append(th);
        }
        thead.append(trhead);

        this.rows = [];

        const tbody = document.createElement('tbody');
        for(let line of this.data) {

            const tr = document.createElement('tr');
            for(let colname of colnames) {
                const td = document.createElement('td');
                td.textContent = line[colname] ?? "N/A";
                tr.append(td);
            }
            tbody.append(tr);

            this.rows.push([line,tr]);
        }

        table.append(caption, colgroup, thead, tbody);
        this.content.replaceChildren(table);
    }

    groupBy( group_colname ) {

        const tbody = this.content.querySelector("tbody");

        let groups = {};

        for(let line of this.data) {
            const group = line[group_colname];
            (groups[group] ??= []).push( line );
        }

        let rows = [];
        for(let groupname in groups) {

            const group = groups[groupname];

            for(let i = 0; i < group.length; ++i) {

                const entry = group[i];
                const tr = document.createElement('tr');

                for(let col in group[i]) {

                    const cell = document.createElement('td');
                    cell.textContent = entry[col];

                    if( col === group_colname ){
                        if(i !== 0)
                            continue;

                        cell.setAttribute("rowspan", group.length);
                    }

                    tr.append(cell);
                }
                rows.push(tr);
            }
                
            rows.push(document.createElement("tr"));
        }

        tbody.replaceChildren(...rows);
    }

    highlightCol( filter ) {
        for(let colname in this.cols)
            this.#highlight(this.cols[colname], filter(colname) );
    }

    #highlight(target, highlight) { // target: HTMLElement, highlight: boolean|string|Record<string, boolean> ) {

        if( typeof highlight === "boolean")
            return target.classList.toggle('highlight', highlight);
        if( typeof highlight === "string" )
            return target.classList.add(highlight);
        
        for(let name in highlight)
            target.classList.toggle(name, highlight[name]);

    }

    highlightRow( filter ) {
        for(let i = 0; i < this.rows.length; ++i)
            this.#highlight( this.rows[i][1], filter(this.rows[i][0], i) );
    }

    highlightCells( filter ) {

        for(let i = 0; i < this.rows.length; ++i) {

            const [row_data, row_html] = this.rows[i];
            const cols = Object.keys(row_data);

            for(let j = 0; j < cols.length; ++j)
                this.#highlight( row_html.children[j] , filter(row_data, cols[j]) );
        }
    }
};


https_raw_githack_com_denis_migdal_LISS_main_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].define("sql-dymtable", SQLDymTable)
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/sql-interactive.js":
/*!***************************************!*\
  !*** ./src/struct/sql-interactive.js ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SQLite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SQLite */ "./src/struct/SQLite.ts");
/* harmony import */ var LISS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! LISS */ "./libs/LISS/index.ts");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_SQLite__WEBPACK_IMPORTED_MODULE_0__]);
_SQLite__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


// LISS



const content = `
    <slot name="select"></slot>
    <slot name="options"></slot>
    <slot></slot>
    <slot name="pre"></slot>
    <div class="choices">
        <div class="options"></div>
        <div class="query"></div>
    </div>
    <pre class="hljs"><code><div class="result"></div></code></pre>
    <div class="spacing"></div>
    <slot name="post"></slot>`;

const css = `
    :host([option]) pre {
        margin: 0;
    }

    :host {
        font-size: 14px;
        line-height: 19px;
    }

    .selected, .highlight {
        background-color: gold;
    }
    :host .spacing {
        flex-grow: 1;
    }
    :host .query pre.hljs {
        padding-right: 0;

        & > code > div {
            padding-right: 0;
        }
    }
    :host pre.hljs {

        margin: 2px;

        & > code > div {
           padding: 8px;
        }
    }
    .options pre {
        position: relative;
        padding-bottom: 4px;
        padding-right: 25px;

        &.withdesc {
            padding-top: 0px;
        }
    }
    .options pre::after {
        content: ">";
        position: absolute;
        right: 0px;
        top: 0px;
        height: 100%;
        width: 25px;
        background-color: orange;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        
    }
    .options pre:hover {
        opacity: 0.5;
    }
    :host {
        /*display: inline-flex;*/
        display: flex;
        gap: 5px;
    }
    slot:not([name="post"]):not([name="pre"]) {
        display: none;
    }
    span.value {
        border: 1px solid black;
        padding-left: 5px;
        padding-right: 5px;
    }

    .option {
        cursor: pointer;
    }

    .error {
        background-color: #FFA07A !important;
    }

    .query > pre .value {
        position: relative;
        margin-right: 13px;
    }

    .query > pre .value::after {

        right: -18px;
        position: absolute;
        content: "🖉";
    }

    :host > pre.hljs {
        /*flex-grow: 1;*/
    }

    :host .desc {
        margin-left: -0.5em;
        /*position: absolute;
        top: 0px;
        left: 0px;*/

        font-size: 14px;
        line-height: 19px;

        width: calc(100% + 0.5em);
        border-left: none;
        border-top: none;
        padding-left: 5px;
        font-style: italic;

        box-sizing: border-box;

        background-color: lightgray;
        opacity: 0.6;
    }

    pre {
        padding: 0.5em;
        background-color: white;
        color: black;
    }

    code {
        font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
    }

    /* Tomorrow Theme */
    /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
    /* Original theme - https://github.com/chriskempson/tomorrow-theme */

    /* Tomorrow Comment */
    .hljs-comment,
    .hljs-quote {
        color: #8e908c;
    }

    /* Tomorrow Red */
    .hljs-variable,
    .hljs-template-variable,
    .hljs-tag,
    .hljs-name,
    .hljs-selector-id,
    .hljs-selector-class,
    .hljs-regexp,
    .hljs-deletion {
        color: #c82829;
    }

    /* Tomorrow Orange */
    .hljs-number,
    .hljs-built_in,
    .hljs-builtin-name,
    .hljs-literal,
    .hljs-type,
    .hljs-params,
    .hljs-meta,
    .hljs-link {
        color: #f5871f;
    }

    /* Tomorrow Yellow */
    .hljs-attribute {
        color: #eab700;
    }

    /* Tomorrow Green */
    .hljs-string,
    .hljs-symbol,
    .hljs-bullet,
    .hljs-addition {
        color: #718c00;
    }

    /* Tomorrow Blue */
    .hljs-title,
    .hljs-section {
        color: #4271ae;
    }

    /* Tomorrow Purple */
    .hljs-keyword,
    .hljs-selector-tag {
        color: #8959a8;
    }

    .hljs {
        display: block;
        overflow-x: auto;
        color: #4d4d4c;
        padding: 0.5em;
    }

    .hljs-emphasis {
        font-style: italic;
    }

    .hljs-strong {
        font-weight: bold;
    }
`;

/*
const styles = [...document.querySelectorAll('style')].map(s => {
    let style = new CSSStyleSheet();
    style.replaceSync(s.textContent);
    return style;
});*/

class SQLInteractive extends (0,LISS__WEBPACK_IMPORTED_MODULE_1__["default"])({
    content,
    css: [css],
    attributes: ["full-reset", "option"]
}) {

    #result   = "";
    #query    = null;
    #options  = null;
    #input    = null;
    #selected = null;

    #selectQuery = null;

    onAttrChanged(name, _old, value) {
        if(name !== "option")
            return;

        setOption(+value);
    }

    setOption(idx) {

        for(let i = 0; i < this.#options.children.length; ++i) {
            const opt = this.#options.children[i];
            opt.style.setProperty("display", i === idx ? null : "none");
            if( i === idx)
                opt.click();
        }
        this.#query.style.setProperty("display", "none");

        this.host.style.setProperty("flex-wrap", "wrap");

    }

    constructor() {
        super();

        this.#result   = this.content.querySelector(".result");
        this.#query    = this.content.querySelector(".query");
        this.#options  = this.content.querySelector(".options");
 
        let selectQuery = this.content.querySelector("slot[name='select']").assignedElements();
        if(selectQuery.length === 1)
            this.#selectQuery  = selectQuery[0].textContent;

        this.#options.addEventListener("click", (ev) => {

            let option = ev.target.closest(".option");
            if(option === null)
                return;
            ev.preventDefault();

            if(this.#selected !== null)
                this.#selected.classList.remove('selected');
            option.classList.add('selected');
            this.#selected = option;

            this.lastVars = {};

            const optsvalues = option.querySelectorAll('.value');
            for( let optsvalue of optsvalues) { // not optimal but it works

                this.lastVars[optsvalue.dataset.name] = optsvalue.textContent;

                const values = this.#input.querySelectorAll(`.value[data-name="${optsvalue.dataset.name}"]`);
                for(let value of values)
                    value.textContent = optsvalue.textContent;
            }

            this.#execQuery( );
        });

        let query = this.content.querySelector("slot:not([name])").assignedElements()[0];
        //TODO: find & replace...

        this.#input = query.cloneNode(true);

        this.#query.append(this.#input);

        let options = this.content.querySelector("slot[name='options']").assignedElements();

        const childNodes = [...this.#input.children[0].childNodes];

        for(let i = 0; i < childNodes.length; ++i) {

            const node = childNodes[i];
            if( node.nodeType !== Node.TEXT_NODE)
                continue;

            let text = node.textContent;
            let start = text.indexOf('$');
            if( start === -1)
                continue;

            let result = [];

            while( start !== -1) { // not optimal but it works...
                
                let end = text.slice(start+1).search(/[\W]/);
                
                if( end === -1) {
                    console.log( text, start, text.slice(start+1) );
                    throw new Error('End of SQL variable not found (you likely used a reserved keyword)');
                }
                end += start + 1;

                const value = document.createElement("span");
                value.classList.add("value");
                value.dataset.name = text.slice(start+1, end).toLowerCase();

                result.push(... text.slice(0, start), value );

                text = text.slice(end);
                start = text.indexOf('$');
            }

            result.push(text);

            node.replaceWith(...result);
        }

        let option_template = this.#input.cloneNode(true);

        const values = this.#input.querySelectorAll('.value');
        for(let value of values) {

            value.toggleAttribute('contenteditable');
            if( ! value.dataset.name.startsWith('m_') ) {
                value.addEventListener('keypress', (ev) => {

                    if(ev.key === "Enter") {
                        ev.preventDefault();
                        value.blur();
                        return;
                    }
                });
            }


            value.addEventListener('input', (ev) => {

                if(this.#selected !== null)
                    this.#selected.classList.remove('selected');
                this.#input.classList.add('selected');
                this.#selected = this.#input;

                const syncinputs = this.#input.querySelectorAll(`.value[data-name="${ev.target.dataset.name}"]`);
                for( let input of syncinputs ) {
                    if(input === ev.target)
                        continue;
                    input.textContent = ev.target.textContent;
                }

                this.#execQuery();
            });
        }

        for(let option of options) {

            const opt = option_template.cloneNode(true);
            opt.classList.add("option");

            const values = opt.querySelectorAll('.value');
            for(let value of values) {
                const name  = value.dataset.name;
                value.textContent = option.dataset[ name ];
            }

            if( option.textContent !== "") {
                opt.classList.add('withdesc');

                const desc = document.createElement('div');
                desc.classList.add("desc");
                desc.textContent = option.textContent.trim() + " :";

                opt.firstElementChild.before(desc);
            }

            this.#options.append( opt );
        }

        if( this.attrs.option !== null) {
            this.setOption(+this.attrs.option);
            return;
        }

        if( this.#selectQuery === null)
            this.#options.firstElementChild.click();
    }

    #getQuery() {

        let query = "";
        for(let elem of this.#input.firstElementChild.childNodes ) {

            const content = elem.textContent;
            if(content === "" && elem instanceof HTMLElement && elem.classList.contains("value")) {
                if( query[query.length-1] === " " )
                    query = query.slice(0,-1);
            }
            query += elem.textContent;
        }

        return query;
    }

    #execQuery() {


        let queries = this.#getQuery().split(';\n').slice(0,-1).map( q => q + ";");

        // build queries to execute...

        const exec_queries = [];
        let show_table = true;

        let show_queries = null;
        if( this.#selectQuery !== null ) {
            show_queries = this.#selectQuery.split(';').slice(0,-1).map( q => q.trim() + ";");
        }

        const show = () => {
            show_table = false;
            if( show_queries === null )
                return;
            exec_queries.push(...show_queries);
        }

        for(let i = 0; i < queries.length; ++i) {
            const query = queries[i];

            if( query.startsWith("SELECT ") ) {
                exec_queries.push(query);
                continue;
            }

            if( query.startsWith("CREATE TABLE ") ) {

                let q = "CREATE TABLE ";
                if( query.startsWith("CREATE TABLE IF EXISTS ") )
                    q = "CREATE TABLE IF EXISTS ";

                exec_queries.push(query);
                const tb_name = query.slice(13, query.indexOf(" ", q.length) );
                exec_queries.push(`SELECT name, type, "notnull", dflt_value, pk, hidden\n        FROM pragma_table_xinfo('${tb_name}');`);
                show_table = false;
                continue;
            }

            if( show_table )
                show();

            exec_queries.push(query);

            show();
        }

        let results = _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.exec_many(exec_queries);
        this.updateResult(exec_queries, results);
        
        if( this.attrs["full-reset"] === "true")
            _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.fullReset();
        else
            _SQLite__WEBPACK_IMPORTED_MODULE_0__.db2.reset();
    }


    #hline(colsizes) {
        let result = '+';
        for(let colsize of colsizes)
            result += "".padEnd(colsize + 2, "-") + '+';

        return result;
    }

    #padRow(row, colsizes) {
        return row.map( (_, i) => row[i].padEnd(colsizes[i] + 1, " ") );
    }
    #rawline(row) {
        let result = "|";
        for(let i = 0; i < row.length; ++i)
            result += " " + row[i] + "|";

        result += "\n";
        return result;

    }

    #line(row, colsizes) {
        let result = "|";
        for(let i = 0; i < colsizes.length; ++i)
            result += " " + row[i].padEnd(colsizes[i] + 1, " ") + "|";

        result += "\n";
        return result;
    }

    updateResult(queries, datas) {

        this.#input.classList.remove('error');
        this.#result.classList.remove('error');
        let content = '';

        for(let i = 0; i < datas.length; ++i) {

            let compare_to = null;

            // correct select
            if( datas[i] !== null && typeof datas[i] !== "string") {

                // compare_to last or first
                for(let j = datas.length - 1; j > i; --j)
                    if( queries[j] === queries[i] && datas[j] !== null && typeof datas[j] !== "string" ) {
                        compare_to = datas[j];
                        break;
                    }
                
                if( compare_to === null) {

                    for(let j = 0; j < i; ++j)
                        if( queries[j] === queries[i] && datas[j] !== null && typeof datas[j] !== "string" ) {
                            compare_to = datas[j];
                            break;
                        }
                }
            }

            const query = queries[i];
            const data  = datas[i];

            content += `sqlite> ${query}\n`;

            if( data === null )
                continue;

            if( typeof data === "string") { // exception

                this.#input.classList.add('error');
                this.#result.classList.add('error');

                content += data;

                continue;
            }

            if( data.length === 0 ) {
                content += `No row returned.\n`;
                continue;
            }

            const headers = Object.keys(data[0]);
            const results = [
                ... data.map(entry => Object.values(entry).map(value => {
                        if( value === null )
                            return 'N/A';
                        if(typeof value === 'string')
                            return `'${value}'`;
                        return value.toString()
                    }) )   
            ];
    
            const colsizes = new Array(headers.length);
            for(let i = 0; i < colsizes.length; ++i) {
                colsizes[i] = headers[i].length;
                for(let row of results)
                    if( row[i].length > colsizes[i] )
                        colsizes[i] = row[i].length;
            }
    
    
            let result_text = this.#hline(colsizes) + "\n";
            result_text +=  this.#line(headers, colsizes);
            result_text +=  this.#hline(colsizes) + "\n";
            for(let j = 0; j < results.length; ++j) {

                let row = results[j];

                if( compare_to === null) {
                    result_text += this.#line(row, colsizes);
                    continue;
                }

                // highlight changes

                let key = "ID";
                if( ! (key in data[j]) )
                    key = "name";

                let cmp_line = compare_to.find( e => e[key] === data[j][key]); // h4cky

                row = this.#padRow(row, colsizes);

                if( cmp_line === undefined) {
                    row = row.map( c => `<strong><em>${c}</em></strong>`);
                    let line = this.#rawline(row);
                    result_text += `<span class="highlight">${line}</span>`;
                    continue;
                }

                for(let i = 0; i < headers.length; ++i) {
                    const colname = headers[i];

                    if( data[j][colname] !== cmp_line[colname])
                        row[i] = `<span class=highlight><em><strong>${row[i]}</strong></em></span>`;
                    
                }

                result_text += this.#rawline(row);
            }
            result_text +=  this.#hline(colsizes);
    
            content += result_text + '\n';   
        }

        this.#result.innerHTML = content;

        this.#lastDatas = datas;

        this.host.dispatchEvent( new CustomEvent("change", {detail: {
            datas
        }}) );
    }

    #lastDatas = null;

    get lastDatas() {
        return this.#lastDatas;
    }
}

LISS__WEBPACK_IMPORTED_MODULE_1__["default"].define("sql-interactive", SQLInteractive)
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./src/struct/sqlite/sqlite3.js":
/*!**************************************!*\
  !*** ./src/struct/sqlite/sqlite3.js ***!
  \**************************************/
/***/ ((module) => {

/*
** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.
**
** This bundle (typically released as sqlite3.js or sqlite3.mjs)
** is an amalgamation of JavaScript source code from two projects:
**
** 1) https://emscripten.org: the Emscripten "glue code" is covered by
**    the terms of the MIT license and University of Illinois/NCSA
**    Open Source License, as described at:
**
**    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html
**
** 2) https://sqlite.org: all code and documentation labeled as being
**    from this source are released under the same terms as the sqlite3
**    C library:
**
** 2022-10-16
**
** The author disclaims copyright to this source code.  In place of a
** legal notice, here is a blessing:
**
** *   May you do good and not evil.
** *   May you find forgiveness for yourself and forgive others.
** *   May you share freely, never taking more than you give.
*/
/*
** This code was built from sqlite3 version...
**
** SQLITE_VERSION "3.45.2"
** SQLITE_VERSION_NUMBER 3045002
** SQLITE_SOURCE_ID "2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77"
**
** Using the Emscripten SDK version 3.1.30.
*/

var sqlite3InitModule = (() => {
  //var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  const ROOT = ["localhost", "127.0.0.1"].includes(location.hostname) ? "/dist/dev/" : "/Cours/dist/dev/";
  const _scriptDir = `${ROOT}assets/sql/sqlite3.wasm`;

  return (
function(config) {
  var sqlite3InitModule = config || {};
















var Module = typeof sqlite3InitModule != 'undefined' ? sqlite3InitModule : {};


var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});






const sqlite3InitModuleState = globalThis.sqlite3InitModuleState
      || Object.assign(Object.create(null),{
        debugModule: ()=>{}
      });
delete globalThis.sqlite3InitModuleState;
sqlite3InitModuleState.debugModule('globalThis.location =',globalThis.location);


Module['locateFile'] = function(path, prefix) {
  'use strict';
  let theFile;
  const up = this.urlParams;
  if(up.has(path)){
    theFile = up.get(path);
  }else if(this.sqlite3Dir){
    theFile = this.sqlite3Dir + path;
  }else if(this.scriptDir){
    theFile = this.scriptDir + path;
  }else{
    theFile = prefix + path;
  }
  sqlite3InitModuleState.debugModule(
    "locateFile(",arguments[0], ',', arguments[1],")",
    'sqlite3InitModuleState.scriptDir =',this.scriptDir,
    'up.entries() =',Array.from(up.entries()),
    "result =", theFile
  );
  return theFile;
}.bind(sqlite3InitModuleState);


const xNameOfInstantiateWasm =  false
      ? 0
      : 'emscripten-bug-17951';
Module[xNameOfInstantiateWasm] = function callee(imports,onSuccess){
  imports.env.foo = function(){};
  const uri = Module.locateFile(
    callee.uri, (
      ('undefined'===typeof scriptDirectory)
        ? "" : scriptDirectory)
  );
  sqlite3InitModuleState.debugModule(
    "instantiateWasm() uri =", uri
  );
  const wfetch = ()=>fetch(uri, {credentials: 'same-origin'});
  const loadWasm = WebAssembly.instantiateStreaming
        ? async ()=>{
          return WebAssembly.instantiateStreaming(wfetch(), imports)
            .then((arg)=>onSuccess(arg.instance, arg.module));
        }
        : async ()=>{ 
          return wfetch()
            .then(response => response.arrayBuffer())
            .then(bytes => WebAssembly.instantiate(bytes, imports))
            .then((arg)=>onSuccess(arg.instance, arg.module));
        };
  loadWasm();
  return {};
};

Module[xNameOfInstantiateWasm].uri = 'sqlite3.wasm';








var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};





var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';


var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;


var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}


var read_,
    readAsync,
    readBinary,
    setWindowTitle;




if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { 
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { 
    scriptDirectory = document.currentScript.src;
  }
  
  
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  
  
  
  
  
  
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  
  
  {



  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array((xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { 
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }


  }

  setWindowTitle = (title) => document.title = title;
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);


Object.assign(Module, moduleOverrides);


moduleOverrides = null;






if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];






var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': case 'u8': return 1;
    case 'i16': case 'u16': return 2;
    case 'i32': case 'u32': return 4;
    case 'i64': case 'u64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      }
      if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      }
      return 0;
    }
  }
}



















var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}



var wasmMemory;







var ABORT = false;




var EXITSTATUS;


function assert(condition, text) {
  if (!condition) {
    
    
    
    abort(text);
  }
}







var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;


function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  
  
  
  
  
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  }
  var str = '';
  
  
  while (idx < endPtr) {
    
    
    
    
    var u0 = heapOrArray[idx++];
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    var u1 = heapOrArray[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    var u2 = heapOrArray[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
    }

    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
  return str;
}


function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}


function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  
  
  if (!(maxBytesToWrite > 0))
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; 
  for (var i = 0; i < str.length; ++i) {
    
    
    
    
    
    
    
    var u = str.charCodeAt(i); 
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  
  heap[outIdx] = 0;
  return outIdx - startIdx;
}


function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}


function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    
    
    
    
    var c = str.charCodeAt(i); 
    if (c <= 0x7F) {
      len++;
    } else if (c <= 0x7FF) {
      len += 2;
    } else if (c >= 0xD800 && c <= 0xDFFF) {
      len += 4; ++i;
    } else {
      len += 3;
    }
  }
  return len;
}




var HEAP,

  HEAP8,

  HEAPU8,

  HEAP16,

  HEAPU16,

  HEAP32,

  HEAPU32,

  HEAPF32,

  HEAP64,

  HEAPU64,

  HEAPF64;

function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
  Module['HEAP64'] = HEAP64 = new BigInt64Array(b);
  Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);
}

var STACK_SIZE = 524288;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;







  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      
      
      
      
      
      'maximum': 2147483648 / 65536
    });
  }

updateMemoryViews();



INITIAL_MEMORY = wasmMemory.buffer.byteLength;







var wasmTable;










var __ATPRERUN__  = []; 
var __ATINIT__    = []; 
var __ATEXIT__    = []; 
var __ATPOSTRUN__ = []; 

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}




















var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; 

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); 
    }
  }
}


function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what = 'Aborted(' + what + ')';
  
  
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what += '. Build with -sASSERTIONS for more info.';

  
  
  
  
  
  
  
  

  
  
  
  
  
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  
  
  
  throw e;
}











var dataURIPrefix = 'data:application/octet-stream;base64,';


function isDataURI(filename) {
  
  return filename.startsWith(dataURIPrefix);
}


function isFileURI(filename) {
  return filename.startsWith('file://');
}


var wasmBinaryFile;
  wasmBinaryFile = 'sqlite3.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  
  
  
  
  
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
  }

  
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}



function createWasm() {
  
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  
  
  
  
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  
  addRunDependency('wasm-instantiate');

  
  function receiveInstantiationResult(result) {
    
    
    
    
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        
        
        
        
        
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            
            
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  
  
  
  
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
        
        readyPromiseReject(e);
    }
  }

  
  instantiateAsync().catch(readyPromiseReject);
  return {}; 
}


var tempDouble;
var tempI64;



var ASM_CONSTS = {
  
};





  
  function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = 'Program terminated with exit(' + status + ')';
      this.status = status;
    }

  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        
        callbacks.shift()(Module);
      }
    }

  
    
  function getValue(ptr, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP64[((ptr)>>3)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return HEAPF64[((ptr)>>3)];
        case '*': return HEAPU32[((ptr)>>2)];
        default: abort('invalid type for getValue: ' + type);
      }
      return null;
    }

  
    
  function setValue(ptr, value, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': HEAP8[((ptr)>>0)] = value; break;
        case 'i8': HEAP8[((ptr)>>0)] = value; break;
        case 'i16': HEAP16[((ptr)>>1)] = value; break;
        case 'i32': HEAP32[((ptr)>>2)] = value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)] = value; break;
        case 'double': HEAPF64[((ptr)>>3)] = value; break;
        case '*': HEAPU32[((ptr)>>2)] = value; break;
        default: abort('invalid type for setValue: ' + type);
      }
    }

  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:(parts, allowAboveRoot) => {
        
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          
          return '.';
        }
        if (dir) {
          
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:(path) => {
        
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },join:function() {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join('/'));
      },join2:(l, r) => {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        
        var randomBuffer = new Uint8Array(1);
        return () => { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      
      return () => abort("randomDevice");
    }
  
  
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; 
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        
        
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  
  
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }
  var TTY = {ttys:[],init:function () {
        
        
        
        
        
        
        
        
      },shutdown:function() {
        
        
        
        
        
        
        
        
        
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          
          stream.tty.ops.fsync(stream.tty);
        },fsync:function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },read:function(stream, buffer, offset, length, pos ) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              
              result = window.prompt('Input: ');  
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); 
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
      return address;
    }
  
  function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
  function mmapAlloc(size) {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      return zeroMemory(ptr, size);
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 , 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; 
          
          
          
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); 
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; 
        
        
        
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); 
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); 
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); 
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; 
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); 
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); 
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          
          
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511  | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { 
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          
          
          
          
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { 
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { 
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { 
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; 
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          
          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
            
            
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          
          return 0;
        }}};
  
  
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, (arrayBuffer) => {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, (event) => {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  
          throw new FS.ErrnoError(32);
        }
  
        
        var parts = path.split('/').filter((p) => !!p);
  
        
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          
          
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || 
              (flags & 512)) { 
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream =  function() {
            this.shared = { };
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              
              get: function() { return this.node; },
              
              set: function(val) { this.node = val; }
            },
            isRead: {
              
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              
              get: function() { return (this.flags & 1024); }
            },
            flags: {
              
              get: function() { return this.shared.flags; },
              
              set: function(val) { this.shared.flags = val; },
            },
            position : {
              
              get: function() { return this.shared.position; },
              
              set: function(val) { this.shared.position = val; },
            },
          });
        }
        
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          
          stream.stream_ops = device.stream_ops;
          
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          
          node.mounted = mount;
  
          
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        
        node.mounted = null;
  
        
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 ;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 ;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 ;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        
        var lookup, old_dir, new_dir;
  
        
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        
        var old_node = FS.lookupNode(old_dir, old_name);
        
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          
        }
        
        if (old_node === new_node) {
          return;
        }
        
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        
        
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        
        FS.hashRemoveNode(old_node);
        
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          
          
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          
          
          
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438  : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            
          }
        }
        
        var created = false;
        if ((flags & 64)) {
          if (node) {
            
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        
        
        
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        
        flags &= ~(128 | 512 | 131072);
  
        
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          
          ungotten: [],
          error: false
        });
        
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; 
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, length, position, prot, flags) => {
        
        
        
        
        
        
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        
        FS.mkdir('/dev');
        
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        
        
        
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        
        
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        
        
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 , 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; 
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        
        
        
  
        
        
        
        
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError =  function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno =  function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        
        
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },analyzePath:(path, dontResolveLastLink) => {
        
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        
        
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos ) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          
          try {
            
            
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        
        
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; 
        }
        LazyUint8Array.prototype.get =  function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; 
  
          if (!hasByteServing) chunkSize = datalength;
  
          
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array((xhr.response || []));
            }
            return intArrayFromString(xhr.responseText || '', true);
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; 
            end = Math.min(end, datalength-1); 
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            
            chunkSize = datalength = 1; 
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get:  function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get:  function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        
        
        
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        
        Object.defineProperties(node, {
          usedBytes: {
            get:  function() { return this.contents.length; }
          }
        });
        
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { 
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { 
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr: ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        
        
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); 
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; 
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAPU32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        (tempI64 = [Math.floor(atime / 1000)>>>0,(tempDouble=Math.floor(atime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(64))>>2)] = (atime % 1000) * 1000;
        (tempI64 = [Math.floor(mtime / 1000)>>>0,(tempDouble=Math.floor(mtime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(80))>>2)] = (mtime % 1000) * 1000;
        (tempI64 = [Math.floor(ctime / 1000)>>>0,(tempDouble=Math.floor(ctime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(96))>>2)] = (ctime % 1000) * 1000;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(104))>>2)] = tempI64[0],HEAP32[(((buf)+(108))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      }};
  function ___syscall_chmod(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        
        return -28;
      }
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node) {
        return -44;
      }
      var perms = '';
      if (amode & 4) perms += 'r';
      if (amode & 2) perms += 'w';
      if (amode & 1) perms += 'x';
      if (perms  && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchmod(fd, mode) {
  try {
  
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchown32(fd, owner, group) {
  try {
  
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  
  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5:
         {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 6:
        case 7:
        
        
          
          
          return 0; 
        case 16:
        case 8:
          return -28; 
        case 9:
          
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var MAX_INT53 = 9007199254740992;
  
  var MIN_INT53 = -9007199254740992;
  function bigintToI53Checked(num) {
      return (num < MIN_INT53 || num > MAX_INT53) ? NaN : Number(num);
    }
  
  
  
  
  function ___syscall_ftruncate64(fd,  length) {
  try {
  
      length = bigintToI53Checked(length); if (isNaN(length)) return -61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes) return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; 
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; 
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          
          
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          
          
          
          if (!stream.tty) return -59;
          return 0;
        }
        default: return -28; 
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdirat(dirfd, path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      
      
      path = PATH.normalize(path);
      if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~6400);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0) return -28;
      var ret = FS.readlink(path);
  
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf+len];
      stringToUTF8(ret, buf, bufsize+1);
      
      
      HEAP8[buf+len] = endChar;
      return len;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function readI53FromI64(ptr) {
      return HEAPU32[ptr>>2] + HEAP32[ptr+4>>2] * 4294967296;
    }
  
  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[(((times)+(8))>>2)];
        atime = (seconds*1000) + (nanoseconds/(1000*1000));
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[(((times)+(8))>>2)];
        mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var nowIsMonotonic = true;;
  function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

  
  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  var __MONTH_DAYS_LEAP_CUMULATIVE = [0,31,60,91,121,152,182,213,244,274,305,335];
  
  var __MONTH_DAYS_REGULAR_CUMULATIVE = [0,31,59,90,120,151,181,212,243,273,304,334];
  function __yday_from_date(date) {
      var isLeapYear = __isLeapYear(date.getFullYear());
      var monthDaysCumulative = (isLeapYear ? __MONTH_DAYS_LEAP_CUMULATIVE : __MONTH_DAYS_REGULAR_CUMULATIVE);
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; 
  
      return yday;
    }
  function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time)*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var yday = __yday_from_date(date)|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    }

  
  
  function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, off, prot, flags);
      var ptr = res.ptr;
      HEAP32[((allocated)>>2)] = res.allocated;
      HEAPU32[((addr)>>2)] = ptr;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  
  
  function __munmap_js(addr, len, prot, flags, fd, offset) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
      
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }
  function __tzset_js(timezone, daylight, tzname) {
      
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      
      
      
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      
      
      
      
      
      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        
        HEAPU32[((tzname)>>2)] = winterNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = summerNamePtr;
      } else {
        HEAPU32[((tzname)>>2)] = summerNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = winterNamePtr;
      }
    }

  function _emscripten_date_now() {
      return Date.now();
    }

  var _emscripten_get_now;_emscripten_get_now = () => performance.now();
  ;

  function getHeapMax() {
      
      
      
      
      return 2147483648;
    }
  
  function emscripten_realloc_buffer(size) {
      var b = wasmMemory.buffer;
      try {
        
        wasmMemory.grow((size - b.byteLength + 65535) >>> 16); 
        updateMemoryViews();
        return 1 ;
      } catch(e) {
      }
      
      
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      
      
  
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
  
      
      
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
  
      
      
      
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); 
        
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    }

  var ENV = {};
  
  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        
        
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        
        for (var x in ENV) {
          
          
          
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  
  
  function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
      }
      
      if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
    }
  
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  
  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      
      
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)] = type;
      
      
      
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; 
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }
  
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  
  
  
  function _fd_seek(fd,  offset, whence, newOffset) {
  try {
  
      offset = bigintToI53Checked(offset); if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; 
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_sync(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (stream.stream_ops && stream.stream_ops.fsync) {
        return stream.stream_ops.fsync(stream);
      }
      return 0; 
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  
  function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (typeof offset !== 'undefined') {
          offset += curr;
        }
      }
      return ret;
    }
  
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  var FSNode =  function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292 | 73;
  var writeMode = 146;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: function() {
     return (this.mode & readMode) === readMode;
    },
    set: function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
var ASSERTIONS = false;

var asmLibraryArg = {
  "__syscall_chmod": ___syscall_chmod,
  "__syscall_faccessat": ___syscall_faccessat,
  "__syscall_fchmod": ___syscall_fchmod,
  "__syscall_fchown32": ___syscall_fchown32,
  "__syscall_fcntl64": ___syscall_fcntl64,
  "__syscall_fstat64": ___syscall_fstat64,
  "__syscall_ftruncate64": ___syscall_ftruncate64,
  "__syscall_getcwd": ___syscall_getcwd,
  "__syscall_ioctl": ___syscall_ioctl,
  "__syscall_lstat64": ___syscall_lstat64,
  "__syscall_mkdirat": ___syscall_mkdirat,
  "__syscall_newfstatat": ___syscall_newfstatat,
  "__syscall_openat": ___syscall_openat,
  "__syscall_readlinkat": ___syscall_readlinkat,
  "__syscall_rmdir": ___syscall_rmdir,
  "__syscall_stat64": ___syscall_stat64,
  "__syscall_unlinkat": ___syscall_unlinkat,
  "__syscall_utimensat": ___syscall_utimensat,
  "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
  "_localtime_js": __localtime_js,
  "_mmap_js": __mmap_js,
  "_munmap_js": __munmap_js,
  "_tzset_js": __tzset_js,
  "emscripten_date_now": _emscripten_date_now,
  "emscripten_get_now": _emscripten_get_now,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "fd_close": _fd_close,
  "fd_fdstat_get": _fd_fdstat_get,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_sync": _fd_sync,
  "fd_write": _fd_write,
  "memory": wasmMemory
};
var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};


var _sqlite3_status64 = Module["_sqlite3_status64"] = function() {
  return (_sqlite3_status64 = Module["_sqlite3_status64"] = Module["asm"]["sqlite3_status64"]).apply(null, arguments);
};


var _sqlite3_status = Module["_sqlite3_status"] = function() {
  return (_sqlite3_status = Module["_sqlite3_status"] = Module["asm"]["sqlite3_status"]).apply(null, arguments);
};


var _sqlite3_db_status = Module["_sqlite3_db_status"] = function() {
  return (_sqlite3_db_status = Module["_sqlite3_db_status"] = Module["asm"]["sqlite3_db_status"]).apply(null, arguments);
};


var _sqlite3_msize = Module["_sqlite3_msize"] = function() {
  return (_sqlite3_msize = Module["_sqlite3_msize"] = Module["asm"]["sqlite3_msize"]).apply(null, arguments);
};


var _sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = function() {
  return (_sqlite3_vfs_find = Module["_sqlite3_vfs_find"] = Module["asm"]["sqlite3_vfs_find"]).apply(null, arguments);
};


var _sqlite3_initialize = Module["_sqlite3_initialize"] = function() {
  return (_sqlite3_initialize = Module["_sqlite3_initialize"] = Module["asm"]["sqlite3_initialize"]).apply(null, arguments);
};


var _sqlite3_malloc = Module["_sqlite3_malloc"] = function() {
  return (_sqlite3_malloc = Module["_sqlite3_malloc"] = Module["asm"]["sqlite3_malloc"]).apply(null, arguments);
};


var _sqlite3_free = Module["_sqlite3_free"] = function() {
  return (_sqlite3_free = Module["_sqlite3_free"] = Module["asm"]["sqlite3_free"]).apply(null, arguments);
};


var _sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = function() {
  return (_sqlite3_vfs_register = Module["_sqlite3_vfs_register"] = Module["asm"]["sqlite3_vfs_register"]).apply(null, arguments);
};


var _sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = function() {
  return (_sqlite3_vfs_unregister = Module["_sqlite3_vfs_unregister"] = Module["asm"]["sqlite3_vfs_unregister"]).apply(null, arguments);
};


var _sqlite3_malloc64 = Module["_sqlite3_malloc64"] = function() {
  return (_sqlite3_malloc64 = Module["_sqlite3_malloc64"] = Module["asm"]["sqlite3_malloc64"]).apply(null, arguments);
};


var _sqlite3_realloc = Module["_sqlite3_realloc"] = function() {
  return (_sqlite3_realloc = Module["_sqlite3_realloc"] = Module["asm"]["sqlite3_realloc"]).apply(null, arguments);
};


var _sqlite3_realloc64 = Module["_sqlite3_realloc64"] = function() {
  return (_sqlite3_realloc64 = Module["_sqlite3_realloc64"] = Module["asm"]["sqlite3_realloc64"]).apply(null, arguments);
};


var _sqlite3_value_text = Module["_sqlite3_value_text"] = function() {
  return (_sqlite3_value_text = Module["_sqlite3_value_text"] = Module["asm"]["sqlite3_value_text"]).apply(null, arguments);
};


var _sqlite3_randomness = Module["_sqlite3_randomness"] = function() {
  return (_sqlite3_randomness = Module["_sqlite3_randomness"] = Module["asm"]["sqlite3_randomness"]).apply(null, arguments);
};


var _sqlite3_stricmp = Module["_sqlite3_stricmp"] = function() {
  return (_sqlite3_stricmp = Module["_sqlite3_stricmp"] = Module["asm"]["sqlite3_stricmp"]).apply(null, arguments);
};


var _sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = function() {
  return (_sqlite3_strnicmp = Module["_sqlite3_strnicmp"] = Module["asm"]["sqlite3_strnicmp"]).apply(null, arguments);
};


var _sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = function() {
  return (_sqlite3_uri_parameter = Module["_sqlite3_uri_parameter"] = Module["asm"]["sqlite3_uri_parameter"]).apply(null, arguments);
};


var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};


var _sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = function() {
  return (_sqlite3_uri_boolean = Module["_sqlite3_uri_boolean"] = Module["asm"]["sqlite3_uri_boolean"]).apply(null, arguments);
};


var _sqlite3_serialize = Module["_sqlite3_serialize"] = function() {
  return (_sqlite3_serialize = Module["_sqlite3_serialize"] = Module["asm"]["sqlite3_serialize"]).apply(null, arguments);
};


var _sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = function() {
  return (_sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = Module["asm"]["sqlite3_prepare_v2"]).apply(null, arguments);
};


var _sqlite3_step = Module["_sqlite3_step"] = function() {
  return (_sqlite3_step = Module["_sqlite3_step"] = Module["asm"]["sqlite3_step"]).apply(null, arguments);
};


var _sqlite3_column_int64 = Module["_sqlite3_column_int64"] = function() {
  return (_sqlite3_column_int64 = Module["_sqlite3_column_int64"] = Module["asm"]["sqlite3_column_int64"]).apply(null, arguments);
};


var _sqlite3_reset = Module["_sqlite3_reset"] = function() {
  return (_sqlite3_reset = Module["_sqlite3_reset"] = Module["asm"]["sqlite3_reset"]).apply(null, arguments);
};


var _sqlite3_exec = Module["_sqlite3_exec"] = function() {
  return (_sqlite3_exec = Module["_sqlite3_exec"] = Module["asm"]["sqlite3_exec"]).apply(null, arguments);
};


var _sqlite3_column_int = Module["_sqlite3_column_int"] = function() {
  return (_sqlite3_column_int = Module["_sqlite3_column_int"] = Module["asm"]["sqlite3_column_int"]).apply(null, arguments);
};


var _sqlite3_finalize = Module["_sqlite3_finalize"] = function() {
  return (_sqlite3_finalize = Module["_sqlite3_finalize"] = Module["asm"]["sqlite3_finalize"]).apply(null, arguments);
};


var _sqlite3_file_control = Module["_sqlite3_file_control"] = function() {
  return (_sqlite3_file_control = Module["_sqlite3_file_control"] = Module["asm"]["sqlite3_file_control"]).apply(null, arguments);
};


var _sqlite3_column_name = Module["_sqlite3_column_name"] = function() {
  return (_sqlite3_column_name = Module["_sqlite3_column_name"] = Module["asm"]["sqlite3_column_name"]).apply(null, arguments);
};


var _sqlite3_column_text = Module["_sqlite3_column_text"] = function() {
  return (_sqlite3_column_text = Module["_sqlite3_column_text"] = Module["asm"]["sqlite3_column_text"]).apply(null, arguments);
};


var _sqlite3_column_type = Module["_sqlite3_column_type"] = function() {
  return (_sqlite3_column_type = Module["_sqlite3_column_type"] = Module["asm"]["sqlite3_column_type"]).apply(null, arguments);
};


var _sqlite3_errmsg = Module["_sqlite3_errmsg"] = function() {
  return (_sqlite3_errmsg = Module["_sqlite3_errmsg"] = Module["asm"]["sqlite3_errmsg"]).apply(null, arguments);
};


var _sqlite3_deserialize = Module["_sqlite3_deserialize"] = function() {
  return (_sqlite3_deserialize = Module["_sqlite3_deserialize"] = Module["asm"]["sqlite3_deserialize"]).apply(null, arguments);
};


var _sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = function() {
  return (_sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = Module["asm"]["sqlite3_clear_bindings"]).apply(null, arguments);
};


var _sqlite3_value_blob = Module["_sqlite3_value_blob"] = function() {
  return (_sqlite3_value_blob = Module["_sqlite3_value_blob"] = Module["asm"]["sqlite3_value_blob"]).apply(null, arguments);
};


var _sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = function() {
  return (_sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = Module["asm"]["sqlite3_value_bytes"]).apply(null, arguments);
};


var _sqlite3_value_double = Module["_sqlite3_value_double"] = function() {
  return (_sqlite3_value_double = Module["_sqlite3_value_double"] = Module["asm"]["sqlite3_value_double"]).apply(null, arguments);
};


var _sqlite3_value_int = Module["_sqlite3_value_int"] = function() {
  return (_sqlite3_value_int = Module["_sqlite3_value_int"] = Module["asm"]["sqlite3_value_int"]).apply(null, arguments);
};


var _sqlite3_value_int64 = Module["_sqlite3_value_int64"] = function() {
  return (_sqlite3_value_int64 = Module["_sqlite3_value_int64"] = Module["asm"]["sqlite3_value_int64"]).apply(null, arguments);
};


var _sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = function() {
  return (_sqlite3_value_subtype = Module["_sqlite3_value_subtype"] = Module["asm"]["sqlite3_value_subtype"]).apply(null, arguments);
};


var _sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = function() {
  return (_sqlite3_value_pointer = Module["_sqlite3_value_pointer"] = Module["asm"]["sqlite3_value_pointer"]).apply(null, arguments);
};


var _sqlite3_value_type = Module["_sqlite3_value_type"] = function() {
  return (_sqlite3_value_type = Module["_sqlite3_value_type"] = Module["asm"]["sqlite3_value_type"]).apply(null, arguments);
};


var _sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = function() {
  return (_sqlite3_value_nochange = Module["_sqlite3_value_nochange"] = Module["asm"]["sqlite3_value_nochange"]).apply(null, arguments);
};


var _sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = function() {
  return (_sqlite3_value_frombind = Module["_sqlite3_value_frombind"] = Module["asm"]["sqlite3_value_frombind"]).apply(null, arguments);
};


var _sqlite3_value_dup = Module["_sqlite3_value_dup"] = function() {
  return (_sqlite3_value_dup = Module["_sqlite3_value_dup"] = Module["asm"]["sqlite3_value_dup"]).apply(null, arguments);
};


var _sqlite3_value_free = Module["_sqlite3_value_free"] = function() {
  return (_sqlite3_value_free = Module["_sqlite3_value_free"] = Module["asm"]["sqlite3_value_free"]).apply(null, arguments);
};


var _sqlite3_result_blob = Module["_sqlite3_result_blob"] = function() {
  return (_sqlite3_result_blob = Module["_sqlite3_result_blob"] = Module["asm"]["sqlite3_result_blob"]).apply(null, arguments);
};


var _sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = function() {
  return (_sqlite3_result_error_toobig = Module["_sqlite3_result_error_toobig"] = Module["asm"]["sqlite3_result_error_toobig"]).apply(null, arguments);
};


var _sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = function() {
  return (_sqlite3_result_error_nomem = Module["_sqlite3_result_error_nomem"] = Module["asm"]["sqlite3_result_error_nomem"]).apply(null, arguments);
};


var _sqlite3_result_double = Module["_sqlite3_result_double"] = function() {
  return (_sqlite3_result_double = Module["_sqlite3_result_double"] = Module["asm"]["sqlite3_result_double"]).apply(null, arguments);
};


var _sqlite3_result_error = Module["_sqlite3_result_error"] = function() {
  return (_sqlite3_result_error = Module["_sqlite3_result_error"] = Module["asm"]["sqlite3_result_error"]).apply(null, arguments);
};


var _sqlite3_result_int = Module["_sqlite3_result_int"] = function() {
  return (_sqlite3_result_int = Module["_sqlite3_result_int"] = Module["asm"]["sqlite3_result_int"]).apply(null, arguments);
};


var _sqlite3_result_int64 = Module["_sqlite3_result_int64"] = function() {
  return (_sqlite3_result_int64 = Module["_sqlite3_result_int64"] = Module["asm"]["sqlite3_result_int64"]).apply(null, arguments);
};


var _sqlite3_result_null = Module["_sqlite3_result_null"] = function() {
  return (_sqlite3_result_null = Module["_sqlite3_result_null"] = Module["asm"]["sqlite3_result_null"]).apply(null, arguments);
};


var _sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = function() {
  return (_sqlite3_result_pointer = Module["_sqlite3_result_pointer"] = Module["asm"]["sqlite3_result_pointer"]).apply(null, arguments);
};


var _sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = function() {
  return (_sqlite3_result_subtype = Module["_sqlite3_result_subtype"] = Module["asm"]["sqlite3_result_subtype"]).apply(null, arguments);
};


var _sqlite3_result_text = Module["_sqlite3_result_text"] = function() {
  return (_sqlite3_result_text = Module["_sqlite3_result_text"] = Module["asm"]["sqlite3_result_text"]).apply(null, arguments);
};


var _sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = function() {
  return (_sqlite3_result_zeroblob = Module["_sqlite3_result_zeroblob"] = Module["asm"]["sqlite3_result_zeroblob"]).apply(null, arguments);
};


var _sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = function() {
  return (_sqlite3_result_zeroblob64 = Module["_sqlite3_result_zeroblob64"] = Module["asm"]["sqlite3_result_zeroblob64"]).apply(null, arguments);
};


var _sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = function() {
  return (_sqlite3_result_error_code = Module["_sqlite3_result_error_code"] = Module["asm"]["sqlite3_result_error_code"]).apply(null, arguments);
};


var _sqlite3_user_data = Module["_sqlite3_user_data"] = function() {
  return (_sqlite3_user_data = Module["_sqlite3_user_data"] = Module["asm"]["sqlite3_user_data"]).apply(null, arguments);
};


var _sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = function() {
  return (_sqlite3_context_db_handle = Module["_sqlite3_context_db_handle"] = Module["asm"]["sqlite3_context_db_handle"]).apply(null, arguments);
};


var _sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = function() {
  return (_sqlite3_vtab_nochange = Module["_sqlite3_vtab_nochange"] = Module["asm"]["sqlite3_vtab_nochange"]).apply(null, arguments);
};


var _sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = function() {
  return (_sqlite3_vtab_in_first = Module["_sqlite3_vtab_in_first"] = Module["asm"]["sqlite3_vtab_in_first"]).apply(null, arguments);
};


var _sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = function() {
  return (_sqlite3_vtab_in_next = Module["_sqlite3_vtab_in_next"] = Module["asm"]["sqlite3_vtab_in_next"]).apply(null, arguments);
};


var _sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = function() {
  return (_sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = Module["asm"]["sqlite3_aggregate_context"]).apply(null, arguments);
};


var _sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = function() {
  return (_sqlite3_get_auxdata = Module["_sqlite3_get_auxdata"] = Module["asm"]["sqlite3_get_auxdata"]).apply(null, arguments);
};


var _sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = function() {
  return (_sqlite3_set_auxdata = Module["_sqlite3_set_auxdata"] = Module["asm"]["sqlite3_set_auxdata"]).apply(null, arguments);
};


var _sqlite3_column_count = Module["_sqlite3_column_count"] = function() {
  return (_sqlite3_column_count = Module["_sqlite3_column_count"] = Module["asm"]["sqlite3_column_count"]).apply(null, arguments);
};


var _sqlite3_data_count = Module["_sqlite3_data_count"] = function() {
  return (_sqlite3_data_count = Module["_sqlite3_data_count"] = Module["asm"]["sqlite3_data_count"]).apply(null, arguments);
};


var _sqlite3_column_blob = Module["_sqlite3_column_blob"] = function() {
  return (_sqlite3_column_blob = Module["_sqlite3_column_blob"] = Module["asm"]["sqlite3_column_blob"]).apply(null, arguments);
};


var _sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = function() {
  return (_sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = Module["asm"]["sqlite3_column_bytes"]).apply(null, arguments);
};


var _sqlite3_column_double = Module["_sqlite3_column_double"] = function() {
  return (_sqlite3_column_double = Module["_sqlite3_column_double"] = Module["asm"]["sqlite3_column_double"]).apply(null, arguments);
};


var _sqlite3_column_value = Module["_sqlite3_column_value"] = function() {
  return (_sqlite3_column_value = Module["_sqlite3_column_value"] = Module["asm"]["sqlite3_column_value"]).apply(null, arguments);
};


var _sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = function() {
  return (_sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = Module["asm"]["sqlite3_bind_blob"]).apply(null, arguments);
};


var _sqlite3_bind_double = Module["_sqlite3_bind_double"] = function() {
  return (_sqlite3_bind_double = Module["_sqlite3_bind_double"] = Module["asm"]["sqlite3_bind_double"]).apply(null, arguments);
};


var _sqlite3_bind_int = Module["_sqlite3_bind_int"] = function() {
  return (_sqlite3_bind_int = Module["_sqlite3_bind_int"] = Module["asm"]["sqlite3_bind_int"]).apply(null, arguments);
};


var _sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = function() {
  return (_sqlite3_bind_int64 = Module["_sqlite3_bind_int64"] = Module["asm"]["sqlite3_bind_int64"]).apply(null, arguments);
};


var _sqlite3_bind_null = Module["_sqlite3_bind_null"] = function() {
  return (_sqlite3_bind_null = Module["_sqlite3_bind_null"] = Module["asm"]["sqlite3_bind_null"]).apply(null, arguments);
};


var _sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = function() {
  return (_sqlite3_bind_pointer = Module["_sqlite3_bind_pointer"] = Module["asm"]["sqlite3_bind_pointer"]).apply(null, arguments);
};


var _sqlite3_bind_text = Module["_sqlite3_bind_text"] = function() {
  return (_sqlite3_bind_text = Module["_sqlite3_bind_text"] = Module["asm"]["sqlite3_bind_text"]).apply(null, arguments);
};


var _sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = function() {
  return (_sqlite3_bind_parameter_count = Module["_sqlite3_bind_parameter_count"] = Module["asm"]["sqlite3_bind_parameter_count"]).apply(null, arguments);
};


var _sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = function() {
  return (_sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = Module["asm"]["sqlite3_bind_parameter_index"]).apply(null, arguments);
};


var _sqlite3_db_handle = Module["_sqlite3_db_handle"] = function() {
  return (_sqlite3_db_handle = Module["_sqlite3_db_handle"] = Module["asm"]["sqlite3_db_handle"]).apply(null, arguments);
};


var _sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = function() {
  return (_sqlite3_stmt_readonly = Module["_sqlite3_stmt_readonly"] = Module["asm"]["sqlite3_stmt_readonly"]).apply(null, arguments);
};


var _sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = function() {
  return (_sqlite3_stmt_isexplain = Module["_sqlite3_stmt_isexplain"] = Module["asm"]["sqlite3_stmt_isexplain"]).apply(null, arguments);
};


var _sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = function() {
  return (_sqlite3_stmt_status = Module["_sqlite3_stmt_status"] = Module["asm"]["sqlite3_stmt_status"]).apply(null, arguments);
};


var _sqlite3_sql = Module["_sqlite3_sql"] = function() {
  return (_sqlite3_sql = Module["_sqlite3_sql"] = Module["asm"]["sqlite3_sql"]).apply(null, arguments);
};


var _sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = function() {
  return (_sqlite3_expanded_sql = Module["_sqlite3_expanded_sql"] = Module["asm"]["sqlite3_expanded_sql"]).apply(null, arguments);
};


var _sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = function() {
  return (_sqlite3_preupdate_old = Module["_sqlite3_preupdate_old"] = Module["asm"]["sqlite3_preupdate_old"]).apply(null, arguments);
};


var _sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = function() {
  return (_sqlite3_preupdate_count = Module["_sqlite3_preupdate_count"] = Module["asm"]["sqlite3_preupdate_count"]).apply(null, arguments);
};


var _sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = function() {
  return (_sqlite3_preupdate_depth = Module["_sqlite3_preupdate_depth"] = Module["asm"]["sqlite3_preupdate_depth"]).apply(null, arguments);
};


var _sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = function() {
  return (_sqlite3_preupdate_blobwrite = Module["_sqlite3_preupdate_blobwrite"] = Module["asm"]["sqlite3_preupdate_blobwrite"]).apply(null, arguments);
};


var _sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = function() {
  return (_sqlite3_preupdate_new = Module["_sqlite3_preupdate_new"] = Module["asm"]["sqlite3_preupdate_new"]).apply(null, arguments);
};


var _sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = function() {
  return (_sqlite3_value_numeric_type = Module["_sqlite3_value_numeric_type"] = Module["asm"]["sqlite3_value_numeric_type"]).apply(null, arguments);
};


var _sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = function() {
  return (_sqlite3_set_authorizer = Module["_sqlite3_set_authorizer"] = Module["asm"]["sqlite3_set_authorizer"]).apply(null, arguments);
};


var _sqlite3_strglob = Module["_sqlite3_strglob"] = function() {
  return (_sqlite3_strglob = Module["_sqlite3_strglob"] = Module["asm"]["sqlite3_strglob"]).apply(null, arguments);
};


var _sqlite3_strlike = Module["_sqlite3_strlike"] = function() {
  return (_sqlite3_strlike = Module["_sqlite3_strlike"] = Module["asm"]["sqlite3_strlike"]).apply(null, arguments);
};


var _sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = function() {
  return (_sqlite3_auto_extension = Module["_sqlite3_auto_extension"] = Module["asm"]["sqlite3_auto_extension"]).apply(null, arguments);
};


var _sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = function() {
  return (_sqlite3_cancel_auto_extension = Module["_sqlite3_cancel_auto_extension"] = Module["asm"]["sqlite3_cancel_auto_extension"]).apply(null, arguments);
};


var _sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = function() {
  return (_sqlite3_reset_auto_extension = Module["_sqlite3_reset_auto_extension"] = Module["asm"]["sqlite3_reset_auto_extension"]).apply(null, arguments);
};


var _sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = function() {
  return (_sqlite3_prepare_v3 = Module["_sqlite3_prepare_v3"] = Module["asm"]["sqlite3_prepare_v3"]).apply(null, arguments);
};


var _sqlite3_create_module = Module["_sqlite3_create_module"] = function() {
  return (_sqlite3_create_module = Module["_sqlite3_create_module"] = Module["asm"]["sqlite3_create_module"]).apply(null, arguments);
};


var _sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = function() {
  return (_sqlite3_create_module_v2 = Module["_sqlite3_create_module_v2"] = Module["asm"]["sqlite3_create_module_v2"]).apply(null, arguments);
};


var _sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = function() {
  return (_sqlite3_drop_modules = Module["_sqlite3_drop_modules"] = Module["asm"]["sqlite3_drop_modules"]).apply(null, arguments);
};


var _sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = function() {
  return (_sqlite3_declare_vtab = Module["_sqlite3_declare_vtab"] = Module["asm"]["sqlite3_declare_vtab"]).apply(null, arguments);
};


var _sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = function() {
  return (_sqlite3_vtab_on_conflict = Module["_sqlite3_vtab_on_conflict"] = Module["asm"]["sqlite3_vtab_on_conflict"]).apply(null, arguments);
};


var _sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = function() {
  return (_sqlite3_vtab_collation = Module["_sqlite3_vtab_collation"] = Module["asm"]["sqlite3_vtab_collation"]).apply(null, arguments);
};


var _sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = function() {
  return (_sqlite3_vtab_in = Module["_sqlite3_vtab_in"] = Module["asm"]["sqlite3_vtab_in"]).apply(null, arguments);
};


var _sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = function() {
  return (_sqlite3_vtab_rhs_value = Module["_sqlite3_vtab_rhs_value"] = Module["asm"]["sqlite3_vtab_rhs_value"]).apply(null, arguments);
};


var _sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = function() {
  return (_sqlite3_vtab_distinct = Module["_sqlite3_vtab_distinct"] = Module["asm"]["sqlite3_vtab_distinct"]).apply(null, arguments);
};


var _sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = function() {
  return (_sqlite3_keyword_name = Module["_sqlite3_keyword_name"] = Module["asm"]["sqlite3_keyword_name"]).apply(null, arguments);
};


var _sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = function() {
  return (_sqlite3_keyword_count = Module["_sqlite3_keyword_count"] = Module["asm"]["sqlite3_keyword_count"]).apply(null, arguments);
};


var _sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = function() {
  return (_sqlite3_keyword_check = Module["_sqlite3_keyword_check"] = Module["asm"]["sqlite3_keyword_check"]).apply(null, arguments);
};


var _sqlite3_complete = Module["_sqlite3_complete"] = function() {
  return (_sqlite3_complete = Module["_sqlite3_complete"] = Module["asm"]["sqlite3_complete"]).apply(null, arguments);
};


var _sqlite3_libversion = Module["_sqlite3_libversion"] = function() {
  return (_sqlite3_libversion = Module["_sqlite3_libversion"] = Module["asm"]["sqlite3_libversion"]).apply(null, arguments);
};


var _sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = function() {
  return (_sqlite3_libversion_number = Module["_sqlite3_libversion_number"] = Module["asm"]["sqlite3_libversion_number"]).apply(null, arguments);
};


var _sqlite3_shutdown = Module["_sqlite3_shutdown"] = function() {
  return (_sqlite3_shutdown = Module["_sqlite3_shutdown"] = Module["asm"]["sqlite3_shutdown"]).apply(null, arguments);
};


var _sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = function() {
  return (_sqlite3_last_insert_rowid = Module["_sqlite3_last_insert_rowid"] = Module["asm"]["sqlite3_last_insert_rowid"]).apply(null, arguments);
};


var _sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = function() {
  return (_sqlite3_set_last_insert_rowid = Module["_sqlite3_set_last_insert_rowid"] = Module["asm"]["sqlite3_set_last_insert_rowid"]).apply(null, arguments);
};


var _sqlite3_changes64 = Module["_sqlite3_changes64"] = function() {
  return (_sqlite3_changes64 = Module["_sqlite3_changes64"] = Module["asm"]["sqlite3_changes64"]).apply(null, arguments);
};


var _sqlite3_changes = Module["_sqlite3_changes"] = function() {
  return (_sqlite3_changes = Module["_sqlite3_changes"] = Module["asm"]["sqlite3_changes"]).apply(null, arguments);
};


var _sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = function() {
  return (_sqlite3_total_changes64 = Module["_sqlite3_total_changes64"] = Module["asm"]["sqlite3_total_changes64"]).apply(null, arguments);
};


var _sqlite3_total_changes = Module["_sqlite3_total_changes"] = function() {
  return (_sqlite3_total_changes = Module["_sqlite3_total_changes"] = Module["asm"]["sqlite3_total_changes"]).apply(null, arguments);
};


var _sqlite3_txn_state = Module["_sqlite3_txn_state"] = function() {
  return (_sqlite3_txn_state = Module["_sqlite3_txn_state"] = Module["asm"]["sqlite3_txn_state"]).apply(null, arguments);
};


var _sqlite3_close_v2 = Module["_sqlite3_close_v2"] = function() {
  return (_sqlite3_close_v2 = Module["_sqlite3_close_v2"] = Module["asm"]["sqlite3_close_v2"]).apply(null, arguments);
};


var _sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = function() {
  return (_sqlite3_busy_handler = Module["_sqlite3_busy_handler"] = Module["asm"]["sqlite3_busy_handler"]).apply(null, arguments);
};


var _sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = function() {
  return (_sqlite3_progress_handler = Module["_sqlite3_progress_handler"] = Module["asm"]["sqlite3_progress_handler"]).apply(null, arguments);
};


var _sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = function() {
  return (_sqlite3_busy_timeout = Module["_sqlite3_busy_timeout"] = Module["asm"]["sqlite3_busy_timeout"]).apply(null, arguments);
};


var _sqlite3_create_function = Module["_sqlite3_create_function"] = function() {
  return (_sqlite3_create_function = Module["_sqlite3_create_function"] = Module["asm"]["sqlite3_create_function"]).apply(null, arguments);
};


var _sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = function() {
  return (_sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = Module["asm"]["sqlite3_create_function_v2"]).apply(null, arguments);
};


var _sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = function() {
  return (_sqlite3_create_window_function = Module["_sqlite3_create_window_function"] = Module["asm"]["sqlite3_create_window_function"]).apply(null, arguments);
};


var _sqlite3_overload_function = Module["_sqlite3_overload_function"] = function() {
  return (_sqlite3_overload_function = Module["_sqlite3_overload_function"] = Module["asm"]["sqlite3_overload_function"]).apply(null, arguments);
};


var _sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = function() {
  return (_sqlite3_trace_v2 = Module["_sqlite3_trace_v2"] = Module["asm"]["sqlite3_trace_v2"]).apply(null, arguments);
};


var _sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = function() {
  return (_sqlite3_commit_hook = Module["_sqlite3_commit_hook"] = Module["asm"]["sqlite3_commit_hook"]).apply(null, arguments);
};


var _sqlite3_update_hook = Module["_sqlite3_update_hook"] = function() {
  return (_sqlite3_update_hook = Module["_sqlite3_update_hook"] = Module["asm"]["sqlite3_update_hook"]).apply(null, arguments);
};


var _sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = function() {
  return (_sqlite3_rollback_hook = Module["_sqlite3_rollback_hook"] = Module["asm"]["sqlite3_rollback_hook"]).apply(null, arguments);
};


var _sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = function() {
  return (_sqlite3_preupdate_hook = Module["_sqlite3_preupdate_hook"] = Module["asm"]["sqlite3_preupdate_hook"]).apply(null, arguments);
};


var _sqlite3_error_offset = Module["_sqlite3_error_offset"] = function() {
  return (_sqlite3_error_offset = Module["_sqlite3_error_offset"] = Module["asm"]["sqlite3_error_offset"]).apply(null, arguments);
};


var _sqlite3_errcode = Module["_sqlite3_errcode"] = function() {
  return (_sqlite3_errcode = Module["_sqlite3_errcode"] = Module["asm"]["sqlite3_errcode"]).apply(null, arguments);
};


var _sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = function() {
  return (_sqlite3_extended_errcode = Module["_sqlite3_extended_errcode"] = Module["asm"]["sqlite3_extended_errcode"]).apply(null, arguments);
};


var _sqlite3_errstr = Module["_sqlite3_errstr"] = function() {
  return (_sqlite3_errstr = Module["_sqlite3_errstr"] = Module["asm"]["sqlite3_errstr"]).apply(null, arguments);
};


var _sqlite3_limit = Module["_sqlite3_limit"] = function() {
  return (_sqlite3_limit = Module["_sqlite3_limit"] = Module["asm"]["sqlite3_limit"]).apply(null, arguments);
};


var _sqlite3_open = Module["_sqlite3_open"] = function() {
  return (_sqlite3_open = Module["_sqlite3_open"] = Module["asm"]["sqlite3_open"]).apply(null, arguments);
};


var _sqlite3_open_v2 = Module["_sqlite3_open_v2"] = function() {
  return (_sqlite3_open_v2 = Module["_sqlite3_open_v2"] = Module["asm"]["sqlite3_open_v2"]).apply(null, arguments);
};


var _sqlite3_create_collation = Module["_sqlite3_create_collation"] = function() {
  return (_sqlite3_create_collation = Module["_sqlite3_create_collation"] = Module["asm"]["sqlite3_create_collation"]).apply(null, arguments);
};


var _sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = function() {
  return (_sqlite3_create_collation_v2 = Module["_sqlite3_create_collation_v2"] = Module["asm"]["sqlite3_create_collation_v2"]).apply(null, arguments);
};


var _sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = function() {
  return (_sqlite3_collation_needed = Module["_sqlite3_collation_needed"] = Module["asm"]["sqlite3_collation_needed"]).apply(null, arguments);
};


var _sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = function() {
  return (_sqlite3_get_autocommit = Module["_sqlite3_get_autocommit"] = Module["asm"]["sqlite3_get_autocommit"]).apply(null, arguments);
};


var _sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = function() {
  return (_sqlite3_table_column_metadata = Module["_sqlite3_table_column_metadata"] = Module["asm"]["sqlite3_table_column_metadata"]).apply(null, arguments);
};


var _sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = function() {
  return (_sqlite3_extended_result_codes = Module["_sqlite3_extended_result_codes"] = Module["asm"]["sqlite3_extended_result_codes"]).apply(null, arguments);
};


var _sqlite3_uri_key = Module["_sqlite3_uri_key"] = function() {
  return (_sqlite3_uri_key = Module["_sqlite3_uri_key"] = Module["asm"]["sqlite3_uri_key"]).apply(null, arguments);
};


var _sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = function() {
  return (_sqlite3_uri_int64 = Module["_sqlite3_uri_int64"] = Module["asm"]["sqlite3_uri_int64"]).apply(null, arguments);
};


var _sqlite3_db_name = Module["_sqlite3_db_name"] = function() {
  return (_sqlite3_db_name = Module["_sqlite3_db_name"] = Module["asm"]["sqlite3_db_name"]).apply(null, arguments);
};


var _sqlite3_db_filename = Module["_sqlite3_db_filename"] = function() {
  return (_sqlite3_db_filename = Module["_sqlite3_db_filename"] = Module["asm"]["sqlite3_db_filename"]).apply(null, arguments);
};


var _sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = function() {
  return (_sqlite3_compileoption_used = Module["_sqlite3_compileoption_used"] = Module["asm"]["sqlite3_compileoption_used"]).apply(null, arguments);
};


var _sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = function() {
  return (_sqlite3_compileoption_get = Module["_sqlite3_compileoption_get"] = Module["asm"]["sqlite3_compileoption_get"]).apply(null, arguments);
};


var _sqlite3session_diff = Module["_sqlite3session_diff"] = function() {
  return (_sqlite3session_diff = Module["_sqlite3session_diff"] = Module["asm"]["sqlite3session_diff"]).apply(null, arguments);
};


var _sqlite3session_attach = Module["_sqlite3session_attach"] = function() {
  return (_sqlite3session_attach = Module["_sqlite3session_attach"] = Module["asm"]["sqlite3session_attach"]).apply(null, arguments);
};


var _sqlite3session_create = Module["_sqlite3session_create"] = function() {
  return (_sqlite3session_create = Module["_sqlite3session_create"] = Module["asm"]["sqlite3session_create"]).apply(null, arguments);
};


var _sqlite3session_delete = Module["_sqlite3session_delete"] = function() {
  return (_sqlite3session_delete = Module["_sqlite3session_delete"] = Module["asm"]["sqlite3session_delete"]).apply(null, arguments);
};


var _sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = function() {
  return (_sqlite3session_table_filter = Module["_sqlite3session_table_filter"] = Module["asm"]["sqlite3session_table_filter"]).apply(null, arguments);
};


var _sqlite3session_changeset = Module["_sqlite3session_changeset"] = function() {
  return (_sqlite3session_changeset = Module["_sqlite3session_changeset"] = Module["asm"]["sqlite3session_changeset"]).apply(null, arguments);
};


var _sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = function() {
  return (_sqlite3session_changeset_strm = Module["_sqlite3session_changeset_strm"] = Module["asm"]["sqlite3session_changeset_strm"]).apply(null, arguments);
};


var _sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = function() {
  return (_sqlite3session_patchset_strm = Module["_sqlite3session_patchset_strm"] = Module["asm"]["sqlite3session_patchset_strm"]).apply(null, arguments);
};


var _sqlite3session_patchset = Module["_sqlite3session_patchset"] = function() {
  return (_sqlite3session_patchset = Module["_sqlite3session_patchset"] = Module["asm"]["sqlite3session_patchset"]).apply(null, arguments);
};


var _sqlite3session_enable = Module["_sqlite3session_enable"] = function() {
  return (_sqlite3session_enable = Module["_sqlite3session_enable"] = Module["asm"]["sqlite3session_enable"]).apply(null, arguments);
};


var _sqlite3session_indirect = Module["_sqlite3session_indirect"] = function() {
  return (_sqlite3session_indirect = Module["_sqlite3session_indirect"] = Module["asm"]["sqlite3session_indirect"]).apply(null, arguments);
};


var _sqlite3session_isempty = Module["_sqlite3session_isempty"] = function() {
  return (_sqlite3session_isempty = Module["_sqlite3session_isempty"] = Module["asm"]["sqlite3session_isempty"]).apply(null, arguments);
};


var _sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = function() {
  return (_sqlite3session_memory_used = Module["_sqlite3session_memory_used"] = Module["asm"]["sqlite3session_memory_used"]).apply(null, arguments);
};


var _sqlite3session_object_config = Module["_sqlite3session_object_config"] = function() {
  return (_sqlite3session_object_config = Module["_sqlite3session_object_config"] = Module["asm"]["sqlite3session_object_config"]).apply(null, arguments);
};


var _sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = function() {
  return (_sqlite3session_changeset_size = Module["_sqlite3session_changeset_size"] = Module["asm"]["sqlite3session_changeset_size"]).apply(null, arguments);
};


var _sqlite3changeset_start = Module["_sqlite3changeset_start"] = function() {
  return (_sqlite3changeset_start = Module["_sqlite3changeset_start"] = Module["asm"]["sqlite3changeset_start"]).apply(null, arguments);
};


var _sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = function() {
  return (_sqlite3changeset_start_v2 = Module["_sqlite3changeset_start_v2"] = Module["asm"]["sqlite3changeset_start_v2"]).apply(null, arguments);
};


var _sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = function() {
  return (_sqlite3changeset_start_strm = Module["_sqlite3changeset_start_strm"] = Module["asm"]["sqlite3changeset_start_strm"]).apply(null, arguments);
};


var _sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = function() {
  return (_sqlite3changeset_start_v2_strm = Module["_sqlite3changeset_start_v2_strm"] = Module["asm"]["sqlite3changeset_start_v2_strm"]).apply(null, arguments);
};


var _sqlite3changeset_next = Module["_sqlite3changeset_next"] = function() {
  return (_sqlite3changeset_next = Module["_sqlite3changeset_next"] = Module["asm"]["sqlite3changeset_next"]).apply(null, arguments);
};


var _sqlite3changeset_op = Module["_sqlite3changeset_op"] = function() {
  return (_sqlite3changeset_op = Module["_sqlite3changeset_op"] = Module["asm"]["sqlite3changeset_op"]).apply(null, arguments);
};


var _sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = function() {
  return (_sqlite3changeset_pk = Module["_sqlite3changeset_pk"] = Module["asm"]["sqlite3changeset_pk"]).apply(null, arguments);
};


var _sqlite3changeset_old = Module["_sqlite3changeset_old"] = function() {
  return (_sqlite3changeset_old = Module["_sqlite3changeset_old"] = Module["asm"]["sqlite3changeset_old"]).apply(null, arguments);
};


var _sqlite3changeset_new = Module["_sqlite3changeset_new"] = function() {
  return (_sqlite3changeset_new = Module["_sqlite3changeset_new"] = Module["asm"]["sqlite3changeset_new"]).apply(null, arguments);
};


var _sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = function() {
  return (_sqlite3changeset_conflict = Module["_sqlite3changeset_conflict"] = Module["asm"]["sqlite3changeset_conflict"]).apply(null, arguments);
};


var _sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = function() {
  return (_sqlite3changeset_fk_conflicts = Module["_sqlite3changeset_fk_conflicts"] = Module["asm"]["sqlite3changeset_fk_conflicts"]).apply(null, arguments);
};


var _sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = function() {
  return (_sqlite3changeset_finalize = Module["_sqlite3changeset_finalize"] = Module["asm"]["sqlite3changeset_finalize"]).apply(null, arguments);
};


var _sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = function() {
  return (_sqlite3changeset_invert = Module["_sqlite3changeset_invert"] = Module["asm"]["sqlite3changeset_invert"]).apply(null, arguments);
};


var _sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = function() {
  return (_sqlite3changeset_invert_strm = Module["_sqlite3changeset_invert_strm"] = Module["asm"]["sqlite3changeset_invert_strm"]).apply(null, arguments);
};


var _sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = function() {
  return (_sqlite3changeset_apply_v2 = Module["_sqlite3changeset_apply_v2"] = Module["asm"]["sqlite3changeset_apply_v2"]).apply(null, arguments);
};


var _sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = function() {
  return (_sqlite3changeset_apply = Module["_sqlite3changeset_apply"] = Module["asm"]["sqlite3changeset_apply"]).apply(null, arguments);
};


var _sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = function() {
  return (_sqlite3changeset_apply_v2_strm = Module["_sqlite3changeset_apply_v2_strm"] = Module["asm"]["sqlite3changeset_apply_v2_strm"]).apply(null, arguments);
};


var _sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = function() {
  return (_sqlite3changeset_apply_strm = Module["_sqlite3changeset_apply_strm"] = Module["asm"]["sqlite3changeset_apply_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = function() {
  return (_sqlite3changegroup_new = Module["_sqlite3changegroup_new"] = Module["asm"]["sqlite3changegroup_new"]).apply(null, arguments);
};


var _sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = function() {
  return (_sqlite3changegroup_add = Module["_sqlite3changegroup_add"] = Module["asm"]["sqlite3changegroup_add"]).apply(null, arguments);
};


var _sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = function() {
  return (_sqlite3changegroup_output = Module["_sqlite3changegroup_output"] = Module["asm"]["sqlite3changegroup_output"]).apply(null, arguments);
};


var _sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = function() {
  return (_sqlite3changegroup_add_strm = Module["_sqlite3changegroup_add_strm"] = Module["asm"]["sqlite3changegroup_add_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = function() {
  return (_sqlite3changegroup_output_strm = Module["_sqlite3changegroup_output_strm"] = Module["asm"]["sqlite3changegroup_output_strm"]).apply(null, arguments);
};


var _sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = function() {
  return (_sqlite3changegroup_delete = Module["_sqlite3changegroup_delete"] = Module["asm"]["sqlite3changegroup_delete"]).apply(null, arguments);
};


var _sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = function() {
  return (_sqlite3changeset_concat = Module["_sqlite3changeset_concat"] = Module["asm"]["sqlite3changeset_concat"]).apply(null, arguments);
};


var _sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = function() {
  return (_sqlite3changeset_concat_strm = Module["_sqlite3changeset_concat_strm"] = Module["asm"]["sqlite3changeset_concat_strm"]).apply(null, arguments);
};


var _sqlite3session_config = Module["_sqlite3session_config"] = function() {
  return (_sqlite3session_config = Module["_sqlite3session_config"] = Module["asm"]["sqlite3session_config"]).apply(null, arguments);
};


var _sqlite3_sourceid = Module["_sqlite3_sourceid"] = function() {
  return (_sqlite3_sourceid = Module["_sqlite3_sourceid"] = Module["asm"]["sqlite3_sourceid"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_ptr = Module["_sqlite3_wasm_pstack_ptr"] = function() {
  return (_sqlite3_wasm_pstack_ptr = Module["_sqlite3_wasm_pstack_ptr"] = Module["asm"]["sqlite3_wasm_pstack_ptr"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_restore = Module["_sqlite3_wasm_pstack_restore"] = function() {
  return (_sqlite3_wasm_pstack_restore = Module["_sqlite3_wasm_pstack_restore"] = Module["asm"]["sqlite3_wasm_pstack_restore"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_alloc = Module["_sqlite3_wasm_pstack_alloc"] = function() {
  return (_sqlite3_wasm_pstack_alloc = Module["_sqlite3_wasm_pstack_alloc"] = Module["asm"]["sqlite3_wasm_pstack_alloc"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_remaining = Module["_sqlite3_wasm_pstack_remaining"] = function() {
  return (_sqlite3_wasm_pstack_remaining = Module["_sqlite3_wasm_pstack_remaining"] = Module["asm"]["sqlite3_wasm_pstack_remaining"]).apply(null, arguments);
};


var _sqlite3_wasm_pstack_quota = Module["_sqlite3_wasm_pstack_quota"] = function() {
  return (_sqlite3_wasm_pstack_quota = Module["_sqlite3_wasm_pstack_quota"] = Module["asm"]["sqlite3_wasm_pstack_quota"]).apply(null, arguments);
};


var _sqlite3_wasm_db_error = Module["_sqlite3_wasm_db_error"] = function() {
  return (_sqlite3_wasm_db_error = Module["_sqlite3_wasm_db_error"] = Module["asm"]["sqlite3_wasm_db_error"]).apply(null, arguments);
};


var _sqlite3_wasm_test_struct = Module["_sqlite3_wasm_test_struct"] = function() {
  return (_sqlite3_wasm_test_struct = Module["_sqlite3_wasm_test_struct"] = Module["asm"]["sqlite3_wasm_test_struct"]).apply(null, arguments);
};


var _sqlite3_wasm_enum_json = Module["_sqlite3_wasm_enum_json"] = function() {
  return (_sqlite3_wasm_enum_json = Module["_sqlite3_wasm_enum_json"] = Module["asm"]["sqlite3_wasm_enum_json"]).apply(null, arguments);
};


var _sqlite3_wasm_vfs_unlink = Module["_sqlite3_wasm_vfs_unlink"] = function() {
  return (_sqlite3_wasm_vfs_unlink = Module["_sqlite3_wasm_vfs_unlink"] = Module["asm"]["sqlite3_wasm_vfs_unlink"]).apply(null, arguments);
};


var _sqlite3_wasm_db_vfs = Module["_sqlite3_wasm_db_vfs"] = function() {
  return (_sqlite3_wasm_db_vfs = Module["_sqlite3_wasm_db_vfs"] = Module["asm"]["sqlite3_wasm_db_vfs"]).apply(null, arguments);
};


var _sqlite3_wasm_db_reset = Module["_sqlite3_wasm_db_reset"] = function() {
  return (_sqlite3_wasm_db_reset = Module["_sqlite3_wasm_db_reset"] = Module["asm"]["sqlite3_wasm_db_reset"]).apply(null, arguments);
};


var _sqlite3_wasm_db_export_chunked = Module["_sqlite3_wasm_db_export_chunked"] = function() {
  return (_sqlite3_wasm_db_export_chunked = Module["_sqlite3_wasm_db_export_chunked"] = Module["asm"]["sqlite3_wasm_db_export_chunked"]).apply(null, arguments);
};


var _sqlite3_wasm_db_serialize = Module["_sqlite3_wasm_db_serialize"] = function() {
  return (_sqlite3_wasm_db_serialize = Module["_sqlite3_wasm_db_serialize"] = Module["asm"]["sqlite3_wasm_db_serialize"]).apply(null, arguments);
};


var _sqlite3_wasm_vfs_create_file = Module["_sqlite3_wasm_vfs_create_file"] = function() {
  return (_sqlite3_wasm_vfs_create_file = Module["_sqlite3_wasm_vfs_create_file"] = Module["asm"]["sqlite3_wasm_vfs_create_file"]).apply(null, arguments);
};


var _sqlite3_wasm_posix_create_file = Module["_sqlite3_wasm_posix_create_file"] = function() {
  return (_sqlite3_wasm_posix_create_file = Module["_sqlite3_wasm_posix_create_file"] = Module["asm"]["sqlite3_wasm_posix_create_file"]).apply(null, arguments);
};


var _sqlite3_wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3_wasm_kvvfsMakeKeyOnPstack"] = function() {
  return (_sqlite3_wasm_kvvfsMakeKeyOnPstack = Module["_sqlite3_wasm_kvvfsMakeKeyOnPstack"] = Module["asm"]["sqlite3_wasm_kvvfsMakeKeyOnPstack"]).apply(null, arguments);
};


var _sqlite3_wasm_kvvfs_methods = Module["_sqlite3_wasm_kvvfs_methods"] = function() {
  return (_sqlite3_wasm_kvvfs_methods = Module["_sqlite3_wasm_kvvfs_methods"] = Module["asm"]["sqlite3_wasm_kvvfs_methods"]).apply(null, arguments);
};


var _sqlite3_wasm_vtab_config = Module["_sqlite3_wasm_vtab_config"] = function() {
  return (_sqlite3_wasm_vtab_config = Module["_sqlite3_wasm_vtab_config"] = Module["asm"]["sqlite3_wasm_vtab_config"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_ip = Module["_sqlite3_wasm_db_config_ip"] = function() {
  return (_sqlite3_wasm_db_config_ip = Module["_sqlite3_wasm_db_config_ip"] = Module["asm"]["sqlite3_wasm_db_config_ip"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_pii = Module["_sqlite3_wasm_db_config_pii"] = function() {
  return (_sqlite3_wasm_db_config_pii = Module["_sqlite3_wasm_db_config_pii"] = Module["asm"]["sqlite3_wasm_db_config_pii"]).apply(null, arguments);
};


var _sqlite3_wasm_db_config_s = Module["_sqlite3_wasm_db_config_s"] = function() {
  return (_sqlite3_wasm_db_config_s = Module["_sqlite3_wasm_db_config_s"] = Module["asm"]["sqlite3_wasm_db_config_s"]).apply(null, arguments);
};


var _sqlite3_wasm_config_i = Module["_sqlite3_wasm_config_i"] = function() {
  return (_sqlite3_wasm_config_i = Module["_sqlite3_wasm_config_i"] = Module["asm"]["sqlite3_wasm_config_i"]).apply(null, arguments);
};


var _sqlite3_wasm_config_ii = Module["_sqlite3_wasm_config_ii"] = function() {
  return (_sqlite3_wasm_config_ii = Module["_sqlite3_wasm_config_ii"] = Module["asm"]["sqlite3_wasm_config_ii"]).apply(null, arguments);
};


var _sqlite3_wasm_config_j = Module["_sqlite3_wasm_config_j"] = function() {
  return (_sqlite3_wasm_config_j = Module["_sqlite3_wasm_config_j"] = Module["asm"]["sqlite3_wasm_config_j"]).apply(null, arguments);
};


var _sqlite3_wasm_init_wasmfs = Module["_sqlite3_wasm_init_wasmfs"] = function() {
  return (_sqlite3_wasm_init_wasmfs = Module["_sqlite3_wasm_init_wasmfs"] = Module["asm"]["sqlite3_wasm_init_wasmfs"]).apply(null, arguments);
};


var _sqlite3_wasm_test_intptr = Module["_sqlite3_wasm_test_intptr"] = function() {
  return (_sqlite3_wasm_test_intptr = Module["_sqlite3_wasm_test_intptr"] = Module["asm"]["sqlite3_wasm_test_intptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_voidptr = Module["_sqlite3_wasm_test_voidptr"] = function() {
  return (_sqlite3_wasm_test_voidptr = Module["_sqlite3_wasm_test_voidptr"] = Module["asm"]["sqlite3_wasm_test_voidptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_max = Module["_sqlite3_wasm_test_int64_max"] = function() {
  return (_sqlite3_wasm_test_int64_max = Module["_sqlite3_wasm_test_int64_max"] = Module["asm"]["sqlite3_wasm_test_int64_max"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_min = Module["_sqlite3_wasm_test_int64_min"] = function() {
  return (_sqlite3_wasm_test_int64_min = Module["_sqlite3_wasm_test_int64_min"] = Module["asm"]["sqlite3_wasm_test_int64_min"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_times2 = Module["_sqlite3_wasm_test_int64_times2"] = function() {
  return (_sqlite3_wasm_test_int64_times2 = Module["_sqlite3_wasm_test_int64_times2"] = Module["asm"]["sqlite3_wasm_test_int64_times2"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64_minmax = Module["_sqlite3_wasm_test_int64_minmax"] = function() {
  return (_sqlite3_wasm_test_int64_minmax = Module["_sqlite3_wasm_test_int64_minmax"] = Module["asm"]["sqlite3_wasm_test_int64_minmax"]).apply(null, arguments);
};


var _sqlite3_wasm_test_int64ptr = Module["_sqlite3_wasm_test_int64ptr"] = function() {
  return (_sqlite3_wasm_test_int64ptr = Module["_sqlite3_wasm_test_int64ptr"] = Module["asm"]["sqlite3_wasm_test_int64ptr"]).apply(null, arguments);
};


var _sqlite3_wasm_test_stack_overflow = Module["_sqlite3_wasm_test_stack_overflow"] = function() {
  return (_sqlite3_wasm_test_stack_overflow = Module["_sqlite3_wasm_test_stack_overflow"] = Module["asm"]["sqlite3_wasm_test_stack_overflow"]).apply(null, arguments);
};


var _sqlite3_wasm_test_str_hello = Module["_sqlite3_wasm_test_str_hello"] = function() {
  return (_sqlite3_wasm_test_str_hello = Module["_sqlite3_wasm_test_str_hello"] = Module["asm"]["sqlite3_wasm_test_str_hello"]).apply(null, arguments);
};


var _sqlite3_wasm_SQLTester_strglob = Module["_sqlite3_wasm_SQLTester_strglob"] = function() {
  return (_sqlite3_wasm_SQLTester_strglob = Module["_sqlite3_wasm_SQLTester_strglob"] = Module["asm"]["sqlite3_wasm_SQLTester_strglob"]).apply(null, arguments);
};


var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};


var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};


var _realloc = Module["_realloc"] = function() {
  return (_realloc = Module["_realloc"] = Module["asm"]["realloc"]).apply(null, arguments);
};


var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
  return (_emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = Module["asm"]["emscripten_builtin_memalign"]).apply(null, arguments);
};


var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};


var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};


var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};







Module["wasmMemory"] = wasmMemory;


var calledRun;

dependenciesFulfilled = function runCaller() {
  
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; 
};


function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    
    
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();





if(!Module.postRun) Module.postRun = [];
Module.postRun.push(function(Module){
  'use strict';
  










'use strict';
globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(
  apiConfig = (globalThis.sqlite3ApiConfig || sqlite3ApiBootstrap.defaultConfig)
){
  if(sqlite3ApiBootstrap.sqlite3){ 
    console.warn("sqlite3ApiBootstrap() called multiple times.",
                 "Config and external initializers are ignored on calls after the first.");
    return sqlite3ApiBootstrap.sqlite3;
  }
  const config = Object.assign(Object.create(null),{
    exports: undefined,
    memory: undefined,
    bigIntEnabled: (()=>{
      if('undefined'!==typeof Module){
        
        return !!Module.HEAPU64;
      }
      return !!globalThis.BigInt64Array;
    })(),
    debug: console.debug.bind(console),
    warn: console.warn.bind(console),
    error: console.error.bind(console),
    log: console.log.bind(console),
    wasmfsOpfsDir: '/opfs',
    
    useStdAlloc: false
  }, apiConfig || {});

  Object.assign(config, {
    allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',
    deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',
    reallocExportName: config.useStdAlloc ? 'realloc' : 'sqlite3_realloc'
  }, config);

  [
    
    
    'exports', 'memory', 'wasmfsOpfsDir'
  ].forEach((k)=>{
    if('function' === typeof config[k]){
      config[k] = config[k]();
    }
  });
  
  const capi = Object.create(null);
  
  const wasm = Object.create(null);

  
  const __rcStr = (rc)=>{
    return (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc))
           || ("Unknown result code #"+rc);
  };

  
  const __isInt = (n)=>'number'===typeof n && n===(n | 0);

  
  class SQLite3Error extends Error {
    
    constructor(...args){
      let rc;
      if(args.length){
        if(__isInt(args[0])){
          rc = args[0];
          if(1===args.length){
            super(__rcStr(args[0]));
          }else{
            const rcStr = __rcStr(rc);
            if('object'===typeof args[1]){
              super(rcStr,args[1]);
            }else{
              args[0] = rcStr+':';
              super(args.join(' '));
            }
          }
        }else{
          if(2===args.length && 'object'===typeof args[1]){
            super(...args);
          }else{
            super(args.join(' '));
          }
        }
      }
      this.resultCode = rc || capi.SQLITE_ERROR;
      this.name = 'SQLite3Error';
    }
  };

  
  SQLite3Error.toss = (...args)=>{
    throw new SQLite3Error(...args);
  };
  const toss3 = SQLite3Error.toss;

  if(config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)){
    toss3("config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.");
  }

  
  const isInt32 = (n)=>{
    return ('bigint'!==typeof n )
      && !!(n===(n|0) && n<=2147483647 && n>=-2147483648);
  };
  
  const bigIntFits64 = function f(b){
    if(!f._max){
      f._max = BigInt("0x7fffffffffffffff");
      f._min = ~f._max;
    }
    return b >= f._min && b <= f._max;
  };

  
  const bigIntFits32 = (b)=>(b >= (-0x7fffffffn - 1n) && b <= 0x7fffffffn);

  
  const bigIntFitsDouble = function f(b){
    if(!f._min){
      f._min = Number.MIN_SAFE_INTEGER;
      f._max = Number.MAX_SAFE_INTEGER;
    }
    return b >= f._min && b <= f._max;
  };

  
  const isTypedArray = (v)=>{
    return (v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)) ? v : false;
  };


  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  
  const isSharedTypedArray = (aTypedArray)=>(aTypedArray.buffer instanceof __SAB);

  
  const typedArrayPart = (aTypedArray, begin, end)=>{
    return isSharedTypedArray(aTypedArray)
      ? aTypedArray.slice(begin, end)
      : aTypedArray.subarray(begin, end);
  };

  
  const isBindableTypedArray = (v)=>{
    return v && (v instanceof Uint8Array
                 || v instanceof Int8Array
                 || v instanceof ArrayBuffer);
  };

  
  const isSQLableTypedArray = (v)=>{
    return v && (v instanceof Uint8Array
                 || v instanceof Int8Array
                 || v instanceof ArrayBuffer);
  };

  
  const affirmBindableTypedArray = (v)=>{
    return isBindableTypedArray(v)
      || toss3("Value is not of a supported TypedArray type.");
  };

  const utf8Decoder = new TextDecoder('utf-8');

  
  const typedArrayToString = function(typedArray, begin, end){
    return utf8Decoder.decode(typedArrayPart(typedArray, begin,end));
  };

  
  const flexibleString = function(v){
    if(isSQLableTypedArray(v)){
      return typedArrayToString(
        (v instanceof ArrayBuffer) ? new Uint8Array(v) : v
      );
    }
    else if(Array.isArray(v)) return v.join("");
    else if(wasm.isPtr(v)) v = wasm.cstrToJs(v);
    return v;
  };

  
  class WasmAllocError extends Error {
    
    constructor(...args){
      if(2===args.length && 'object'===typeof args[1]){
        super(...args);
      }else if(args.length){
        super(args.join(' '));
      }else{
        super("Allocation failed.");
      }
      this.resultCode = capi.SQLITE_NOMEM;
      this.name = 'WasmAllocError';
    }
  };
  
  WasmAllocError.toss = (...args)=>{
    throw new WasmAllocError(...args);
  };

  Object.assign(capi, {
    
    sqlite3_bind_blob: undefined,

    
    sqlite3_bind_text: undefined,

    
    sqlite3_create_function_v2: (
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal, xDestroy
    )=>{},
    
    sqlite3_create_function: (
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal
    )=>{},
    
    sqlite3_create_window_function: (
      pDb, funcName, nArg, eTextRep, pApp,
      xStep, xFinal, xValue, xInverse, xDestroy
    )=>{},
    
    sqlite3_prepare_v3: (dbPtr, sql, sqlByteLen, prepFlags,
                         stmtPtrPtr, strPtrPtr)=>{},

    
    sqlite3_prepare_v2: (dbPtr, sql, sqlByteLen,
                         stmtPtrPtr,strPtrPtr)=>{},

    
    sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg)=>{},

    
    sqlite3_randomness: (n, outPtr)=>{},
  });

  
  const util = {
    affirmBindableTypedArray, flexibleString,
    bigIntFits32, bigIntFits64, bigIntFitsDouble,
    isBindableTypedArray,
    isInt32, isSQLableTypedArray, isTypedArray,
    typedArrayToString,
    isUIThread: ()=>(globalThis.window===globalThis && !!globalThis.document),
    
    isSharedTypedArray,
    toss: function(...args){throw new Error(args.join(' '))},
    toss3,
    typedArrayPart,
    
    affirmDbHeader: function(bytes){
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      const header = "SQLite format 3";
      if( header.length > bytes.byteLength ){
        toss3("Input does not contain an SQLite3 database header.");
      }
      for(let i = 0; i < header.length; ++i){
        if( header.charCodeAt(i) !== bytes[i] ){
          toss3("Input does not contain an SQLite3 database header.");
        }
      }
    },
    
    affirmIsDb: function(bytes){
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      const n = bytes.byteLength;
      if(n<512 || n%512!==0) {
        toss3("Byte array size",n,"is invalid for an SQLite3 db.");
      }
      util.affirmDbHeader(bytes);
    }
  };

  Object.assign(wasm, {
    
    ptrSizeof: config.wasmPtrSizeof || 4,
    
    ptrIR: config.wasmPtrIR || "i32",
    
    bigIntEnabled: !!config.bigIntEnabled,
    
    exports: config.exports
      || toss3("Missing API config.exports (WASM module exports)."),

    
    memory: config.memory || config.exports['memory']
      || toss3("API config object requires a WebAssembly.Memory object",
              "in either config.exports.memory (exported)",
              "or config.memory (imported)."),

    
    alloc: undefined,

    
    realloc: undefined,

    
    dealloc: undefined

    
  });

  
  wasm.allocFromTypedArray = function(srcTypedArray){
    if(srcTypedArray instanceof ArrayBuffer){
      srcTypedArray = new Uint8Array(srcTypedArray);
    }
    affirmBindableTypedArray(srcTypedArray);
    const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
    wasm.heapForSize(srcTypedArray.constructor).set(
      srcTypedArray.byteLength ? srcTypedArray : [0], pRet
    );
    return pRet;
  };

  {
    
    const keyAlloc = config.allocExportName,
          keyDealloc = config.deallocExportName,
          keyRealloc = config.reallocExportName;
    for(const key of [keyAlloc, keyDealloc, keyRealloc]){
      const f = wasm.exports[key];
      if(!(f instanceof Function)) toss3("Missing required exports[",key,"] function.");
    }

    wasm.alloc = function f(n){
      return f.impl(n) || WasmAllocError.toss("Failed to allocate",n," bytes.");
    };
    wasm.alloc.impl = wasm.exports[keyAlloc];
    wasm.realloc = function f(m,n){
      const m2 = f.impl(m,n);
      return n ? (m2 || WasmAllocError.toss("Failed to reallocate",n," bytes.")) : 0;
    };
    wasm.realloc.impl = wasm.exports[keyRealloc];
    wasm.dealloc = wasm.exports[keyDealloc];
  }

  
  wasm.compileOptionUsed = function f(optName){
    if(!arguments.length){
      if(f._result) return f._result;
      else if(!f._opt){
        f._rx = /^([^=]+)=(.+)/;
        f._rxInt = /^-?\d+$/;
        f._opt = function(opt, rv){
          const m = f._rx.exec(opt);
          rv[0] = (m ? m[1] : opt);
          rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;
        };
      }
      const rc = {}, ov = [0,0];
      let i = 0, k;
      while((k = capi.sqlite3_compileoption_get(i++))){
        f._opt(k,ov);
        rc[ov[0]] = ov[1];
      }
      return f._result = rc;
    }else if(Array.isArray(optName)){
      const rc = {};
      optName.forEach((v)=>{
        rc[v] = capi.sqlite3_compileoption_used(v);
      });
      return rc;
    }else if('object' === typeof optName){
      Object.keys(optName).forEach((k)=> {
        optName[k] = capi.sqlite3_compileoption_used(k);
      });
      return optName;
    }
    return (
      'string'===typeof optName
    ) ? !!capi.sqlite3_compileoption_used(optName) : false;
  };

  
  wasm.pstack = Object.assign(Object.create(null),{
    
    restore: wasm.exports.sqlite3_wasm_pstack_restore,
    
    alloc: function(n){
      if('string'===typeof n && !(n = wasm.sizeofIR(n))){
        WasmAllocError.toss("Invalid value for pstack.alloc(",arguments[0],")");
      }
      return wasm.exports.sqlite3_wasm_pstack_alloc(n)
        || WasmAllocError.toss("Could not allocate",n,
                               "bytes from the pstack.");
    },
    
    allocChunks: function(n,sz){
      if('string'===typeof sz && !(sz = wasm.sizeofIR(sz))){
        WasmAllocError.toss("Invalid size value for allocChunks(",arguments[1],")");
      }
      const mem = wasm.pstack.alloc(n * sz);
      const rc = [];
      let i = 0, offset = 0;
      for(; i < n; ++i, offset += sz) rc.push(mem + offset);
      return rc;
    },
    
    allocPtr: (n=1,safePtrSize=true)=>{
      return 1===n
        ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)
        : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);
    },

    
    call: function(f){
      const stackPos = wasm.pstack.pointer;
      try{ return f(sqlite3) } finally{
        wasm.pstack.restore(stackPos);
      }
    }

  });
  Object.defineProperties(wasm.pstack, {
    
    pointer: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_ptr
      
      
      
    },
    
    quota: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_quota
    },
    
    remaining: {
      configurable: false, iterable: true, writeable: false,
      get: wasm.exports.sqlite3_wasm_pstack_remaining
    }
  });

  capi.sqlite3_randomness = (...args)=>{
    if(1===args.length && util.isTypedArray(args[0])
      && 1===args[0].BYTES_PER_ELEMENT){
      const ta = args[0];
      if(0===ta.byteLength){
        wasm.exports.sqlite3_randomness(0,0);
        return ta;
      }
      const stack = wasm.pstack.pointer;
      try {
        let n = ta.byteLength, offset = 0;
        const r = wasm.exports.sqlite3_randomness;
        const heap = wasm.heap8u();
        const nAlloc = n < 512 ? n : 512;
        const ptr = wasm.pstack.alloc(nAlloc);
        do{
          const j = (n>nAlloc ? nAlloc : n);
          r(j, ptr);
          ta.set(typedArrayPart(heap, ptr, ptr+j), offset);
          n -= j;
          offset += j;
        } while(n > 0);
      }catch(e){
        console.error("Highly unexpected (and ignored!) "+
                      "exception in sqlite3_randomness():",e);
      }finally{
        wasm.pstack.restore(stack);
      }
      return ta;
    }
    wasm.exports.sqlite3_randomness(...args);
  };

  
  let __wasmfsOpfsDir = undefined;
  
  capi.sqlite3_wasmfs_opfs_dir = function(){
    if(undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;
    
    const pdir = config.wasmfsOpfsDir;
    if(!pdir
       || !globalThis.FileSystemHandle
       || !globalThis.FileSystemDirectoryHandle
       || !globalThis.FileSystemFileHandle){
      return __wasmfsOpfsDir = "";
    }
    try{
      if(pdir && 0===wasm.xCallWrapped(
        'sqlite3_wasm_init_wasmfs', 'i32', ['string'], pdir
      )){
        return __wasmfsOpfsDir = pdir;
      }else{
        return __wasmfsOpfsDir = "";
      }
    }catch(e){
      
      return __wasmfsOpfsDir = "";
    }
  };

  
  capi.sqlite3_wasmfs_filename_is_persistent = function(name){
    const p = capi.sqlite3_wasmfs_opfs_dir();
    return (p && name) ? name.startsWith(p+'/') : false;
  };

  
  capi.sqlite3_js_db_uses_vfs = function(pDb,vfsName,dbName=0){
    try{
      const pK = capi.sqlite3_vfs_find(vfsName);
      if(!pK) return false;
      else if(!pDb){
        return pK===capi.sqlite3_vfs_find(0) ? pK : false;
      }else{
        return pK===capi.sqlite3_js_db_vfs(pDb,dbName) ? pK : false;
      }
    }catch(e){
      
      return false;
    }
  };

  
  capi.sqlite3_js_vfs_list = function(){
    const rc = [];
    let pVfs = capi.sqlite3_vfs_find(0);
    while(pVfs){
      const oVfs = new capi.sqlite3_vfs(pVfs);
      rc.push(wasm.cstrToJs(oVfs.$zName));
      pVfs = oVfs.$pNext;
      oVfs.dispose();
    }
    return rc;
  };

  
  capi.sqlite3_js_db_export = function(pDb, schema=0){
    pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);
    if(!pDb) toss3('Invalid sqlite3* argument.');
    if(!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');
    const scope = wasm.scopedAllocPush();
    let pOut;
    try{
      const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
      const ppOut = pSize + 8;
      
      const zSchema = schema
            ? (wasm.isPtr(schema) ? schema : wasm.scopedAllocCString(''+schema))
            : 0;
      let rc = wasm.exports.sqlite3_wasm_db_serialize(
        pDb, zSchema, ppOut, pSize, 0
      );
      if(rc){
        toss3("Database serialization failed with code",
             sqlite3.capi.sqlite3_js_rc_str(rc));
      }
      pOut = wasm.peekPtr(ppOut);
      const nOut = wasm.peek(pSize, 'i64');
      rc = nOut
        ? wasm.heap8u().slice(pOut, pOut + Number(nOut))
        : new Uint8Array();
      return rc;
    }finally{
      if(pOut) wasm.exports.sqlite3_free(pOut);
      wasm.scopedAllocPop(scope);
    }
  };

  
  capi.sqlite3_js_db_vfs =
    (dbPointer, dbName=0)=>wasm.sqlite3_wasm_db_vfs(dbPointer, dbName);

  
  capi.sqlite3_js_aggregate_context = (pCtx, n)=>{
    return capi.sqlite3_aggregate_context(pCtx, n)
      || (n ? WasmAllocError.toss("Cannot allocate",n,
                                  "bytes for sqlite3_aggregate_context()")
          : 0);
  };

  
  capi.sqlite3_js_posix_create_file = function(filename, data, dataLen){
    let pData;
    if(data && wasm.isPtr(data)){
      pData = data;
    }else if(data instanceof ArrayBuffer || data instanceof Uint8Array){
      pData = wasm.allocFromTypedArray(data);
      if(arguments.length<3 || !util.isInt32(dataLen) || dataLen<0){
        dataLen = data.byteLength;
      }
    }else{
      SQLite3Error.toss("Invalid 2nd argument for sqlite3_js_posix_create_file().");
    }
    try{
      if(!util.isInt32(dataLen) || dataLen<0){
        SQLite3Error.toss("Invalid 3rd argument for sqlite3_js_posix_create_file().");
      }
      const rc = wasm.sqlite3_wasm_posix_create_file(filename, pData, dataLen);
      if(rc) SQLite3Error.toss("Creation of file failed with sqlite3 result code",
                               capi.sqlite3_js_rc_str(rc));
    }finally{
       wasm.dealloc(pData);
    }
  };

  
  capi.sqlite3_js_vfs_create_file = function(vfs, filename, data, dataLen){
    config.warn("sqlite3_js_vfs_create_file() is deprecated and",
                "should be avoided because it can lead to C-level crashes.",
                "See its documentation for alternative options.");
    let pData;
    if(data){
      if(wasm.isPtr(data)){
        pData = data;
      }else if(data instanceof ArrayBuffer){
        data = new Uint8Array(data);
      }
      if(data instanceof Uint8Array){
        pData = wasm.allocFromTypedArray(data);
        if(arguments.length<4 || !util.isInt32(dataLen) || dataLen<0){
          dataLen = data.byteLength;
        }
      }else{
        SQLite3Error.toss("Invalid 3rd argument type for sqlite3_js_vfs_create_file().");
      }
    }else{
       pData = 0;
    }
    if(!util.isInt32(dataLen) || dataLen<0){
      wasm.dealloc(pData);
      SQLite3Error.toss("Invalid 4th argument for sqlite3_js_vfs_create_file().");
    }
    try{
      const rc = wasm.sqlite3_wasm_vfs_create_file(vfs, filename, pData, dataLen);
      if(rc) SQLite3Error.toss("Creation of file failed with sqlite3 result code",
                               capi.sqlite3_js_rc_str(rc));
    }finally{
       wasm.dealloc(pData);
    }
  };

  
  capi.sqlite3_js_sql_to_string = (sql)=>{
    if('string' === typeof sql){
      return sql;
    }
    const x = flexibleString(v);
    return x===v ? undefined : x;
  }

  if( util.isUIThread() ){
    

    
    const __kvvfsInfo = function(which){
      const rc = Object.create(null);
      rc.prefix = 'kvvfs-'+which;
      rc.stores = [];
      if('session'===which || ""===which) rc.stores.push(globalThis.sessionStorage);
      if('local'===which || ""===which) rc.stores.push(globalThis.localStorage);
      return rc;
    };

    
    capi.sqlite3_js_kvvfs_clear = function(which=""){
      let rc = 0;
      const kvinfo = __kvvfsInfo(which);
      kvinfo.stores.forEach((s)=>{
        const toRm = [] ;
        let i;
        for( i = 0; i < s.length; ++i ){
          const k = s.key(i);
          if(k.startsWith(kvinfo.prefix)) toRm.push(k);
        }
        toRm.forEach((kk)=>s.removeItem(kk));
        rc += toRm.length;
      });
      return rc;
    };

    
    capi.sqlite3_js_kvvfs_size = function(which=""){
      let sz = 0;
      const kvinfo = __kvvfsInfo(which);
      kvinfo.stores.forEach((s)=>{
        let i;
        for(i = 0; i < s.length; ++i){
          const k = s.key(i);
          if(k.startsWith(kvinfo.prefix)){
            sz += k.length;
            sz += s.getItem(k).length;
          }
        }
      });
      return sz * 2 ;
    };

  }

  
  capi.sqlite3_db_config = function(pDb, op, ...args){
    if(!this.s){
      this.s = wasm.xWrap('sqlite3_wasm_db_config_s','int',
                          ['sqlite3*', 'int', 'string:static']
                          );
      this.pii = wasm.xWrap('sqlite3_wasm_db_config_pii', 'int',
                            ['sqlite3*', 'int', '*','int', 'int']);
      this.ip = wasm.xWrap('sqlite3_wasm_db_config_ip','int',
                           ['sqlite3*', 'int', 'int','*']);
    }
    switch(op){
        case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
        case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
        case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
        case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
        case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
        case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
        case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
        case capi.SQLITE_DBCONFIG_RESET_DATABASE:
        case capi.SQLITE_DBCONFIG_DEFENSIVE:
        case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
        case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
        case capi.SQLITE_DBCONFIG_DQS_DML:
        case capi.SQLITE_DBCONFIG_DQS_DDL:
        case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
        case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
        case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
        case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
        case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
          return this.ip(pDb, op, args[0], args[1] || 0);
        case capi.SQLITE_DBCONFIG_LOOKASIDE:
          return this.pii(pDb, op, args[0], args[1], args[2]);
        case capi.SQLITE_DBCONFIG_MAINDBNAME:
          return this.s(pDb, op, args[0]);
        default:
          return capi.SQLITE_MISUSE;
    }
  }.bind(Object.create(null));

  
  capi.sqlite3_value_to_js = function(pVal,throwIfCannotConvert=true){
    let arg;
    const valType = capi.sqlite3_value_type(pVal);
    switch(valType){
        case capi.SQLITE_INTEGER:
          if(wasm.bigIntEnabled){
            arg = capi.sqlite3_value_int64(pVal);
            if(util.bigIntFitsDouble(arg)) arg = Number(arg);
          }
          else arg = capi.sqlite3_value_double(pVal);
          break;
        case capi.SQLITE_FLOAT:
          arg = capi.sqlite3_value_double(pVal);
          break;
        case capi.SQLITE_TEXT:
          arg = capi.sqlite3_value_text(pVal);
          break;
        case capi.SQLITE_BLOB:{
          const n = capi.sqlite3_value_bytes(pVal);
          const pBlob = capi.sqlite3_value_blob(pVal);
          if(n && !pBlob) sqlite3.WasmAllocError.toss(
            "Cannot allocate memory for blob argument of",n,"byte(s)"
          );
          arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;
          break;
        }
        case capi.SQLITE_NULL:
          arg = null; break;
        default:
          if(throwIfCannotConvert){
            toss3(capi.SQLITE_MISMATCH,
                  "Unhandled sqlite3_value_type():",valType);
          }
          arg = undefined;
    }
    return arg;
  };

  
  capi.sqlite3_values_to_js = function(argc,pArgv,throwIfCannotConvert=true){
    let i;
    const tgt = [];
    for(i = 0; i < argc; ++i){
      
      tgt.push(capi.sqlite3_value_to_js(
        wasm.peekPtr(pArgv + (wasm.ptrSizeof * i)),
        throwIfCannotConvert
      ));
    }
    return tgt;
  };

  
  capi.sqlite3_result_error_js = function(pCtx,e){
    if(e instanceof WasmAllocError){
      capi.sqlite3_result_error_nomem(pCtx);
    }else{
      ;
      capi.sqlite3_result_error(pCtx, ''+e, -1);
    }
  };

  
  capi.sqlite3_result_js = function(pCtx,val){
    if(val instanceof Error){
      capi.sqlite3_result_error_js(pCtx, val);
      return;
    }
    try{
      switch(typeof val) {
          case 'undefined':
            
            break;
          case 'boolean':
            capi.sqlite3_result_int(pCtx, val ? 1 : 0);
            break;
          case 'bigint':
            if(util.bigIntFits32(val)){
              capi.sqlite3_result_int(pCtx, Number(val));
            }else if(util.bigIntFitsDouble(val)){
              capi.sqlite3_result_double(pCtx, Number(val));
            }else if(wasm.bigIntEnabled){
              if(util.bigIntFits64(val)) capi.sqlite3_result_int64(pCtx, val);
              else toss3("BigInt value",val.toString(),"is too BigInt for int64.");
            }else{
              toss3("BigInt value",val.toString(),"is too BigInt.");
            }
            break;
          case 'number': {
            let f;
            if(util.isInt32(val)){
              f = capi.sqlite3_result_int;
            }else if(wasm.bigIntEnabled
                     && Number.isInteger(val)
                     && util.bigIntFits64(BigInt(val))){
              f = capi.sqlite3_result_int64;
            }else{
              f = capi.sqlite3_result_double;
            }
            f(pCtx, val);
            break;
          }
          case 'string': {
            const [p, n] = wasm.allocCString(val,true);
            capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);
            break;
          }
          case 'object':
            if(null===val) {
              capi.sqlite3_result_null(pCtx);
              break;
            }else if(util.isBindableTypedArray(val)){
              const pBlob = wasm.allocFromTypedArray(val);
              capi.sqlite3_result_blob(
                pCtx, pBlob, val.byteLength,
                capi.SQLITE_WASM_DEALLOC
              );
              break;
            }
            
          default:
            toss3("Don't not how to handle this UDF result value:",(typeof val), val);
      }
    }catch(e){
      capi.sqlite3_result_error_js(pCtx, e);
    }
  };

  
  capi.sqlite3_column_js = function(pStmt, iCol, throwIfCannotConvert=true){
    const v = capi.sqlite3_column_value(pStmt, iCol);
    return (0===v) ? undefined : capi.sqlite3_value_to_js(v, throwIfCannotConvert);
  };

  
  const __newOldValue = function(pObj, iCol, impl){
    impl = capi[impl];
    if(!this.ptr) this.ptr = wasm.allocPtr();
    else wasm.pokePtr(this.ptr, 0);
    const rc = impl(pObj, iCol, this.ptr);
    if(rc) return SQLite3Error.toss(rc,arguments[2]+"() failed with code "+rc);
    const pv = wasm.peekPtr(this.ptr);
    return pv ? capi.sqlite3_value_to_js( pv, true ) : undefined;
  }.bind(Object.create(null));

  
  capi.sqlite3_preupdate_new_js =
    (pDb, iCol)=>__newOldValue(pDb, iCol, 'sqlite3_preupdate_new');

  
  capi.sqlite3_preupdate_old_js =
    (pDb, iCol)=>__newOldValue(pDb, iCol, 'sqlite3_preupdate_old');

  
  capi.sqlite3changeset_new_js =
    (pChangesetIter, iCol) => __newOldValue(pChangesetIter, iCol,
                                            'sqlite3changeset_new');

  
  capi.sqlite3changeset_old_js =
    (pChangesetIter, iCol)=>__newOldValue(pChangesetIter, iCol,
                                          'sqlite3changeset_old');

  
  const sqlite3 = {
    WasmAllocError: WasmAllocError,
    SQLite3Error: SQLite3Error,
    capi,
    util,
    wasm,
    config,
    
    version: Object.create(null),

    
    client: undefined,

    
    asyncPostInit: async function ff(){
      if(ff.isReady instanceof Promise) return ff.isReady;
      let lia = sqlite3ApiBootstrap.initializersAsync;
      delete sqlite3ApiBootstrap.initializersAsync;
      const postInit = async ()=>{
        if(!sqlite3.__isUnderTest){
          
          delete sqlite3.util;
          
          delete sqlite3.StructBinder;
        }
        return sqlite3;
      };
      const catcher = (e)=>{
        config.error("an async sqlite3 initializer failed:",e);
        throw e;
      };
      if(!lia || !lia.length){
        return ff.isReady = postInit().catch(catcher);
      }
      lia = lia.map((f)=>{
        return (f instanceof Function) ? async x=>f(sqlite3) : f;
      });
      lia.push(postInit);
      let p = Promise.resolve(sqlite3);
      while(lia.length) p = p.then(lia.shift());
      return ff.isReady = p.catch(catcher);
    },
    
    scriptInfo: undefined
  };
  try{
    sqlite3ApiBootstrap.initializers.forEach((f)=>{
      f(sqlite3);
    });
  }catch(e){
    
    console.error("sqlite3 bootstrap initializer threw:",e);
    throw e;
  }
  delete sqlite3ApiBootstrap.initializers;
  sqlite3ApiBootstrap.sqlite3 = sqlite3;
  return sqlite3;
};

globalThis.sqlite3ApiBootstrap.initializers = [];

globalThis.sqlite3ApiBootstrap.initializersAsync = [];

globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);

globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;




globalThis.WhWasmUtilInstaller = function(target){
  'use strict';
  if(undefined===target.bigIntEnabled){
    target.bigIntEnabled = !!globalThis['BigInt64Array'];
  }

  
  const toss = (...args)=>{throw new Error(args.join(' '))};

  if(!target.exports){
    Object.defineProperty(target, 'exports', {
      enumerable: true, configurable: true,
      get: ()=>(target.instance && target.instance.exports)
    });
  }

  
  

  
  const ptrIR = target.pointerIR || 'i32';
  const ptrSizeof = target.ptrSizeof =
        ('i32'===ptrIR ? 4
         : ('i64'===ptrIR
            ? 8 : toss("Unhandled ptrSizeof:",ptrIR)));
  
  const cache = Object.create(null);
  
  cache.heapSize = 0;
  
  cache.memory = null;
  
  cache.freeFuncIndexes = [];
  
  cache.scopedAlloc = [];

  cache.utf8Decoder = new TextDecoder();
  cache.utf8Encoder = new TextEncoder('utf-8');

  
  target.sizeofIR = (n)=>{
    switch(n){
        case 'i8': return 1;
        case 'i16': return 2;
        case 'i32': case 'f32': case 'float': return 4;
        case 'i64': case 'f64': case 'double': return 8;
        case '*': return ptrSizeof;
        default:
          return (''+n).endsWith('*') ? ptrSizeof : undefined;
    }
  };

  
  const heapWrappers = function(){
    if(!cache.memory){
      cache.memory = (target.memory instanceof WebAssembly.Memory)
        ? target.memory : target.exports.memory;
    }else if(cache.heapSize === cache.memory.buffer.byteLength){
      return cache;
    }
    
    const b = cache.memory.buffer;
    cache.HEAP8 = new Int8Array(b); cache.HEAP8U = new Uint8Array(b);
    cache.HEAP16 = new Int16Array(b); cache.HEAP16U = new Uint16Array(b);
    cache.HEAP32 = new Int32Array(b); cache.HEAP32U = new Uint32Array(b);
    if(target.bigIntEnabled){
      cache.HEAP64 = new BigInt64Array(b); cache.HEAP64U = new BigUint64Array(b);
    }
    cache.HEAP32F = new Float32Array(b); cache.HEAP64F = new Float64Array(b);
    cache.heapSize = b.byteLength;
    return cache;
  };

  
  target.heap8 = ()=>heapWrappers().HEAP8;

  
  target.heap8u = ()=>heapWrappers().HEAP8U;

  
  target.heap16 = ()=>heapWrappers().HEAP16;

  
  target.heap16u = ()=>heapWrappers().HEAP16U;

  
  target.heap32 = ()=>heapWrappers().HEAP32;

  
  target.heap32u = ()=>heapWrappers().HEAP32U;

  
  target.heapForSize = function(n,unsigned = true){
    let ctor;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    switch(n){
        case Int8Array: return c.HEAP8; case Uint8Array: return c.HEAP8U;
        case Int16Array: return c.HEAP16; case Uint16Array: return c.HEAP16U;
        case Int32Array: return c.HEAP32; case Uint32Array: return c.HEAP32U;
        case 8:  return unsigned ? c.HEAP8U : c.HEAP8;
        case 16: return unsigned ? c.HEAP16U : c.HEAP16;
        case 32: return unsigned ? c.HEAP32U : c.HEAP32;
        case 64:
          if(c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;
          break;
        default:
          if(target.bigIntEnabled){
            if(n===globalThis['BigUint64Array']) return c.HEAP64U;
            else if(n===globalThis['BigInt64Array']) return c.HEAP64;
            break;
          }
    }
    toss("Invalid heapForSize() size: expecting 8, 16, 32,",
         "or (if BigInt is enabled) 64.");
  };

  
  target.functionTable = function(){
    return target.exports.__indirect_function_table;
    
  };

  
  target.functionEntry = function(fptr){
    const ft = target.functionTable();
    return fptr < ft.length ? ft.get(fptr) : undefined;
  };

  
  target.jsFuncToWasm = function f(func, sig){
    
    if(!f._){
      f._ = {
        
        sigTypes: Object.assign(Object.create(null),{
          i: 'i32', p: 'i32', P: 'i32', s: 'i32',
          j: 'i64', f: 'f32', d: 'f64'
        }),
        
        typeCodes: Object.assign(Object.create(null),{
          f64: 0x7c, f32: 0x7d, i64: 0x7e, i32: 0x7f
        }),
        
        uleb128Encode: function(tgt, method, n){
          if(n<128) tgt[method](n);
          else tgt[method]( (n % 128) | 128, n>>7);
        },
        
        rxJSig: /^(\w)\((\w*)\)$/,
        
        sigParams: function(sig){
          const m = f._.rxJSig.exec(sig);
          return m ? m[2] : sig.substr(1);
        },
        
        letterType: (x)=>f._.sigTypes[x] || toss("Invalid signature letter:",x),
        
        
        
        pushSigType: (dest, letter)=>dest.push(f._.typeCodes[f._.letterType(letter)])
      };
    }
    if('string'===typeof func){
      const x = sig;
      sig = func;
      func = x;
    }
    const sigParams = f._.sigParams(sig);
    const wasmCode = [0x01, 0x60];
    f._.uleb128Encode(wasmCode, 'push', sigParams.length);
    for(const x of sigParams) f._.pushSigType(wasmCode, x);
    if('v'===sig[0]) wasmCode.push(0);
    else{
      wasmCode.push(1);
      f._.pushSigType(wasmCode, sig[0]);
    }
    f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);
    wasmCode.unshift(
      0x00, 0x61, 0x73, 0x6d, 
      0x01, 0x00, 0x00, 0x00, 
      0x01 
    );
    wasmCode.push(
       0x02, 0x07,
      
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
       0x07, 0x05,
      
      0x01, 0x01, 0x66, 0x00, 0x00
    );
    return (new WebAssembly.Instance(
      new WebAssembly.Module(new Uint8Array(wasmCode)), {
        e: { f: func }
      })).exports['f'];
  };

  
  const __installFunction = function f(func, sig, scoped){
    if(scoped && !cache.scopedAlloc.length){
      toss("No scopedAllocPush() scope is active.");
    }
    if('string'===typeof func){
      const x = sig;
      sig = func;
      func = x;
    }
    if('string'!==typeof sig || !(func instanceof Function)){
      toss("Invalid arguments: expecting (function,signature) "+
           "or (signature,function).");
    }
    const ft = target.functionTable();
    const oldLen = ft.length;
    let ptr;
    while(cache.freeFuncIndexes.length){
      ptr = cache.freeFuncIndexes.pop();
      if(ft.get(ptr)){ 
        ptr = null;
        continue;
      }else{
        break;
      }
    }
    if(!ptr){
      ptr = oldLen;
      ft.grow(1);
    }
    try{
      
      ft.set(ptr, func);
      if(scoped){
        cache.scopedAlloc[cache.scopedAlloc.length-1].push(ptr);
      }
      return ptr;
    }catch(e){
      if(!(e instanceof TypeError)){
        if(ptr===oldLen) cache.freeFuncIndexes.push(oldLen);
        throw e;
      }
    }
    
    try {
      const fptr = target.jsFuncToWasm(func, sig);
      ft.set(ptr, fptr);
      if(scoped){
        cache.scopedAlloc[cache.scopedAlloc.length-1].push(ptr);
      }
    }catch(e){
      if(ptr===oldLen) cache.freeFuncIndexes.push(oldLen);
      throw e;
    }
    return ptr;
  };

  
  target.installFunction = (func, sig)=>__installFunction(func, sig, false);

  
  target.scopedInstallFunction = (func, sig)=>__installFunction(func, sig, true);

  
  target.uninstallFunction = function(ptr){
    if(!ptr && 0!==ptr) return undefined;
    const fi = cache.freeFuncIndexes;
    const ft = target.functionTable();
    fi.push(ptr);
    const rc = ft.get(ptr);
    ft.set(ptr, null);
    return rc;
  };

  
  target.peek = function f(ptr, type='i8'){
    if(type.endsWith('*')) type = ptrIR;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    const list = Array.isArray(ptr) ? [] : undefined;
    let rc;
    do{
      if(list) ptr = arguments[0].shift();
      switch(type){
          case 'i1':
          case 'i8': rc = c.HEAP8[ptr>>0]; break;
          case 'i16': rc = c.HEAP16[ptr>>1]; break;
          case 'i32': rc = c.HEAP32[ptr>>2]; break;
          case 'float': case 'f32': rc = c.HEAP32F[ptr>>2]; break;
          case 'double': case 'f64': rc = Number(c.HEAP64F[ptr>>3]); break;
          case 'i64':
            if(target.bigIntEnabled){
              rc = BigInt(c.HEAP64[ptr>>3]);
              break;
            }
            
          default:
            toss('Invalid type for peek():',type);
      }
      if(list) list.push(rc);
    }while(list && arguments[0].length);
    return list || rc;
  };

  
  target.poke = function(ptr, value, type='i8'){
    if (type.endsWith('*')) type = ptrIR;
    const c = (cache.memory && cache.heapSize === cache.memory.buffer.byteLength)
          ? cache : heapWrappers();
    for(const p of (Array.isArray(ptr) ? ptr : [ptr])){
      switch (type) {
          case 'i1':
          case 'i8': c.HEAP8[p>>0] = value; continue;
          case 'i16': c.HEAP16[p>>1] = value; continue;
          case 'i32': c.HEAP32[p>>2] = value; continue;
          case 'float': case 'f32': c.HEAP32F[p>>2] = value; continue;
          case 'double': case 'f64': c.HEAP64F[p>>3] = value; continue;
          case 'i64':
            if(c.HEAP64){
              c.HEAP64[p>>3] = BigInt(value);
              continue;
            }
            
          default:
            toss('Invalid type for poke(): ' + type);
      }
    }
    return this;
  };

  
  target.peekPtr = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), ptrIR );

  
  target.pokePtr = (ptr, value=0)=>target.poke(ptr, value, ptrIR);

  
  target.peek8 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i8' );
  
  target.poke8 = (ptr, value)=>target.poke(ptr, value, 'i8');
  
  target.peek16 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i16' );
  
  target.poke16 = (ptr, value)=>target.poke(ptr, value, 'i16');
  
  target.peek32 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i32' );
  
  target.poke32 = (ptr, value)=>target.poke(ptr, value, 'i32');
  
  target.peek64 = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'i64' );
  
  target.poke64 = (ptr, value)=>target.poke(ptr, value, 'i64');
  
  target.peek32f = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'f32' );
  
  target.poke32f = (ptr, value)=>target.poke(ptr, value, 'f32');
  
  target.peek64f = (...ptr)=>target.peek( (1===ptr.length ? ptr[0] : ptr), 'f64' );
  
  target.poke64f = (ptr, value)=>target.poke(ptr, value, 'f64');

  
  target.getMemValue = target.peek;
  
  target.getPtrValue = target.peekPtr;
  
  target.setMemValue = target.poke;
  
  target.setPtrValue = target.pokePtr;

  
  target.isPtr32 = (ptr)=>('number'===typeof ptr && (ptr===(ptr|0)) && ptr>=0);

  
  target.isPtr = target.isPtr32;

  
  target.cstrlen = function(ptr){
    if(!ptr || !target.isPtr(ptr)) return null;
    const h = heapWrappers().HEAP8U;
    let pos = ptr;
    for( ; h[pos] !== 0; ++pos ){}
    return pos - ptr;
  };

  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  const __utf8Decode = function(arrayBuffer, begin, end){
    return cache.utf8Decoder.decode(
      (arrayBuffer.buffer instanceof __SAB)
        ? arrayBuffer.slice(begin, end)
        : arrayBuffer.subarray(begin, end)
    );
  };

  
  target.cstrToJs = function(ptr){
    const n = target.cstrlen(ptr);
    return n ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr+n) : (null===n ? n : "");
  };

  
  target.jstrlen = function(str){
    
    if('string'!==typeof str) return null;
    const n = str.length;
    let len = 0;
    for(let i = 0; i < n; ++i){
      let u = str.charCodeAt(i);
      if(u>=0xd800 && u<=0xdfff){
        u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
      }
      if(u<=0x7f) ++len;
      else if(u<=0x7ff) len += 2;
      else if(u<=0xffff) len += 3;
      else len += 4;
    }
    return len;
  };

  
  target.jstrcpy = function(jstr, tgt, offset = 0, maxBytes = -1, addNul = true){
    
    if(!tgt || (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))){
      toss("jstrcpy() target must be an Int8Array or Uint8Array.");
    }
    if(maxBytes<0) maxBytes = tgt.length - offset;
    if(!(maxBytes>0) || !(offset>=0)) return 0;
    let i = 0, max = jstr.length;
    const begin = offset, end = offset + maxBytes - (addNul ? 1 : 0);
    for(; i < max && offset < end; ++i){
      let u = jstr.charCodeAt(i);
      if(u>=0xd800 && u<=0xdfff){
        u = 0x10000 + ((u & 0x3FF) << 10) | (jstr.charCodeAt(++i) & 0x3FF);
      }
      if(u<=0x7f){
        if(offset >= end) break;
        tgt[offset++] = u;
      }else if(u<=0x7ff){
        if(offset + 1 >= end) break;
        tgt[offset++] = 0xC0 | (u >> 6);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }else if(u<=0xffff){
        if(offset + 2 >= end) break;
        tgt[offset++] = 0xe0 | (u >> 12);
        tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }else{
        if(offset + 3 >= end) break;
        tgt[offset++] = 0xf0 | (u >> 18);
        tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);
        tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
        tgt[offset++] = 0x80 | (u & 0x3f);
      }
    }
    if(addNul) tgt[offset++] = 0;
    return offset - begin;
  };

  
  target.cstrncpy = function(tgtPtr, srcPtr, n){
    if(!tgtPtr || !srcPtr) toss("cstrncpy() does not accept NULL strings.");
    if(n<0) n = target.cstrlen(strPtr)+1;
    else if(!(n>0)) return 0;
    const heap = target.heap8u();
    let i = 0, ch;
    for(; i < n && (ch = heap[srcPtr+i]); ++i){
      heap[tgtPtr+i] = ch;
    }
    if(i<n) heap[tgtPtr + i++] = 0;
    return i;
  };

  
  target.jstrToUintArray = (str, addNul=false)=>{
    return cache.utf8Encoder.encode(addNul ? (str+"\0") : str);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  };

  const __affirmAlloc = (obj,funcName)=>{
    if(!(obj.alloc instanceof Function) ||
       !(obj.dealloc instanceof Function)){
      toss("Object is missing alloc() and/or dealloc() function(s)",
           "required by",funcName+"().");
    }
  };

  const __allocCStr = function(jstr, returnWithLength, allocator, funcName){
    __affirmAlloc(target, funcName);
    if('string'!==typeof jstr) return null;
    if(false){}else{
      const u = cache.utf8Encoder.encode(jstr),
            ptr = allocator(u.length+1),
            heap = heapWrappers().HEAP8U;
      heap.set(u, ptr);
      heap[ptr + u.length] = 0;
      return returnWithLength ? [ptr, u.length] : ptr;
    }
  };

  
  target.allocCString =
    (jstr, returnWithLength=false)=>__allocCStr(jstr, returnWithLength,
                                                target.alloc, 'allocCString()');

  
  target.scopedAllocPush = function(){
    __affirmAlloc(target, 'scopedAllocPush');
    const a = [];
    cache.scopedAlloc.push(a);
    return a;
  };

  
  target.scopedAllocPop = function(state){
    __affirmAlloc(target, 'scopedAllocPop');
    const n = arguments.length
          ? cache.scopedAlloc.indexOf(state)
          : cache.scopedAlloc.length-1;
    if(n<0) toss("Invalid state object for scopedAllocPop().");
    if(0===arguments.length) state = cache.scopedAlloc[n];
    cache.scopedAlloc.splice(n,1);
    for(let p; (p = state.pop()); ){
      if(target.functionEntry(p)){
        
        target.uninstallFunction(p);
      }
      else target.dealloc(p);
    }
  };

  
  target.scopedAlloc = function(n){
    if(!cache.scopedAlloc.length){
      toss("No scopedAllocPush() scope is active.");
    }
    const p = target.alloc(n);
    cache.scopedAlloc[cache.scopedAlloc.length-1].push(p);
    return p;
  };

  Object.defineProperty(target.scopedAlloc, 'level', {
    configurable: false, enumerable: false,
    get: ()=>cache.scopedAlloc.length,
    set: ()=>toss("The 'active' property is read-only.")
  });

  
  target.scopedAllocCString =
    (jstr, returnWithLength=false)=>__allocCStr(jstr, returnWithLength,
                                                target.scopedAlloc, 'scopedAllocCString()');

  
  const __allocMainArgv = function(isScoped, list){
    const pList = target[
      isScoped ? 'scopedAlloc' : 'alloc'
    ]((list.length + 1) * target.ptrSizeof);
    let i = 0;
    list.forEach((e)=>{
      target.pokePtr(pList + (target.ptrSizeof * i++),
                         target[
                           isScoped ? 'scopedAllocCString' : 'allocCString'
                         ](""+e));
    });
    target.pokePtr(pList + (target.ptrSizeof * i), 0);
    return pList;
  };

  
  target.scopedAllocMainArgv = (list)=>__allocMainArgv(true, list);

  
  target.allocMainArgv = (list)=>__allocMainArgv(false, list);

  
  target.cArgvToJs = (argc, pArgv)=>{
    const list = [];
    for(let i = 0; i < argc; ++i){
      const arg = target.peekPtr(pArgv + (target.ptrSizeof * i));
      list.push( arg ? target.cstrToJs(arg) : null );
    }
    return list;
  };

  
  target.scopedAllocCall = function(func){
    target.scopedAllocPush();
    try{ return func() } finally{ target.scopedAllocPop() }
  };

  
  const __allocPtr = function(howMany, safePtrSize, method){
    __affirmAlloc(target, method);
    const pIr = safePtrSize ? 'i64' : ptrIR;
    let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
    target.poke(m, 0, pIr)
    if(1===howMany){
      return m;
    }
    const a = [m];
    for(let i = 1; i < howMany; ++i){
      m += (safePtrSize ? 8 : ptrSizeof);
      a[i] = m;
      target.poke(m, 0, pIr);
    }
    return a;
  };

  
  target.allocPtr =
    (howMany=1, safePtrSize=true)=>__allocPtr(howMany, safePtrSize, 'alloc');

  
  target.scopedAllocPtr =
    (howMany=1, safePtrSize=true)=>__allocPtr(howMany, safePtrSize, 'scopedAlloc');

  
  target.xGet = function(name){
    return target.exports[name] || toss("Cannot find exported symbol:",name);
  };

  const __argcMismatch =
        (f,n)=>toss(f+"() requires",n,"argument(s).");

  
  target.xCall = function(fname, ...args){
    const f = target.xGet(fname);
    if(!(f instanceof Function)) toss("Exported symbol",fname,"is not a function.");
    if(f.length!==args.length) __argcMismatch(fname,f.length)
    ;
    return (2===arguments.length && Array.isArray(arguments[1]))
      ? f.apply(null, arguments[1])
      : f.apply(null, args);
  };

  
  cache.xWrap = Object.create(null);
  cache.xWrap.convert = Object.create(null);
  
  cache.xWrap.convert.arg = new Map;
  
  cache.xWrap.convert.result = new Map;
  const xArg = cache.xWrap.convert.arg, xResult = cache.xWrap.convert.result;

  if(target.bigIntEnabled){
    xArg.set('i64', (i)=>BigInt(i));
  }
  const __xArgPtr = 'i32' === ptrIR
        ? ((i)=>(i | 0)) : ((i)=>(BigInt(i) | BigInt(0)));
  xArg.set('i32', __xArgPtr )
    .set('i16', (i)=>((i | 0) & 0xFFFF))
    .set('i8', (i)=>((i | 0) & 0xFF))
    .set('f32', (i)=>Number(i).valueOf())
    .set('float', xArg.get('f32'))
    .set('f64', xArg.get('f32'))
    .set('double', xArg.get('f64'))
    .set('int', xArg.get('i32'))
    .set('null', (i)=>i)
    .set(null, xArg.get('null'))
    .set('**', __xArgPtr)
    .set('*', __xArgPtr);
  xResult.set('*', __xArgPtr)
    .set('pointer', __xArgPtr)
    .set('number', (v)=>Number(v))
    .set('void', (v)=>undefined)
    .set('null', (v)=>v)
    .set(null, xResult.get('null'));

  { 
    const copyToResult = ['i8', 'i16', 'i32', 'int',
                          'f32', 'float', 'f64', 'double'];
    if(target.bigIntEnabled) copyToResult.push('i64');
    const adaptPtr = xArg.get(ptrIR);
    for(const t of copyToResult){
      xArg.set(t+'*', adaptPtr);
      xResult.set(t+'*', adaptPtr);
      xResult.set(t, (xArg.get(t) || toss("Missing arg converter:",t)));
    }
  }

  
  const __xArgString = function(v){
    if('string'===typeof v) return target.scopedAllocCString(v);
    return v ? __xArgPtr(v) : null;
  };
  xArg.set('string', __xArgString)
    .set('utf8', __xArgString)
    .set('pointer', __xArgString);
  

  xResult.set('string', (i)=>target.cstrToJs(i))
    .set('utf8', xResult.get('string'))
    .set('string:dealloc', (i)=>{
      try { return i ? target.cstrToJs(i) : null }
      finally{ target.dealloc(i) }
    })
    .set('utf8:dealloc', xResult.get('string:dealloc'))
    .set('json', (i)=>JSON.parse(target.cstrToJs(i)))
    .set('json:dealloc', (i)=>{
      try{ return i ? JSON.parse(target.cstrToJs(i)) : null }
      finally{ target.dealloc(i) }
    });

  
  const AbstractArgAdapter = class {
    constructor(opt){
      this.name = opt.name || 'unnamed adapter';
    }
    
    convertArg(v,argv,argIndex){
      toss("AbstractArgAdapter must be subclassed.");
    }
  };

  
  xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
    constructor(opt) {
      super(opt);
      if(xArg.FuncPtrAdapter.warnOnUse){
        console.warn('xArg.FuncPtrAdapter is an internal-only API',
                     'and is not intended to be invoked from',
                     'client-level code. Invoked with:',opt);
      }
      this.name = opt.name || "unnamed";
      this.signature = opt.signature;
      if(opt.contextKey instanceof Function){
        this.contextKey = opt.contextKey;
        if(!opt.bindScope) opt.bindScope = 'context';
      }
      this.bindScope = opt.bindScope
        || toss("FuncPtrAdapter options requires a bindScope (explicit or implied).");
      if(FuncPtrAdapter.bindScopes.indexOf(opt.bindScope)<0){
        toss("Invalid options.bindScope ("+opt.bindMod+") for FuncPtrAdapter. "+
             "Expecting one of: ("+FuncPtrAdapter.bindScopes.join(', ')+')');
      }
      this.isTransient = 'transient'===this.bindScope;
      this.isContext = 'context'===this.bindScope;
      this.isPermanent = 'permanent'===this.bindScope;
      this.singleton = ('singleton'===this.bindScope) ? [] : undefined;
      
      this.callProxy = (opt.callProxy instanceof Function)
        ? opt.callProxy : undefined;
    }

    

    
    contextKey(argv,argIndex){
      return this;
    }

    
    contextMap(key){
      const cm = (this.__cmap || (this.__cmap = new Map));
      let rc = cm.get(key);
      if(undefined===rc) cm.set(key, (rc = []));
      return rc;
    }

    
    convertArg(v,argv,argIndex){
      
      let pair = this.singleton;
      if(!pair && this.isContext){
        pair = this.contextMap(this.contextKey(argv,argIndex));
        
      }
      if(pair && pair[0]===v) return pair[1];
      if(v instanceof Function){
        
        
        if(this.callProxy) v = this.callProxy(v);
        const fp = __installFunction(v, this.signature, this.isTransient);
        if(FuncPtrAdapter.debugFuncInstall){
          FuncPtrAdapter.debugOut("FuncPtrAdapter installed", this,
                                  this.contextKey(argv,argIndex), '@'+fp, v);
        }
        if(pair){
          
          if(pair[1]){
            if(FuncPtrAdapter.debugFuncInstall){
              FuncPtrAdapter.debugOut("FuncPtrAdapter uninstalling", this,
                                      this.contextKey(argv,argIndex), '@'+pair[1], v);
            }
            try{
              
              cache.scopedAlloc[cache.scopedAlloc.length-1].push(pair[1]);
            }
            catch(e){}
          }
          pair[0] = v;
          pair[1] = fp;
        }
        return fp;
      }else if(target.isPtr(v) || null===v || undefined===v){
        
        if(pair && pair[1] && pair[1]!==v){
          
          if(FuncPtrAdapter.debugFuncInstall){
            FuncPtrAdapter.debugOut("FuncPtrAdapter uninstalling", this,
                                    this.contextKey(argv,argIndex), '@'+pair[1], v);
          }
          try{ cache.scopedAlloc[cache.scopedAlloc.length-1].push(pair[1]) }
          catch(e){}
          pair[0] = pair[1] = (v | 0);
        }
        return v || 0;
      }else{
        throw new TypeError("Invalid FuncPtrAdapter argument type. "+
                            "Expecting a function pointer or a "+
                            (this.name ? this.name+' ' : '')+
                            "function matching signature "+
                            this.signature+".");
      }
    }
  };

  
  xArg.FuncPtrAdapter.warnOnUse = false;

  
  xArg.FuncPtrAdapter.debugFuncInstall = false;

  
  xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);

  xArg.FuncPtrAdapter.bindScopes = [
    'transient', 'context', 'singleton', 'permanent'
  ];

  const __xArgAdapterCheck =
        (t)=>xArg.get(t) || toss("Argument adapter not found:",t);

  const __xResultAdapterCheck =
        (t)=>xResult.get(t) || toss("Result adapter not found:",t);

  cache.xWrap.convertArg = (t,...args)=>__xArgAdapterCheck(t)(...args);
  cache.xWrap.convertArgNoCheck = (t,...args)=>xArg.get(t)(...args);

  cache.xWrap.convertResult =
    (t,v)=>(null===t ? v : (t ? __xResultAdapterCheck(t)(v) : undefined));
  cache.xWrap.convertResultNoCheck =
    (t,v)=>(null===t ? v : (t ? xResult.get(t)(v) : undefined));

  
  target.xWrap = function(fArg, resultType, ...argTypes){
    if(3===arguments.length && Array.isArray(arguments[2])){
      argTypes = arguments[2];
    }
    if(target.isPtr(fArg)){
      fArg = target.functionEntry(fArg)
        || toss("Function pointer not found in WASM function table.");
    }
    const fIsFunc = (fArg instanceof Function);
    const xf = fIsFunc ? fArg : target.xGet(fArg);
    if(fIsFunc) fArg = xf.name || 'unnamed function';
    if(argTypes.length!==xf.length) __argcMismatch(fArg, xf.length);
    if((null===resultType) && 0===xf.length){
      
      return xf;
    }
    ;
    if(undefined!==resultType && null!==resultType) __xResultAdapterCheck(resultType);
    for(const t of argTypes){
      if(t instanceof AbstractArgAdapter) xArg.set(t, (...args)=>t.convertArg(...args));
      else __xArgAdapterCheck(t);
    }
    const cxw = cache.xWrap;
    if(0===xf.length){
      
      return (...args)=>(args.length
                         ? __argcMismatch(fArg, xf.length)
                         : cxw.convertResult(resultType, xf.call(null)));
    }
    return function(...args){
      if(args.length!==xf.length) __argcMismatch(fArg, xf.length);
      const scope = target.scopedAllocPush();
      try{
        
        for(const i in args) args[i] = cxw.convertArgNoCheck(
          argTypes[i], args[i], args, i
        );
        return cxw.convertResultNoCheck(resultType, xf.apply(null,args));
      }finally{
        target.scopedAllocPop(scope);
      }
    };
  };

  
  const __xAdapter = function(func, argc, typeName, adapter, modeName, xcvPart){
    if('string'===typeof typeName){
      if(1===argc) return xcvPart.get(typeName);
      else if(2===argc){
        if(!adapter){
          delete xcvPart.get(typeName);
          return func;
        }else if(!(adapter instanceof Function)){
          toss(modeName,"requires a function argument.");
        }
        xcvPart.set(typeName, adapter);
        return func;
      }
    }
    toss("Invalid arguments to",modeName);
  };

  
  target.xWrap.resultAdapter = function f(typeName, adapter){
    return __xAdapter(f, arguments.length, typeName, adapter,
                      'resultAdapter()', xResult);
  };

  
  target.xWrap.argAdapter = function f(typeName, adapter){
    return __xAdapter(f, arguments.length, typeName, adapter,
                      'argAdapter()', xArg);
  };

  target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;

  
  target.xCallWrapped = function(fArg, resultType, argTypes, ...args){
    if(Array.isArray(arguments[3])) args = arguments[3];
    return target.xWrap(fArg, resultType, argTypes||[]).apply(null, args||[]);
  };

  
  target.xWrap.testConvertArg = cache.xWrap.convertArg;

  
  target.xWrap.testConvertResult = cache.xWrap.convertResult;

  return target;
};


globalThis.WhWasmUtilInstaller.yawl = function(config){
  const wfetch = ()=>fetch(config.uri, {credentials: 'same-origin'});
  const wui = this;
  const finalThen = function(arg){
    
    if(config.wasmUtilTarget){
      const toss = (...args)=>{throw new Error(args.join(' '))};
      const tgt = config.wasmUtilTarget;
      tgt.module = arg.module;
      tgt.instance = arg.instance;
      
      if(!tgt.instance.exports.memory){
        
        tgt.memory = (config.imports && config.imports.env
                      && config.imports.env.memory)
          || toss("Missing 'memory' object!");
      }
      if(!tgt.alloc && arg.instance.exports.malloc){
        const exports = arg.instance.exports;
        tgt.alloc = function(n){
          return exports.malloc(n) || toss("Allocation of",n,"bytes failed.");
        };
        tgt.dealloc = function(m){exports.free(m)};
      }
      wui(tgt);
    }
    if(config.onload) config.onload(arg,config);
    return arg ;
  };
  const loadWasm = WebAssembly.instantiateStreaming
        ? function loadWasmStreaming(){
          return WebAssembly.instantiateStreaming(wfetch(), config.imports||{})
            .then(finalThen);
        }
        : function loadWasmOldSchool(){ 
          return wfetch()
            .then(response => response.arrayBuffer())
            .then(bytes => WebAssembly.instantiate(bytes, config.imports||{}))
            .then(finalThen);
        };
  return loadWasm;
}.bind(globalThis.WhWasmUtilInstaller);



'use strict';
globalThis.Jaccwabyt = function StructBinderFactory(config){


  
  const toss = (...args)=>{throw new Error(args.join(' '))};

  
  if(!(config.heap instanceof WebAssembly.Memory)
     && !(config.heap instanceof Function)){
    toss("config.heap must be WebAssembly.Memory instance or a function.");
  }
  ['alloc','dealloc'].forEach(function(k){
    (config[k] instanceof Function) ||
      toss("Config option '"+k+"' must be a function.");
  });
  const SBF = StructBinderFactory;
  const heap = (config.heap instanceof Function)
        ? config.heap : (()=>new Uint8Array(config.heap.buffer)),
        alloc = config.alloc,
        dealloc = config.dealloc,
        log = config.log || console.log.bind(console),
        memberPrefix = (config.memberPrefix || ""),
        memberSuffix = (config.memberSuffix || ""),
        bigIntEnabled = (undefined===config.bigIntEnabled
                         ? !!globalThis['BigInt64Array'] : !!config.bigIntEnabled),
        BigInt = globalThis['BigInt'],
        BigInt64Array = globalThis['BigInt64Array'],
        
        ptrSizeof = config.ptrSizeof || 4,
        ptrIR = config.ptrIR || 'i32'
  ;

  if(!SBF.debugFlags){
    SBF.__makeDebugFlags = function(deriveFrom=null){
      
      if(deriveFrom && deriveFrom.__flags) deriveFrom = deriveFrom.__flags;
      const f = function f(flags){
        if(0===arguments.length){
          return f.__flags;
        }
        if(flags<0){
          delete f.__flags.getter; delete f.__flags.setter;
          delete f.__flags.alloc; delete f.__flags.dealloc;
        }else{
          f.__flags.getter  = 0!==(0x01 & flags);
          f.__flags.setter  = 0!==(0x02 & flags);
          f.__flags.alloc   = 0!==(0x04 & flags);
          f.__flags.dealloc = 0!==(0x08 & flags);
        }
        return f._flags;
      };
      Object.defineProperty(f,'__flags', {
        iterable: false, writable: false,
        value: Object.create(deriveFrom)
      });
      if(!deriveFrom) f(0);
      return f;
    };
    SBF.debugFlags = SBF.__makeDebugFlags();
  }

  const isLittleEndian = (function() {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true );
    
    return new Int16Array(buffer)[0] === 256;
  })();
  

  
  const isFuncSig = (s)=>'('===s[1];
  
  const isPtrSig = (s)=>'p'===s || 'P'===s;
  const isAutoPtrSig = (s)=>'P'===s ;
  const sigLetter = (s)=>isFuncSig(s) ? 'p' : s[0];
  
  const sigIR = function(s){
    switch(sigLetter(s)){
        case 'c': case 'C': return 'i8';
        case 'i': return 'i32';
        case 'p': case 'P': case 's': return ptrIR;
        case 'j': return 'i64';
        case 'f': return 'float';
        case 'd': return 'double';
    }
    toss("Unhandled signature IR:",s);
  };

  const affirmBigIntArray = BigInt64Array
        ? ()=>true : ()=>toss('BigInt64Array is not available.');
  
  const sigDVGetter = function(s){
    switch(sigLetter(s)) {
        case 'p': case 'P': case 's': {
          switch(ptrSizeof){
              case 4: return 'getInt32';
              case 8: return affirmBigIntArray() && 'getBigInt64';
          }
          break;
        }
        case 'i': return 'getInt32';
        case 'c': return 'getInt8';
        case 'C': return 'getUint8';
        case 'j': return affirmBigIntArray() && 'getBigInt64';
        case 'f': return 'getFloat32';
        case 'd': return 'getFloat64';
    }
    toss("Unhandled DataView getter for signature:",s);
  };
  
  const sigDVSetter = function(s){
    switch(sigLetter(s)){
        case 'p': case 'P': case 's': {
          switch(ptrSizeof){
              case 4: return 'setInt32';
              case 8: return affirmBigIntArray() && 'setBigInt64';
          }
          break;
        }
        case 'i': return 'setInt32';
        case 'c': return 'setInt8';
        case 'C': return 'setUint8';
        case 'j': return affirmBigIntArray() && 'setBigInt64';
        case 'f': return 'setFloat32';
        case 'd': return 'setFloat64';
    }
    toss("Unhandled DataView setter for signature:",s);
  };
  
  const sigDVSetWrapper = function(s){
    switch(sigLetter(s)) {
        case 'i': case 'f': case 'c': case 'C': case 'd': return Number;
        case 'j': return affirmBigIntArray() && BigInt;
        case 'p': case 'P': case 's':
          switch(ptrSizeof){
              case 4: return Number;
              case 8: return affirmBigIntArray() && BigInt;
          }
          break;
    }
    toss("Unhandled DataView set wrapper for signature:",s);
  };

  
  const sPropName = (s,k)=>s+'::'+k;

  const __propThrowOnSet = function(structName,propName){
    return ()=>toss(sPropName(structName,propName),"is read-only.");
  };

  
  const __instancePointerMap = new WeakMap();

  
  const xPtrPropName = '(pointer-is-external)';

  
  const __freeStruct = function(ctor, obj, m){
    if(!m) m = __instancePointerMap.get(obj);
    if(m) {
      __instancePointerMap.delete(obj);
      if(Array.isArray(obj.ondispose)){
        let x;
        while((x = obj.ondispose.shift())){
          try{
            if(x instanceof Function) x.call(obj);
            else if(x instanceof StructType) x.dispose();
            else if('number' === typeof x) dealloc(x);
            
            
          }catch(e){
            console.warn("ondispose() for",ctor.structName,'@',
                         m,'threw. NOT propagating it.',e);
          }
        }
      }else if(obj.ondispose instanceof Function){
        try{obj.ondispose()}
        catch(e){
          
          console.warn("ondispose() for",ctor.structName,'@',
                       m,'threw. NOT propagating it.',e);
        }
      }
      delete obj.ondispose;
      if(ctor.debugFlags.__flags.dealloc){
        log("debug.dealloc:",(obj[xPtrPropName]?"EXTERNAL":""),
            ctor.structName,"instance:",
            ctor.structInfo.sizeof,"bytes @"+m);
      }
      if(!obj[xPtrPropName]) dealloc(m);
    }
  };

  
  const rop = (v)=>{return {configurable: false, writable: false,
                            iterable: false, value: v}};

  
  const __allocStruct = function(ctor, obj, m){
    let fill = !m;
    if(m) Object.defineProperty(obj, xPtrPropName, rop(m));
    else{
      m = alloc(ctor.structInfo.sizeof);
      if(!m) toss("Allocation of",ctor.structName,"structure failed.");
    }
    try {
      if(ctor.debugFlags.__flags.alloc){
        log("debug.alloc:",(fill?"":"EXTERNAL"),
            ctor.structName,"instance:",
            ctor.structInfo.sizeof,"bytes @"+m);
      }
      if(fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
      __instancePointerMap.set(obj, m);
    }catch(e){
      __freeStruct(ctor, obj, m);
      throw e;
    }
  };
  
  const __memoryDump = function(){
    const p = this.pointer;
    return p
      ? new Uint8Array(heap().slice(p, p+this.structInfo.sizeof))
      : null;
  };

  const __memberKey = (k)=>memberPrefix + k + memberSuffix;
  const __memberKeyProp = rop(__memberKey);

  
  const __lookupMember = function(structInfo, memberName, tossIfNotFound=true){
    let m = structInfo.members[memberName];
    if(!m && (memberPrefix || memberSuffix)){
      
      for(const v of Object.values(structInfo.members)){
        if(v.key===memberName){ m = v; break; }
      }
      if(!m && tossIfNotFound){
        toss(sPropName(structInfo.name,memberName),'is not a mapped struct member.');
      }
    }
    return m;
  };

  
  const __memberSignature = function f(obj,memberName,emscriptenFormat=false){
    if(!f._) f._ = (x)=>x.replace(/[^vipPsjrdcC]/g,"").replace(/[pPscC]/g,'i');
    const m = __lookupMember(obj.structInfo, memberName, true);
    return emscriptenFormat ? f._(m.signature) : m.signature;
  };

  const __ptrPropDescriptor = {
    configurable: false, enumerable: false,
    get: function(){return __instancePointerMap.get(this)},
    set: ()=>toss("Cannot assign the 'pointer' property of a struct.")
    
    
    
  };

  
  const __structMemberKeys = rop(function(){
    const a = [];
    for(const k of Object.keys(this.structInfo.members)){
      a.push(this.memberKey(k));
    }
    return a;
  });

  const __utf8Decoder = new TextDecoder('utf-8');
  const __utf8Encoder = new TextEncoder();
  
  const __SAB = ('undefined'===typeof SharedArrayBuffer)
        ? function(){} : SharedArrayBuffer;
  const __utf8Decode = function(arrayBuffer, begin, end){
    return __utf8Decoder.decode(
      (arrayBuffer.buffer instanceof __SAB)
        ? arrayBuffer.slice(begin, end)
        : arrayBuffer.subarray(begin, end)
    );
  };
  
  const __memberIsString = function(obj,memberName, tossIfNotFound=false){
    const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
    return (m && 1===m.signature.length && 's'===m.signature[0]) ? m : false;
  };

  
  const __affirmCStringSignature = function(member){
    if('s'===member.signature) return;
    toss("Invalid member type signature for C-string value:",
         JSON.stringify(member));
  };

  
  const __memberToJsString = function f(obj,memberName){
    const m = __lookupMember(obj.structInfo, memberName, true);
    __affirmCStringSignature(m);
    const addr = obj[m.key];
    
    if(!addr) return null;
    let pos = addr;
    const mem = heap();
    for( ; mem[pos]!==0; ++pos ) {
      
    };
    
    return (addr===pos) ? "" : __utf8Decode(mem, addr, pos);
  };

  
  const __addOnDispose = function(obj, ...v){
    if(obj.ondispose){
      if(!Array.isArray(obj.ondispose)){
        obj.ondispose = [obj.ondispose];
      }
    }else{
      obj.ondispose = [];
    }
    obj.ondispose.push(...v);
  };

  
  const __allocCString = function(str){
    const u = __utf8Encoder.encode(str);
    const mem = alloc(u.length+1);
    if(!mem) toss("Allocation error while duplicating string:",str);
    const h = heap();
    
    
    h.set(u, mem);
    h[mem + u.length] = 0;
    
    return mem;
  };

  
  const __setMemberCString = function(obj, memberName, str){
    const m = __lookupMember(obj.structInfo, memberName, true);
    __affirmCStringSignature(m);
    
    const mem = __allocCString(str);
    obj[m.key] = mem;
    __addOnDispose(obj, mem);
    return obj;
  };

  
  const StructType = function ctor(structName, structInfo){
    if(arguments[2]!==rop){
      toss("Do not call the StructType constructor",
           "from client-level code.");
    }
    Object.defineProperties(this,{
      
      structName: rop(structName),
      structInfo: rop(structInfo)
    });
  };

  
  StructType.prototype = Object.create(null, {
    dispose: rop(function(){__freeStruct(this.constructor, this)}),
    lookupMember: rop(function(memberName, tossIfNotFound=true){
      return __lookupMember(this.structInfo, memberName, tossIfNotFound);
    }),
    memberToJsString: rop(function(memberName){
      return __memberToJsString(this, memberName);
    }),
    memberIsString: rop(function(memberName, tossIfNotFound=true){
      return __memberIsString(this, memberName, tossIfNotFound);
    }),
    memberKey: __memberKeyProp,
    memberKeys: __structMemberKeys,
    memberSignature: rop(function(memberName, emscriptenFormat=false){
      return __memberSignature(this, memberName, emscriptenFormat);
    }),
    memoryDump: rop(__memoryDump),
    pointer: __ptrPropDescriptor,
    setMemberCString: rop(function(memberName, str){
      return __setMemberCString(this, memberName, str);
    })
  });
  
  Object.assign(StructType.prototype,{
    addOnDispose: function(...v){
      __addOnDispose(this,...v);
      return this;
    }
  });

  
  Object.defineProperties(StructType, {
    allocCString: rop(__allocCString),
    isA: rop((v)=>v instanceof StructType),
    hasExternalPointer: rop((v)=>(v instanceof StructType) && !!v[xPtrPropName]),
    memberKey: __memberKeyProp
  });

  const isNumericValue = (v)=>Number.isFinite(v) || (v instanceof (BigInt || Number));

  
  const makeMemberWrapper = function f(ctor,name, descr){
    if(!f._){
      
      f._ = {getters: {}, setters: {}, sw:{}};
      const a = ['i','c','C','p','P','s','f','d','v()'];
      if(bigIntEnabled) a.push('j');
      a.forEach(function(v){
        
        f._.getters[v] = sigDVGetter(v) ;
        f._.setters[v] = sigDVSetter(v) ;
        f._.sw[v] = sigDVSetWrapper(v)  ;
      });
      const rxSig1 = /^[ipPsjfdcC]$/,
            rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
      f.sigCheck = function(obj, name, key,sig){
        if(Object.prototype.hasOwnProperty.call(obj, key)){
          toss(obj.structName,'already has a property named',key+'.');
        }
        rxSig1.test(sig) || rxSig2.test(sig)
          || toss("Malformed signature for",
                  sPropName(obj.structName,name)+":",sig);
      };
    }
    const key = ctor.memberKey(name);
    f.sigCheck(ctor.prototype, name, key, descr.signature);
    descr.key = key;
    descr.name = name;
    const sigGlyph = sigLetter(descr.signature);
    const xPropName = sPropName(ctor.prototype.structName,key);
    const dbg = ctor.prototype.debugFlags.__flags;
    
    const prop = Object.create(null);
    prop.configurable = false;
    prop.enumerable = false;
    prop.get = function(){
      if(dbg.getter){
        log("debug.getter:",f._.getters[sigGlyph],"for", sigIR(sigGlyph),
            xPropName,'@', this.pointer,'+',descr.offset,'sz',descr.sizeof);
      }
      let rc = (
        new DataView(heap().buffer, this.pointer + descr.offset, descr.sizeof)
      )[f._.getters[sigGlyph]](0, isLittleEndian);
      if(dbg.getter) log("debug.getter:",xPropName,"result =",rc);
      return rc;
    };
    if(descr.readOnly){
      prop.set = __propThrowOnSet(ctor.prototype.structName,key);
    }else{
      prop.set = function(v){
        if(dbg.setter){
          log("debug.setter:",f._.setters[sigGlyph],"for", sigIR(sigGlyph),
              xPropName,'@', this.pointer,'+',descr.offset,'sz',descr.sizeof, v);
        }
        if(!this.pointer){
          toss("Cannot set struct property on disposed instance.");
        }
        if(null===v) v = 0;
        else while(!isNumericValue(v)){
          if(isAutoPtrSig(descr.signature) && (v instanceof StructType)){
            
            v = v.pointer || 0;
            if(dbg.setter) log("debug.setter:",xPropName,"resolved to",v);
            break;
          }
          toss("Invalid value for pointer-type",xPropName+'.');
        }
        (
          new DataView(heap().buffer, this.pointer + descr.offset, descr.sizeof)
        )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);
      };
    }
    Object.defineProperty(ctor.prototype, key, prop);
  };
  
  
  const StructBinder = function StructBinder(structName, structInfo){
    if(1===arguments.length){
      structInfo = structName;
      structName = structInfo.name;
    }else if(!structInfo.name){
      structInfo.name = structName;
    }
    if(!structName) toss("Struct name is required.");
    let lastMember = false;
    Object.keys(structInfo.members).forEach((k)=>{
      
      const m = structInfo.members[k];
      if(!m.sizeof) toss(structName,"member",k,"is missing sizeof.");
      else if(m.sizeof===1){
        (m.signature === 'c' || m.signature === 'C') ||
          toss("Unexpected sizeof==1 member",
               sPropName(structInfo.name,k),
               "with signature",m.signature);
      }else{
        
        
        if(0!==(m.sizeof%4)){
          console.warn("Invalid struct member description =",m,"from",structInfo);
          toss(structName,"member",k,"sizeof is not aligned. sizeof="+m.sizeof);
        }
        if(0!==(m.offset%4)){
          console.warn("Invalid struct member description =",m,"from",structInfo);
          toss(structName,"member",k,"offset is not aligned. offset="+m.offset);
        }
      }
      if(!lastMember || lastMember.offset < m.offset) lastMember = m;
    });
    if(!lastMember) toss("No member property descriptions found.");
    else if(structInfo.sizeof < lastMember.offset+lastMember.sizeof){
      toss("Invalid struct config:",structName,
           "max member offset ("+lastMember.offset+") ",
           "extends past end of struct (sizeof="+structInfo.sizeof+").");
    }
    const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));
    
    const StructCtor = function StructCtor(externalMemory){
      if(!(this instanceof StructCtor)){
        toss("The",structName,"constructor may only be called via 'new'.");
      }else if(arguments.length){
        if(externalMemory!==(externalMemory|0) || externalMemory<=0){
          toss("Invalid pointer value for",structName,"constructor.");
        }
        __allocStruct(StructCtor, this, externalMemory);
      }else{
        __allocStruct(StructCtor, this);
      }
    };
    Object.defineProperties(StructCtor,{
      debugFlags: debugFlags,
      isA: rop((v)=>v instanceof StructCtor),
      memberKey: __memberKeyProp,
      memberKeys: __structMemberKeys,
      methodInfoForKey: rop(function(mKey){
      }),
      structInfo: rop(structInfo),
      structName: rop(structName)
    });
    StructCtor.prototype = new StructType(structName, structInfo, rop);
    Object.defineProperties(StructCtor.prototype,{
      debugFlags: debugFlags,
      constructor: rop(StructCtor)
      
    });
    Object.keys(structInfo.members).forEach(
      (name)=>makeMemberWrapper(StructCtor, name, structInfo.members[name])
    );
    return StructCtor;
  };
  StructBinder.StructType = StructType;
  StructBinder.config = config;
  StructBinder.allocCString = __allocCString;
  if(!StructBinder.debugFlags){
    StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
  }
  return StructBinder;
};



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  'use strict';
  const toss = (...args)=>{throw new Error(args.join(' '))};
  const toss3 = sqlite3.SQLite3Error.toss;
  const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
  globalThis.WhWasmUtilInstaller(wasm);
  delete globalThis.WhWasmUtilInstaller;

  if(false){}

  
  wasm.bindingSignatures = [
    
    ["sqlite3_aggregate_context","void*", "sqlite3_context*", "int"],
    
    
    ["sqlite3_bind_double","int", "sqlite3_stmt*", "int", "f64"],
    ["sqlite3_bind_int","int", "sqlite3_stmt*", "int", "int"],
    ["sqlite3_bind_null",undefined, "sqlite3_stmt*", "int"],
    ["sqlite3_bind_parameter_count", "int", "sqlite3_stmt*"],
    ["sqlite3_bind_parameter_index","int", "sqlite3_stmt*", "string"],
    ["sqlite3_bind_pointer", "int",
     "sqlite3_stmt*", "int", "*", "string:static", "*"],
    ["sqlite3_busy_handler","int", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        signature: 'i(pi)',
        contextKey: (argv,argIndex)=>argv[0]
      }),
      "*"
    ]],
    ["sqlite3_busy_timeout","int", "sqlite3*", "int"],
    
    
    ["sqlite3_changes", "int", "sqlite3*"],
    ["sqlite3_clear_bindings","int", "sqlite3_stmt*"],
    ["sqlite3_collation_needed", "int", "sqlite3*", "*", "*"],
    ["sqlite3_column_blob","*", "sqlite3_stmt*", "int"],
    ["sqlite3_column_bytes","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_count", "int", "sqlite3_stmt*"],
    ["sqlite3_column_double","f64", "sqlite3_stmt*", "int"],
    ["sqlite3_column_int","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_name","string", "sqlite3_stmt*", "int"],
    ["sqlite3_column_text","string", "sqlite3_stmt*", "int"],
    ["sqlite3_column_type","int", "sqlite3_stmt*", "int"],
    ["sqlite3_column_value","sqlite3_value*", "sqlite3_stmt*", "int"],
    ["sqlite3_commit_hook", "void*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_commit_hook',
        signature: 'i(p)',
        contextKey: (argv)=>argv[0]
      }),
      '*'
    ]],
    ["sqlite3_compileoption_get", "string", "int"],
    ["sqlite3_compileoption_used", "int", "string"],
    ["sqlite3_complete", "int", "string:flexible"],
    ["sqlite3_context_db_handle", "sqlite3*", "sqlite3_context*"],

    
    
    ["sqlite3_data_count", "int", "sqlite3_stmt*"],
    ["sqlite3_db_filename", "string", "sqlite3*", "string"],
    ["sqlite3_db_handle", "sqlite3*", "sqlite3_stmt*"],
    ["sqlite3_db_name", "string", "sqlite3*", "int"],
    ["sqlite3_db_status", "int", "sqlite3*", "int", "*", "*", "int"],
    ["sqlite3_errcode", "int", "sqlite3*"],
    ["sqlite3_errmsg", "string", "sqlite3*"],
    ["sqlite3_error_offset", "int", "sqlite3*"],
    ["sqlite3_errstr", "string", "int"],
    ["sqlite3_exec", "int", [
      "sqlite3*", "string:flexible",
      new wasm.xWrap.FuncPtrAdapter({
        signature: 'i(pipp)',
        bindScope: 'transient',
        callProxy: (callback)=>{
          let aNames;
          return (pVoid, nCols, pColVals, pColNames)=>{
            try {
              const aVals = wasm.cArgvToJs(nCols, pColVals);
              if(!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);
              return callback(aVals, aNames) | 0;
            }catch(e){
              
              return e.resultCode || capi.SQLITE_ERROR;
            }
          }
        }
      }),
      "*", "**"
    ]],
    ["sqlite3_expanded_sql", "string", "sqlite3_stmt*"],
    ["sqlite3_extended_errcode", "int", "sqlite3*"],
    ["sqlite3_extended_result_codes", "int", "sqlite3*", "int"],
    ["sqlite3_file_control", "int", "sqlite3*", "string", "int", "*"],
    ["sqlite3_finalize", "int", "sqlite3_stmt*"],
    ["sqlite3_free", undefined,"*"],
    ["sqlite3_get_autocommit", "int", "sqlite3*"],
    ["sqlite3_get_auxdata", "*", "sqlite3_context*", "int"],
    ["sqlite3_initialize", undefined],
    
    ["sqlite3_keyword_count", "int"],
    ["sqlite3_keyword_name", "int", ["int", "**", "*"]],
    ["sqlite3_keyword_check", "int", ["string", "int"]],
    ["sqlite3_libversion", "string"],
    ["sqlite3_libversion_number", "int"],
    ["sqlite3_limit", "int", ["sqlite3*", "int", "int"]],
    ["sqlite3_malloc", "*","int"],
    ["sqlite3_open", "int", "string", "*"],
    ["sqlite3_open_v2", "int", "string", "*", "int", "string"],
    
    
    ["sqlite3_progress_handler", undefined, [
      "sqlite3*", "int", new wasm.xWrap.FuncPtrAdapter({
        name: 'xProgressHandler',
        signature: 'i(p)',
        bindScope: 'context',
        contextKey: (argv,argIndex)=>argv[0]
      }), "*"
    ]],
    ["sqlite3_realloc", "*","*","int"],
    ["sqlite3_reset", "int", "sqlite3_stmt*"],
    
    ["sqlite3_result_blob", undefined, "sqlite3_context*", "*", "int", "*"],
    ["sqlite3_result_double", undefined, "sqlite3_context*", "f64"],
    ["sqlite3_result_error", undefined, "sqlite3_context*", "string", "int"],
    ["sqlite3_result_error_code", undefined, "sqlite3_context*", "int"],
    ["sqlite3_result_error_nomem", undefined, "sqlite3_context*"],
    ["sqlite3_result_error_toobig", undefined, "sqlite3_context*"],
    ["sqlite3_result_int", undefined, "sqlite3_context*", "int"],
    ["sqlite3_result_null", undefined, "sqlite3_context*"],
    ["sqlite3_result_pointer", undefined,
     "sqlite3_context*", "*", "string:static", "*"],
    ["sqlite3_result_subtype", undefined, "sqlite3_value*", "int"],
    ["sqlite3_result_text", undefined, "sqlite3_context*", "string", "int", "*"],
    ["sqlite3_result_zeroblob", undefined, "sqlite3_context*", "int"],
    ["sqlite3_rollback_hook", "void*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_rollback_hook',
        signature: 'v(p)',
        contextKey: (argv)=>argv[0]
      }),
      '*'
    ]],
    ["sqlite3_set_authorizer", "int", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: "sqlite3_set_authorizer::xAuth",
        signature: "i(pi"+"ssss)",
        contextKey: (argv, argIndex)=>argv[0],
        callProxy: (callback)=>{
          return (pV, iCode, s0, s1, s2, s3)=>{
            try{
              s0 = s0 && wasm.cstrToJs(s0); s1 = s1 && wasm.cstrToJs(s1);
              s2 = s2 && wasm.cstrToJs(s2); s3 = s3 && wasm.cstrToJs(s3);
              return callback(pV, iCode, s0, s1, s2, s3) || 0;
            }catch(e){
              return e.resultCode || capi.SQLITE_ERROR;
            }
          }
        }
      }),
      "*"
    ]],
    ["sqlite3_set_auxdata", undefined, [
      "sqlite3_context*", "int", "*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'xDestroyAuxData',
        signature: 'v(*)',
        contextKey: (argv, argIndex)=>argv[0]
      })
    ]],
    ["sqlite3_shutdown", undefined],
    ["sqlite3_sourceid", "string"],
    ["sqlite3_sql", "string", "sqlite3_stmt*"],
    ["sqlite3_status", "int", "int", "*", "*", "int"],
    ["sqlite3_step", "int", "sqlite3_stmt*"],
    ["sqlite3_stmt_isexplain", "int", ["sqlite3_stmt*"]],
    ["sqlite3_stmt_readonly", "int", ["sqlite3_stmt*"]],
    ["sqlite3_stmt_status", "int", "sqlite3_stmt*", "int", "int"],
    ["sqlite3_strglob", "int", "string","string"],
    ["sqlite3_stricmp", "int", "string", "string"],
    ["sqlite3_strlike", "int", "string", "string","int"],
    ["sqlite3_strnicmp", "int", "string", "string", "int"],
    ["sqlite3_table_column_metadata", "int",
     "sqlite3*", "string", "string", "string",
     "**", "**", "*", "*", "*"],
    ["sqlite3_total_changes", "int", "sqlite3*"],
    ["sqlite3_trace_v2", "int", [
      "sqlite3*", "int",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_trace_v2::callback',
        signature: 'i(ippp)',
        contextKey: (argv,argIndex)=>argv[0]
      }),
      "*"
    ]],
    ["sqlite3_txn_state", "int", ["sqlite3*","string"]],
    
    ["sqlite3_uri_boolean", "int", "sqlite3_filename", "string", "int"],
    ["sqlite3_uri_key", "string", "sqlite3_filename", "int"],
    ["sqlite3_uri_parameter", "string", "sqlite3_filename", "string"],
    ["sqlite3_user_data","void*", "sqlite3_context*"],
    ["sqlite3_value_blob", "*", "sqlite3_value*"],
    ["sqlite3_value_bytes","int", "sqlite3_value*"],
    ["sqlite3_value_double","f64", "sqlite3_value*"],
    ["sqlite3_value_dup", "sqlite3_value*", "sqlite3_value*"],
    ["sqlite3_value_free", undefined, "sqlite3_value*"],
    ["sqlite3_value_frombind", "int", "sqlite3_value*"],
    ["sqlite3_value_int","int", "sqlite3_value*"],
    ["sqlite3_value_nochange", "int", "sqlite3_value*"],
    ["sqlite3_value_numeric_type", "int", "sqlite3_value*"],
    ["sqlite3_value_pointer", "*", "sqlite3_value*", "string:static"],
    ["sqlite3_value_subtype", "int", "sqlite3_value*"],
    ["sqlite3_value_text", "string", "sqlite3_value*"],
    ["sqlite3_value_type", "int", "sqlite3_value*"],
    ["sqlite3_vfs_find", "*", "string"],
    ["sqlite3_vfs_register", "int", "sqlite3_vfs*", "int"],
    ["sqlite3_vfs_unregister", "int", "sqlite3_vfs*"]
  ];

  if(false){}

  if(wasm.exports.sqlite3_activate_see instanceof Function){
    wasm.bindingSignatures.push(
      ["sqlite3_key", "int", "sqlite3*", "string", "int"],
      ["sqlite3_key_v2","int","sqlite3*","string","*","int"],
      ["sqlite3_rekey", "int", "sqlite3*", "string", "int"],
      ["sqlite3_rekey_v2", "int", "sqlite3*", "string", "*", "int"],
      ["sqlite3_activate_see", undefined, "string"]
    );
  }
  
  wasm.bindingSignatures.int64 = [
    ["sqlite3_bind_int64","int", ["sqlite3_stmt*", "int", "i64"]],
    ["sqlite3_changes64","i64", ["sqlite3*"]],
    ["sqlite3_column_int64","i64", ["sqlite3_stmt*", "int"]],
    ["sqlite3_create_module", "int",
     ["sqlite3*","string","sqlite3_module*","*"]],
    ["sqlite3_create_module_v2", "int",
     ["sqlite3*","string","sqlite3_module*","*","*"]],
    ["sqlite3_declare_vtab", "int", ["sqlite3*", "string:flexible"]],
    ["sqlite3_deserialize", "int", "sqlite3*", "string", "*", "i64", "i64", "int"]
    ,
    ["sqlite3_drop_modules", "int", ["sqlite3*", "**"]],
    ["sqlite3_last_insert_rowid", "i64", ["sqlite3*"]],
    ["sqlite3_malloc64", "*","i64"],
    ["sqlite3_msize", "i64", "*"],
    ["sqlite3_overload_function", "int", ["sqlite3*","string","int"]],
    ["sqlite3_preupdate_blobwrite", "int", "sqlite3*"],
    ["sqlite3_preupdate_count", "int", "sqlite3*"],
    ["sqlite3_preupdate_depth", "int", "sqlite3*"],
    ["sqlite3_preupdate_hook", "*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_preupdate_hook',
        signature: "v(ppippjj)",
        contextKey: (argv)=>argv[0],
        callProxy: (callback)=>{
          return (p,db,op,zDb,zTbl,iKey1,iKey2)=>{
            callback(p, db, op, wasm.cstrToJs(zDb), wasm.cstrToJs(zTbl),
                     iKey1, iKey2);
          };
        }
      }),
      "*"
    ]],
    ["sqlite3_preupdate_new", "int", ["sqlite3*", "int", "**"]],
    ["sqlite3_preupdate_old", "int", ["sqlite3*", "int", "**"]],
    ["sqlite3_realloc64", "*","*", "i64"],
    ["sqlite3_result_int64", undefined, "*", "i64"],
    ["sqlite3_result_zeroblob64", "int", "*", "i64"],
    ["sqlite3_serialize","*", "sqlite3*", "string", "*", "int"],
    ["sqlite3_set_last_insert_rowid", undefined, ["sqlite3*", "i64"]],
    ["sqlite3_status64", "int", "int", "*", "*", "int"],
    ["sqlite3_total_changes64", "i64", ["sqlite3*"]],
    ["sqlite3_update_hook", "*", [
      "sqlite3*",
      new wasm.xWrap.FuncPtrAdapter({
        name: 'sqlite3_update_hook',
        signature: "v(iippj)",
        contextKey: (argv)=>argv[0],
        callProxy: (callback)=>{
          return (p,op,z0,z1,rowid)=>{
            callback(p, op, wasm.cstrToJs(z0), wasm.cstrToJs(z1), rowid);
          };
        }
      }),
      "*"
    ]],
    ["sqlite3_uri_int64", "i64", ["sqlite3_filename", "string", "i64"]],
    ["sqlite3_value_int64","i64", "sqlite3_value*"],
    ["sqlite3_vtab_collation","string","sqlite3_index_info*","int"],
    ["sqlite3_vtab_distinct","int", "sqlite3_index_info*"],
    ["sqlite3_vtab_in","int", "sqlite3_index_info*", "int", "int"],
    ["sqlite3_vtab_in_first", "int", "sqlite3_value*", "**"],
    ["sqlite3_vtab_in_next", "int", "sqlite3_value*", "**"],
    
    ["sqlite3_vtab_nochange","int", "sqlite3_context*"],
    ["sqlite3_vtab_on_conflict","int", "sqlite3*"],
    ["sqlite3_vtab_rhs_value","int", "sqlite3_index_info*", "int", "**"]
  ];

  
  if(wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add){
    
    
    const __ipsProxy = {
      signature: 'i(ps)',
      callProxy:(callback)=>{
        return (p,s)=>{
          try{return callback(p, wasm.cstrToJs(s)) | 0}
          catch(e){return e.resultCode || capi.SQLITE_ERROR}
        }
      }
    };

    wasm.bindingSignatures.int64.push(...[
      ['sqlite3changegroup_add', 'int', ['sqlite3_changegroup*', 'int', 'void*']],
      ['sqlite3changegroup_add_strm', 'int', [
        'sqlite3_changegroup*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changegroup_delete', undefined, ['sqlite3_changegroup*']],
      ['sqlite3changegroup_new', 'int', ['**']],
      ['sqlite3changegroup_output', 'int', ['sqlite3_changegroup*', 'int*', '**']],
      ['sqlite3changegroup_output_strm', 'int', [
        'sqlite3_changegroup*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply', 'int', [
        'sqlite3*', 'int', 'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply_strm', 'int', [
        'sqlite3*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_apply_v2', 'int', [
        'sqlite3*', 'int', 'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*', '**', 'int*', 'int'

      ]],
      ['sqlite3changeset_apply_v2_strm', 'int', [
        'sqlite3*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', bindScope: 'transient', ...__ipsProxy
        }),
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xConflict', signature: 'i(pip)', bindScope: 'transient'
        }),
        'void*', '**', 'int*', 'int'
      ]],
      ['sqlite3changeset_concat', 'int', ['int','void*', 'int', 'void*', 'int*', '**']],
      ['sqlite3changeset_concat_strm', 'int', [
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInputA', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInputB', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_conflict', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],
      ['sqlite3changeset_fk_conflicts', 'int', ['sqlite3_changeset_iter*', 'int*']],
      ['sqlite3changeset_invert', 'int', ['int', 'void*', 'int*', '**']],
      ['sqlite3changeset_invert_strm', 'int', [
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppi)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_new', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],
      ['sqlite3changeset_old', 'int', ['sqlite3_changeset_iter*', 'int', '**']],
      ['sqlite3changeset_op', 'int', [
        'sqlite3_changeset_iter*', '**', 'int*', 'int*','int*'
      ]],
      ['sqlite3changeset_pk', 'int', ['sqlite3_changeset_iter*', '**', 'int*']],
      ['sqlite3changeset_start', 'int', ['**', 'int', '*']],
      ['sqlite3changeset_start_strm', 'int', [
        '**',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],
      ['sqlite3changeset_start_v2_strm', 'int', [
        '**',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xInput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*', 'int'
      ]],
      ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],
      ['sqlite3session_changeset', 'int', ['sqlite3_session*', 'int*', '**']],
      ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],
      ['sqlite3session_changeset_strm', 'int', [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3session_config', 'int', ['int', 'void*']],
      ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],
      
      ['sqlite3session_diff', 'int', ['sqlite3_session*', 'string', 'string', '**']],
      ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],
      ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],
      ['sqlite3session_isempty', 'int', ['sqlite3_session*']],
      ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],
      ['sqlite3session_object_config', 'int', ['sqlite3_session*', 'int', 'void*']],
      ['sqlite3session_patchset', 'int', ['sqlite3_session*', '*', '**']],
      ['sqlite3session_patchset_strm', 'int', [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xOutput', signature: 'i(ppp)', bindScope: 'transient'
        }),
        'void*'
      ]],
      ['sqlite3session_table_filter', undefined, [
        'sqlite3_session*',
        new wasm.xWrap.FuncPtrAdapter({
          name: 'xFilter', ...__ipsProxy,
          contextKey: (argv,argIndex)=>argv[0]
        }),
        '*'
      ]]
    ]);
  }

  
  wasm.bindingSignatures.wasm = [
    ["sqlite3_wasm_db_reset", "int", "sqlite3*"],
    ["sqlite3_wasm_db_vfs", "sqlite3_vfs*", "sqlite3*","string"],
    ["sqlite3_wasm_vfs_create_file", "int",
     "sqlite3_vfs*","string","*", "int"],
    ["sqlite3_wasm_posix_create_file", "int", "string","*", "int"],
    ["sqlite3_wasm_vfs_unlink", "int", "sqlite3_vfs*","string"]
  ];

  
  sqlite3.StructBinder = globalThis.Jaccwabyt({
    heap:  false ? 0 : wasm.heap8u,
    alloc: wasm.alloc,
    dealloc: wasm.dealloc,
    bigIntEnabled: wasm.bigIntEnabled,
    memberPrefix:  '$'
  });
  delete globalThis.Jaccwabyt;

  {

    
    const __xString = wasm.xWrap.argAdapter('string');
    wasm.xWrap.argAdapter(
      'string:flexible', (v)=>__xString(util.flexibleString(v))
    );

    
    wasm.xWrap.argAdapter(
      'string:static',
      function(v){
        if(wasm.isPtr(v)) return v;
        v = ''+v;
        let rc = this[v];
        return rc || (this[v] = wasm.allocCString(v));
      }.bind(Object.create(null))
    );

    
    const __xArgPtr = wasm.xWrap.argAdapter('*');
    const nilType = function(){};
    wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)
    ('sqlite3_context*', __xArgPtr)
    ('sqlite3_value*', __xArgPtr)
    ('void*', __xArgPtr)
    ('sqlite3_changegroup*', __xArgPtr)
    ('sqlite3_changeset_iter*', __xArgPtr)
    
    ('sqlite3_session*', __xArgPtr)
    ('sqlite3_stmt*', (v)=>
      __xArgPtr((v instanceof (sqlite3?.oo1?.Stmt || nilType))
           ? v.pointer : v))
    ('sqlite3*', (v)=>
      __xArgPtr((v instanceof (sqlite3?.oo1?.DB || nilType))
           ? v.pointer : v))
    ('sqlite3_index_info*', (v)=>
      __xArgPtr((v instanceof (capi.sqlite3_index_info || nilType))
           ? v.pointer : v))
    ('sqlite3_module*', (v)=>
      __xArgPtr((v instanceof (capi.sqlite3_module || nilType))
           ? v.pointer : v))
    
    ('sqlite3_vfs*', (v)=>{
      if('string'===typeof v){
        
        return capi.sqlite3_vfs_find(v)
          || sqlite3.SQLite3Error.toss(
            capi.SQLITE_NOTFOUND,
            "Unknown sqlite3_vfs name:", v
          );
      }
      return __xArgPtr((v instanceof (capi.sqlite3_vfs || nilType))
                       ? v.pointer : v);
    });

    const __xRcPtr = wasm.xWrap.resultAdapter('*');
    wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)
    ('sqlite3_context*', __xRcPtr)
    ('sqlite3_stmt*', __xRcPtr)
    ('sqlite3_value*', __xRcPtr)
    ('sqlite3_vfs*', __xRcPtr)
    ('void*', __xRcPtr);

    
    if(0 === wasm.exports.sqlite3_step.length){
      
      wasm.xWrap.doArgcCheck = false;
      sqlite3.config.warn(
        "Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks."
      );
    }
    for(const e of wasm.bindingSignatures){
      capi[e[0]] = wasm.xWrap.apply(null, e);
    }
    for(const e of wasm.bindingSignatures.wasm){
      wasm[e[0]] = wasm.xWrap.apply(null, e);
    }

    
    const fI64Disabled = function(fname){
      return ()=>toss(fname+"() is unavailable due to lack",
                      "of BigInt support in this build.");
    };
    for(const e of wasm.bindingSignatures.int64){
      capi[e[0]] = wasm.bigIntEnabled
        ? wasm.xWrap.apply(null, e)
        : fI64Disabled(e[0]);
    }

    
    delete wasm.bindingSignatures;

    if(wasm.exports.sqlite3_wasm_db_error){
      const __db_err = wasm.xWrap(
        'sqlite3_wasm_db_error', 'int', 'sqlite3*', 'int', 'string'
      );
      
      util.sqlite3_wasm_db_error = function(pDb, resultCode, message){
        if(resultCode instanceof sqlite3.WasmAllocError){
          resultCode = capi.SQLITE_NOMEM;
          message = 0 ;
        }else if(resultCode instanceof Error){
          message = message || ''+resultCode;
          resultCode = (resultCode.resultCode || capi.SQLITE_ERROR);
        }
        return pDb ? __db_err(pDb, resultCode, message) : resultCode;
      };
    }else{
      util.sqlite3_wasm_db_error = function(pDb,errCode,msg){
        console.warn("sqlite3_wasm_db_error() is not exported.",arguments);
        return errCode;
      };
    }
  }

  {
    const cJson = wasm.xCall('sqlite3_wasm_enum_json');
    if(!cJson){
      toss("Maintenance required: increase sqlite3_wasm_enum_json()'s",
           "static buffer size!");
    }
    
    wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));
    
    const defineGroups = ['access', 'authorizer',
                          'blobFinalizers', 'changeset',
                          'config', 'dataTypes',
                          'dbConfig', 'dbStatus',
                          'encodings', 'fcntl', 'flock', 'ioCap',
                          'limits', 'openFlags',
                          'prepareFlags', 'resultCodes',
                          'sqlite3Status',
                          'stmtStatus', 'syncFlags',
                          'trace', 'txnState', 'udfFlags',
                          'version' ];
    if(wasm.bigIntEnabled){
      defineGroups.push('serialize', 'session', 'vtab');
    }
    for(const t of defineGroups){
      for(const e of Object.entries(wasm.ctype[t])){
        
        
        capi[e[0]] = e[1];
      }
    }
    if(!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)){
      toss("Internal error: cannot resolve exported function",
           "entry SQLITE_WASM_DEALLOC (=="+capi.SQLITE_WASM_DEALLOC+").");
    }
    const __rcMap = Object.create(null);
    for(const t of ['resultCodes']){
      for(const e of Object.entries(wasm.ctype[t])){
        __rcMap[e[1]] = e[0];
      }
    }
    
    capi.sqlite3_js_rc_str = (rc)=>__rcMap[rc];
    
    const notThese = Object.assign(Object.create(null),{
      
      WasmTestStruct: true,
      
      sqlite3_kvvfs_methods: !util.isUIThread(),
      
      sqlite3_index_info: !wasm.bigIntEnabled,
      sqlite3_index_constraint: !wasm.bigIntEnabled,
      sqlite3_index_orderby: !wasm.bigIntEnabled,
      sqlite3_index_constraint_usage: !wasm.bigIntEnabled
    });
    for(const s of wasm.ctype.structs){
      if(!notThese[s.name]){
        capi[s.name] = sqlite3.StructBinder(s);
      }
    }
    if(capi.sqlite3_index_info){
      
      for(const k of ['sqlite3_index_constraint',
                      'sqlite3_index_orderby',
                      'sqlite3_index_constraint_usage']){
        capi.sqlite3_index_info[k] = capi[k];
        delete capi[k];
      }
      capi.sqlite3_vtab_config = wasm.xWrap(
        'sqlite3_wasm_vtab_config','int',[
          'sqlite3*', 'int', 'int']
      );
    }
  }

  
  const __dbArgcMismatch = (pDb,f,n)=>{
    return util.sqlite3_wasm_db_error(pDb, capi.SQLITE_MISUSE,
                                      f+"() requires "+n+" argument"+
                                      (1===n?"":'s')+".");
  };

  
  const __errEncoding = (pDb)=>{
    return util.sqlite3_wasm_db_error(
      pDb, capi.SQLITE_FORMAT, "SQLITE_UTF8 is the only supported encoding."
    );
  };

  
  const __argPDb = (pDb)=>wasm.xWrap.argAdapter('sqlite3*')(pDb);
  const __argStr = (str)=>wasm.isPtr(str) ? wasm.cstrToJs(str) : str;
  const __dbCleanupMap = function(
    pDb, mode
  ){
    pDb = __argPDb(pDb);
    let m = this.dbMap.get(pDb);
    if(!mode){
      this.dbMap.delete(pDb);
      return m;
    }else if(!m && mode>0){
      this.dbMap.set(pDb, (m = Object.create(null)));
    }
    return m;
  }.bind(Object.assign(Object.create(null),{
    dbMap: new Map
  }));

  __dbCleanupMap.addCollation = function(pDb, name){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.collation) m.collation = new Set;
    m.collation.add(__argStr(name).toLowerCase());
  };

  __dbCleanupMap._addUDF = function(pDb, name, arity, map){
    
    name = __argStr(name).toLowerCase();
    let u = map.get(name);
    if(!u) map.set(name, (u = new Set));
    u.add((arity<0) ? -1 : arity);
  };

  __dbCleanupMap.addFunction = function(pDb, name, arity){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.udf) m.udf = new Map;
    this._addUDF(pDb, name, arity, m.udf);
  };

  __dbCleanupMap.addWindowFunc = function(pDb, name, arity){
    const m = __dbCleanupMap(pDb, 1);
    if(!m.wudf) m.wudf = new Map;
    this._addUDF(pDb, name, arity, m.wudf);
  };

  
  __dbCleanupMap.cleanup = function(pDb){
    pDb = __argPDb(pDb);
    
    
    const closeArgs = [pDb];
    for(const name of [
      'sqlite3_busy_handler',
      'sqlite3_commit_hook',
      'sqlite3_preupdate_hook',
      'sqlite3_progress_handler',
      'sqlite3_rollback_hook',
      'sqlite3_set_authorizer',
      'sqlite3_trace_v2',
      'sqlite3_update_hook'
    ]) {
      const x = wasm.exports[name];
      closeArgs.length = x.length
      ;
      try{ capi[name](...closeArgs) }
      catch(e){
        console.warn("close-time call of",name+"(",closeArgs,") threw:",e);
      }
    }
    const m = __dbCleanupMap(pDb, 0);
    if(!m) return;
    if(m.collation){
      for(const name of m.collation){
        try{
          capi.sqlite3_create_collation_v2(
            pDb, name, capi.SQLITE_UTF8, 0, 0, 0
          );
        }catch(e){
          
        }
      }
      delete m.collation;
    }
    let i;
    for(i = 0; i < 2; ++i){ 
      const fmap = i ? m.wudf : m.udf;
      if(!fmap) continue;
      const func = i
            ? capi.sqlite3_create_window_function
            : capi.sqlite3_create_function_v2;
      for(const e of fmap){
        const name = e[0], arities = e[1];
        const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
        if(i) fargs.push(0);
        for(const arity of arities){
          try{ fargs[2] = arity; func.apply(null, fargs); }
          catch(e){}
        }
        arities.clear();
      }
      fmap.clear();
    }
    delete m.udf;
    delete m.wudf;
  };

  {
    const __sqlite3CloseV2 = wasm.xWrap("sqlite3_close_v2", "int", "sqlite3*");
    capi.sqlite3_close_v2 = function(pDb){
      if(1!==arguments.length) return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);
      if(pDb){
        try{__dbCleanupMap.cleanup(pDb)} catch(e){}
      }
      return __sqlite3CloseV2(pDb);
    };
  }

  if(capi.sqlite3session_table_filter){
    const __sqlite3SessionDelete = wasm.xWrap(
      'sqlite3session_delete', undefined, ['sqlite3_session*']
    );
    capi.sqlite3session_delete = function(pSession){
      if(1!==arguments.length){
        return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);
        
      }
      else if(pSession){
        
        capi.sqlite3session_table_filter(pSession, 0, 0);
      }
      __sqlite3SessionDelete(pSession);
    };
  }

  {
    
    const contextKey = (argv,argIndex)=>{
      return 'argv['+argIndex+']:'+argv[0]+
        ':'+wasm.cstrToJs(argv[1]).toLowerCase()
    };
    const __sqlite3CreateCollationV2 = wasm.xWrap(
      'sqlite3_create_collation_v2', 'int', [
        'sqlite3*', 'string', 'int', '*',
        new wasm.xWrap.FuncPtrAdapter({
          
          name: 'xCompare', signature: 'i(pipip)', contextKey
        }),
        new wasm.xWrap.FuncPtrAdapter({
          
          name: 'xDestroy', signature: 'v(p)', contextKey
        })
      ]
    );

    
    capi.sqlite3_create_collation_v2 = function(pDb,zName,eTextRep,pArg,xCompare,xDestroy){
      if(6!==arguments.length) return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);
      else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateCollationV2(pDb, zName, eTextRep, pArg, xCompare, xDestroy);
        if(0===rc && xCompare instanceof Function){
          __dbCleanupMap.addCollation(pDb, zName);
        }
        return rc;
      }catch(e){
        return util.sqlite3_wasm_db_error(pDb, e);
      }
    };

    capi.sqlite3_create_collation = (pDb,zName,eTextRep,pArg,xCompare)=>{
      return (5===arguments.length)
        ? capi.sqlite3_create_collation_v2(pDb,zName,eTextRep,pArg,xCompare,0)
        : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);
    };

  }

  {
    
    const contextKey = function(argv,argIndex){
      return (
        argv[0]
          +':'+(argv[2] < 0 ? -1 : argv[2])
          +':'+argIndex
          +':'+wasm.cstrToJs(argv[1]).toLowerCase()
      )
    };

    
    const __cfProxy = Object.assign(Object.create(null), {
      xInverseAndStep: {
        signature:'v(pip)', contextKey,
        callProxy: (callback)=>{
          return (pCtx, argc, pArgv)=>{
            try{ callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)) }
            catch(e){ capi.sqlite3_result_error_js(pCtx, e) }
          };
        }
      },
      xFinalAndValue: {
        signature:'v(p)', contextKey,
        callProxy: (callback)=>{
          return (pCtx)=>{
            try{ capi.sqlite3_result_js(pCtx, callback(pCtx)) }
            catch(e){ capi.sqlite3_result_error_js(pCtx, e) }
          };
        }
      },
      xFunc: {
        signature:'v(pip)', contextKey,
        callProxy: (callback)=>{
          return (pCtx, argc, pArgv)=>{
            try{
              capi.sqlite3_result_js(
                pCtx,
                callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv))
              );
            }catch(e){
              
              capi.sqlite3_result_error_js(pCtx, e);
            }
          };
        }
      },
      xDestroy: {
        signature:'v(p)', contextKey,
        
        callProxy: (callback)=>{
          return (pVoid)=>{
            try{ callback(pVoid) }
            catch(e){ console.error("UDF xDestroy method threw:",e) }
          };
        }
      }
    });

    const __sqlite3CreateFunction = wasm.xWrap(
      "sqlite3_create_function_v2", "int", [
        "sqlite3*", "string", "int",
        "int", "*",
        new wasm.xWrap.FuncPtrAdapter({name: 'xFunc', ...__cfProxy.xFunc}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xStep', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xFinal', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xDestroy', ...__cfProxy.xDestroy})
      ]
    );

    const __sqlite3CreateWindowFunction = wasm.xWrap(
      "sqlite3_create_window_function", "int", [
        "sqlite3*", "string", "int",
        "int", "*",
        new wasm.xWrap.FuncPtrAdapter({name: 'xStep', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xFinal', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xValue', ...__cfProxy.xFinalAndValue}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xInverse', ...__cfProxy.xInverseAndStep}),
        new wasm.xWrap.FuncPtrAdapter({name: 'xDestroy', ...__cfProxy.xDestroy})
      ]
    );

    
    capi.sqlite3_create_function_v2 = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc,   
      xStep,   
      xFinal,  
      xDestroy 
    ){
      if( f.length!==arguments.length ){
        return __dbArgcMismatch(pDb,"sqlite3_create_function_v2",f.length);
      }else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateFunction(pDb, funcName, nArg, eTextRep,
                                           pApp, xFunc, xStep, xFinal, xDestroy);
        if(0===rc && (xFunc instanceof Function
                      || xStep instanceof Function
                      || xFinal instanceof Function
                      || xDestroy instanceof Function)){
          __dbCleanupMap.addFunction(pDb, funcName, nArg);
        }
        return rc;
      }catch(e){
        console.error("sqlite3_create_function_v2() setup threw:",e);
        return util.sqlite3_wasm_db_error(pDb, e, "Creation of UDF threw: "+e);
      }
    };

    
    capi.sqlite3_create_function = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xFunc, xStep, xFinal
    ){
      return (f.length===arguments.length)
        ? capi.sqlite3_create_function_v2(pDb, funcName, nArg, eTextRep,
                                          pApp, xFunc, xStep, xFinal, 0)
        : __dbArgcMismatch(pDb,"sqlite3_create_function",f.length);
    };

    
    capi.sqlite3_create_window_function = function f(
      pDb, funcName, nArg, eTextRep, pApp,
      xStep,   
      xFinal,  
      xValue,  
      xInverse,
      xDestroy 
    ){
      if( f.length!==arguments.length ){
        return __dbArgcMismatch(pDb,"sqlite3_create_window_function",f.length);
      }else if( 0 === (eTextRep & 0xf) ){
        eTextRep |= capi.SQLITE_UTF8;
      }else if( capi.SQLITE_UTF8 !== (eTextRep & 0xf) ){
        return __errEncoding(pDb);
      }
      try{
        const rc = __sqlite3CreateWindowFunction(pDb, funcName, nArg, eTextRep,
                                                 pApp, xStep, xFinal, xValue,
                                                 xInverse, xDestroy);
        if(0===rc && (xStep instanceof Function
                      || xFinal instanceof Function
                      || xValue instanceof Function
                      || xInverse instanceof Function
                      || xDestroy instanceof Function)){
          __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);
        }
        return rc;
      }catch(e){
        console.error("sqlite3_create_window_function() setup threw:",e);
        return util.sqlite3_wasm_db_error(pDb, e, "Creation of UDF threw: "+e);
      }
    };
    
    capi.sqlite3_create_function_v2.udfSetResult =
      capi.sqlite3_create_function.udfSetResult =
      capi.sqlite3_create_window_function.udfSetResult = capi.sqlite3_result_js;

    
    capi.sqlite3_create_function_v2.udfConvertArgs =
      capi.sqlite3_create_function.udfConvertArgs =
      capi.sqlite3_create_window_function.udfConvertArgs = capi.sqlite3_values_to_js;

    
    capi.sqlite3_create_function_v2.udfSetError =
      capi.sqlite3_create_function.udfSetError =
      capi.sqlite3_create_window_function.udfSetError = capi.sqlite3_result_error_js;

  };

  {

    
    const __flexiString = (v,n)=>{
      if('string'===typeof v){
        n = -1;
      }else if(util.isSQLableTypedArray(v)){
        n = v.byteLength;
        v = util.typedArrayToString(
          (v instanceof ArrayBuffer) ? new Uint8Array(v) : v
        );
      }else if(Array.isArray(v)){
        v = v.join("");
        n = -1;
      }
      return [v, n];
    };

    
    const __prepare = {
      
      basic: wasm.xWrap('sqlite3_prepare_v3',
                        "int", ["sqlite3*", "string",
                                "int",
                                "int", "**",
                                "**"]),
      
      full: wasm.xWrap('sqlite3_prepare_v3',
                       "int", ["sqlite3*", "*", "int", "int",
                               "**", "**"])
    };

    
    capi.sqlite3_prepare_v3 = function f(pDb, sql, sqlLen, prepFlags, ppStmt, pzTail){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(pDb,"sqlite3_prepare_v3",f.length);
      }
      const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
      switch(typeof xSql){
          case 'string': return __prepare.basic(pDb, xSql, xSqlLen, prepFlags, ppStmt, null);
          case 'number': return __prepare.full(pDb, xSql, xSqlLen, prepFlags, ppStmt, pzTail);
          default:
            return util.sqlite3_wasm_db_error(
              pDb, capi.SQLITE_MISUSE,
              "Invalid SQL argument type for sqlite3_prepare_v2/v3()."
            );
      }
    };

    
    capi.sqlite3_prepare_v2 = function f(pDb, sql, sqlLen, ppStmt, pzTail){
      return (f.length===arguments.length)
        ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)
        : __dbArgcMismatch(pDb,"sqlite3_prepare_v2",f.length);
    };

  }

  {
    const __bindText = wasm.xWrap("sqlite3_bind_text", "int", [
      "sqlite3_stmt*", "int", "string", "int", "*"
    ]);
    const __bindBlob = wasm.xWrap("sqlite3_bind_blob", "int", [
      "sqlite3_stmt*", "int", "*", "int", "*"
    ]);

    
    capi.sqlite3_bind_text = function f(pStmt, iCol, text, nText, xDestroy){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(capi.sqlite3_db_handle(pStmt),
                                "sqlite3_bind_text", f.length);
      }else if(wasm.isPtr(text) || null===text){
        return __bindText(pStmt, iCol, text, nText, xDestroy);
      }else if(text instanceof ArrayBuffer){
        text = new Uint8Array(text);
      }else if(Array.isArray(pMem)){
        text = pMem.join('');
      }
      let p, n;
      try{
        if(util.isSQLableTypedArray(text)){
          p = wasm.allocFromTypedArray(text);
          n = text.byteLength;
        }else if('string'===typeof text){
          [p, n] = wasm.allocCString(text);
        }else{
          return util.sqlite3_wasm_db_error(
            capi.sqlite3_db_handle(pStmt), capi.SQLITE_MISUSE,
            "Invalid 3rd argument type for sqlite3_bind_text()."
          );
        }
        return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
      }catch(e){
        wasm.dealloc(p);
        return util.sqlite3_wasm_db_error(
          capi.sqlite3_db_handle(pStmt), e
        );
      }
    };

    
    capi.sqlite3_bind_blob = function f(pStmt, iCol, pMem, nMem, xDestroy){
      if(f.length!==arguments.length){
        return __dbArgcMismatch(capi.sqlite3_db_handle(pStmt),
                                "sqlite3_bind_blob", f.length);
      }else if(wasm.isPtr(pMem) || null===pMem){
        return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);
      }else if(pMem instanceof ArrayBuffer){
        pMem = new Uint8Array(pMem);
      }else if(Array.isArray(pMem)){
        pMem = pMem.join('');
      }
      let p, n;
      try{
        if(util.isBindableTypedArray(pMem)){
          p = wasm.allocFromTypedArray(pMem);
          n = nMem>=0 ? nMem : pMem.byteLength;
        }else if('string'===typeof pMem){
          [p, n] = wasm.allocCString(pMem);
        }else{
          return util.sqlite3_wasm_db_error(
            capi.sqlite3_db_handle(pStmt), capi.SQLITE_MISUSE,
            "Invalid 3rd argument type for sqlite3_bind_blob()."
          );
        }
        return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
      }catch(e){
        wasm.dealloc(p);
        return util.sqlite3_wasm_db_error(
          capi.sqlite3_db_handle(pStmt), e
        );
      }
    };

  }

  {
    
    capi.sqlite3_config = function(op, ...args){
      if(arguments.length<2) return capi.SQLITE_MISUSE;
      switch(op){
          case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN: 
          case capi.SQLITE_CONFIG_MEMSTATUS:
          case capi.SQLITE_CONFIG_SMALL_MALLOC: 
          case capi.SQLITE_CONFIG_SORTERREF_SIZE: 
          case capi.SQLITE_CONFIG_STMTJRNL_SPILL: 
          case capi.SQLITE_CONFIG_URI:
            return wasm.exports.sqlite3_wasm_config_i(op, args[0]);
          case capi.SQLITE_CONFIG_LOOKASIDE: 
            return wasm.exports.sqlite3_wasm_config_ii(op, args[0], args[1]);
          case capi.SQLITE_CONFIG_MEMDB_MAXSIZE: 
            return wasm.exports.sqlite3_wasm_config_j(op, args[0]);
          case capi.SQLITE_CONFIG_GETMALLOC: 
          case capi.SQLITE_CONFIG_GETMUTEX: 
          case capi.SQLITE_CONFIG_GETPCACHE2: 
          case capi.SQLITE_CONFIG_GETPCACHE: 
          case capi.SQLITE_CONFIG_HEAP: 
          case capi.SQLITE_CONFIG_LOG: 
          case capi.SQLITE_CONFIG_MALLOC:
          case capi.SQLITE_CONFIG_MMAP_SIZE: 
          case capi.SQLITE_CONFIG_MULTITHREAD: 
          case capi.SQLITE_CONFIG_MUTEX: 
          case capi.SQLITE_CONFIG_PAGECACHE: 
          case capi.SQLITE_CONFIG_PCACHE2: 
          case capi.SQLITE_CONFIG_PCACHE: 
          case capi.SQLITE_CONFIG_PCACHE_HDRSZ: 
          case capi.SQLITE_CONFIG_PMASZ: 
          case capi.SQLITE_CONFIG_SERIALIZED: 
          case capi.SQLITE_CONFIG_SINGLETHREAD: 
          case capi.SQLITE_CONFIG_SQLLOG: 
          case capi.SQLITE_CONFIG_WIN32_HEAPSIZE: 
          default:
            return capi.SQLITE_NOTFOUND;
      }
    };
  }

  {
    const __autoExtFptr = new Set;

    capi.sqlite3_auto_extension = function(fPtr){
      if( fPtr instanceof Function ){
        fPtr = wasm.installFunction('i(ppp)', fPtr);
      }else if( 1!==arguments.length || !wasm.isPtr(fPtr) ){
        return capi.SQLITE_MISUSE;
      }
      const rc = wasm.exports.sqlite3_auto_extension(fPtr);
      if( fPtr!==arguments[0] ){
        if(0===rc) __autoExtFptr.add(fPtr);
        else wasm.uninstallFunction(fPtr);
      }
      return rc;
    };

    capi.sqlite3_cancel_auto_extension = function(fPtr){
     ;
      if(!fPtr || 1!==arguments.length || !wasm.isPtr(fPtr)) return 0;
      return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
      
    };

    capi.sqlite3_reset_auto_extension = function(){
      wasm.exports.sqlite3_reset_auto_extension();
      for(const fp of __autoExtFptr) wasm.uninstallFunction(fp);
      __autoExtFptr.clear();
    };
  }

  const pKvvfs = capi.sqlite3_vfs_find("kvvfs");
  if( pKvvfs ){
    if(util.isUIThread()){
      const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
        wasm.exports.sqlite3_wasm_kvvfs_methods()
      );
      delete capi.sqlite3_kvvfs_methods;

      const kvvfsMakeKey = wasm.exports.sqlite3_wasm_kvvfsMakeKeyOnPstack,
            pstack = wasm.pstack;

      const kvvfsStorage = (zClass)=>
            ((115===wasm.peek(zClass))
             ? sessionStorage : localStorage);

      
      const kvvfsImpls = {
        xRead: (zClass, zKey, zBuf, nBuf)=>{
          const stack = pstack.pointer,
                astack = wasm.scopedAllocPush();
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return -3;
            const jKey = wasm.cstrToJs(zXKey);
            const jV = kvvfsStorage(zClass).getItem(jKey);
            if(!jV) return -1;
            const nV = jV.length ;
            if(nBuf<=0) return nV;
            else if(1===nBuf){
              wasm.poke(zBuf, 0);
              return nV;
            }
            const zV = wasm.scopedAllocCString(jV);
            if(nBuf > nV + 1) nBuf = nV + 1;
            wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
            wasm.poke(zBuf + nBuf - 1, 0);
            return nBuf - 1;
          }catch(e){
            console.error("kvstorageRead()",e);
            return -2;
          }finally{
            pstack.restore(stack);
            wasm.scopedAllocPop(astack);
          }
        },
        xWrite: (zClass, zKey, zData)=>{
          const stack = pstack.pointer;
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return 1;
            const jKey = wasm.cstrToJs(zXKey);
            kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
            return 0;
          }catch(e){
            console.error("kvstorageWrite()",e);
            return capi.SQLITE_IOERR;
          }finally{
            pstack.restore(stack);
          }
        },
        xDelete: (zClass, zKey)=>{
          const stack = pstack.pointer;
          try {
            const zXKey = kvvfsMakeKey(zClass,zKey);
            if(!zXKey) return 1;
            kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
            return 0;
          }catch(e){
            console.error("kvstorageDelete()",e);
            return capi.SQLITE_IOERR;
          }finally{
            pstack.restore(stack);
          }
        }
      };
      for(const k of Object.keys(kvvfsImpls)){
        kvvfsMethods[kvvfsMethods.memberKey(k)] =
          wasm.installFunction(
            kvvfsMethods.memberSignature(k),
            kvvfsImpls[k]
          );
      }
    }else{
      
      capi.sqlite3_vfs_unregister(pKvvfs);
    }
  }

  wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
});


globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  sqlite3.version = {"libVersion": "3.45.2", "libVersionNumber": 3045002, "sourceId": "2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77","downloadVersion": 3450200};
});



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  const toss = (...args)=>{throw new Error(args.join(' '))};
  const toss3 = (...args)=>{throw new sqlite3.SQLite3Error(...args)};

  const capi = sqlite3.capi, wasm = sqlite3.wasm, util = sqlite3.util;
  

  
  const __ptrMap = new WeakMap();
  
  const __stmtMap = new WeakMap();

  
  const getOwnOption = (opts, p, dflt)=>{
    const d = Object.getOwnPropertyDescriptor(opts,p);
    return d ? d.value : dflt;
  };

  
  const checkSqlite3Rc = function(dbPtr, sqliteResultCode){
    if(sqliteResultCode){
      if(dbPtr instanceof DB) dbPtr = dbPtr.pointer;
      toss3(
        sqliteResultCode,
        "sqlite3 result code",sqliteResultCode+":",
        (dbPtr
         ? capi.sqlite3_errmsg(dbPtr)
         : capi.sqlite3_errstr(sqliteResultCode))
      );
    }
    return arguments[0];
  };

  
  const __dbTraceToConsole =
        wasm.installFunction('i(ippp)', function(t,c,p,x){
          if(capi.SQLITE_TRACE_STMT===t){
            
            console.log("SQL TRACE #"+(++this.counter)+' via sqlite3@'+c+':',
                        wasm.cstrToJs(x));
          }
        }.bind({counter: 0}));

  
  const __vfsPostOpenSql = Object.create(null);

  
  const dbCtorHelper = function ctor(...args){
    if(!ctor._name2vfs){
      
      ctor._name2vfs = Object.create(null);
      const isWorkerThread = ('function'===typeof importScripts)
            ? (n)=>toss3("The VFS for",n,"is only available in the main window thread.")
            : false;
      ctor._name2vfs[':localStorage:'] = {
        vfs: 'kvvfs', filename: isWorkerThread || (()=>'local')
      };
      ctor._name2vfs[':sessionStorage:'] = {
        vfs: 'kvvfs', filename: isWorkerThread || (()=>'session')
      };
    }
    const opt = ctor.normalizeArgs(...args);
    let fn = opt.filename, vfsName = opt.vfs, flagsStr = opt.flags;
    if(('string'!==typeof fn && 'number'!==typeof fn)
       || 'string'!==typeof flagsStr
       || (vfsName && ('string'!==typeof vfsName && 'number'!==typeof vfsName))){
      sqlite3.config.error("Invalid DB ctor args",opt,arguments);
      toss3("Invalid arguments for DB constructor.");
    }
    let fnJs = ('number'===typeof fn) ? wasm.cstrToJs(fn) : fn;
    const vfsCheck = ctor._name2vfs[fnJs];
    if(vfsCheck){
      vfsName = vfsCheck.vfs;
      fn = fnJs = vfsCheck.filename(fnJs);
    }
    let pDb, oflags = 0;
    if( flagsStr.indexOf('c')>=0 ){
      oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
    }
    if( flagsStr.indexOf('w')>=0 ) oflags |= capi.SQLITE_OPEN_READWRITE;
    if( 0===oflags ) oflags |= capi.SQLITE_OPEN_READONLY;
    oflags |= capi.SQLITE_OPEN_EXRESCODE;
    const stack = wasm.pstack.pointer;
    try {
      const pPtr = wasm.pstack.allocPtr() ;
      let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
      pDb = wasm.peekPtr(pPtr);
      checkSqlite3Rc(pDb, rc);
      capi.sqlite3_extended_result_codes(pDb, 1);
      if(flagsStr.indexOf('t')>=0){
        capi.sqlite3_trace_v2(pDb, capi.SQLITE_TRACE_STMT,
                              __dbTraceToConsole, pDb);
      }
    }catch( e ){
      if( pDb ) capi.sqlite3_close_v2(pDb);
      throw e;
    }finally{
      wasm.pstack.restore(stack);
    }
    this.filename = fnJs;
    __ptrMap.set(this, pDb);
    __stmtMap.set(this, Object.create(null));
    try{
      
      const pVfs = capi.sqlite3_js_db_vfs(pDb);
      if(!pVfs) toss3("Internal error: cannot get VFS for new db handle.");
      const postInitSql = __vfsPostOpenSql[pVfs];
      if(postInitSql instanceof Function){
        postInitSql(this, sqlite3);
      }else if(postInitSql){
        checkSqlite3Rc(
          pDb, capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0)
        );
      }
    }catch(e){
      this.close();
      throw e;
    }
  };

  
  dbCtorHelper.setVfsPostOpenSql = function(pVfs, sql){
    __vfsPostOpenSql[pVfs] = sql;
  };

  
  dbCtorHelper.normalizeArgs = function(filename=':memory:',flags = 'c',vfs = null){
    const arg = {};
    if(1===arguments.length && arguments[0] && 'object'===typeof arguments[0]){
      Object.assign(arg, arguments[0]);
      if(undefined===arg.flags) arg.flags = 'c';
      if(undefined===arg.vfs) arg.vfs = null;
      if(undefined===arg.filename) arg.filename = ':memory:';
    }else{
      arg.filename = filename;
      arg.flags = flags;
      arg.vfs = vfs;
    }
    return arg;
  };
  
  const DB = function(...args){
    dbCtorHelper.apply(this, args);
  };
  DB.dbCtorHelper = dbCtorHelper;

  
  const BindTypes = {
    null: 1,
    number: 2,
    string: 3,
    boolean: 4,
    blob: 5
  };
  BindTypes['undefined'] == BindTypes.null;
  if(wasm.bigIntEnabled){
    BindTypes.bigint = BindTypes.number;
  }

  
  const Stmt = function(){
    if(BindTypes!==arguments[2]){
      toss3(capi.SQLITE_MISUSE, "Do not call the Stmt constructor directly. Use DB.prepare().");
    }
    this.db = arguments[0];
    __ptrMap.set(this, arguments[1]);
    this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
  };

  
  const affirmDbOpen = function(db){
    if(!db.pointer) toss3("DB has been closed.");
    return db;
  };

  
  const affirmColIndex = function(stmt,ndx){
    if((ndx !== (ndx|0)) || ndx<0 || ndx>=stmt.columnCount){
      toss3("Column index",ndx,"is out of range.");
    }
    return stmt;
  };

  
  const parseExecArgs = function(db, args){
    const out = Object.create(null);
    out.opt = Object.create(null);
    switch(args.length){
        case 1:
          if('string'===typeof args[0] || util.isSQLableTypedArray(args[0])){
            out.sql = args[0];
          }else if(Array.isArray(args[0])){
            out.sql = args[0];
          }else if(args[0] && 'object'===typeof args[0]){
            out.opt = args[0];
            out.sql = out.opt.sql;
          }
          break;
        case 2:
          out.sql = args[0];
          out.opt = args[1];
          break;
        default: toss3("Invalid argument count for exec().");
    };
    out.sql = util.flexibleString(out.sql);
    if('string'!==typeof out.sql){
      toss3("Missing SQL argument or unsupported SQL value type.");
    }
    const opt = out.opt;
    switch(opt.returnValue){
        case 'resultRows':
          if(!opt.resultRows) opt.resultRows = [];
          out.returnVal = ()=>opt.resultRows;
          break;
        case 'saveSql':
          if(!opt.saveSql) opt.saveSql = [];
          out.returnVal = ()=>opt.saveSql;
          break;
        case undefined:
        case 'this':
          out.returnVal = ()=>db;
          break;
        default:
          toss3("Invalid returnValue value:",opt.returnValue);
    }
    if(!opt.callback && !opt.returnValue && undefined!==opt.rowMode){
      if(!opt.resultRows) opt.resultRows = [];
      out.returnVal = ()=>opt.resultRows;
    }
    if(opt.callback || opt.resultRows){
      switch((undefined===opt.rowMode)
             ? 'array' : opt.rowMode) {
          case 'object': out.cbArg = (stmt)=>stmt.get(Object.create(null)); break;
          case 'array': out.cbArg = (stmt)=>stmt.get([]); break;
          case 'stmt':
            if(Array.isArray(opt.resultRows)){
              toss3("exec(): invalid rowMode for a resultRows array: must",
                    "be one of 'array', 'object',",
                    "a result column number, or column name reference.");
            }
            out.cbArg = (stmt)=>stmt;
            break;
          default:
            if(util.isInt32(opt.rowMode)){
              out.cbArg = (stmt)=>stmt.get(opt.rowMode);
              break;
            }else if('string'===typeof opt.rowMode
                     && opt.rowMode.length>1
                     && '$'===opt.rowMode[0]){
              
              const $colName = opt.rowMode.substr(1);
              out.cbArg = (stmt)=>{
                const rc = stmt.get(Object.create(null))[$colName];
                return (undefined===rc)
                  ? toss3(capi.SQLITE_NOTFOUND,
                          "exec(): unknown result column:",$colName)
                  : rc;
              };
              break;
            }
            toss3("Invalid rowMode:",opt.rowMode);
      }
    }
    return out;
  };

  
  const __selectFirstRow = (db, sql, bind, ...getArgs)=>{
    const stmt = db.prepare(sql);
    try {
      const rc = stmt.bind(bind).step() ? stmt.get(...getArgs) : undefined;
      stmt.reset();
      return rc;
    }finally{
      stmt.finalize();
    }
  };

  
  const __selectAll =
        (db, sql, bind, rowMode)=>db.exec({
          sql, bind, rowMode, returnValue: 'resultRows'
        });

  
  DB.checkRc = (db,resultCode)=>checkSqlite3Rc(db,resultCode);

  DB.prototype = {
    
    isOpen: function(){
      return !!this.pointer;
    },
    
    affirmOpen: function(){
      return affirmDbOpen(this);
    },
    
    close: function(){
      if(this.pointer){
        if(this.onclose && (this.onclose.before instanceof Function)){
          try{this.onclose.before(this)}
          catch(e){}
        }
        const pDb = this.pointer;
        Object.keys(__stmtMap.get(this)).forEach((k,s)=>{
          if(s && s.pointer){
            try{s.finalize()}
            catch(e){}
          }
        });
        __ptrMap.delete(this);
        __stmtMap.delete(this);
        capi.sqlite3_close_v2(pDb);
        if(this.onclose && (this.onclose.after instanceof Function)){
          try{this.onclose.after(this)}
          catch(e){}
        }
        delete this.filename;
      }
    },
    
    changes: function(total=false,sixtyFour=false){
      const p = affirmDbOpen(this).pointer;
      if(total){
        return sixtyFour
          ? capi.sqlite3_total_changes64(p)
          : capi.sqlite3_total_changes(p);
      }else{
        return sixtyFour
          ? capi.sqlite3_changes64(p)
          : capi.sqlite3_changes(p);
      }
    },
    
    dbFilename: function(dbName='main'){
      return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
    },
    
    dbName: function(dbNumber=0){
      return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
    },
    
    dbVfsName: function(dbName=0){
      let rc;
      const pVfs = capi.sqlite3_js_db_vfs(
        affirmDbOpen(this).pointer, dbName
      );
      if(pVfs){
        const v = new capi.sqlite3_vfs(pVfs);
        try{ rc = wasm.cstrToJs(v.$zName) }
        finally { v.dispose() }
      }
      return rc;
    },
    
    prepare: function(sql){
      affirmDbOpen(this);
      const stack = wasm.pstack.pointer;
      let ppStmt, pStmt;
      try{
        ppStmt = wasm.pstack.alloc(8);
        DB.checkRc(this, capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null));
        pStmt = wasm.peekPtr(ppStmt);
      }
      finally {
        wasm.pstack.restore(stack);
      }
      if(!pStmt) toss3("Cannot prepare empty SQL.");
      const stmt = new Stmt(this, pStmt, BindTypes);
      __stmtMap.get(this)[pStmt] = stmt;
      return stmt;
    },
    
    exec: function(){
      affirmDbOpen(this);
      const arg = parseExecArgs(this, arguments);
      if(!arg.sql){
        return toss3("exec() requires an SQL string.");
      }
      const opt = arg.opt;
      const callback = opt.callback;
      const resultRows =
            Array.isArray(opt.resultRows) ? opt.resultRows : undefined;
      let stmt;
      let bind = opt.bind;
      let evalFirstResult = !!(
        arg.cbArg || opt.columnNames || resultRows
      ) ;
      const stack = wasm.scopedAllocPush();
      const saveSql = Array.isArray(opt.saveSql) ? opt.saveSql : undefined;
      try{
        const isTA = util.isSQLableTypedArray(arg.sql)
        ;
        
        let sqlByteLen = isTA ? arg.sql.byteLength : wasm.jstrlen(arg.sql);
        const ppStmt  = wasm.scopedAlloc(
          
          (2 * wasm.ptrSizeof) + (sqlByteLen + 1)
        );
        const pzTail = ppStmt + wasm.ptrSizeof ;
        let pSql = pzTail + wasm.ptrSizeof;
        const pSqlEnd = pSql + sqlByteLen;
        if(isTA) wasm.heap8().set(arg.sql, pSql);
        else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
        wasm.poke(pSql + sqlByteLen, 0);
        while(pSql && wasm.peek(pSql, 'i8')
               ){
          wasm.pokePtr([ppStmt, pzTail], 0);
          DB.checkRc(this, capi.sqlite3_prepare_v3(
            this.pointer, pSql, sqlByteLen, 0, ppStmt, pzTail
          ));
          const pStmt = wasm.peekPtr(ppStmt);
          pSql = wasm.peekPtr(pzTail);
          sqlByteLen = pSqlEnd - pSql;
          if(!pStmt) continue;
          if(saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
          stmt = new Stmt(this, pStmt, BindTypes);
          if(bind && stmt.parameterCount){
            stmt.bind(bind);
            bind = null;
          }
          if(evalFirstResult && stmt.columnCount){
            
            let gotColNames = Array.isArray(
              opt.columnNames
              ) ? 0 : 1;
            evalFirstResult = false;
            if(arg.cbArg || resultRows){
              for(; stmt.step(); stmt._lockedByExec = false){
                if(0===gotColNames++) stmt.getColumnNames(opt.columnNames);
                stmt._lockedByExec = true;
                const row = arg.cbArg(stmt);
                if(resultRows) resultRows.push(row);
                if(callback && false === callback.call(opt, row, stmt)){
                  break;
                }
              }
              stmt._lockedByExec = false;
            }
            if(0===gotColNames){
              
              stmt.getColumnNames(opt.columnNames);
            }
          }else{
            stmt.step();
          }
          stmt.reset(
            ).finalize();
          stmt = null;
        }
      }finally{
        wasm.scopedAllocPop(stack);
        if(stmt){
          delete stmt._lockedByExec;
          stmt.finalize();
        }
      }
      return arg.returnVal();
    },

    
    createFunction: function f(name, xFunc, opt){
      const isFunc = (f)=>(f instanceof Function);
      switch(arguments.length){
          case 1: 
            opt = name;
            name = opt.name;
            xFunc = opt.xFunc || 0;
            break;
          case 2: 
            if(!isFunc(xFunc)){
              opt = xFunc;
              xFunc = opt.xFunc || 0;
            }
            break;
          case 3: 
            break;
          default: break;
      }
      if(!opt) opt = {};
      if('string' !== typeof name){
        toss3("Invalid arguments: missing function name.");
      }
      let xStep = opt.xStep || 0;
      let xFinal = opt.xFinal || 0;
      const xValue = opt.xValue || 0;
      const xInverse = opt.xInverse || 0;
      let isWindow = undefined;
      if(isFunc(xFunc)){
        isWindow = false;
        if(isFunc(xStep) || isFunc(xFinal)){
          toss3("Ambiguous arguments: scalar or aggregate?");
        }
        xStep = xFinal = null;
      }else if(isFunc(xStep)){
        if(!isFunc(xFinal)){
          toss3("Missing xFinal() callback for aggregate or window UDF.");
        }
        xFunc = null;
      }else if(isFunc(xFinal)){
        toss3("Missing xStep() callback for aggregate or window UDF.");
      }else{
        toss3("Missing function-type properties.");
      }
      if(false === isWindow){
        if(isFunc(xValue) || isFunc(xInverse)){
          toss3("xValue and xInverse are not permitted for non-window UDFs.");
        }
      }else if(isFunc(xValue)){
        if(!isFunc(xInverse)){
          toss3("xInverse must be provided if xValue is.");
        }
        isWindow = true;
      }else if(isFunc(xInverse)){
        toss3("xValue must be provided if xInverse is.");
      }
      const pApp = opt.pApp;
      if(undefined!==pApp &&
         null!==pApp &&
         (('number'!==typeof pApp) || !util.isInt32(pApp))){
        toss3("Invalid value for pApp property. Must be a legal WASM pointer value.");
      }
      const xDestroy = opt.xDestroy || 0;
      if(xDestroy && !isFunc(xDestroy)){
        toss3("xDestroy property must be a function.");
      }
      let fFlags = 0 ;
      if(getOwnOption(opt, 'deterministic')) fFlags |= capi.SQLITE_DETERMINISTIC;
      if(getOwnOption(opt, 'directOnly')) fFlags |= capi.SQLITE_DIRECTONLY;
      if(getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;
      name = name.toLowerCase();
      const xArity = xFunc || xStep;
      const arity = getOwnOption(opt, 'arity');
      const arityArg = ('number'===typeof arity
                        ? arity
                        : (xArity.length ? xArity.length-1 : 0));
      let rc;
      if( isWindow ){
        rc = capi.sqlite3_create_window_function(
          this.pointer, name, arityArg,
          capi.SQLITE_UTF8 | fFlags, pApp || 0,
          xStep, xFinal, xValue, xInverse, xDestroy);
      }else{
        rc = capi.sqlite3_create_function_v2(
          this.pointer, name, arityArg,
          capi.SQLITE_UTF8 | fFlags, pApp || 0,
          xFunc, xStep, xFinal, xDestroy);
      }
      DB.checkRc(this, rc);
      return this;
    },
    
    selectValue: function(sql,bind,asType){
      return __selectFirstRow(this, sql, bind, 0, asType);
    },

    
    selectValues: function(sql,bind,asType){
      const stmt = this.prepare(sql), rc = [];
      try {
        stmt.bind(bind);
        while(stmt.step()) rc.push(stmt.get(0,asType));
        stmt.reset();
      }finally{
        stmt.finalize();
      }
      return rc;
    },

    
    selectArray: function(sql,bind){
      return __selectFirstRow(this, sql, bind, []);
    },

    
    selectObject: function(sql,bind){
      return __selectFirstRow(this, sql, bind, {});
    },

    
    selectArrays: function(sql,bind){
      return __selectAll(this, sql, bind, 'array');
    },

    
    selectObjects: function(sql,bind){
      return __selectAll(this, sql, bind, 'object');
    },

    
    openStatementCount: function(){
      return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
    },

    
    transaction: function(callback){
      let opener = 'BEGIN';
      if(arguments.length>1){
        if(/[^a-zA-Z]/.test(arguments[0])){
          toss3(capi.SQLITE_MISUSE, "Invalid argument for BEGIN qualifier.");
        }
        opener += ' '+arguments[0];
        callback = arguments[1];
      }
      affirmDbOpen(this).exec(opener);
      try {
        const rc = callback(this);
        this.exec("COMMIT");
        return rc;
      }catch(e){
        this.exec("ROLLBACK");
        throw e;
      }
    },

    
    savepoint: function(callback){
      affirmDbOpen(this).exec("SAVEPOINT oo1");
      try {
        const rc = callback(this);
        this.exec("RELEASE oo1");
        return rc;
      }catch(e){
        this.exec("ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1");
        throw e;
      }
    },

    
    checkRc: function(resultCode){
      return checkSqlite3Rc(this, resultCode);
    }
  };


  
  const affirmStmtOpen = function(stmt){
    if(!stmt.pointer) toss3("Stmt has been closed.");
    return stmt;
  };

  
  const isSupportedBindType = function(v){
    let t = BindTypes[(null===v||undefined===v) ? 'null' : typeof v];
    switch(t){
        case BindTypes.boolean:
        case BindTypes.null:
        case BindTypes.number:
        case BindTypes.string:
          return t;
        case BindTypes.bigint:
          if(wasm.bigIntEnabled) return t;
          
        default:
          return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;
    }
  };

  
  const affirmSupportedBindType = function(v){
    
    return isSupportedBindType(v) || toss3("Unsupported bind() argument type:",typeof v);
  };

  
  const affirmParamIndex = function(stmt,key){
    const n = ('number'===typeof key)
          ? key : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
    if(0===n || !util.isInt32(n)){
      toss3("Invalid bind() parameter name: "+key);
    }
    else if(n<1 || n>stmt.parameterCount) toss3("Bind index",key,"is out of range.");
    return n;
  };

  
  const affirmNotLockedByExec = function(stmt,currentOpName){
    if(stmt._lockedByExec){
      toss3("Operation is illegal when statement is locked:",currentOpName);
    }
    return stmt;
  };

  
  const bindOne = function f(stmt,ndx,bindType,val){
    affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');
    if(!f._){
      f._tooBigInt = (v)=>toss3(
        "BigInt value is too big to store without precision loss:", v
      );
      f._ = {
        string: function(stmt, ndx, val, asBlob){
          const [pStr, n] = wasm.allocCString(val, true);
          const f = asBlob ? capi.sqlite3_bind_blob : capi.sqlite3_bind_text;
          return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);
        }
      };
    }
    affirmSupportedBindType(val);
    ndx = affirmParamIndex(stmt,ndx);
    let rc = 0;
    switch((null===val || undefined===val) ? BindTypes.null : bindType){
        case BindTypes.null:
          rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
          break;
        case BindTypes.string:
          rc = f._.string(stmt, ndx, val, false);
          break;
        case BindTypes.number: {
          let m;
          if(util.isInt32(val)) m = capi.sqlite3_bind_int;
          else if('bigint'===typeof val){
            if(!util.bigIntFits64(val)){
              f._tooBigInt(val);
            }else if(wasm.bigIntEnabled){
              m = capi.sqlite3_bind_int64;
            }else if(util.bigIntFitsDouble(val)){
              val = Number(val);
              m = capi.sqlite3_bind_double;
            }else{
              f._tooBigInt(val);
            }
          }else{ 
            val = Number(val);
            if(wasm.bigIntEnabled && Number.isInteger(val)){
              m = capi.sqlite3_bind_int64;
            }else{
              m = capi.sqlite3_bind_double;
            }
          }
          rc = m(stmt.pointer, ndx, val);
          break;
        }
        case BindTypes.boolean:
          rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
          break;
        case BindTypes.blob: {
          if('string'===typeof val){
            rc = f._.string(stmt, ndx, val, true);
            break;
          }else if(val instanceof ArrayBuffer){
            val = new Uint8Array(val);
          }else if(!util.isBindableTypedArray(val)){
            toss3("Binding a value as a blob requires",
                  "that it be a string, Uint8Array, Int8Array, or ArrayBuffer.");
          }
          const pBlob = wasm.alloc(val.byteLength || 1);
          wasm.heap8().set(val.byteLength ? val : [0], pBlob)
          rc = capi.sqlite3_bind_blob(stmt.pointer, ndx, pBlob, val.byteLength,
                                      capi.SQLITE_WASM_DEALLOC);
          break;
        }
        default:
          sqlite3.config.warn("Unsupported bind() argument type:",val);
          toss3("Unsupported bind() argument type: "+(typeof val));
    }
    if(rc) DB.checkRc(stmt.db.pointer, rc);
    stmt._mayGet = false;
    return stmt;
  };

  Stmt.prototype = {
    
    finalize: function(){
      if(this.pointer){
        affirmNotLockedByExec(this,'finalize()');
        const rc = capi.sqlite3_finalize(this.pointer);
        delete __stmtMap.get(this.db)[this.pointer];
        __ptrMap.delete(this);
        delete this._mayGet;
        delete this.parameterCount;
        delete this._lockedByExec;
        delete this.db;
        return rc;
      }
    },
    
    clearBindings: function(){
      affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()')
      capi.sqlite3_clear_bindings(this.pointer);
      this._mayGet = false;
      return this;
    },
    
    reset: function(alsoClearBinds){
      affirmNotLockedByExec(this,'reset()');
      if(alsoClearBinds) this.clearBindings();
      const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
      this._mayGet = false;
      checkSqlite3Rc(this.db, rc);
      return this;
    },
    
    bind: function(){
      affirmStmtOpen(this);
      let ndx, arg;
      switch(arguments.length){
          case 1: ndx = 1; arg = arguments[0]; break;
          case 2: ndx = arguments[0]; arg = arguments[1]; break;
          default: toss3("Invalid bind() arguments.");
      }
      if(undefined===arg){
        
        return this;
      }else if(!this.parameterCount){
        toss3("This statement has no bindable parameters.");
      }
      this._mayGet = false;
      if(null===arg){
        
        return bindOne(this, ndx, BindTypes.null, arg);
      }
      else if(Array.isArray(arg)){
        
        if(1!==arguments.length){
          toss3("When binding an array, an index argument is not permitted.");
        }
        arg.forEach((v,i)=>bindOne(this, i+1, affirmSupportedBindType(v), v));
        return this;
      }else if(arg instanceof ArrayBuffer){
        arg = new Uint8Array(arg);
      }
      if('object'===typeof arg
              && !util.isBindableTypedArray(arg)){
        
        if(1!==arguments.length){
          toss3("When binding an object, an index argument is not permitted.");
        }
        Object.keys(arg)
          .forEach(k=>bindOne(this, k,
                              affirmSupportedBindType(arg[k]),
                              arg[k]));
        return this;
      }else{
        return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
      }
      toss3("Should not reach this point.");
    },
    
    bindAsBlob: function(ndx,arg){
      affirmStmtOpen(this);
      if(1===arguments.length){
        arg = ndx;
        ndx = 1;
      }
      const t = affirmSupportedBindType(arg);
      if(BindTypes.string !== t && BindTypes.blob !== t
         && BindTypes.null !== t){
        toss3("Invalid value type for bindAsBlob()");
      }
      return bindOne(this, ndx, BindTypes.blob, arg);
    },
    
    step: function(){
      affirmNotLockedByExec(this, 'step()');
      const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
      switch(rc){
          case capi.SQLITE_DONE: return this._mayGet = false;
          case capi.SQLITE_ROW: return this._mayGet = true;
          default:
            this._mayGet = false;
            sqlite3.config.warn("sqlite3_step() rc=",rc,
                         capi.sqlite3_js_rc_str(rc),
                         "SQL =", capi.sqlite3_sql(this.pointer));
            DB.checkRc(this.db.pointer, rc);
      }
    },
    
    stepReset: function(){
      this.step();
      return this.reset();
    },
    
    stepFinalize: function(){
      try{
        const rc = this.step();
        this.reset();
        return rc;
      }finally{
        try{this.finalize()}
        catch(e){}
      }
    },
    
    get: function(ndx,asType){
      if(!affirmStmtOpen(this)._mayGet){
        toss3("Stmt.step() has not (recently) returned true.");
      }
      if(Array.isArray(ndx)){
        let i = 0;
        const n = this.columnCount;
        while(i<n){
          ndx[i] = this.get(i++);
        }
        return ndx;
      }else if(ndx && 'object'===typeof ndx){
        let i = 0;
        const n = this.columnCount;
        while(i<n){
          ndx[capi.sqlite3_column_name(this.pointer,i)] = this.get(i++);
        }
        return ndx;
      }
      affirmColIndex(this, ndx);
      switch(undefined===asType
             ? capi.sqlite3_column_type(this.pointer, ndx)
             : asType){
          case capi.SQLITE_NULL: return null;
          case capi.SQLITE_INTEGER:{
            if(wasm.bigIntEnabled){
              const rc = capi.sqlite3_column_int64(this.pointer, ndx);
              if(rc>=Number.MIN_SAFE_INTEGER && rc<=Number.MAX_SAFE_INTEGER){
                
                return Number(rc).valueOf();
              }
              return rc;
            }else{
              const rc = capi.sqlite3_column_double(this.pointer, ndx);
              if(rc>Number.MAX_SAFE_INTEGER || rc<Number.MIN_SAFE_INTEGER){
                
                toss3("Integer is out of range for JS integer range: "+rc);
              }
              
              return util.isInt32(rc) ? (rc | 0) : rc;
            }
          }
          case capi.SQLITE_FLOAT:
            return capi.sqlite3_column_double(this.pointer, ndx);
          case capi.SQLITE_TEXT:
            return capi.sqlite3_column_text(this.pointer, ndx);
          case capi.SQLITE_BLOB: {
            const n = capi.sqlite3_column_bytes(this.pointer, ndx),
                  ptr = capi.sqlite3_column_blob(this.pointer, ndx),
                  rc = new Uint8Array(n);
            
            if(n) rc.set(wasm.heap8u().slice(ptr, ptr+n), 0);
            
            if(n && this.db._blobXfer instanceof Array){
              
              this.db._blobXfer.push(rc.buffer);
            }
            return rc;
          }
          default: toss3("Don't know how to translate",
                         "type of result column #"+ndx+".");
      }
      toss3("Not reached.");
    },
    
    getInt: function(ndx){return this.get(ndx,capi.SQLITE_INTEGER)},
    
    getFloat: function(ndx){return this.get(ndx,capi.SQLITE_FLOAT)},
    
    getString: function(ndx){return this.get(ndx,capi.SQLITE_TEXT)},
    
    getBlob: function(ndx){return this.get(ndx,capi.SQLITE_BLOB)},
    
    getJSON: function(ndx){
      const s = this.get(ndx, capi.SQLITE_STRING);
      return null===s ? s : JSON.parse(s);
    },
    
    
    
    
    
    getColumnName: function(ndx){
      return capi.sqlite3_column_name(
        affirmColIndex(affirmStmtOpen(this),ndx).pointer, ndx
      );
    },
    
    getColumnNames: function(tgt=[]){
      affirmColIndex(affirmStmtOpen(this),0);
      const n = this.columnCount;
      for(let i = 0; i < n; ++i){
        tgt.push(capi.sqlite3_column_name(this.pointer, i));
      }
      return tgt;
    },
    
    getParamIndex: function(name){
      return (affirmStmtOpen(this).parameterCount
              ? capi.sqlite3_bind_parameter_index(this.pointer, name)
              : undefined);
    }
  };

  {
    const prop = {
      enumerable: true,
      get: function(){return __ptrMap.get(this)},
      set: ()=>toss3("The pointer property is read-only.")
    }
    Object.defineProperty(Stmt.prototype, 'pointer', prop);
    Object.defineProperty(DB.prototype, 'pointer', prop);
  }
  
  Object.defineProperty(Stmt.prototype, 'columnCount', {
    enumerable: false,
    get: function(){return capi.sqlite3_column_count(this.pointer)},
    set: ()=>toss3("The columnCount property is read-only.")
  });

  
  sqlite3.oo1 = {
    DB,
    Stmt
  };

  if(util.isUIThread()){
    
    sqlite3.oo1.JsStorageDb = function(storageName='session'){
      if('session'!==storageName && 'local'!==storageName){
        toss3("JsStorageDb db name must be one of 'session' or 'local'.");
      }
      dbCtorHelper.call(this, {
        filename: storageName,
        flags: 'c',
        vfs: "kvvfs"
      });
    };
    const jdb = sqlite3.oo1.JsStorageDb;
    jdb.prototype = Object.create(DB.prototype);
    
    jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;
    
    jdb.prototype.clearStorage = function(){
      return jdb.clearStorage(affirmDbOpen(this).filename);
    };
    
    jdb.storageSize = capi.sqlite3_js_kvvfs_size;
    
    jdb.prototype.storageSize = function(){
      return jdb.storageSize(affirmDbOpen(this).filename);
    };
  }

});





globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
sqlite3.initWorker1API = function(){
  'use strict';
  const toss = (...args)=>{throw new Error(args.join(' '))};
  if(!(globalThis.WorkerGlobalScope instanceof Function)){
    toss("initWorker1API() must be run from a Worker thread.");
  }
  const sqlite3 = this.sqlite3 || toss("Missing this.sqlite3 object.");
  const DB = sqlite3.oo1.DB;

  
  const getDbId = function(db){
    let id = wState.idMap.get(db);
    if(id) return id;
    id = 'db#'+(++wState.idSeq)+'@'+db.pointer;
    
    wState.idMap.set(db, id);
    return id;
  };

  
  const wState = {
    
    dbList: [],
    
    idSeq: 0,
    
    idMap: new WeakMap,
    
    xfer: [],
    open: function(opt){
      const db = new DB(opt);
      this.dbs[getDbId(db)] = db;
      if(this.dbList.indexOf(db)<0) this.dbList.push(db);
      return db;
    },
    close: function(db,alsoUnlink){
      if(db){
        delete this.dbs[getDbId(db)];
        const filename = db.filename;
        const pVfs = sqlite3.wasm.sqlite3_wasm_db_vfs(db.pointer, 0);
        db.close();
        const ddNdx = this.dbList.indexOf(db);
        if(ddNdx>=0) this.dbList.splice(ddNdx, 1);
        if(alsoUnlink && filename && pVfs){
          sqlite3.wasm.sqlite3_wasm_vfs_unlink(pVfs, filename);
        }
      }
    },
    
    post: function(msg,xferList){
      if(xferList && xferList.length){
        globalThis.postMessage( msg, Array.from(xferList) );
        xferList.length = 0;
      }else{
        globalThis.postMessage(msg);
      }
    },
    
    dbs: Object.create(null),
    
    getDb: function(id,require=true){
      return this.dbs[id]
        || (require ? toss("Unknown (or closed) DB ID:",id) : undefined);
    }
  };

  
  const affirmDbOpen = function(db = wState.dbList[0]){
    return (db && db.pointer) ? db : toss("DB is not opened.");
  };

  
  const getMsgDb = function(msgData,affirmExists=true){
    const db = wState.getDb(msgData.dbId,false) || wState.dbList[0];
    return affirmExists ? affirmDbOpen(db) : db;
  };

  const getDefaultDbId = function(){
    return wState.dbList[0] && getDbId(wState.dbList[0]);
  };

  const guessVfs = function(filename){
    const m = /^file:.+(vfs=(\w+))/.exec(filename);
    return sqlite3.capi.sqlite3_vfs_find(m ? m[2] : 0);
  };

  const isSpecialDbFilename = (n)=>{
    return ""===n || ':'===n[0];
  };

  
  const wMsgHandler = {
    open: function(ev){
      const oargs = Object.create(null), args = (ev.args || Object.create(null));
      if(args.simulateError){ 
        toss("Throwing because of simulateError flag.");
      }
      const rc = Object.create(null);
      let byteArray, pVfs;
      oargs.vfs = args.vfs;
      if(isSpecialDbFilename(args.filename)){
        oargs.filename = args.filename || "";
      }else{
        oargs.filename = args.filename;
        byteArray = args.byteArray;
        if(byteArray) pVfs = guessVfs(args.filename);
      }
      if(pVfs){
        
        let pMem;
        try{
          pMem = sqlite3.wasm.allocFromTypedArray(byteArray);
          const rc = sqlite3.wasm.sqlite3_wasm_vfs_create_file(
            pVfs, oargs.filename, pMem, byteArray.byteLength
          );
          if(rc) sqlite3.SQLite3Error.toss(rc);
        }catch(e){
          throw new sqlite3.SQLite3Error(
            e.name+' creating '+args.filename+": "+e.message, {
              cause: e
            }
          );
        }finally{
          if(pMem) sqlite3.wasm.dealloc(pMem);
        }
      }
      const db = wState.open(oargs);
      rc.filename = db.filename;
      rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(db.pointer, "opfs");
      rc.dbId = getDbId(db);
      rc.vfs = db.dbVfsName();
      return rc;
    },

    close: function(ev){
      const db = getMsgDb(ev,false);
      const response = {
        filename: db && db.filename
      };
      if(db){
        const doUnlink = ((ev.args && 'object'===typeof ev.args)
                         ? !!ev.args.unlink : false);
        wState.close(db, doUnlink);
      }
      return response;
    },

    exec: function(ev){
      const rc = (
        'string'===typeof ev.args
      ) ? {sql: ev.args} : (ev.args || Object.create(null));
      if('stmt'===rc.rowMode){
        toss("Invalid rowMode for 'exec': stmt mode",
             "does not work in the Worker API.");
      }else if(!rc.sql){
        toss("'exec' requires input SQL.");
      }
      const db = getMsgDb(ev);
      if(rc.callback || Array.isArray(rc.resultRows)){
        
        db._blobXfer = wState.xfer;
      }
      const theCallback = rc.callback;
      let rowNumber = 0;
      const hadColNames = !!rc.columnNames;
      if('string' === typeof theCallback){
        if(!hadColNames) rc.columnNames = [];
        
        rc.callback = function(row,stmt){
          wState.post({
            type: theCallback,
            columnNames: rc.columnNames,
            rowNumber: ++rowNumber,
            row: row
          }, wState.xfer);
        }
      }
      try {
        const changeCount = !!rc.countChanges
              ? db.changes(true,(64===rc.countChanges))
              : undefined;
        db.exec(rc);
        if(undefined !== changeCount){
          rc.changeCount = db.changes(true,64===rc.countChanges) - changeCount;
        }
        if(rc.callback instanceof Function){
          rc.callback = theCallback;
          
          wState.post({
            type: theCallback,
            columnNames: rc.columnNames,
            rowNumber: null ,
            row: undefined 
          });
        }
      }finally{
        delete db._blobXfer;
        if(rc.callback) rc.callback = theCallback;
      }
      return rc;
    },

    'config-get': function(){
      const rc = Object.create(null), src = sqlite3.config;
      [
        'bigIntEnabled'
      ].forEach(function(k){
        if(Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
      });
      rc.version = sqlite3.version;
      rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();
      rc.opfsEnabled = !!sqlite3.opfs;
      return rc;
    },

    
    export: function(ev){
      const db = getMsgDb(ev);
      const response = {
        byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),
        filename: db.filename,
        mimetype: 'application/x-sqlite3'
      };
      wState.xfer.push(response.byteArray.buffer);
      return response;
    },

    toss: function(ev){
      toss("Testing worker exception");
    },

    'opfs-tree': async function(ev){
      if(!sqlite3.opfs) toss("OPFS support is unavailable.");
      const response = await sqlite3.opfs.treeList();
      return response;
    }
  };

  globalThis.onmessage = async function(ev){
    ev = ev.data;
    let result, dbId = ev.dbId, evType = ev.type;
    const arrivalTime = performance.now();
    try {
      if(wMsgHandler.hasOwnProperty(evType) &&
         wMsgHandler[evType] instanceof Function){
        result = await wMsgHandler[evType](ev);
      }else{
        toss("Unknown db worker message type:",ev.type);
      }
    }catch(err){
      evType = 'error';
      result = {
        operation: ev.type,
        message: err.message,
        errorClass: err.name,
        input: ev
      };
      if(err.stack){
        result.stack = ('string'===typeof err.stack)
          ? err.stack.split(/\n\s*/) : err.stack;
      }
      if(false) {}
    }
    if(!dbId){
      dbId = result.dbId
        || getDefaultDbId();
    }
    
    
    wState.post({
      type: evType,
      dbId: dbId,
      messageId: ev.messageId,
      workerReceivedTime: arrivalTime,
      workerRespondTime: performance.now(),
      departureTime: ev.departureTime,
      
      
      
      
      
      
      result: result
    }, wState.xfer);
  };
  globalThis.postMessage({type:'sqlite3-api',result:'worker1-ready'});
}.bind({sqlite3});
});





'use strict';
globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  const wasm = sqlite3.wasm, capi = sqlite3.capi, toss = sqlite3.util.toss3;
  const vfs = Object.create(null), vtab = Object.create(null);

  const StructBinder = sqlite3.StructBinder
  ;
  sqlite3.vfs = vfs;
  sqlite3.vtab = vtab;

  const sii = capi.sqlite3_index_info;
  
  sii.prototype.nthConstraint = function(n, asPtr=false){
    if(n<0 || n>=this.$nConstraint) return false;
    const ptr = this.$aConstraint + (
      sii.sqlite3_index_constraint.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
  };

  
  sii.prototype.nthConstraintUsage = function(n, asPtr=false){
    if(n<0 || n>=this.$nConstraint) return false;
    const ptr = this.$aConstraintUsage + (
      sii.sqlite3_index_constraint_usage.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
  };

  
  sii.prototype.nthOrderBy = function(n, asPtr=false){
    if(n<0 || n>=this.$nOrderBy) return false;
    const ptr = this.$aOrderBy + (
      sii.sqlite3_index_orderby.structInfo.sizeof * n
    );
    return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
  };

  
  const installMethod = function callee(
    tgt, name, func, applyArgcCheck = callee.installMethodArgcCheck
  ){
    if(!(tgt instanceof StructBinder.StructType)){
      toss("Usage error: target object is-not-a StructType.");
    }else if(!(func instanceof Function) && !wasm.isPtr(func)){
      toss("Usage errror: expecting a Function or WASM pointer to one.");
    }
    if(1===arguments.length){
      return (n,f)=>callee(tgt, n, f, applyArgcCheck);
    }
    if(!callee.argcProxy){
      callee.argcProxy = function(tgt, funcName, func,sig){
        return function(...args){
          if(func.length!==arguments.length){
            toss("Argument mismatch for",
                 tgt.structInfo.name+"::"+funcName
                 +": Native signature is:",sig);
          }
          return func.apply(this, args);
        }
      };
      
      callee.removeFuncList = function(){
        if(this.ondispose.__removeFuncList){
          this.ondispose.__removeFuncList.forEach(
            (v,ndx)=>{
              if('number'===typeof v){
                try{wasm.uninstallFunction(v)}
                catch(e){}
              }
              
            }
          );
          delete this.ondispose.__removeFuncList;
        }
      };
    }
    const sigN = tgt.memberSignature(name);
    if(sigN.length<2){
      toss("Member",name,"does not have a function pointer signature:",sigN);
    }
    const memKey = tgt.memberKey(name);
    const fProxy = (applyArgcCheck && !wasm.isPtr(func))
    
          ? callee.argcProxy(tgt, memKey, func, sigN)
          : func;
    if(wasm.isPtr(fProxy)){
      if(fProxy && !wasm.functionEntry(fProxy)){
        toss("Pointer",fProxy,"is not a WASM function table entry.");
      }
      tgt[memKey] = fProxy;
    }else{
      const pFunc = wasm.installFunction(fProxy, tgt.memberSignature(name, true));
      tgt[memKey] = pFunc;
      if(!tgt.ondispose || !tgt.ondispose.__removeFuncList){
        tgt.addOnDispose('ondispose.__removeFuncList handler',
                         callee.removeFuncList);
        tgt.ondispose.__removeFuncList = [];
      }
      tgt.ondispose.__removeFuncList.push(memKey, pFunc);
    }
    return (n,f)=>callee(tgt, n, f, applyArgcCheck);
  };
  installMethod.installMethodArgcCheck = false;

  
  const installMethods = function(
    structInstance, methods, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    const seen = new Map ;
    for(const k of Object.keys(methods)){
      const m = methods[k];
      const prior = seen.get(m);
      if(prior){
        const mkey = structInstance.memberKey(k);
        structInstance[mkey] = structInstance[structInstance.memberKey(prior)];
      }else{
        installMethod(structInstance, k, m, applyArgcCheck);
        seen.set(m, k);
      }
    }
    return structInstance;
  };

  
  StructBinder.StructType.prototype.installMethod = function callee(
    name, func, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    return (arguments.length < 3 && name && 'object'===typeof name)
      ? installMethods(this, ...arguments)
      : installMethod(this, ...arguments);
  };

  
  StructBinder.StructType.prototype.installMethods = function(
    methods, applyArgcCheck = installMethod.installMethodArgcCheck
  ){
    return installMethods(this, methods, applyArgcCheck);
  };

  
  capi.sqlite3_vfs.prototype.registerVfs = function(asDefault=false){
    if(!(this instanceof sqlite3.capi.sqlite3_vfs)){
      toss("Expecting a sqlite3_vfs-type argument.");
    }
    const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
    if(rc){
      toss("sqlite3_vfs_register(",this,") failed with rc",rc);
    }
    if(this.pointer !== capi.sqlite3_vfs_find(this.$zName)){
      toss("BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS",
           this);
    }
    return this;
  };

  
  vfs.installVfs = function(opt){
    let count = 0;
    const propList = ['io','vfs'];
    for(const key of propList){
      const o = opt[key];
      if(o){
        ++count;
        installMethods(o.struct, o.methods, !!o.applyArgcCheck);
        if('vfs'===key){
          if(!o.struct.$zName && 'string'===typeof o.name){
            o.struct.addOnDispose(
              o.struct.$zName = wasm.allocCString(o.name)
            );
          }
          o.struct.registerVfs(!!o.asDefault);
        }
      }
    }
    if(!count) toss("Misuse: installVfs() options object requires at least",
                    "one of:", propList);
    return this;
  };

  
  const __xWrapFactory = function(methodName,StructType){
    return function(ptr,removeMapping=false){
      if(0===arguments.length) ptr = new StructType;
      if(ptr instanceof StructType){
        
        this.set(ptr.pointer, ptr);
        return ptr;
      }else if(!wasm.isPtr(ptr)){
        sqlite3.SQLite3Error.toss("Invalid argument to",methodName+"()");
      }
      let rc = this.get(ptr);
      if(removeMapping) this.delete(ptr);
      return rc;
    }.bind(new Map);
  };

  
  const StructPtrMapper = function(name, StructType){
    const __xWrap = __xWrapFactory(name,StructType);
    
    return Object.assign(Object.create(null),{
      
      StructType,
      
      create: (ppOut)=>{
        const rc = __xWrap();
        wasm.pokePtr(ppOut, rc.pointer);
        return rc;
      },
      
      get: (pCObj)=>__xWrap(pCObj),
      
      unget: (pCObj)=>__xWrap(pCObj,true),
      
      dispose: (pCObj)=>{
        const o = __xWrap(pCObj,true);
        if(o) o.dispose();
      }
    });
  };

  
  vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);

  
  vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);

  
  vtab.xIndexInfo = (pIdxInfo)=>new capi.sqlite3_index_info(pIdxInfo);

  
  

  
  vtab.xError = function f(methodName, err, defaultRc){
    if(f.errorReporter instanceof Function){
      try{f.errorReporter("sqlite3_module::"+methodName+"(): "+err.message);}
      catch(e){}
    }
    let rc;
    if(err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;
    else if(arguments.length>2) rc = defaultRc;
    else if(err instanceof sqlite3.SQLite3Error) rc = err.resultCode;
    return rc || capi.SQLITE_ERROR;
  };
  vtab.xError.errorReporter =  true ? console.error.bind(console) : 0;

  
  

  
  vtab.xRowid = (ppRowid64, value)=>wasm.poke(ppRowid64, value, 'i64');

  
  vtab.setupModule = function(opt){
    let createdMod = false;
    const mod = (this instanceof capi.sqlite3_module)
          ? this : (opt.struct || (createdMod = new capi.sqlite3_module()));
    try{
      const methods = opt.methods || toss("Missing 'methods' object.");
      for(const e of Object.entries({
        
        
        xConnect: 'xCreate', xDisconnect: 'xDestroy'
      })){
        
        const k = e[0], v = e[1];
        if(true === methods[k]) methods[k] = methods[v];
        else if(true === methods[v]) methods[v] = methods[k];
      }
      if(opt.catchExceptions){
        const fwrap = function(methodName, func){
          if(['xConnect','xCreate'].indexOf(methodName) >= 0){
            return function(pDb, pAux, argc, argv, ppVtab, pzErr){
              try{return func(...arguments) || 0}
              catch(e){
                if(!(e instanceof sqlite3.WasmAllocError)){
                  wasm.dealloc(wasm.peekPtr(pzErr));
                  wasm.pokePtr(pzErr, wasm.allocCString(e.message));
                }
                return vtab.xError(methodName, e);
              }
            };
          }else{
            return function(...args){
              try{return func(...args) || 0}
              catch(e){
                return vtab.xError(methodName, e);
              }
            };
          }
        };
        const mnames = [
          'xCreate', 'xConnect', 'xBestIndex', 'xDisconnect',
          'xDestroy', 'xOpen', 'xClose', 'xFilter', 'xNext',
          'xEof', 'xColumn', 'xRowid', 'xUpdate',
          'xBegin', 'xSync', 'xCommit', 'xRollback',
          'xFindFunction', 'xRename', 'xSavepoint', 'xRelease',
          'xRollbackTo', 'xShadowName'
        ];
        const remethods = Object.create(null);
        for(const k of mnames){
          const m = methods[k];
          if(!(m instanceof Function)) continue;
          else if('xConnect'===k && methods.xCreate===m){
            remethods[k] = methods.xCreate;
          }else if('xCreate'===k && methods.xConnect===m){
            remethods[k] = methods.xConnect;
          }else{
            remethods[k] = fwrap(k, m);
          }
        }
        installMethods(mod, remethods, false);
      }else{
        
        
        installMethods(
          mod, methods, !!opt.applyArgcCheck
        );
      }
      if(0===mod.$iVersion){
        let v;
        if('number'===typeof opt.iVersion) v = opt.iVersion;
        else if(mod.$xShadowName) v = 3;
        else if(mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo) v = 2;
        else v = 1;
        mod.$iVersion = v;
      }
    }catch(e){
      if(createdMod) createdMod.dispose();
      throw e;
    }
    return mod;
  };

  
  capi.sqlite3_module.prototype.setupModule = function(opt){
    return vtab.setupModule.call(this, opt);
  };
});



'use strict';
globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){

const installOpfsVfs = function callee(options){
  if(!globalThis.SharedArrayBuffer
    || !globalThis.Atomics){
    return Promise.reject(
      new Error("Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. "+
                "The server must emit the COOP/COEP response headers to enable those. "+
                "See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep")
    );
  }else if('undefined'===typeof WorkerGlobalScope){
    return Promise.reject(
      new Error("The OPFS sqlite3_vfs cannot run in the main thread "+
                "because it requires Atomics.wait().")
    );
  }else if(!globalThis.FileSystemHandle ||
           !globalThis.FileSystemDirectoryHandle ||
           !globalThis.FileSystemFileHandle ||
           !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
           !navigator?.storage?.getDirectory){
    return Promise.reject(
      new Error("Missing required OPFS APIs.")
    );
  }
  if(!options || 'object'!==typeof options){
    options = Object.create(null);
  }
  const urlParams = new URL(globalThis.location.href).searchParams;
  if(urlParams.has('opfs-disable')){
    
    return Promise.resolve(sqlite3);
  }
  if(undefined===options.verbose){
    options.verbose = urlParams.has('opfs-verbose')
      ? (+urlParams.get('opfs-verbose') || 2) : 1;
  }
  if(undefined===options.sanityChecks){
    options.sanityChecks = urlParams.has('opfs-sanity-check');
  }
  if(undefined===options.proxyUri){
    options.proxyUri = callee.defaultProxyUri;
  }

  

  if('function' === typeof options.proxyUri){
    options.proxyUri = options.proxyUri();
  }
  const thePromise = new Promise(function(promiseResolve_, promiseReject_){
    const loggers = [
      sqlite3.config.error,
      sqlite3.config.warn,
      sqlite3.config.log
    ];
    const logImpl = (level,...args)=>{
      if(options.verbose>level) loggers[level]("OPFS syncer:",...args);
    };
    const log =    (...args)=>logImpl(2, ...args);
    const warn =   (...args)=>logImpl(1, ...args);
    const error =  (...args)=>logImpl(0, ...args);
    const toss = sqlite3.util.toss;
    const capi = sqlite3.capi;
    const util = sqlite3.util;
    const wasm = sqlite3.wasm;
    const sqlite3_vfs = capi.sqlite3_vfs;
    const sqlite3_file = capi.sqlite3_file;
    const sqlite3_io_methods = capi.sqlite3_io_methods;
    
    const opfsUtil = Object.create(null);

    
    const thisThreadHasOPFS = ()=>{
      return globalThis.FileSystemHandle &&
        globalThis.FileSystemDirectoryHandle &&
        globalThis.FileSystemFileHandle &&
        globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle &&
        navigator?.storage?.getDirectory;
    };

    
    opfsUtil.metrics = {
      dump: function(){
        let k, n = 0, t = 0, w = 0;
        for(k in state.opIds){
          const m = metrics[k];
          n += m.count;
          t += m.time;
          w += m.wait;
          m.avgTime = (m.count && m.time) ? (m.time / m.count) : 0;
          m.avgWait = (m.count && m.wait) ? (m.wait / m.count) : 0;
        }
        sqlite3.config.log(globalThis.location.href,
                    "metrics for",globalThis.location.href,":",metrics,
                    "\nTotal of",n,"op(s) for",t,
                    "ms (incl. "+w+" ms of waiting on the async side)");
        sqlite3.config.log("Serialization metrics:",metrics.s11n);
        W.postMessage({type:'opfs-async-metrics'});
      },
      reset: function(){
        let k;
        const r = (m)=>(m.count = m.time = m.wait = 0);
        for(k in state.opIds){
          r(metrics[k] = Object.create(null));
        }
        let s = metrics.s11n = Object.create(null);
        s = s.serialize = Object.create(null);
        s.count = s.time = 0;
        s = metrics.s11n.deserialize = Object.create(null);
        s.count = s.time = 0;
      }
    };
    const opfsIoMethods = new sqlite3_io_methods();
    const opfsVfs = new sqlite3_vfs()
          .addOnDispose( ()=>opfsIoMethods.dispose());
    let promiseWasRejected = undefined;
    const promiseReject = (err)=>{
      promiseWasRejected = true;
      opfsVfs.dispose();
      return promiseReject_(err);
    };
    const promiseResolve = ()=>{
      promiseWasRejected = false;
      return promiseResolve_(sqlite3);
    };
    const W =
    new Worker(options.proxyUri);
    setTimeout(()=>{
      
      if(undefined===promiseWasRejected){
        promiseReject(
          new Error("Timeout while waiting for OPFS async proxy worker.")
        );
      }
    }, 4000);
    W._originalOnError = W.onerror ;
    W.onerror = function(err){
      
      
      error("Error initializing OPFS asyncer:",err);
      promiseReject(new Error("Loading OPFS async Worker failed for unknown reasons."));
    };
    const pDVfs = capi.sqlite3_vfs_find(null);
    const dVfs = pDVfs
          ? new sqlite3_vfs(pDVfs)
          : null ;
    opfsIoMethods.$iVersion = 1;
    opfsVfs.$iVersion = 2;
    opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
    opfsVfs.$mxPathname = 1024;
    opfsVfs.$zName = wasm.allocCString("opfs");
    
    opfsVfs.$xDlOpen = opfsVfs.$xDlError = opfsVfs.$xDlSym = opfsVfs.$xDlClose = null;
    opfsVfs.addOnDispose(
      '$zName', opfsVfs.$zName,
      'cleanup default VFS wrapper', ()=>(dVfs ? dVfs.dispose() : null)
    );
    
    
    const state = Object.create(null);
    state.verbose = options.verbose;
    state.littleEndian = (()=>{
      const buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true );
      
      return new Int16Array(buffer)[0] === 256;
    })();
    
    state.asyncIdleWaitTime = 150;

    
    state.asyncS11nExceptions = 1;
    
    state.fileBufferSize = 1024 * 64;
    state.sabS11nOffset = state.fileBufferSize;
    
    state.sabS11nSize = opfsVfs.$mxPathname * 2;
    
    state.sabIO = new SharedArrayBuffer(
      state.fileBufferSize
      + state.sabS11nSize
    );
    state.opIds = Object.create(null);
    const metrics = Object.create(null);
    {
      
      let i = 0;
      
      state.opIds.whichOp = i++;
      
      state.opIds.rc = i++;
      
      state.opIds.xAccess = i++;
      state.opIds.xClose = i++;
      state.opIds.xDelete = i++;
      state.opIds.xDeleteNoWait = i++;
      state.opIds.xFileSize = i++;
      state.opIds.xLock = i++;
      state.opIds.xOpen = i++;
      state.opIds.xRead = i++;
      state.opIds.xSleep = i++;
      state.opIds.xSync = i++;
      state.opIds.xTruncate = i++;
      state.opIds.xUnlock = i++;
      state.opIds.xWrite = i++;
      state.opIds.mkdir = i++;
      state.opIds['opfs-async-metrics'] = i++;
      state.opIds['opfs-async-shutdown'] = i++;
      
      state.opIds.retry = i++;
      state.sabOP = new SharedArrayBuffer(
        i * 4);
      opfsUtil.metrics.reset();
    }
    
    state.sq3Codes = Object.create(null);
    [
      'SQLITE_ACCESS_EXISTS',
      'SQLITE_ACCESS_READWRITE',
      'SQLITE_BUSY',
      'SQLITE_ERROR',
      'SQLITE_IOERR',
      'SQLITE_IOERR_ACCESS',
      'SQLITE_IOERR_CLOSE',
      'SQLITE_IOERR_DELETE',
      'SQLITE_IOERR_FSYNC',
      'SQLITE_IOERR_LOCK',
      'SQLITE_IOERR_READ',
      'SQLITE_IOERR_SHORT_READ',
      'SQLITE_IOERR_TRUNCATE',
      'SQLITE_IOERR_UNLOCK',
      'SQLITE_IOERR_WRITE',
      'SQLITE_LOCK_EXCLUSIVE',
      'SQLITE_LOCK_NONE',
      'SQLITE_LOCK_PENDING',
      'SQLITE_LOCK_RESERVED',
      'SQLITE_LOCK_SHARED',
      'SQLITE_LOCKED',
      'SQLITE_MISUSE',
      'SQLITE_NOTFOUND',
      'SQLITE_OPEN_CREATE',
      'SQLITE_OPEN_DELETEONCLOSE',
      'SQLITE_OPEN_MAIN_DB',
      'SQLITE_OPEN_READONLY'
    ].forEach((k)=>{
      if(undefined === (state.sq3Codes[k] = capi[k])){
        toss("Maintenance required: not found:",k);
      }
    });
    state.opfsFlags = Object.assign(Object.create(null),{
      
      OPFS_UNLOCK_ASAP: 0x01,
      
      defaultUnlockAsap: false
    });

    
    const opRun = (op,...args)=>{
      const opNdx = state.opIds[op] || toss("Invalid op ID:",op);
      state.s11n.serialize(...args);
      Atomics.store(state.sabOPView, state.opIds.rc, -1);
      Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
      Atomics.notify(state.sabOPView, state.opIds.whichOp)
      ;
      const t = performance.now();
      Atomics.wait(state.sabOPView, state.opIds.rc, -1)
      ;
      const rc = Atomics.load(state.sabOPView, state.opIds.rc);
      metrics[op].wait += performance.now() - t;
      if(rc && state.asyncS11nExceptions){
        const err = state.s11n.deserialize();
        if(err) error(op+"() async error:",...err);
      }
      return rc;
    };

    
    opfsUtil.debug = {
      asyncShutdown: ()=>{
        warn("Shutting down OPFS async listener. The OPFS VFS will no longer work.");
        opRun('opfs-async-shutdown');
      },
      asyncRestart: ()=>{
        warn("Attempting to restart OPFS VFS async listener. Might work, might not.");
        W.postMessage({type: 'opfs-async-restart'});
      }
    };

    const initS11n = ()=>{
      
      if(state.s11n) return state.s11n;
      const textDecoder = new TextDecoder(),
            textEncoder = new TextEncoder('utf-8'),
            viewU8 = new Uint8Array(state.sabIO, state.sabS11nOffset, state.sabS11nSize),
            viewDV = new DataView(state.sabIO, state.sabS11nOffset, state.sabS11nSize);
      state.s11n = Object.create(null);
      
      const TypeIds = Object.create(null);
      TypeIds.number  = { id: 1, size: 8, getter: 'getFloat64', setter: 'setFloat64' };
      TypeIds.bigint  = { id: 2, size: 8, getter: 'getBigInt64', setter: 'setBigInt64' };
      TypeIds.boolean = { id: 3, size: 4, getter: 'getInt32', setter: 'setInt32' };
      TypeIds.string =  { id: 4 };

      const getTypeId = (v)=>(
        TypeIds[typeof v]
          || toss("Maintenance required: this value type cannot be serialized.",v)
      );
      const getTypeIdById = (tid)=>{
        switch(tid){
            case TypeIds.number.id: return TypeIds.number;
            case TypeIds.bigint.id: return TypeIds.bigint;
            case TypeIds.boolean.id: return TypeIds.boolean;
            case TypeIds.string.id: return TypeIds.string;
            default: toss("Invalid type ID:",tid);
        }
      };

      
      state.s11n.deserialize = function(clear=false){
        ++metrics.s11n.deserialize.count;
        const t = performance.now();
        const argc = viewU8[0];
        const rc = argc ? [] : null;
        if(argc){
          const typeIds = [];
          let offset = 1, i, n, v;
          for(i = 0; i < argc; ++i, ++offset){
            typeIds.push(getTypeIdById(viewU8[offset]));
          }
          for(i = 0; i < argc; ++i){
            const t = typeIds[i];
            if(t.getter){
              v = viewDV[t.getter](offset, state.littleEndian);
              offset += t.size;
            }else{
              n = viewDV.getInt32(offset, state.littleEndian);
              offset += 4;
              v = textDecoder.decode(viewU8.slice(offset, offset+n));
              offset += n;
            }
            rc.push(v);
          }
        }
        if(clear) viewU8[0] = 0;
        
        metrics.s11n.deserialize.time += performance.now() - t;
        return rc;
      };

      
      state.s11n.serialize = function(...args){
        const t = performance.now();
        ++metrics.s11n.serialize.count;
        if(args.length){
          
          const typeIds = [];
          let i = 0, offset = 1;
          viewU8[0] = args.length & 0xff ;
          for(; i < args.length; ++i, ++offset){
            
            typeIds.push(getTypeId(args[i]));
            viewU8[offset] = typeIds[i].id;
          }
          for(i = 0; i < args.length; ++i) {
            
            const t = typeIds[i];
            if(t.setter){
              viewDV[t.setter](offset, args[i], state.littleEndian);
              offset += t.size;
            }else{
              const s = textEncoder.encode(args[i]);
              viewDV.setInt32(offset, s.byteLength, state.littleEndian);
              offset += 4;
              viewU8.set(s, offset);
              offset += s.byteLength;
            }
          }
          
        }else{
          viewU8[0] = 0;
        }
        metrics.s11n.serialize.time += performance.now() - t;
      };
      return state.s11n;
    };

    
    const randomFilename = function f(len=16){
      if(!f._chars){
        f._chars = "abcdefghijklmnopqrstuvwxyz"+
          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"+
          "012346789";
        f._n = f._chars.length;
      }
      const a = [];
      let i = 0;
      for( ; i < len; ++i){
        const ndx = Math.random() * (f._n * 64) % f._n | 0;
        a[i] = f._chars[ndx];
      }
      return a.join("");
      
    };

    
    const __openFiles = Object.create(null);

    const opTimer = Object.create(null);
    opTimer.op = undefined;
    opTimer.start = undefined;
    const mTimeStart = (op)=>{
      opTimer.start = performance.now();
      opTimer.op = op;
      ++metrics[op].count;
    };
    const mTimeEnd = ()=>(
      metrics[opTimer.op].time += performance.now() - opTimer.start
    );

    
    const ioSyncWrappers = {
      xCheckReservedLock: function(pFile,pOut){
        
        const f = __openFiles[pFile];
        wasm.poke(pOut, f.lockType ? 1 : 0, 'i32');
        return 0;
      },
      xClose: function(pFile){
        mTimeStart('xClose');
        let rc = 0;
        const f = __openFiles[pFile];
        if(f){
          delete __openFiles[pFile];
          rc = opRun('xClose', pFile);
          if(f.sq3File) f.sq3File.dispose();
        }
        mTimeEnd();
        return rc;
      },
      xDeviceCharacteristics: function(pFile){
        
        return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
      },
      xFileControl: function(pFile, opId, pArg){
        
        return capi.SQLITE_NOTFOUND;
      },
      xFileSize: function(pFile,pSz64){
        mTimeStart('xFileSize');
        let rc = opRun('xFileSize', pFile);
        if(0==rc){
          try {
            const sz = state.s11n.deserialize()[0];
            wasm.poke(pSz64, sz, 'i64');
          }catch(e){
            error("Unexpected error reading xFileSize() result:",e);
            rc = state.sq3Codes.SQLITE_IOERR;
          }
        }
        mTimeEnd();
        return rc;
      },
      xLock: function(pFile,lockType){
        mTimeStart('xLock');
        const f = __openFiles[pFile];
        let rc = 0;
        
        if( !f.lockType ) {
          rc = opRun('xLock', pFile, lockType);
          if( 0===rc ) f.lockType = lockType;
        }else{
          f.lockType = lockType;
        }
        mTimeEnd();
        return rc;
      },
      xRead: function(pFile,pDest,n,offset64){
        mTimeStart('xRead');
        const f = __openFiles[pFile];
        let rc;
        try {
          rc = opRun('xRead',pFile, n, Number(offset64));
          if(0===rc || capi.SQLITE_IOERR_SHORT_READ===rc){
            
            wasm.heap8u().set(f.sabView.subarray(0, n), pDest);
          }
        }catch(e){
          error("xRead(",arguments,") failed:",e,f);
          rc = capi.SQLITE_IOERR_READ;
        }
        mTimeEnd();
        return rc;
      },
      xSync: function(pFile,flags){
        mTimeStart('xSync');
        ++metrics.xSync.count;
        const rc = opRun('xSync', pFile, flags);
        mTimeEnd();
        return rc;
      },
      xTruncate: function(pFile,sz64){
        mTimeStart('xTruncate');
        const rc = opRun('xTruncate', pFile, Number(sz64));
        mTimeEnd();
        return rc;
      },
      xUnlock: function(pFile,lockType){
        mTimeStart('xUnlock');
        const f = __openFiles[pFile];
        let rc = 0;
        if( capi.SQLITE_LOCK_NONE === lockType
          && f.lockType ){
          rc = opRun('xUnlock', pFile, lockType);
        }
        if( 0===rc ) f.lockType = lockType;
        mTimeEnd();
        return rc;
      },
      xWrite: function(pFile,pSrc,n,offset64){
        mTimeStart('xWrite');
        const f = __openFiles[pFile];
        let rc;
        try {
          f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc+n));
          rc = opRun('xWrite', pFile, n, Number(offset64));
        }catch(e){
          error("xWrite(",arguments,") failed:",e,f);
          rc = capi.SQLITE_IOERR_WRITE;
        }
        mTimeEnd();
        return rc;
      }
    };

    
    const vfsSyncWrappers = {
      xAccess: function(pVfs,zName,flags,pOut){
        mTimeStart('xAccess');
        const rc = opRun('xAccess', wasm.cstrToJs(zName));
        wasm.poke( pOut, (rc ? 0 : 1), 'i32' );
        mTimeEnd();
        return 0;
      },
      xCurrentTime: function(pVfs,pOut){
        
        wasm.poke(pOut, 2440587.5 + (new Date().getTime()/86400000),
                  'double');
        return 0;
      },
      xCurrentTimeInt64: function(pVfs,pOut){
        wasm.poke(pOut, (2440587.5 * 86400000) + new Date().getTime(),
                  'i64');
        return 0;
      },
      xDelete: function(pVfs, zName, doSyncDir){
        mTimeStart('xDelete');
        const rc = opRun('xDelete', wasm.cstrToJs(zName), doSyncDir, false);
        mTimeEnd();
        return rc;
      },
      xFullPathname: function(pVfs,zName,nOut,pOut){
        
        const i = wasm.cstrncpy(pOut, zName, nOut);
        return i<nOut ? 0 : capi.SQLITE_CANTOPEN
        ;
      },
      xGetLastError: function(pVfs,nOut,pOut){
        
        warn("OPFS xGetLastError() has nothing sensible to return.");
        return 0;
      },
      
      xOpen: function f(pVfs, zName, pFile, flags, pOutFlags){
        mTimeStart('xOpen');
        let opfsFlags = 0;
        if(0===zName){
          zName = randomFilename();
        }else if('number'===typeof zName){
          if(capi.sqlite3_uri_boolean(zName, "opfs-unlock-asap", 0)){
            
            opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
          }
          zName = wasm.cstrToJs(zName);
        }
        const fh = Object.create(null);
        fh.fid = pFile;
        fh.filename = zName;
        fh.sab = new SharedArrayBuffer(state.fileBufferSize);
        fh.flags = flags;
        const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);
        if(!rc){
          
          if(fh.readOnly){
            wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');
          }
          __openFiles[pFile] = fh;
          fh.sabView = state.sabFileBufView;
          fh.sq3File = new sqlite3_file(pFile);
          fh.sq3File.$pMethods = opfsIoMethods.pointer;
          fh.lockType = capi.SQLITE_LOCK_NONE;
        }
        mTimeEnd();
        return rc;
      }
    };

    if(dVfs){
      opfsVfs.$xRandomness = dVfs.$xRandomness;
      opfsVfs.$xSleep = dVfs.$xSleep;
    }
    if(!opfsVfs.$xRandomness){
      
      vfsSyncWrappers.xRandomness = function(pVfs, nOut, pOut){
        const heap = wasm.heap8u();
        let i = 0;
        for(; i < nOut; ++i) heap[pOut + i] = (Math.random()*255000) & 0xFF;
        return i;
      };
    }
    if(!opfsVfs.$xSleep){
      
      vfsSyncWrappers.xSleep = function(pVfs,ms){
        Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
        return 0;
      };
    }

    
    opfsUtil.getResolvedPath = function(filename,splitIt){
      const p = new URL(filename, "file://irrelevant").pathname;
      return splitIt ? p.split('/').filter((v)=>!!v) : p;
    };

    
    opfsUtil.getDirForFilename = async function f(absFilename, createDirs = false){
      const path = opfsUtil.getResolvedPath(absFilename, true);
      const filename = path.pop();
      let dh = opfsUtil.rootDirectory;
      for(const dirName of path){
        if(dirName){
          dh = await dh.getDirectoryHandle(dirName, {create: !!createDirs});
        }
      }
      return [dh, filename];
    };

    
    opfsUtil.mkdir = async function(absDirName){
      try {
        await opfsUtil.getDirForFilename(absDirName+"/filepart", true);
        return true;
      }catch(e){
        
        return false;
      }
    };
    
    opfsUtil.entryExists = async function(fsEntryName){
      try {
        const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
        await dh.getFileHandle(fn);
        return true;
      }catch(e){
        return false;
      }
    };

    
    opfsUtil.randomFilename = randomFilename;

    
    opfsUtil.registerVfs = (asDefault=false)=>{
      return wasm.exports.sqlite3_vfs_register(
        opfsVfs.pointer, asDefault ? 1 : 0
      );
    };

    
    opfsUtil.treeList = async function(){
      const doDir = async function callee(dirHandle,tgt){
        tgt.name = dirHandle.name;
        tgt.dirs = [];
        tgt.files = [];
        for await (const handle of dirHandle.values()){
          if('directory' === handle.kind){
            const subDir = Object.create(null);
            tgt.dirs.push(subDir);
            await callee(handle, subDir);
          }else{
            tgt.files.push(handle.name);
          }
        }
      };
      const root = Object.create(null);
      await doDir(opfsUtil.rootDirectory, root);
      return root;
    };

    
    opfsUtil.rmfr = async function(){
      const dir = opfsUtil.rootDirectory, opt = {recurse: true};
      for await (const handle of dir.values()){
        dir.removeEntry(handle.name, opt);
      }
    };

    
    opfsUtil.unlink = async function(fsEntryName, recursive = false,
                                     throwOnError = false){
      try {
        const [hDir, filenamePart] =
              await opfsUtil.getDirForFilename(fsEntryName, false);
        await hDir.removeEntry(filenamePart, {recursive});
        return true;
      }catch(e){
        if(throwOnError){
          throw new Error("unlink(",arguments[0],") failed: "+e.message,{
            cause: e
          });
        }
        return false;
      }
    };

    
    opfsUtil.traverse = async function(opt){
      const defaultOpt = {
        recursive: true,
        directory: opfsUtil.rootDirectory
      };
      if('function'===typeof opt){
        opt = {callback:opt};
      }
      opt = Object.assign(defaultOpt, opt||{});
      const doDir = async function callee(dirHandle, depth){
        for await (const handle of dirHandle.values()){
          if(false === opt.callback(handle, dirHandle, depth)) return false;
          else if(opt.recursive && 'directory' === handle.kind){
            if(false === await callee(handle, depth + 1)) break;
          }
        }
      };
      doDir(opt.directory, 0);
    };

    
    const importDbChunked = async function(filename, callback){
      const [hDir, fnamePart] = await opfsUtil.getDirForFilename(filename, true);
      const hFile = await hDir.getFileHandle(fnamePart, {create:true});
      let sah = await hFile.createSyncAccessHandle();
      let nWrote = 0, chunk, checkedHeader = false, err = false;
      try{
        sah.truncate(0);
        while( undefined !== (chunk = await callback()) ){
          if(chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
          if( 0===nWrote && chunk.byteLength>=15 ){
            util.affirmDbHeader(chunk);
            checkedHeader = true;
          }
          sah.write(chunk, {at: nWrote});
          nWrote += chunk.byteLength;
        }
        if( nWrote < 512 || 0!==nWrote % 512 ){
          toss("Input size",nWrote,"is not correct for an SQLite database.");
        }
        if( !checkedHeader ){
          const header = new Uint8Array(20);
          sah.read( header, {at: 0} );
          util.affirmDbHeader( header );
        }
        sah.write(new Uint8Array([1,1]), {at: 18});
        return nWrote;
      }catch(e){
        await sah.close();
        sah = undefined;
        await hDir.removeEntry( fnamePart ).catch(()=>{});
        throw e;
      }finally {
        if( sah ) await sah.close();
      }
    };

    
    opfsUtil.importDb = async function(filename, bytes){
      if( bytes instanceof Function ){
        return importDbChunked(filename, bytes);
      }
      if(bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
      util.affirmIsDb(bytes);
      const n = bytes.byteLength;
      const [hDir, fnamePart] = await opfsUtil.getDirForFilename(filename, true);
      let sah, err, nWrote = 0;
      try {
        const hFile = await hDir.getFileHandle(fnamePart, {create:true});
        sah = await hFile.createSyncAccessHandle();
        sah.truncate(0);
        nWrote = sah.write(bytes, {at: 0});
        if(nWrote != n){
          toss("Expected to write "+n+" bytes but wrote "+nWrote+".");
        }
        sah.write(new Uint8Array([1,1]), {at: 18}) ;
        return nWrote;
      }catch(e){
        if( sah ){ await sah.close(); sah = undefined; }
        await hDir.removeEntry( fnamePart ).catch(()=>{});
        throw e;
      }finally{
        if( sah ) await sah.close();
      }
    };

    if(sqlite3.oo1){
      const OpfsDb = function(...args){
        const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
        opt.vfs = opfsVfs.$zName;
        sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
      };
      OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
      sqlite3.oo1.OpfsDb = OpfsDb;
      OpfsDb.importDb = opfsUtil.importDb;
      sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
        opfsVfs.pointer,
        function(oo1Db, sqlite3){
          
          sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);
          sqlite3.capi.sqlite3_exec(oo1Db, [
            
            "pragma journal_mode=DELETE;",
            
            "pragma cache_size=-16384;"
          ], 0, 0, 0);
        }
      );
    }

    const sanityCheck = function(){
      const scope = wasm.scopedAllocPush();
      const sq3File = new sqlite3_file();
      try{
        const fid = sq3File.pointer;
        const openFlags = capi.SQLITE_OPEN_CREATE
              | capi.SQLITE_OPEN_READWRITE
        
              | capi.SQLITE_OPEN_MAIN_DB;
        const pOut = wasm.scopedAlloc(8);
        const dbFile = "/sanity/check/file"+randomFilename(8);
        const zDbFile = wasm.scopedAllocCString(dbFile);
        let rc;
        state.s11n.serialize("This is ä string.");
        rc = state.s11n.deserialize();
        log("deserialize() says:",rc);
        if("This is ä string."!==rc[0]) toss("String d13n error.");
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        log("xAccess(",dbFile,") exists ?=",rc);
        rc = vfsSyncWrappers.xOpen(opfsVfs.pointer, zDbFile,
                                   fid, openFlags, pOut);
        log("open rc =",rc,"state.sabOPView[xOpen] =",
            state.sabOPView[state.opIds.xOpen]);
        if(0!==rc){
          error("open failed with code",rc);
          return;
        }
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        if(!rc) toss("xAccess() failed to detect file.");
        rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
        if(rc) toss('sync failed w/ rc',rc);
        rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
        if(rc) toss('truncate failed w/ rc',rc);
        wasm.poke(pOut,0,'i64');
        rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
        if(rc) toss('xFileSize failed w/ rc',rc);
        log("xFileSize says:",wasm.peek(pOut, 'i64'));
        rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
        if(rc) toss("xWrite() failed!");
        const readBuf = wasm.scopedAlloc(16);
        rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
        wasm.poke(readBuf+6,0);
        let jRead = wasm.cstrToJs(readBuf);
        log("xRead() got:",jRead);
        if("sanity"!==jRead) toss("Unexpected xRead() value.");
        if(vfsSyncWrappers.xSleep){
          log("xSleep()ing before close()ing...");
          vfsSyncWrappers.xSleep(opfsVfs.pointer,2000);
          log("waking up from xSleep()");
        }
        rc = ioSyncWrappers.xClose(fid);
        log("xClose rc =",rc,"sabOPView =",state.sabOPView);
        log("Deleting file:",dbFile);
        vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);
        vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
        rc = wasm.peek(pOut,'i32');
        if(rc) toss("Expecting 0 from xAccess(",dbFile,") after xDelete().");
        warn("End of OPFS sanity checks.");
      }finally{
        sq3File.dispose();
        wasm.scopedAllocPop(scope);
      }
    };

    W.onmessage = function({data}){
      
      switch(data.type){
          case 'opfs-unavailable':
            
            promiseReject(new Error(data.payload.join(' ')));
            break;
          case 'opfs-async-loaded':
            
            W.postMessage({type: 'opfs-async-init',args: state});
            break;
          case 'opfs-async-inited': {
            
            if(true===promiseWasRejected){
              break ;
            }
            try {
              sqlite3.vfs.installVfs({
                io: {struct: opfsIoMethods, methods: ioSyncWrappers},
                vfs: {struct: opfsVfs, methods: vfsSyncWrappers}
              });
              state.sabOPView = new Int32Array(state.sabOP);
              state.sabFileBufView = new Uint8Array(state.sabIO, 0, state.fileBufferSize);
              state.sabS11nView = new Uint8Array(state.sabIO, state.sabS11nOffset, state.sabS11nSize);
              initS11n();
              if(options.sanityChecks){
                warn("Running sanity checks because of opfs-sanity-check URL arg...");
                sanityCheck();
              }
              if(thisThreadHasOPFS()){
                navigator.storage.getDirectory().then((d)=>{
                  W.onerror = W._originalOnError;
                  delete W._originalOnError;
                  sqlite3.opfs = opfsUtil;
                  opfsUtil.rootDirectory = d;
                  log("End of OPFS sqlite3_vfs setup.", opfsVfs);
                  promiseResolve();
                }).catch(promiseReject);
              }else{
                promiseResolve();
              }
            }catch(e){
              error(e);
              promiseReject(e);
            }
            break;
          }
          default: {
            const errMsg = (
              "Unexpected message from the OPFS async worker: " +
              JSON.stringify(data)
            );
            error(errMsg);
            promiseReject(new Error(errMsg));
            break;
          }
      }
    };
  });
  return thePromise;
};
installOpfsVfs.defaultProxyUri =
  "sqlite3-opfs-async-proxy.js";
globalThis.sqlite3ApiBootstrap.initializersAsync.push(async (sqlite3)=>{
  try{
    let proxyJs = installOpfsVfs.defaultProxyUri;
    if(sqlite3.scriptInfo.sqlite3Dir){
      installOpfsVfs.defaultProxyUri =
        sqlite3.scriptInfo.sqlite3Dir + proxyJs;
      
    }
    return installOpfsVfs().catch((e)=>{
      sqlite3.config.warn("Ignoring inability to install OPFS sqlite3_vfs:",e.message);
    });
  }catch(e){
    sqlite3.config.error("installOpfsVfs() exception:",e);
    return Promise.reject(e);
  }
});
});



globalThis.sqlite3ApiBootstrap.initializers.push(function(sqlite3){
  'use strict';
  const toss = sqlite3.util.toss;
  const toss3 = sqlite3.util.toss3;
  const initPromises = Object.create(null);
  const capi = sqlite3.capi;
  const util = sqlite3.util;
  const wasm = sqlite3.wasm;
  
  const SECTOR_SIZE = 4096;
  const HEADER_MAX_PATH_SIZE = 512;
  const HEADER_FLAGS_SIZE = 4;
  const HEADER_DIGEST_SIZE = 8;
  const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
  const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
  const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
  const HEADER_OFFSET_DATA = SECTOR_SIZE;
  
  const PERSISTENT_FILE_TYPES =
        capi.SQLITE_OPEN_MAIN_DB |
        capi.SQLITE_OPEN_MAIN_JOURNAL |
        capi.SQLITE_OPEN_SUPER_JOURNAL |
        capi.SQLITE_OPEN_WAL ;

  
  const OPAQUE_DIR_NAME = ".opaque";

  
  const getRandomName = ()=>Math.random().toString(36).slice(2);

  const textDecoder = new TextDecoder();
  const textEncoder = new TextEncoder();

  const optionDefaults = Object.assign(Object.create(null),{
    name: 'opfs-sahpool',
    directory: undefined ,
    initialCapacity: 6,
    clearOnInit: false,
    
    verbosity: 2
  });

  
  const loggers = [
    sqlite3.config.error,
    sqlite3.config.warn,
    sqlite3.config.log
  ];
  const log = sqlite3.config.log;
  const warn = sqlite3.config.warn;
  const error = sqlite3.config.error;

  
  const __mapVfsToPool = new Map();
  const getPoolForVfs = (pVfs)=>__mapVfsToPool.get(pVfs);
  const setPoolForVfs = (pVfs,pool)=>{
    if(pool) __mapVfsToPool.set(pVfs, pool);
    else __mapVfsToPool.delete(pVfs);
  };
  
  const __mapSqlite3File = new Map();
  const getPoolForPFile = (pFile)=>__mapSqlite3File.get(pFile);
  const setPoolForPFile = (pFile,pool)=>{
    if(pool) __mapSqlite3File.set(pFile, pool);
    else __mapSqlite3File.delete(pFile);
  };

  
  const ioMethods = {
    xCheckReservedLock: function(pFile,pOut){
      const pool = getPoolForPFile(pFile);
      pool.log('xCheckReservedLock');
      pool.storeErr();
      wasm.poke32(pOut, 1);
      return 0;
    },
    xClose: function(pFile){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      if(file) {
        try{
          pool.log(`xClose ${file.path}`);
          pool.mapS3FileToOFile(pFile, false);
          file.sah.flush();
          if(file.flags & capi.SQLITE_OPEN_DELETEONCLOSE){
            pool.deletePath(file.path);
          }
        }catch(e){
          return pool.storeErr(e, capi.SQLITE_IOERR);
        }
      }
      return 0;
    },
    xDeviceCharacteristics: function(pFile){
      return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
    },
    xFileControl: function(pFile, opId, pArg){
      return capi.SQLITE_NOTFOUND;
    },
    xFileSize: function(pFile,pSz64){
      const pool = getPoolForPFile(pFile);
      pool.log(`xFileSize`);
      const file = pool.getOFileForS3File(pFile);
      const size = file.sah.getSize() - HEADER_OFFSET_DATA;
      
      wasm.poke64(pSz64, BigInt(size));
      return 0;
    },
    xLock: function(pFile,lockType){
      const pool = getPoolForPFile(pFile);
      pool.log(`xLock ${lockType}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      file.lockType = lockType;
      return 0;
    },
    xRead: function(pFile,pDest,n,offset64){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      pool.log(`xRead ${file.path} ${n} @ ${offset64}`);
      try {
        const nRead = file.sah.read(
          wasm.heap8u().subarray(pDest, pDest+n),
          {at: HEADER_OFFSET_DATA + Number(offset64)}
        );
        if(nRead < n){
          wasm.heap8u().fill(0, pDest + nRead, pDest + n);
          return capi.SQLITE_IOERR_SHORT_READ;
        }
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xSectorSize: function(pFile){
      return SECTOR_SIZE;
    },
    xSync: function(pFile,flags){
      const pool = getPoolForPFile(pFile);
      pool.log(`xSync ${flags}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      
      try{
        file.sah.flush();
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xTruncate: function(pFile,sz64){
      const pool = getPoolForPFile(pFile);
      pool.log(`xTruncate ${sz64}`);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      
      try{
        file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
        return 0;
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    },
    xUnlock: function(pFile,lockType){
      const pool = getPoolForPFile(pFile);
      pool.log('xUnlock');
      const file = pool.getOFileForS3File(pFile);
      file.lockType = lockType;
      return 0;
    },
    xWrite: function(pFile,pSrc,n,offset64){
      const pool = getPoolForPFile(pFile);
      pool.storeErr();
      const file = pool.getOFileForS3File(pFile);
      pool.log(`xWrite ${file.path} ${n} ${offset64}`);
      try{
        const nBytes = file.sah.write(
          wasm.heap8u().subarray(pSrc, pSrc+n),
          { at: HEADER_OFFSET_DATA + Number(offset64) }
        );
        return n===nBytes ? 0 : toss("Unknown write() failure.");
      }catch(e){
        return pool.storeErr(e, capi.SQLITE_IOERR);
      }
    }
  };

  const opfsIoMethods = new capi.sqlite3_io_methods();
  opfsIoMethods.$iVersion = 1;
  sqlite3.vfs.installVfs({
    io: {struct: opfsIoMethods, methods: ioMethods}
  });

  
  const vfsMethods = {
    xAccess: function(pVfs,zName,flags,pOut){
      
      const pool = getPoolForVfs(pVfs);
      pool.storeErr();
      try{
        const name = pool.getPath(zName);
        wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
      }catch(e){
        
        wasm.poke32(pOut, 0);
      }
      return 0;
    },
    xCurrentTime: function(pVfs,pOut){
      wasm.poke(pOut, 2440587.5 + (new Date().getTime()/86400000),
                'double');
      return 0;
    },
    xCurrentTimeInt64: function(pVfs,pOut){
      wasm.poke(pOut, (2440587.5 * 86400000) + new Date().getTime(),
                'i64');
      return 0;
    },
    xDelete: function(pVfs, zName, doSyncDir){
      const pool = getPoolForVfs(pVfs);
      pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
      pool.storeErr();
      try{
        pool.deletePath(pool.getPath(zName));
        return 0;
      }catch(e){
        pool.storeErr(e);
        return capi.SQLITE_IOERR_DELETE;
      }
    },
    xFullPathname: function(pVfs,zName,nOut,pOut){
      
      
      const i = wasm.cstrncpy(pOut, zName, nOut);
      return i<nOut ? 0 : capi.SQLITE_CANTOPEN;
    },
    xGetLastError: function(pVfs,nOut,pOut){
      const pool = getPoolForVfs(pVfs);
      const e = pool.popErr();
      pool.log(`xGetLastError ${nOut} e =`,e);
      if(e){
        const scope = wasm.scopedAllocPush();
        try{
          const [cMsg, n] = wasm.scopedAllocCString(e.message, true);
          wasm.cstrncpy(pOut, cMsg, nOut);
          if(n > nOut) wasm.poke8(pOut + nOut - 1, 0);
        }catch(e){
          return capi.SQLITE_NOMEM;
        }finally{
          wasm.scopedAllocPop(scope);
        }
      }
      return e ? (e.sqlite3Rc || capi.SQLITE_IOERR) : 0;
    },
    
    xOpen: function f(pVfs, zName, pFile, flags, pOutFlags){
      const pool = getPoolForVfs(pVfs);
      try{
        pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);
        
        const path = (zName && wasm.peek8(zName))
              ? pool.getPath(zName)
              : getRandomName();
        let sah = pool.getSAHForPath(path);
        if(!sah && (flags & capi.SQLITE_OPEN_CREATE)) {
          
          if(pool.getFileCount() < pool.getCapacity()) {
            
            sah = pool.nextAvailableSAH();
            pool.setAssociatedPath(sah, path, flags);
          }else{
            
            toss('SAH pool is full. Cannot create file',path);
          }
        }
        if(!sah){
          toss('file not found:',path);
        }
        
        
        const file = {path, flags, sah};
        pool.mapS3FileToOFile(pFile, file);
        file.lockType = capi.SQLITE_LOCK_NONE;
        const sq3File = new capi.sqlite3_file(pFile);
        sq3File.$pMethods = opfsIoMethods.pointer;
        sq3File.dispose();
        wasm.poke32(pOutFlags, flags);
        return 0;
      }catch(e){
        pool.storeErr(e);
        return capi.SQLITE_CANTOPEN;
      }
    }
  };

  
  const createOpfsVfs = function(vfsName){
    if( sqlite3.capi.sqlite3_vfs_find(vfsName)){
      toss3("VFS name is already registered:", vfsName);
    }
    const opfsVfs = new capi.sqlite3_vfs();
    
    const pDVfs = capi.sqlite3_vfs_find(null);
    const dVfs = pDVfs
          ? new capi.sqlite3_vfs(pDVfs)
          : null ;
    opfsVfs.$iVersion = 2;
    opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
    opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
    opfsVfs.addOnDispose(
      opfsVfs.$zName = wasm.allocCString(vfsName),
      ()=>setPoolForVfs(opfsVfs.pointer, 0)
    );

    if(dVfs){
      
      opfsVfs.$xRandomness = dVfs.$xRandomness;
      opfsVfs.$xSleep = dVfs.$xSleep;
      dVfs.dispose();
    }
    if(!opfsVfs.$xRandomness && !vfsMethods.xRandomness){
      
      vfsMethods.xRandomness = function(pVfs, nOut, pOut){
        const heap = wasm.heap8u();
        let i = 0;
        for(; i < nOut; ++i) heap[pOut + i] = (Math.random()*255000) & 0xFF;
        return i;
      };
    }
    if(!opfsVfs.$xSleep && !vfsMethods.xSleep){
      vfsMethods.xSleep = (pVfs,ms)=>0;
    }
    sqlite3.vfs.installVfs({
      vfs: {struct: opfsVfs, methods: vfsMethods}
    });
    return opfsVfs;
  };

  
  class OpfsSAHPool {
    
    vfsDir;
    
    #dhVfsRoot;
    
    #dhOpaque;
    
    #dhVfsParent;
    
    #mapSAHToName = new Map();
    
    #mapFilenameToSAH = new Map();
    
    #availableSAH = new Set();
    
    #mapS3FileToOFile_ = new Map();

    
    

    
    #apBody = new Uint8Array(HEADER_CORPUS_SIZE);
    
    #dvBody;

    
    #cVfs;

    
    #verbosity;

    constructor(options = Object.create(null)){
      this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
      this.vfsName = options.name || optionDefaults.name;
      this.#cVfs = createOpfsVfs(this.vfsName);
      setPoolForVfs(this.#cVfs.pointer, this);
      this.vfsDir = options.directory || ("."+this.vfsName);
      this.#dvBody =
        new DataView(this.#apBody.buffer, this.#apBody.byteOffset);
      this.isReady = this
        .reset(!!(options.clearOnInit ?? optionDefaults.clearOnInit))
        .then(()=>{
          if(this.$error) throw this.$error;
          return this.getCapacity()
            ? Promise.resolve(undefined)
            : this.addCapacity(options.initialCapacity
                               || optionDefaults.initialCapacity);
        });
    }

    #logImpl(level,...args){
      if(this.#verbosity>level) loggers[level](this.vfsName+":",...args);
    };
    log(...args){this.#logImpl(2, ...args)};
    warn(...args){this.#logImpl(1, ...args)};
    error(...args){this.#logImpl(0, ...args)};

    getVfs(){return this.#cVfs}

    
    getCapacity(){return this.#mapSAHToName.size}

    
    getFileCount(){return this.#mapFilenameToSAH.size}

    
    getFileNames(){
      const rc = [];
      const iter = this.#mapFilenameToSAH.keys();
      for(const n of iter) rc.push(n);
      return rc;
    }












    
    async addCapacity(n){
      for(let i = 0; i < n; ++i){
        const name = getRandomName();
        const h = await this.#dhOpaque.getFileHandle(name, {create:true});
        const ah = await h.createSyncAccessHandle();
        this.#mapSAHToName.set(ah,name);
        this.setAssociatedPath(ah, '', 0);
        
      }
      return this.getCapacity();
    }

    
    async reduceCapacity(n){
      let nRm = 0;
      for(const ah of Array.from(this.#availableSAH)){
        if(nRm === n || this.getFileCount() === this.getCapacity()){
          break;
        }
        const name = this.#mapSAHToName.get(ah);
        
        ah.close();
        await this.#dhOpaque.removeEntry(name);
        this.#mapSAHToName.delete(ah);
        this.#availableSAH.delete(ah);
        ++nRm;
      }
      return nRm;
    }

    
    releaseAccessHandles(){
      for(const ah of this.#mapSAHToName.keys()) ah.close();
      this.#mapSAHToName.clear();
      this.#mapFilenameToSAH.clear();
      this.#availableSAH.clear();
    }

    
    async acquireAccessHandles(clearFiles){
      const files = [];
      for await (const [name,h] of this.#dhOpaque){
        if('file'===h.kind){
          files.push([name,h]);
        }
      }
      return Promise.all(files.map(async([name,h])=>{
        try{
          const ah = await h.createSyncAccessHandle()
          this.#mapSAHToName.set(ah, name);
          if(clearFiles){
            ah.truncate(HEADER_OFFSET_DATA);
            this.setAssociatedPath(ah, '', 0);
          }else{
            const path = this.getAssociatedPath(ah);
            if(path){
              this.#mapFilenameToSAH.set(path, ah);
            }else{
              this.#availableSAH.add(ah);
            }
          }
        }catch(e){
          this.storeErr(e);
          this.releaseAccessHandles();
          throw e;
        }
      }));
    }

    
    getAssociatedPath(sah){
      sah.read(this.#apBody, {at: 0});
      
      
      const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
      if(this.#apBody[0] &&
         ((flags & capi.SQLITE_OPEN_DELETEONCLOSE) ||
          (flags & PERSISTENT_FILE_TYPES)===0)){
        warn(`Removing file with unexpected flags ${flags.toString(16)}`,
             this.#apBody);
        this.setAssociatedPath(sah, '', 0);
        return '';
      }

      const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
      sah.read(fileDigest, {at: HEADER_OFFSET_DIGEST});
      const compDigest = this.computeDigest(this.#apBody);
      if(fileDigest.every((v,i) => v===compDigest[i])){
        
        const pathBytes = this.#apBody.findIndex((v)=>0===v);
        if(0===pathBytes){
          
          
          sah.truncate(HEADER_OFFSET_DATA);
        }
        return pathBytes
          ? textDecoder.decode(this.#apBody.subarray(0,pathBytes))
          : '';
      }else{
        
        warn('Disassociating file with bad digest.');
        this.setAssociatedPath(sah, '', 0);
        return '';
      }
    }

    
    setAssociatedPath(sah, path, flags){
      const enc = textEncoder.encodeInto(path, this.#apBody);
      if(HEADER_MAX_PATH_SIZE <= enc.written + 1){
        toss("Path too long:",path);
      }
      this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
      this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);

      const digest = this.computeDigest(this.#apBody);
      sah.write(this.#apBody, {at: 0});
      sah.write(digest, {at: HEADER_OFFSET_DIGEST});
      sah.flush();

      if(path){
        this.#mapFilenameToSAH.set(path, sah);
        this.#availableSAH.delete(sah);
      }else{
        
        sah.truncate(HEADER_OFFSET_DATA);
        this.#availableSAH.add(sah);
      }
    }

    
    computeDigest(byteArray){
      let h1 = 0xdeadbeef;
      let h2 = 0x41c6ce57;
      for(const v of byteArray){
        h1 = 31 * h1 + (v * 307);
        h2 = 31 * h2 + (v * 307);
      }
      return new Uint32Array([h1>>>0, h2>>>0]);
    }

    
    async reset(clearFiles){
      await this.isReady;
      let h = await navigator.storage.getDirectory();
      let prev, prevName;
      for(const d of this.vfsDir.split('/')){
        if(d){
          prev = h;
          h = await h.getDirectoryHandle(d,{create:true});
        }
      }
      this.#dhVfsRoot = h;
      this.#dhVfsParent = prev;
      this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
        OPAQUE_DIR_NAME,{create:true}
      );
      this.releaseAccessHandles();
      return this.acquireAccessHandles(clearFiles);
    }

    
    getPath(arg) {
      if(wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);
      return ((arg instanceof URL)
              ? arg
              : new URL(arg, 'file://localhost/')).pathname;
    }

    
    deletePath(path) {
      const sah = this.#mapFilenameToSAH.get(path);
      if(sah) {
        
        this.#mapFilenameToSAH.delete(path);
        this.setAssociatedPath(sah, '', 0);
      }
      return !!sah;
    }

    
    storeErr(e,code){
      if(e){
        e.sqlite3Rc = code || capi.SQLITE_IOERR;
        this.error(e);
      }
      this.$error = e;
      return code;
    }
    
    popErr(){
      const rc = this.$error;
      this.$error = undefined;
      return rc;
    }

    
    nextAvailableSAH(){
      const [rc] = this.#availableSAH.keys();
      return rc;
    }

    
    getOFileForS3File(pFile){
      return this.#mapS3FileToOFile_.get(pFile);
    }
    
    mapS3FileToOFile(pFile,file){
      if(file){
        this.#mapS3FileToOFile_.set(pFile, file);
        setPoolForPFile(pFile, this);
      }else{
        this.#mapS3FileToOFile_.delete(pFile);
        setPoolForPFile(pFile, false);
      }
    }

    
    hasFilename(name){
      return this.#mapFilenameToSAH.has(name)
    }

    
    getSAHForPath(path){
      return this.#mapFilenameToSAH.get(path);
    }

    
    async removeVfs(){
      if(!this.#cVfs.pointer || !this.#dhOpaque) return false;
      capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
      this.#cVfs.dispose();
      try{
        this.releaseAccessHandles();
        await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {recursive: true});
        this.#dhOpaque = undefined;
        await this.#dhVfsParent.removeEntry(
          this.#dhVfsRoot.name, {recursive: true}
        );
        this.#dhVfsRoot = this.#dhVfsParent = undefined;
      }catch(e){
        sqlite3.config.error(this.vfsName,"removeVfs() failed:",e);
        
      }
      return true;
    }


    
    exportFile(name){
      const sah = this.#mapFilenameToSAH.get(name) || toss("File not found:",name);
      const n = sah.getSize() - HEADER_OFFSET_DATA;
      const b = new Uint8Array(n>0 ? n : 0);
      if(n>0){
        const nRead = sah.read(b, {at: HEADER_OFFSET_DATA});
        if(nRead != n){
          toss("Expected to read "+n+" bytes but read "+nRead+".");
        }
      }
      return b;
    }

    
    async importDbChunked(name, callback){
      const sah = this.#mapFilenameToSAH.get(name)
            || this.nextAvailableSAH()
            || toss("No available handles to import to.");
      sah.truncate(0);
      let nWrote = 0, chunk, checkedHeader = false, err = false;
      try{
        while( undefined !== (chunk = await callback()) ){
          if(chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
          if( 0===nWrote && chunk.byteLength>=15 ){
            util.affirmDbHeader(chunk);
            checkedHeader = true;
          }
          sah.write(chunk, {at:  HEADER_OFFSET_DATA + nWrote});
          nWrote += chunk.byteLength;
        }
        if( nWrote < 512 || 0!==nWrote % 512 ){
          toss("Input size",nWrote,"is not correct for an SQLite database.");
        }
        if( !checkedHeader ){
          const header = new Uint8Array(20);
          sah.read( header, {at: 0} );
          util.affirmDbHeader( header );
        }
        sah.write(new Uint8Array([1,1]), {
          at: HEADER_OFFSET_DATA + 18
        });
      }catch(e){
        this.setAssociatedPath(sah, '', 0);
        throw e;
      }
      this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
      return nWrote;
    }

    
    importDb(name, bytes){
      if( bytes instanceof ArrayBuffer ) bytes = new Uint8Array(bytes);
      else if( bytes instanceof Function ) return this.importDbChunked(name, bytes);
      const sah = this.#mapFilenameToSAH.get(name)
            || this.nextAvailableSAH()
            || toss("No available handles to import to.");
      const n = bytes.byteLength;
      if(n<512 || n%512!=0){
        toss("Byte array size is invalid for an SQLite db.");
      }
      const header = "SQLite format 3";
      for(let i = 0; i < header.length; ++i){
        if( header.charCodeAt(i) !== bytes[i] ){
          toss("Input does not contain an SQLite database header.");
        }
      }
      const nWrote = sah.write(bytes, {at: HEADER_OFFSET_DATA});
      if(nWrote != n){
        this.setAssociatedPath(sah, '', 0);
        toss("Expected to write "+n+" bytes but wrote "+nWrote+".");
      }else{
        sah.write(new Uint8Array([1,1]), {at: HEADER_OFFSET_DATA+18}
                   );
        this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
      }
      return nWrote;
    }

  };


  
  class OpfsSAHPoolUtil {
    
    #p;

    constructor(sahPool){
      this.#p = sahPool;
      this.vfsName = sahPool.vfsName;
    }

    async addCapacity(n){ return this.#p.addCapacity(n) }

    async reduceCapacity(n){ return this.#p.reduceCapacity(n) }

    getCapacity(){ return this.#p.getCapacity(this.#p) }

    getFileCount(){ return this.#p.getFileCount() }
    getFileNames(){ return this.#p.getFileNames() }

    async reserveMinimumCapacity(min){
      const c = this.#p.getCapacity();
      return (c < min) ? this.#p.addCapacity(min - c) : c;
    }

    exportFile(name){ return this.#p.exportFile(name) }

    importDb(name, bytes){ return this.#p.importDb(name,bytes) }

    async wipeFiles(){ return this.#p.reset(true) }

    unlink(filename){ return this.#p.deletePath(filename) }

    async removeVfs(){ return this.#p.removeVfs() }

  };

  
  const apiVersionCheck = async ()=>{
    const dh = await navigator.storage.getDirectory();
    const fn = '.opfs-sahpool-sync-check-'+getRandomName();
    const fh = await dh.getFileHandle(fn, { create: true });
    const ah = await fh.createSyncAccessHandle();
    const close = ah.close();
    await close;
    await dh.removeEntry(fn);
    if(close?.then){
      toss("The local OPFS API is too old for opfs-sahpool:",
           "it has an async FileSystemSyncAccessHandle.close() method.");
    }
    return true;
  };

  
  let instanceCounter = 0;

  
  sqlite3.installOpfsSAHPoolVfs = async function(options=Object.create(null)){
    const vfsName = options.name || optionDefaults.name;
    if(false){}
    if(initPromises[vfsName]){
      
      return initPromises[vfsName];
    }
    if(!globalThis.FileSystemHandle ||
       !globalThis.FileSystemDirectoryHandle ||
       !globalThis.FileSystemFileHandle ||
       !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
       !navigator?.storage?.getDirectory){
      return (initPromises[vfsName] = Promise.reject(new Error("Missing required OPFS APIs.")));
    }

    
    return initPromises[vfsName] = apiVersionCheck().then(async function(){
      if(options.$testThrowInInit){
        throw options.$testThrowInInit;
      }
      const thePool = new OpfsSAHPool(options);
      return thePool.isReady.then(async()=>{
        
        const poolUtil = new OpfsSAHPoolUtil(thePool);
        if(sqlite3.oo1){
          const oo1 = sqlite3.oo1;
          const theVfs = thePool.getVfs();
          const OpfsSAHPoolDb = function(...args){
            const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
            opt.vfs = theVfs.$zName;
            oo1.DB.dbCtorHelper.call(this, opt);
          };
          OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);
          
          poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
          oo1.DB.dbCtorHelper.setVfsPostOpenSql(
            theVfs.pointer,
            function(oo1Db, sqlite3){
              sqlite3.capi.sqlite3_exec(oo1Db, [
                
                "pragma journal_mode=DELETE;",
                "pragma cache_size=-16384;"
              ], 0, 0, 0);
            }
          );
        }
        thePool.log("VFS initialized.");
        return poolUtil;
      }).catch(async (e)=>{
        await thePool.removeVfs().catch(()=>{});
        return e;
      });
    }).catch((err)=>{
      
      return initPromises[vfsName] = Promise.reject(err);
    });
  };
});



'use strict';
if('undefined' !== typeof Module){ 
  
  const SABC = Object.assign(
    Object.create(null), {
      exports: ('undefined'===typeof wasmExports)
        ? Module['asm']
        : wasmExports  ,
      memory: Module.wasmMemory 
    },
    globalThis.sqlite3ApiConfig || {}
  );

  
  
  globalThis.sqlite3ApiConfig = SABC;
  let sqlite3;
  try{
    sqlite3 = globalThis.sqlite3ApiBootstrap();
  }catch(e){
    console.error("sqlite3ApiBootstrap() error:",e);
    throw e;
  }finally{
    delete globalThis.sqlite3ApiBootstrap;
    delete globalThis.sqlite3ApiConfig;
  }

  Module.sqlite3 = sqlite3 ;
}else{
  console.warn("This is not running in an Emscripten module context, so",
               "globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack",
               "of config info for the WASM environment.",
               "It must be called manually.");
}




});



  return sqlite3InitModule.ready
}
);
})();
if (true)
  module.exports = sqlite3InitModule;
else {}



(function(){
  
  const originalInit = sqlite3InitModule;
  if(!originalInit){
    throw new Error("Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.");
  }
  
  const initModuleState = globalThis.sqlite3InitModuleState = Object.assign(Object.create(null),{
    moduleScript: globalThis?.document?.currentScript,
    isWorker: ('undefined' !== typeof WorkerGlobalScope),
    location: globalThis.location,
    urlParams:  globalThis?.location?.href
      ? new URL(globalThis.location.href).searchParams
      : new URLSearchParams()
  });
  initModuleState.debugModule =
    initModuleState.urlParams.has('sqlite3.debugModule')
    ? (...args)=>console.warn('sqlite3.debugModule:',...args)
    : ()=>{};

  if(initModuleState.urlParams.has('sqlite3.dir')){
    initModuleState.sqlite3Dir = initModuleState.urlParams.get('sqlite3.dir') +'/';
  }else if(initModuleState.moduleScript){
    const li = initModuleState.moduleScript.src.split('/');
    li.pop();
    initModuleState.sqlite3Dir = li.join('/') + '/';
  }

  globalThis.sqlite3InitModule = function ff(...args){
    
    return originalInit(...args).then((EmscriptenModule)=>{
      
      const s = EmscriptenModule.sqlite3;
      s.scriptInfo = initModuleState;
      
      if(ff.__isUnderTest) s.__isUnderTest = true;
      const f = s.asyncPostInit;
      delete s.asyncPostInit;
      return f();
    }).catch((e)=>{
      console.error("Exception loading sqlite3 module:",e);
      throw e;
    });
  };
  globalThis.sqlite3InitModule.ready = originalInit.ready;

  if(globalThis.sqlite3InitModuleState.moduleScript){
    const sim = globalThis.sqlite3InitModuleState;
    let src = sim.moduleScript.src.split('/');
    src.pop();
    sim.scriptDir = src.join('/') + '/';
  }
  initModuleState.debugModule('sqlite3InitModuleState =',initModuleState);
  if(false){}



  
  if (true){
    module.exports = sqlite3InitModule;
  }else {}
  
  return globalThis.sqlite3InitModule ;
})();


/***/ }),

/***/ "./src/pages/R1-02/CM/sqlite3.wasm":
/*!*****************************************!*\
  !*** ./src/pages/R1-02/CM/sqlite3.wasm ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "pages/R1-02/CM/sqlite3.wasm";

/***/ }),

/***/ "https://raw.githack.com/denis-migdal/LISS/main/index.js":
/*!**************************************************************************!*\
  !*** external "https://raw.githack.com/denis-migdal/LISS/main/index.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_https_raw_githack_com_denis_migdal_LISS_main_index_js_bb6a3cae__;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/async module */
/******/ (() => {
/******/ 	var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 	var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 	var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 	var resolveQueue = (queue) => {
/******/ 		if(queue && queue.d < 1) {
/******/ 			queue.d = 1;
/******/ 			queue.forEach((fn) => (fn.r--));
/******/ 			queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 		}
/******/ 	}
/******/ 	var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 		if(dep !== null && typeof dep === "object") {
/******/ 			if(dep[webpackQueues]) return dep;
/******/ 			if(dep.then) {
/******/ 				var queue = [];
/******/ 				queue.d = 0;
/******/ 				dep.then((r) => {
/******/ 					obj[webpackExports] = r;
/******/ 					resolveQueue(queue);
/******/ 				}, (e) => {
/******/ 					obj[webpackError] = e;
/******/ 					resolveQueue(queue);
/******/ 				});
/******/ 				var obj = {};
/******/ 				obj[webpackQueues] = (fn) => (fn(queue));
/******/ 				return obj;
/******/ 			}
/******/ 		}
/******/ 		var ret = {};
/******/ 		ret[webpackQueues] = x => {};
/******/ 		ret[webpackExports] = dep;
/******/ 		return ret;
/******/ 	}));
/******/ 	__webpack_require__.a = (module, body, hasAwait) => {
/******/ 		var queue;
/******/ 		hasAwait && ((queue = []).d = -1);
/******/ 		var depQueues = new Set();
/******/ 		var exports = module.exports;
/******/ 		var currentDeps;
/******/ 		var outerResolve;
/******/ 		var reject;
/******/ 		var promise = new Promise((resolve, rej) => {
/******/ 			reject = rej;
/******/ 			outerResolve = resolve;
/******/ 		});
/******/ 		promise[webpackExports] = exports;
/******/ 		promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 		module.exports = promise;
/******/ 		body((deps) => {
/******/ 			currentDeps = wrapDeps(deps);
/******/ 			var fn;
/******/ 			var getResult = () => (currentDeps.map((d) => {
/******/ 				if(d[webpackError]) throw d[webpackError];
/******/ 				return d[webpackExports];
/******/ 			}))
/******/ 			var promise = new Promise((resolve) => {
/******/ 				fn = () => (resolve(getResult));
/******/ 				fn.r = 0;
/******/ 				var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 				currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 			});
/******/ 			return fn.r ? promise : getResult();
/******/ 		}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 		queue && queue.d < 0 && (queue.d = 0);
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	__webpack_require__.p = "";
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module used 'module' so it can't be inlined
/******/ __webpack_require__("./src/pages/R1-02/CM/index.ts");
/******/ __webpack_require__("./src/pages/R1-02/CM/index.css");
/******/ var __webpack_exports__ = __webpack_require__("./src/pages/R1-02/CM/index.md");
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ export { __webpack_exports__default as default };
/******/ 

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQSxtREFBbUQ7OztBQUduRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLG1DQUFtQztBQUNoRjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFL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Q0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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VUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUJBQWlCOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBLHVDQUF1QztBQUN2QyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNERBQTREO0FBQzVELHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw2REFBNkQ7QUFDN0QsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUMsQ0FBQyxFQUtKO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCLFNBQVM7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsZUFBZTtBQUNmLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBOzs7QUFHQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLEtBQUMsQ0FBQyxFQWdCSjs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxLQUEwRCxDQUFDLEVBRzdEOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFDLEdBQUcsQ0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLHFCQUFxQjtBQUNyQixDQUFDOzs7O0FBSUQ7QUFDQSwyQkFBMkI7QUFDM0IsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPLFdBQVc7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFDLEVBQUUsRUFDMkU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCLDBDQUEwQztBQUNwRSxDQUFDLE9BQU8sUUFBUTtBQUNoQixDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUMsaUNBQWlDLENBQUs7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxLQUFLLEVBRzhDOzs7O0FBSW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBQyxDQUFDLEVBT0o7Ozs7QUFJSDtBQUNBLE1BQU0sSUFBeUQ7QUFDL0Q7QUFDQSxHQUFHLEtBQUssRUFFTDtBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1bVpEOzs7Ozs7U0NBQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBOztTQUVBO1NBQ0E7O1NBRUE7U0FDQTtTQUNBOzs7OztVQ3RCQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLElBQUk7VUFDSjtVQUNBO1VBQ0EsSUFBSTtVQUNKO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLENBQUM7VUFDRDtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsRUFBRTtVQUNGO1VBQ0Esc0dBQXNHO1VBQ3RHO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EsR0FBRztVQUNIO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQSxHQUFHO1VBQ0g7VUFDQSxFQUFFO1VBQ0Y7VUFDQTs7Ozs7VUNoRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLGlDQUFpQyxXQUFXO1VBQzVDO1VBQ0E7Ozs7O1VDUEE7VUFDQTtVQUNBO1VBQ0E7VUFDQSx5Q0FBeUMsd0NBQXdDO1VBQ2pGO1VBQ0E7VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7O1VDTkE7Ozs7O1NFQUE7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvcGFnZXMvUjEtMDIvQ00vaW5kZXguY3NzPzQ0YjIiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvcGFnZXMvUjEtMDIvQ00vaW5kZXgubWQiLCJ3ZWJwYWNrOi8vQ291cnMvLi9saWJzL0xJU1MvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvcGFnZXMvUjEtMDIvQ00vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvc3RydWN0L1NRTGl0ZS50cyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3QvY29udGVudC50cyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3QvbWVudS50cyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3QvYW5pbS1wbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvc3RydWN0L3NxbC1keW0tdGFibGUuanMiLCJ3ZWJwYWNrOi8vQ291cnMvLi9zcmMvc3RydWN0L3NxbC1pbnRlcmFjdGl2ZS5qcyIsIndlYnBhY2s6Ly9Db3Vycy8uL3NyYy9zdHJ1Y3Qvc3FsaXRlL3NxbGl0ZTMuanMiLCJ3ZWJwYWNrOi8vQ291cnMvZXh0ZXJuYWwgbW9kdWxlIFwiaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vZGVuaXMtbWlnZGFsL0xJU1MvbWFpbi9pbmRleC5qc1wiIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svcnVudGltZS9hc3luYyBtb2R1bGUiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vQ291cnMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL0NvdXJzL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9Db3Vycy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcInBhZ2VzL1IxLTAyL0NNL2luZGV4Lmh0bWxcIjsiLCIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTIGV4cG9ydGVkIHR5cGVzID09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCB0eXBlIENTU19SZXNvdXJjZSA9IHN0cmluZ3xSZXNwb25zZXxIVE1MU3R5bGVFbGVtZW50fENTU1N0eWxlU2hlZXQ7XG5leHBvcnQgdHlwZSBDU1NfU291cmNlICAgPSBDU1NfUmVzb3VyY2UgfCBQcm9taXNlPENTU19SZXNvdXJjZT47XG5cbmV4cG9ydCB0eXBlIEhUTUxfUmVzb3VyY2UgPSBzdHJpbmd8UmVzcG9uc2V8SFRNTFRlbXBsYXRlRWxlbWVudDtcbmV4cG9ydCB0eXBlIEhUTUxfU291cmNlICAgPSBIVE1MX1Jlc291cmNlIHwgUHJvbWlzZTxIVE1MX1Jlc291cmNlPjtcblxuZXhwb3J0IHR5cGUgTElTU09wdGlvbnM8RXh0ZW5kcyAgICBleHRlbmRzIENsYXNzLFxuXHRcdFx0XHRcdFx0SG9zdCAgICAgICBleHRlbmRzIEhUTUxFbGVtZW50LFxuXHRcdFx0XHRcdFx0QXR0cnMgICAgICBleHRlbmRzIHN0cmluZyxcblx0XHRcdFx0XHRcdFBhcmFtZXRlcnMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PiA9IHtcblxuXHRleHRlbmRzPzogQ29uc3RydWN0b3I8RXh0ZW5kcz4sXG5cdGhvc3QgICA/OiBDb25zdHJ1Y3RvcjxIb3N0PixcblxuXHRkZXBlbmRlbmNpZXM/OiByZWFkb25seSBQcm9taXNlPGFueT5bXSxcblx0YXR0cmlidXRlcyAgPzogcmVhZG9ubHkgQXR0cnNbXSxcblx0cGFyYW1zICAgICAgPzogUmVhZG9ubHk8UGFyYW1ldGVycz4sXG5cblx0Y29udGVudD86IEhUTUxfU291cmNlLFxuXHRjc3MgICAgPzogIENTU19Tb3VyY2UgfCByZWFkb25seSBDU1NfU291cmNlW10sXG5cdHNoYWRvdyA/OiAgU2hhZG93Q2ZnLFxufTtcblxuZXhwb3J0IGVudW0gU2hhZG93Q2ZnIHtcblx0Tk9ORSA9ICdub25lJyxcblx0T1BFTiA9ICdvcGVuJywgXG5cdENMT1NFPSAnY2xvc2VkJ1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT0gTElTUyBDbGFzcyA9PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5sZXQgX19jc3RyX2hvc3QgIDogYW55ID0gbnVsbDtcblxudHlwZSBDb25zdHJ1Y3RvcjxUPiA9IG5ldyAoKSA9PiBUO1xuaW50ZXJmYWNlIENsYXNzIHt9XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2F0dGFjaFNoYWRvd1xuY29uc3QgQ0FOX0hBVkVfU0hBRE9XID0gW1xuXHRudWxsLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnZGl2Jyxcblx0J2Zvb3RlcicsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkZXInLCAnbWFpbicsXG5cdCduYXYnLCAncCcsICdzZWN0aW9uJywgJ3NwYW4nXG5cdFxuXTtcbmZ1bmN0aW9uIF9jYW5IYXNTaGFkb3codGFnOiB0eXBlb2YgSFRNTEVsZW1lbnQpIHtcblx0cmV0dXJuIENBTl9IQVZFX1NIQURPVy5pbmNsdWRlcyggX2VsZW1lbnQydGFnbmFtZSh0YWcpICk7XG59XG5cbnR5cGUgUmVzb3VyY2UgPSBVUkx8UmVzcG9uc2U7XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTElTUzxFeHRlbmRzICAgIGV4dGVuZHMgQ2xhc3MgICAgICAgICAgICAgID0gQ2xhc3MsXG5cdFx0XHRcdFx0XHRcdCBIb3N0ICAgICAgIGV4dGVuZHMgSFRNTEVsZW1lbnQgICAgICAgID0gSFRNTEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdCBBdHRycyAgICAgIGV4dGVuZHMgc3RyaW5nICAgICAgICAgICAgID0gbmV2ZXIsXG5cdFx0XHRcdFx0XHRcdCBQYXJhbWV0ZXJzIGV4dGVuZHMgUmVjb3JkPHN0cmluZyxhbnk+ID0ge30+KHtcblx0XHRcdFx0XHRcdFx0XHRleHRlbmRzICAgICA6IHBfZXh0ZW5kcyxcblx0XHRcdFx0XHRcdFx0XHRob3N0ICAgICAgICA6IHBfaG9zdCxcblx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXM6IHBfZGVwcyxcblx0XHRcdFx0XHRcdFx0ICAgIGF0dHJpYnV0ZXMgIDogcF9hdHRycyxcblx0XHRcdFx0XHRcdFx0ICAgIHBhcmFtcyxcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50LFxuXHRcdFx0XHRcdFx0XHRcdGNzcyxcblx0XHRcdFx0XHRcdFx0XHRzaGFkb3cgICAgICA6IHBfc2hhZG93LFxuXHRcdFx0XHRcdFx0XHR9OiBMSVNTT3B0aW9uczxFeHRlbmRzLCBIb3N0LCBBdHRycywgUGFyYW1ldGVycz4gPSB7fSkge1xuXG5cdC8vVE9ETyBtZXJnZSBwcm9wIGlmIGV4dGVuZHMgTElTUy4uLlxuXG5cdGNvbnN0IGhvc3QgICAgICAgID0gcF9ob3N0ICAgID8/IEhUTUxFbGVtZW50IGFzIENvbnN0cnVjdG9yPEhvc3Q+O1xuXHRjb25zdCBfZXh0ZW5kcyAgICA9IHBfZXh0ZW5kcyA/PyBPYmplY3QgICAgICBhcyB1bmtub3duIGFzIENvbnN0cnVjdG9yPEV4dGVuZHM+O1xuXHRjb25zdCBhdHRyaWJ1dGVzICA9IHBfYXR0cnMgICA/PyBbXTtcblx0Y29uc3QgZGVwZW5kZW5jaWVzPSBwX2RlcHMgICAgPyBbLi4ucF9kZXBzXSA6IFtdO1xuXHRjb25zdCBjYW5IYXNTaGFkb3c9IF9jYW5IYXNTaGFkb3coaG9zdCk7XG5cdGNvbnN0IHNoYWRvdyAgICAgID0gcF9zaGFkb3cgID8/IChjYW5IYXNTaGFkb3cgPyBTaGFkb3dDZmcuQ0xPU0UgOiBTaGFkb3dDZmcuTk9ORSk7XG5cblx0aWYoICEgY2FuSGFzU2hhZG93ICYmIHNoYWRvdyAhPT0gU2hhZG93Q2ZnLk5PTkUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBIb3N0IGVsZW1lbnQgJHtfZWxlbWVudDJ0YWduYW1lKGhvc3QpfSBkb2VzIG5vdCBzdXBwb3J0IFNoYWRvd1Jvb3RgKTtcblxuXHQvLyBDT05URU5UIHByb2Nlc3Npbmdcblx0aWYoIGNvbnRlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGRlcGVuZGVuY2llcy5wdXNoKCAoIGFzeW5jICgpID0+IHtcblxuXHRcdFx0Y29udGVudCA9IGF3YWl0IGNvbnRlbnQ7XG5cblx0XHRcdGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBIVE1MVGVtcGxhdGVFbGVtZW50KVxuXHRcdFx0Y29udGVudCA9IGNvbnRlbnQuaW5uZXJIVE1MO1xuXG5cdFx0XHRpZiggdHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcblxuXHRcdFx0XHRjb250ZW50ID0gY29udGVudC50cmltKCk7IC8vIE5ldmVyIHJldHVybiBhIHRleHQgbm9kZSBvZiB3aGl0ZXNwYWNlIGFzIHRoZSByZXN1bHRcblx0XHRcdFx0aWYoY29udGVudCA9PT0gJycpXG5cdFx0XHRcdFx0Y29udGVudCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0fVxuXHRcdFx0aWYoIGNvbnRlbnQgaW5zdGFuY2VvZiBSZXNwb25zZSApXG5cdFx0XHRcdGNvbnRlbnQgPSBhd2FpdCBjb250ZW50LnRleHQoKTtcblxuXHRcdFx0cmV0dXJuIExJU1NCYXNlLlBhcmFtZXRlcnMuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0fSkoKSApO1xuXHR9XG5cblx0Ly8gQ1NTIHByb2Nlc3Npbmdcblx0bGV0IHN0eWxlc2hlZXRzOiByZWFkb25seSBDU1NTdHlsZVNoZWV0W10gPSBbXTtcblx0aWYoIGNzcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0aWYoICEgQXJyYXkuaXNBcnJheShjc3MpIClcblx0XHRcdGNzcyA9IFtjc3MgYXMgQ1NTX1NvdXJjZV07XG5cblx0XHRzdHlsZXNoZWV0cyA9IG5ldyBBcnJheTxDU1NTdHlsZVNoZWV0Pihjc3MubGVuZ3RoKTtcblxuXHRcdGNvbnN0IGZldGNoX2NzcyA9IChhc3luYyAoY3NzOiBDU1NfU291cmNlKSA9PiB7XG5cdFx0XHRjc3MgPSBhd2FpdCBjc3M7XG5cdFx0XHRpZihjc3MgaW5zdGFuY2VvZiBDU1NTdHlsZVNoZWV0KVxuXHRcdFx0XHRyZXR1cm4gY3NzO1xuXHRcdFx0aWYoIGNzcyBpbnN0YW5jZW9mIEhUTUxTdHlsZUVsZW1lbnQpXG5cdFx0XHRcdHJldHVybiBjc3Muc2hlZXQhO1xuXG5cdFx0XHRsZXQgc3R5bGUgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuXHRcdFx0aWYoIHR5cGVvZiBjc3MgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGF3YWl0IHN0eWxlLnJlcGxhY2UoY3NzKTtcblx0XHRcdFx0cmV0dXJuIHN0eWxlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2lmKCBjc3MgaW5zdGFuY2VvZiBSZXNwb25zZSApXG5cdFx0XHRhd2FpdCBzdHlsZS5yZXBsYWNlKGF3YWl0IGNzcy50ZXh0KCkpO1xuXHRcdFx0cmV0dXJuIHN0eWxlO1xuXHRcdH0pO1xuXG5cdFx0ZGVwZW5kZW5jaWVzLnB1c2goIC4uLmNzcy5tYXAoIGFzeW5jIChjc3MsIGlkeCkgPT4gIChzdHlsZXNoZWV0cyBhcyBhbnkpW2lkeF0gPSBhd2FpdCBmZXRjaF9jc3MoY3NzKSApICk7XG5cdH1cblxuXHR0eXBlIExIb3N0ID0gTElTU0hvc3Q8TElTU0Jhc2U+O1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0Y2xhc3MgTElTU0Jhc2UgZXh0ZW5kcyBfZXh0ZW5kcyB7XG5cblx0XHRyZWFkb25seSAjaG9zdDogYW55OyAvLyBwcmV2ZW50cyBpc3N1ZSAjMS4uLlxuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHN1cGVyKCk7XG5cblx0XHRcdC8vIGg0Y2ssIG9rYXkgYmVjYXVzZSBKUyBpcyBtb25vdGhyZWFkZWQuXG5cdFx0XHRpZiggX19jc3RyX2hvc3QgPT09IG51bGwgKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgZG8gbm90IGRpcmVjdGx5IGNhbGwgdGhpcyBjb25zdHJ1Y3RvclwiKTtcblx0XHRcdHRoaXMuI2hvc3QgPSBfX2NzdHJfaG9zdDtcblx0XHRcdF9fY3N0cl9ob3N0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRwdWJsaWMgZ2V0IGhvc3QoKTogSG9zdCB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jaG9zdDtcblx0XHR9XG5cdFx0cHJvdGVjdGVkIGdldCBhdHRycygpIHtcblx0XHRcdHJldHVybiAodGhpcy4jaG9zdCBhcyBMSG9zdCkuYXR0cnM7XG5cdFx0fVxuXHRcdHByb3RlY3RlZCBzZXRBdHRyRGVmYXVsdCggYXR0cjogQXR0cnMsIHZhbHVlOiBzdHJpbmd8bnVsbCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLiNob3N0IGFzIExIb3N0KS5zZXRBdHRyRGVmYXVsdChhdHRyLCB2YWx1ZSk7XG5cblx0XHR9XG5cdFx0cHVibGljIGdldCBwYXJhbXMoKTogUmVhZG9ubHk8UGFyYW1ldGVycz4ge1xuXHRcdFx0cmV0dXJuICh0aGlzLiNob3N0IGFzIExIb3N0KS5wYXJhbXM7XG5cdFx0fVxuXHRcdHB1YmxpYyBzZXRQYXJhbTxUIGV4dGVuZHMga2V5b2YgUGFyYW1ldGVycz4obmFtZTogVCwgdmFsdWU6IFBhcmFtZXRlcnNbVF0pIHtcblx0XHRcdCh0aGlzLiNob3N0IGFzIExIb3N0KS5wYXJhbXNbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cdFx0cHJvdGVjdGVkIGdldCBjb250ZW50KCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLiNob3N0IGFzIExIb3N0KS5jb250ZW50ITtcblx0XHR9XG5cblx0XHRzdGF0aWMgcmVhZG9ubHkgUGFyYW1ldGVycyA9IHtcblx0XHRcdGhvc3QsXG5cdFx0XHRkZXBlbmRlbmNpZXMsXG5cdFx0XHRhdHRyaWJ1dGVzLFxuXHRcdFx0cGFyYW1zLFxuXHRcdFx0Y29udGVudCxcblx0XHRcdHN0eWxlc2hlZXRzLFxuXHRcdFx0c2hhZG93LFxuXHRcdH07XG5cblx0XHRwcm90ZWN0ZWQgb25BdHRyQ2hhbmdlZChfbmFtZTogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRcdF9vbGRWYWx1ZTogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRcdF9uZXdWYWx1ZTogc3RyaW5nKTogdm9pZHxmYWxzZSB7fVxuXG5cdFx0cHVibGljIGdldCBpc0luRE9NKCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLiNob3N0IGFzIExIb3N0KS5pc0luRE9NO1xuXHRcdH1cblx0XHRwcm90ZWN0ZWQgb25ET01Db25uZWN0ZWQoKSB7fVxuXHRcdHByb3RlY3RlZCBvbkRPTURpc2Nvbm5lY3RlZCgpIHt9XG5cdH1cblxuXHRyZXR1cm4gTElTU0Jhc2U7XG59XG5cbi8vVE9ETzogb3RoZXIgb3B0aW9ucy4uLlxuZnVuY3Rpb24gZXh0ZW5kc0xJU1M8RXh0ZW5kcyBleHRlbmRzIENsYXNzLFxuXHRIb3N0ICAgIGV4dGVuZHMgSFRNTEVsZW1lbnQsXG5cdEF0dHJzMSAgIGV4dGVuZHMgc3RyaW5nLFxuXHRBdHRyczIgICBleHRlbmRzIHN0cmluZyxcblx0UGFyYW1zICBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55Pixcblx0VCBleHRlbmRzIExJU1NSZXR1cm5UeXBlPEV4dGVuZHMsIEhvc3QsIEF0dHJzMSwgUGFyYW1zPj4oTGlzczogVCxcblx0XHRwYXJhbWV0ZXJzOiB7XG5cdFx0XHRzaGFkb3cgICAgICA/OiBTaGFkb3dDZmcsXG5cdFx0XHRhdHRyaWJ1dGVzICA/OiByZWFkb25seSBBdHRyczJbXSxcblx0XHRcdGRlcGVuZGVuY2llcz86IHJlYWRvbmx5IFByb21pc2U8YW55PltdXG5cdFx0fSkge1xuXG5cdGNvbnN0IGF0dHJpYnV0ZXMgICA9IFsuLi5MaXNzLlBhcmFtZXRlcnMuYXR0cmlidXRlcyAgLCAuLi5wYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgID8/W11dO1xuXHRjb25zdCBkZXBlbmRlbmNpZXMgPSBbLi4uTGlzcy5QYXJhbWV0ZXJzLmRlcGVuZGVuY2llcywgLi4ucGFyYW1ldGVycy5kZXBlbmRlbmNpZXM/P1tdXTtcblxuXHRjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBMaXNzLlBhcmFtZXRlcnMsIHtcblx0XHRhdHRyaWJ1dGVzLFxuXHRcdGRlcGVuZGVuY2llc1xuXHR9KTtcblx0aWYoIHBhcmFtZXRlcnMuc2hhZG93ICE9PSB1bmRlZmluZWQpXG5cdFx0cGFyYW1zLnNoYWRvdyA9IHBhcmFtZXRlcnMuc2hhZG93O1xuXG5cdC8vIEB0cy1pZ25vcmUgOiBiZWNhdXNlIFRTIHN0dXBpZFxuXHRjbGFzcyBFeHRlbmRlZExJU1MgZXh0ZW5kcyBMaXNzIHtcblx0XHRjb25zdHJ1Y3RvciguLi50OiBhbnlbXSkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSA6IGJlY2F1c2UgVFMgc3R1cGlkXG5cdFx0XHRzdXBlciguLi50KTtcblx0XHR9XG5cblx0XHRwcm90ZWN0ZWQgb3ZlcnJpZGUgZ2V0IGF0dHJzKCkge1xuXHRcdFx0cmV0dXJuIHN1cGVyLmF0dHJzIGFzIFJlY29yZDxBdHRyczJ8QXR0cnMxLCBzdHJpbmd8bnVsbD47XG5cdFx0fVxuXG5cdFx0c3RhdGljIG92ZXJyaWRlIFBhcmFtZXRlcnMgPSBwYXJhbXM7XG5cdH1cblxuXHRyZXR1cm4gRXh0ZW5kZWRMSVNTO1xufVxuTElTUy5leHRlbmRzTElTUyA9IGV4dGVuZHNMSVNTO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTIHR5cGUgaGVscGVycyA9PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnR5cGUgYnVpbGRMSVNTSG9zdFJldHVyblR5cGU8VD4gID0gVCBleHRlbmRzIExJU1NSZXR1cm5UeXBlPGluZmVyIEV4dGVuZHMgZXh0ZW5kcyBDbGFzcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZmVyIEhvc3QgICAgZXh0ZW5kcyBIVE1MRWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZmVyIEF0dHJzICAgZXh0ZW5kcyBzdHJpbmcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbmZlciBQYXJhbXMgIGV4dGVuZHMgUmVjb3JkPHN0cmluZyxhbnk+PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PyBSZXR1cm5UeXBlPHR5cGVvZiBidWlsZExJU1NIb3N0PEV4dGVuZHMsIEhvc3QsIEF0dHJzLCBQYXJhbXMsIFQ+PiA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBMSVNTUmV0dXJuVHlwZTxcblx0RXh0ZW5kcyBleHRlbmRzIENsYXNzLFxuXHRIb3N0ICAgIGV4dGVuZHMgSFRNTEVsZW1lbnQsXG5cdEF0dHJzICAgZXh0ZW5kcyBzdHJpbmcsXG5cdFBhcmFtcyAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLGFueT4+ID0gUmV0dXJuVHlwZTx0eXBlb2YgTElTUzxFeHRlbmRzLCBIb3N0LCBBdHRycywgUGFyYW1zPj47XG5leHBvcnQgdHlwZSBMSVNTQmFzZTxFeHRlbmRzIGV4dGVuZHMgQ2xhc3MsXG5cdFx0XHRcdFx0IEhvc3QgICAgZXh0ZW5kcyBIVE1MRWxlbWVudCxcblx0XHRcdFx0XHQgQXR0cnMgICBleHRlbmRzIHN0cmluZyxcblx0XHRcdFx0XHQgUGFyYW1zICBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55Pj4gPSBJbnN0YW5jZVR5cGU8TElTU1JldHVyblR5cGU8RXh0ZW5kcywgSG9zdCwgQXR0cnMsIFBhcmFtcz4+O1xuZXhwb3J0IHR5cGUgTElTU0hvc3Q8TElTUyBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4gPiA9IEluc3RhbmNlVHlwZTxidWlsZExJU1NIb3N0UmV0dXJuVHlwZTxDb25zdHJ1Y3RvcjxMSVNTPiAmIHtQYXJhbWV0ZXJzOiBhbnl9Pj47XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1NIb3N0IGNsYXNzID09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxubGV0IGlkID0gMDtcblxuZnVuY3Rpb24gYnVpbGRMSVNTSG9zdDxFeHRlbmRzIGV4dGVuZHMgQ2xhc3MsXG5cdFx0XHRcdFx0ICAgSG9zdCAgICBleHRlbmRzIEhUTUxFbGVtZW50LFxuXHRcdFx0XHRcdCAgIEF0dHJzICAgZXh0ZW5kcyBzdHJpbmcsXG5cdFx0XHRcdFx0ICAgUGFyYW1zICBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55Pixcblx0XHRcdFx0XHQgICBUIGV4dGVuZHMgTElTU1JldHVyblR5cGU8RXh0ZW5kcywgSG9zdCwgQXR0cnMsIFBhcmFtcz4+KExpc3M6IFQsIF9wYXJhbXM6IFBhcnRpYWw8UGFyYW1zPiA9IHt9KSB7XG5cdGNvbnN0IHtcblx0XHRob3N0LFxuXHRcdGF0dHJpYnV0ZXMsXG5cdFx0Y29udGVudCxcblx0XHRzdHlsZXNoZWV0cyxcblx0XHRzaGFkb3csXG5cdH0gPSBMaXNzLlBhcmFtZXRlcnM7XG5cblx0Y29uc3QgYWxyZWFkeURlY2xhcmVkQ1NTID0gbmV3IFNldCgpO1xuXG5cdGNvbnN0IEdFVCA9IFN5bWJvbCgnZ2V0Jyk7XG5cdGNvbnN0IFNFVCA9IFN5bWJvbCgnc2V0Jyk7XG5cblx0Y29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5mcm9tRW50cmllcyggYXR0cmlidXRlcy5tYXAobiA9PiBbbiwge1xuXG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uKCk6IHN0cmluZ3xudWxsICAgICAgeyByZXR1cm4gKHRoaXMgYXMgdW5rbm93biBhcyBBdHRyaWJ1dGVzKVtHRVRdKG4pOyB9LFxuXHRcdHNldDogZnVuY3Rpb24odmFsdWU6IHN0cmluZ3xudWxsKSB7IHJldHVybiAodGhpcyBhcyB1bmtub3duIGFzIEF0dHJpYnV0ZXMpW1NFVF0obiwgdmFsdWUpOyB9XG5cdH1dKSApO1xuXG5cdGNsYXNzIEF0dHJpYnV0ZXMge1xuICAgICAgICBbeDogc3RyaW5nXTogc3RyaW5nfG51bGw7XG5cbiAgICAgICAgI2RhdGEgICAgIDogUmVjb3JkPEF0dHJzLCBzdHJpbmd8bnVsbD47XG4gICAgICAgICNkZWZhdWx0cyA6IFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+O1xuICAgICAgICAjc2V0dGVyICAgOiAobmFtZTogQXR0cnMsIHZhbHVlOiBzdHJpbmd8bnVsbCkgPT4gdm9pZDtcblxuICAgICAgICBbR0VUXShuYW1lOiBBdHRycykge1xuICAgICAgICBcdHJldHVybiB0aGlzLiNkYXRhW25hbWVdID8/IHRoaXMuI2RlZmF1bHRzW25hbWVdID8/IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFtTRVRdKG5hbWU6IEF0dHJzLCB2YWx1ZTogc3RyaW5nfG51bGwpe1xuICAgICAgICBcdHJldHVybiB0aGlzLiNzZXR0ZXIobmFtZSwgdmFsdWUpOyAvLyByZXF1aXJlZCB0byBnZXQgYSBjbGVhbiBvYmplY3Qgd2hlbiBkb2luZyB7Li4uYXR0cnN9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhICAgIDogUmVjb3JkPEF0dHJzLCBzdHJpbmd8bnVsbD4sXG5cdFx0XHRcdFx0ZGVmYXVsdHM6IFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+LFxuICAgICAgICBcdFx0XHRzZXR0ZXIgIDogKG5hbWU6IEF0dHJzLCB2YWx1ZTogc3RyaW5nfG51bGwpID0+IHZvaWQpIHtcblxuICAgICAgICBcdHRoaXMuI2RhdGEgICAgID0gZGF0YTtcblx0XHRcdHRoaXMuI2RlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIFx0dGhpcy4jc2V0dGVyID0gc2V0dGVyO1xuXG4gICAgICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgcHJvcGVydGllcyk7XG4gICAgICAgIH1cblx0fVxuXG5cdC8vIEB0cy1pZ25vcmUgOiBiZWNhdXNlIFRTIGlzIHN0dXBpZC5cblx0Y2xhc3MgTElTU0hvc3RCYXNlIGV4dGVuZHMgaG9zdCB7XG5cblx0XHRyZWFkb25seSAjcGFyYW1zOiBQYXJhbXM7XG5cblx0XHRyZWFkb25seSAjaWQgPSArK2lkOyAvLyBmb3IgZGVidWdcblxuXHRcdGNvbnN0cnVjdG9yKHBhcmFtczogUGFydGlhbDxQYXJhbXM+ID0ge30pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiNwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBMaXNzLlBhcmFtZXRlcnMucGFyYW1zLCBfcGFyYW1zLCBwYXJhbXMpO1xuXG5cdFx0XHR0aGlzLiN3YWl0SW5pdCA9IG5ldyBQcm9taXNlKCAocmVzb2x2ZSkgPT4ge1xuXHRcdFx0XHRpZih0aGlzLmlzSW5pdClcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZSh0aGlzLiNBUEkhKTtcblx0XHRcdFx0dGhpcy4jcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKioqKiBwdWJsaWMgQVBJICoqKioqKioqKioqKiovXG5cblx0XHRnZXQgaXNJbml0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuI0FQSSAhPT0gbnVsbDtcblx0XHR9XG5cdFx0aW5pdGlhbGl6ZShwYXJhbXM6IFBhcnRpYWw8UGFyYW1zPiA9IHt9KSB7XG5cblx0XHRcdGlmKCB0aGlzLmlzSW5pdCApXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRWxlbWVudCBhbHJlYWR5IGluaXRpYWxpemVkIScpO1xuXG5cdFx0XHRPYmplY3QuYXNzaWduKHRoaXMuI3BhcmFtcywgcGFyYW1zKTtcblxuXHRcdFx0Y29uc3QgYXBpID0gdGhpcy5pbml0KCk7XG5cblx0XHRcdGlmKCB0aGlzLiNpc0luRE9NIClcblx0XHRcdFx0KGFwaSBhcyBhbnkpLm9uRE9NQ29ubmVjdGVkKCk7XG5cblx0XHRcdHJldHVybiBhcGk7XG5cdFx0fVxuXG5cdFx0Z2V0IExJU1NTeW5jKCkge1xuXHRcdFx0aWYoICEgdGhpcy5pc0luaXQgKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FjY2Vzc2luZyBBUEkgYmVmb3JlIFdlYkNvbXBvbmVudCBpbml0aWFsaXphdGlvbiEnKTtcblx0XHRcdHJldHVybiB0aGlzLiNBUEkhO1xuXHRcdH1cblx0XHRnZXQgTElTUygpIHtcblx0XHRcdHJldHVybiB0aGlzLiN3YWl0SW5pdDtcblx0XHR9XG5cblx0XHQvKioqIGluaXQgKioqL1xuXHRcdCN3YWl0SW5pdDogUHJvbWlzZTxJbnN0YW5jZVR5cGU8VD4+O1xuXHRcdCNyZXNvbHZlOiAoKHU6IEluc3RhbmNlVHlwZTxUPikgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcblx0XHQjQVBJOiBJbnN0YW5jZVR5cGU8VD4gfCBudWxsID0gbnVsbDtcblxuXHRcdCNpc0luRE9NID0gZmFsc2U7XG5cdFx0Z2V0IGlzSW5ET00oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jaXNJbkRPTTtcblx0XHR9XG5cblx0XHRkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuI2lzSW5ET00gPSBmYWxzZTtcblx0XHRcdCh0aGlzLiNBUEkhIGFzIGFueSkub25ET01EaXNjb25uZWN0ZWQoKTtcblx0XHR9XG5cblx0XHRjb25uZWN0ZWRDYWxsYmFjaygpIHtcblxuXHRcdFx0dGhpcy4jaXNJbkRPTSA9IHRydWU7XG5cdFxuXHRcdFx0aWYoICEgdGhpcy5pc0luaXQgKVxuXHRcdFx0XHR0aGlzLmluaXQoKTtcblxuXHRcdFx0KHRoaXMuI0FQSSEgYXMgYW55KS5vbkRPTUNvbm5lY3RlZCgpO1xuXHRcdH1cblxuXHRcdHByaXZhdGUgaW5pdCgpIHtcblx0XHRcdFxuXHRcdFx0Y3VzdG9tRWxlbWVudHMudXBncmFkZSh0aGlzKTtcblx0XHRcdFxuXHRcdFx0Ly8gc2hhZG93XG5cdFx0XHR0aGlzLiNjb250ZW50ID0gdGhpcyBhcyB1bmtub3duIGFzIEhvc3Q7XG5cdFx0XHRpZiggc2hhZG93ICE9PSAnbm9uZScpIHtcblx0XHRcdFx0dGhpcy4jY29udGVudCA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiBzaGFkb3d9KTtcblxuXHRcdFx0XHQvL0B0cy1pZ25vcmVcblx0XHRcdFx0dGhpcy4jY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2tFdmVudCk7XG5cdFx0XHRcdC8vQHRzLWlnbm9yZVxuXHRcdFx0XHR0aGlzLiNjb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgb25DbGlja0V2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXR0cnNcblx0XHRcdGZvcihsZXQgb2JzIG9mIGF0dHJpYnV0ZXMhKVxuXHRcdFx0XHR0aGlzLiNhdHRyaWJ1dGVzW29ic10gPSB0aGlzLmdldEF0dHJpYnV0ZShvYnMpO1xuXG5cdFx0XHQvLyBjc3Ncblx0XHRcdGlmKCBzaGFkb3cgIT09ICdub25lJylcblx0XHRcdFx0KHRoaXMuI2NvbnRlbnQgYXMgU2hhZG93Um9vdCkuYWRvcHRlZFN0eWxlU2hlZXRzLnB1c2goc2hhcmVkQ1NTKTtcblx0XHRcdGlmKCBzdHlsZXNoZWV0cy5sZW5ndGggKSB7XG5cblx0XHRcdFx0aWYoIHNoYWRvdyAhPT0gJ25vbmUnKVxuXHRcdFx0XHRcdCh0aGlzLiNjb250ZW50IGFzIFNoYWRvd1Jvb3QpLmFkb3B0ZWRTdHlsZVNoZWV0cy5wdXNoKC4uLnN0eWxlc2hlZXRzKTtcblx0XHRcdFx0ZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zdCBjc3NzZWxlY3RvciA9IHRoaXMuQ1NTU2VsZWN0b3I7XG5cblx0XHRcdFx0XHQvLyBpZiBub3QgeWV0IGluc2VydGVkIDpcblx0XHRcdFx0XHRpZiggISBhbHJlYWR5RGVjbGFyZWRDU1MuaGFzKGNzc3NlbGVjdG9yKSApIHtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0bGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuXHRcdFx0XHRcdFx0c3R5bGUuc2V0QXR0cmlidXRlKCdmb3InLCBjc3NzZWxlY3Rvcik7XG5cblx0XHRcdFx0XHRcdGxldCBodG1sX3N0eWxlc2hlZXRzID0gXCJcIjtcblxuXHRcdFx0XHRcdFx0Zm9yKGxldCBzdHlsZSBvZiBzdHlsZXNoZWV0cylcblx0XHRcdFx0XHRcdFx0Zm9yKGxldCBydWxlIG9mIHN0eWxlLmNzc1J1bGVzKVxuXHRcdFx0XHRcdFx0XHRcdGh0bWxfc3R5bGVzaGVldHMgKz0gcnVsZS5jc3NUZXh0ICsgJ1xcbic7XG5cblx0XHRcdFx0XHRcdHN0eWxlLmlubmVySFRNTCA9IGh0bWxfc3R5bGVzaGVldHMucmVwbGFjZSgnOmhvc3QnLCBgOmlzKCR7Y3Nzc2VsZWN0b3J9KWApO1xuXG5cdFx0XHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZChzdHlsZSk7XG5cblx0XHRcdFx0XHRcdGFscmVhZHlEZWNsYXJlZENTUy5hZGQoY3Nzc2VsZWN0b3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb250ZW50XG5cdFx0XHRpZiggY29udGVudCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRsZXQgdGVtcGxhdGVfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5cdFx0XHRcdGxldCBzdHIgPSAoY29udGVudCBhcyBzdHJpbmcpLnJlcGxhY2UoL1xcJFxceyguKz8pXFx9L2csIChfLCBtYXRjaCkgPT4gdGhpcy5nZXRBdHRyaWJ1dGUobWF0Y2gpPz8nJylcblx0ICAgIFx0XHR0ZW1wbGF0ZV9lbGVtLmlubmVySFRNTCA9IHN0cjtcblx0ICAgIFx0XHR0aGlzLiNjb250ZW50LmFwcGVuZCguLi50ZW1wbGF0ZV9lbGVtLmNvbnRlbnQuY2hpbGROb2Rlcyk7XG5cdCAgICBcdH1cblxuXHQgICAgXHQvLyBidWlsZFxuXG5cdCAgICBcdC8vIGg0Y2ssIG9rYXkgYmVjYXVzZSBKUyBpcyBtb25vdGhyZWFkZWQuXG5cdFx0XHRfX2NzdHJfaG9zdCAgID0gdGhpcztcblxuXHQgICAgXHRsZXQgb2JqID0gbmV3IExpc3MoKTtcblxuXHQgICAgXHQvKmlmKCBvYmogaW5zdGFuY2VvZiBQcm9taXNlKVxuXHQgICAgXHRcdG9iaiA9IGF3YWl0IG9iajsqL1xuXG5cdFx0XHR0aGlzLiNBUEkgPSBvYmogYXMgSW5zdGFuY2VUeXBlPFQ+O1xuXG5cdFx0XHQvLyBkZWZhdWx0IHNsb3Rcblx0XHRcdGlmKCB0aGlzLmhhc1NoYWRvdyAmJiB0aGlzLiNjb250ZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwIClcblx0XHRcdFx0dGhpcy4jY29udGVudC5hcHBlbmQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Nsb3QnKSApO1xuXG5cdFx0XHRpZiggdGhpcy4jcmVzb2x2ZSAhPT0gbnVsbClcblx0XHRcdFx0dGhpcy4jcmVzb2x2ZSh0aGlzLiNBUEkpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy4jQVBJO1xuXHRcdH1cblxuXHRcdGdldCBwYXJhbXMoKTogUGFyYW1zIHtcblx0XHRcdHJldHVybiB0aGlzLiNwYXJhbXM7XG5cdFx0fVxuXHRcdHB1YmxpYyBzZXRQYXJhbTxUIGV4dGVuZHMga2V5b2YgUGFyYW1zPihuYW1lOiBULCB2YWx1ZTogUGFyYW1zW1RdKSB7XG5cdFx0XHRpZiggdGhpcy5pc0luaXQgKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy4jQVBJIS5zZXRQYXJhbShuYW1lLCB2YWx1ZSk7XG5cblx0XHRcdHRoaXMuI3BhcmFtc1tuYW1lXSA9IHZhbHVlOyAvLyB3aWxsIGJlIGdpdmVuIHRvIGNvbnN0cnVjdG9yLlxuXHRcdH1cblxuXG5cdFx0LyoqKiBjb250ZW50ICoqKi9cblx0XHQjY29udGVudDogSG9zdHxTaGFkb3dSb290fG51bGwgPSBudWxsO1xuXG5cdFx0Z2V0IGNvbnRlbnQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jY29udGVudDtcblx0XHR9XG5cblx0XHRnZXRQYXJ0KG5hbWU6IHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHRoaXMuaGFzU2hhZG93XG5cdFx0XHRcdFx0PyB0aGlzLiNjb250ZW50Py5xdWVyeVNlbGVjdG9yKGA6OnBhcnQoJHtuYW1lfSlgKVxuXHRcdFx0XHRcdDogdGhpcy4jY29udGVudD8ucXVlcnlTZWxlY3RvcihgW3BhcnQ9XCIke25hbWV9XCJdYCk7XG5cdFx0fVxuXHRcdGdldFBhcnRzKG5hbWU6IHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHRoaXMuaGFzU2hhZG93XG5cdFx0XHRcdFx0PyB0aGlzLiNjb250ZW50Py5xdWVyeVNlbGVjdG9yQWxsKGA6OnBhcnQoJHtuYW1lfSlgKVxuXHRcdFx0XHRcdDogdGhpcy4jY29udGVudD8ucXVlcnlTZWxlY3RvckFsbChgW3BhcnQ9XCIke25hbWV9XCJdYCk7XG5cdFx0fVxuXG5cdFx0cHJvdGVjdGVkIGdldCBoYXNTaGFkb3coKTogYm9vbGVhbiB7XG5cdFx0XHRyZXR1cm4gc2hhZG93ICE9PSAnbm9uZSc7XG5cdFx0fVxuXG5cdFx0LyoqKiBDU1MgKioqL1xuXG5cdFx0Z2V0IENTU1NlbGVjdG9yKCkge1xuXG5cdFx0XHRpZih0aGlzLmhhc1NoYWRvdyB8fCAhIHRoaXMuaGFzQXR0cmlidXRlKFwiaXNcIikgKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy50YWdOYW1lO1xuXG5cdFx0XHRyZXR1cm4gYCR7dGhpcy50YWdOYW1lfVtpcz1cIiR7dGhpcy5nZXRBdHRyaWJ1dGUoXCJpc1wiKX1cIl1gO1xuXHRcdH1cblxuXHRcdC8qKiogYXR0cnMgKioqL1xuXHRcdCNhdHRyc19mbGFnID0gZmFsc2U7XG5cblx0XHQjYXR0cmlidXRlcyAgICAgICAgID0ge30gYXMgUmVjb3JkPEF0dHJzLCBzdHJpbmd8bnVsbD47XG5cdFx0I2F0dHJpYnV0ZXNEZWZhdWx0cyA9IHt9IGFzIFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+O1xuXHRcdCNhdHRycyA9IG5ldyBBdHRyaWJ1dGVzKFxuXHRcdFx0dGhpcy4jYXR0cmlidXRlcyxcblx0XHRcdHRoaXMuI2F0dHJpYnV0ZXNEZWZhdWx0cyxcblx0XHRcdChuYW1lOiBBdHRycywgdmFsdWU6c3RyaW5nfG51bGwpID0+IHtcblxuXHRcdFx0XHR0aGlzLiNhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cblx0XHRcdFx0dGhpcy4jYXR0cnNfZmxhZyA9IHRydWU7IC8vIGRvIG5vdCB0cmlnZ2VyIG9uQXR0cnNDaGFuZ2VkLlxuXHRcdFx0XHRpZiggdmFsdWUgPT09IG51bGwpXG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0KSBhcyB1bmtub3duIGFzIFJlY29yZDxBdHRycywgc3RyaW5nfG51bGw+O1xuXG5cdFx0c2V0QXR0ckRlZmF1bHQobmFtZTogQXR0cnMsIHZhbHVlOiBzdHJpbmd8bnVsbCkge1xuXHRcdFx0aWYoIHZhbHVlID09PSBudWxsKVxuXHRcdFx0XHRkZWxldGUgdGhpcy4jYXR0cmlidXRlc0RlZmF1bHRzW25hbWVdO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLiNhdHRyaWJ1dGVzRGVmYXVsdHNbbmFtZV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRnZXQgYXR0cnMoKTogUmVhZG9ubHk8UmVjb3JkPEF0dHJzLCBzdHJpbmd8bnVsbD4+IHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuI2F0dHJzO1xuXHRcdH1cblxuXHRcdHN0YXRpYyBvYnNlcnZlZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXHRcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lICAgIDogQXR0cnMsXG5cdFx0XHRcdFx0XHRcdFx0IG9sZFZhbHVlOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRcdFx0IG5ld1ZhbHVlOiBzdHJpbmcpIHtcblxuXHRcdFx0aWYodGhpcy4jYXR0cnNfZmxhZykge1xuXHRcdFx0XHR0aGlzLiNhdHRyc19mbGFnID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy4jYXR0cmlidXRlc1tuYW1lXSA9IG5ld1ZhbHVlO1xuXHRcdFx0aWYoICEgdGhpcy5pc0luaXQgKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmKCAodGhpcy4jQVBJISBhcyBhbnkpLm9uQXR0ckNoYW5nZWQobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy4jYXR0cnNbbmFtZV0gPSBvbGRWYWx1ZTsgLy8gcmV2ZXJ0IHRoZSBjaGFuZ2UuXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBMSVNTSG9zdEJhc2U7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgZGVmaW5lID09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgX0RPTUNvbnRlbnRMb2FkZWQgPSBuZXcgUHJvbWlzZTx2b2lkPiggKHJlc29sdmUpID0+IHtcblxuXHRpZihkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKVxuXHRcdHJldHVybiByZXNvbHZlKCk7XG5cblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcblx0XHRyZXNvbHZlKCk7XG5cdH0sIHRydWUpO1xufSk7XG5cbkxJU1MuZGVmaW5lID0gYXN5bmMgZnVuY3Rpb248RXh0ZW5kcyBleHRlbmRzIENsYXNzLFxuXHRcdFx0XHRcdFx0XHQgSG9zdCAgICBleHRlbmRzIEhUTUxFbGVtZW50LFxuXHRcdFx0XHRcdFx0ICAgICBBdHRycyAgIGV4dGVuZHMgc3RyaW5nLFxuXHRcdFx0XHRcdFx0ICAgICBQYXJhbXMgIGV4dGVuZHMgUmVjb3JkPHN0cmluZyxhbnk+LFxuXHRcdFx0XHRcdFx0ICAgXHQgVCBleHRlbmRzIExJU1NSZXR1cm5UeXBlPEV4dGVuZHMsIEhvc3QsIEF0dHJzLCBQYXJhbXM+Pihcblx0XHRcdFx0XHRcdCAgIFx0dGFnbmFtZTogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRDb21wb25lbnRDbGFzczogVCxcblx0XHRcdFx0XHRcdFx0e2RlcGVuZGVuY2llcywgcGFyYW1zfToge3BhcmFtcz86IFBhcnRpYWw8UGFyYW1zPiwgZGVwZW5kZW5jaWVzPzogcmVhZG9ubHkgUHJvbWlzZTxzdHJpbmc+W119ID0ge30pIHtcblxuXHRkZXBlbmRlbmNpZXM/Pz1bXTtcblx0cGFyYW1zICAgICAgPz89IHt9O1xuXG5cdGNvbnN0IENsYXNzID0gQ29tcG9uZW50Q2xhc3MuUGFyYW1ldGVycy5ob3N0O1xuXHRsZXQgTElTU0Jhc2U6IGFueSA9IENvbXBvbmVudENsYXNzO1xuXHRsZXQgaHRtbHRhZyA9IF9lbGVtZW50MnRhZ25hbWUoQ2xhc3MpPz91bmRlZmluZWQ7XG5cblx0YXdhaXQgUHJvbWlzZS5hbGwoW19ET01Db250ZW50TG9hZGVkLCAuLi5kZXBlbmRlbmNpZXMsIC4uLkxJU1NCYXNlLlBhcmFtZXRlcnMuZGVwZW5kZW5jaWVzXSk7XG5cblx0Y29uc3QgTElTU2NsYXNzID0gYnVpbGRMSVNTSG9zdDxFeHRlbmRzLCBIb3N0LCBBdHRycywgUGFyYW1zLCBUPihDb21wb25lbnRDbGFzcywgcGFyYW1zKTtcblx0XG5cdGNvbnN0IG9wdHMgPSBodG1sdGFnID09PSB1bmRlZmluZWQgPyB7fVxuXHRcdFx0XHRcdFx0XHRcdFx0ICAgOiB7ZXh0ZW5kczogaHRtbHRhZ307XG5cdFxuXHRjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnbmFtZSwgTElTU2NsYXNzLCBvcHRzKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgU2hhZG93Um9vdCB0b29scyA9PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3Qgc2hhcmVkQ1NTID0gbmV3IENTU1N0eWxlU2hlZXQoKTtcbmRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5wdXNoKHNoYXJlZENTUyk7XG5cbkxJU1MuaW5zZXJ0R2xvYmFsQ1NTUnVsZXMgPSBmdW5jdGlvbihjc3M6IHN0cmluZ3xIVE1MU3R5bGVFbGVtZW50KSB7XG5cblx0bGV0IGNzc19zdHlsZSE6IENTU1N0eWxlU2hlZXQ7XG5cblx0aWYoIGNzcyBpbnN0YW5jZW9mIEhUTUxTdHlsZUVsZW1lbnQgKVxuXHRcdGNzc19zdHlsZSA9IGNzcy5zaGVldCE7XG5cdGlmKCB0eXBlb2YgY3NzID09PSBcInN0cmluZ1wiKSB7XG5cdFx0Y3NzX3N0eWxlID0gbmV3IENTU1N0eWxlU2hlZXQoKTtcblx0XHRjc3Nfc3R5bGUucmVwbGFjZVN5bmMoY3NzKTtcblx0fVxuXG5cdGZvcihsZXQgcnVsZSBvZiBjc3Nfc3R5bGUuY3NzUnVsZXMpXG5cdFx0c2hhcmVkQ1NTLmluc2VydFJ1bGUocnVsZS5jc3NUZXh0KTtcbn1cblxudHlwZSBEZWxlZ2F0ZWRIYW5kbGVyID0gW3N0cmluZywgKGV2OiBNb3VzZUV2ZW50KSA9PiB2b2lkXTtcbmNvbnN0IERFTEVHQVRFRF9FVkVOVFMgPSB7XG5cdFwiY2xpY2tcIjogW10gYXMgRGVsZWdhdGVkSGFuZGxlcltdLFxuXHRcImRibGNsaWNrXCI6IFtdIGFzIERlbGVnYXRlZEhhbmRsZXJbXVxufTtcblxuY29uc3QgQUxSRUFEWV9QUk9DRVNTRUQgPSBTeW1ib2woKTtcblxuZnVuY3Rpb24gb25DbGlja0V2ZW50KGV2OiBNb3VzZUV2ZW50KSB7XG5cblx0aWYoIChldiBhcyBhbnkpW0FMUkVBRFlfUFJPQ0VTU0VEXSA9PT0gdHJ1ZSApXG5cdFx0cmV0dXJuO1xuXHQoZXYgYXMgYW55KVtBTFJFQURZX1BST0NFU1NFRF0gPSB0cnVlO1xuXG5cdGNvbnN0IGhhbmRsZXJzID0gREVMRUdBVEVEX0VWRU5UU1tldi50eXBlIGFzIGtleW9mIHR5cGVvZiBERUxFR0FURURfRVZFTlRTXTtcblxuXHRmb3IobGV0IGVsZW0gb2YgZXYuY29tcG9zZWRQYXRoKCkgKSB7XG5cdFxuXHRcdGlmKCBlbGVtIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fCBlbGVtID09PSBkb2N1bWVudCB8fCBlbGVtID09PSB3aW5kb3cgKVxuXHRcdFx0Y29udGludWU7XG5cblx0XHR2YXIgdGFyZ2V0ID0gZWxlbSBhcyBFbGVtZW50O1xuXG5cdFx0Zm9yKGxldCBbc2VsZWN0b3IsIGhhbmRsZXJdIG9mIGhhbmRsZXJzKSB7XG5cdFx0XHRpZiggdGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpIClcblx0XHRcdFx0aGFuZGxlcihldik7XG5cdFx0fVxuXHR9XG59XG5cbkxJU1MuaW5zZXJ0R2xvYmFsRGVsZWdhdGVkTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudF9uYW1lOiBrZXlvZiB0eXBlb2YgREVMRUdBVEVEX0VWRU5UUywgc2VsZWN0b3I6IHN0cmluZywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB2b2lkICkge1xuXHRERUxFR0FURURfRVZFTlRTW2V2ZW50X25hbWVdLnB1c2goW3NlbGVjdG9yLCBoYW5kbGVyXSlcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrRXZlbnQpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBvbkNsaWNrRXZlbnQpO1xuXG5MSVNTLmNsb3Nlc3QgPSBmdW5jdGlvbiBjbG9zZXN0PEUgZXh0ZW5kcyBFbGVtZW50PihzZWxlY3Rvcjogc3RyaW5nLCBlbGVtZW50OiBFbGVtZW50KSB7XG5cblx0d2hpbGUodHJ1ZSkge1xuXHRcdHZhciByZXN1bHQgPSBlbGVtZW50LmNsb3Nlc3Q8RT4oc2VsZWN0b3IpO1xuXG5cdFx0aWYoIHJlc3VsdCAhPT0gbnVsbClcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuXHRcdGlmKCAhIChcImhvc3RcIiBpbiByb290KSApXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdGVsZW1lbnQgPSAocm9vdCBhcyBTaGFkb3dSb290KS5ob3N0O1xuXHR9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgaGVscGVycyA9PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudHlwZSBpbmZlclBhcmFtczxUPiA9IFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSwgaW5mZXIgUCBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55Pj4gPyBQIDogbmV2ZXI7XG5cbnR5cGUgQlVJTERfT1BUSU9OUzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4gPSBQYXJ0aWFsPHtcblx0XHRcdFx0XHQgIFx0cGFyYW1zICAgIDogUGFydGlhbDxpbmZlclBhcmFtczxUPj4sXG5cdFx0XHRcdFx0ICBcdGNvbnRlbnRcdCAgOiBzdHJpbmd8Tm9kZXxyZWFkb25seSBOb2RlW10sXG5cdFx0XHRcdFx0XHRpZCBcdFx0ICA6IHN0cmluZyxcblx0XHRcdFx0XHQgIFx0Y2xhc3Nlc1x0ICA6IHJlYWRvbmx5IHN0cmluZ1tdLFxuXHRcdFx0XHRcdCAgXHRjc3N2YXJzICAgOiBSZWFkb25seTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+Pixcblx0XHRcdFx0XHQgIFx0YXR0cnMgXHQgIDogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+Pixcblx0XHRcdFx0XHQgIFx0ZGF0YSBcdCAgOiBSZWFkb25seTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmd8Ym9vbGVhbj4+LFxuXHRcdFx0XHRcdCAgXHRsaXN0ZW5lcnMgOiBSZWFkb25seTxSZWNvcmQ8c3RyaW5nLCAoZXY6IEV2ZW50KSA9PiB2b2lkPj5cblx0XHRcdFx0XHR9PiAmICh7XG5cdFx0XHRcdFx0XHRpbml0aWFsaXplOiBmYWxzZSxcblx0XHRcdFx0XHRcdHBhcmVudDogRWxlbWVudFxuXHRcdFx0XHRcdH18e1xuXHRcdFx0XHRcdFx0aW5pdGlhbGl6ZT86IHRydWUsXG5cdFx0XHRcdFx0XHRwYXJlbnQ/OiBFbGVtZW50XG5cdFx0XHRcdFx0fSk7XG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkPFQgZXh0ZW5kcyBrZXlvZiBDb21wb25lbnRzPih0YWduYW1lOiBULCBvcHRpb25zPzogQlVJTERfT1BUSU9OUzxDb21wb25lbnRzW1RdPik6IFByb21pc2U8Q29tcG9uZW50c1tUXT47XG5hc3luYyBmdW5jdGlvbiBidWlsZDxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4odGFnbmFtZTogc3RyaW5nLCBvcHRpb25zPzogQlVJTERfT1BUSU9OUzxUPik6IFByb21pc2U8VD47XG5hc3luYyBmdW5jdGlvbiBidWlsZDxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4odGFnbmFtZTogc3RyaW5nLCB7XG5cdFx0cGFyYW1zICAgID0ge30sXG5cdFx0aW5pdGlhbGl6ZT0gdHJ1ZSxcblx0XHRjb250ZW50ICAgPSBbXSxcblx0XHRwYXJlbnQgICAgPSB1bmRlZmluZWQsXG5cdFx0aWQgXHRcdCAgPSB1bmRlZmluZWQsXG5cdFx0Y2xhc3NlcyAgID0gW10sXG5cdFx0Y3NzdmFycyAgID0ge30sXG5cdFx0YXR0cnMgICAgID0ge30sXG5cdFx0ZGF0YSBcdCAgPSB7fSxcblx0XHRsaXN0ZW5lcnMgPSB7fVxuXHR9OiBCVUlMRF9PUFRJT05TPFQ+ID0ge30pOiBQcm9taXNlPFQ+IHtcblxuXHRpZiggISBpbml0aWFsaXplICYmIHBhcmVudCA9PT0gbnVsbClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBIHBhcmVudCBtdXN0IGJlIGdpdmVuIGlmIGluaXRpYWxpemUgaXMgZmFsc2VcIik7XG5cblx0bGV0IEN1c3RvbUNsYXNzID0gYXdhaXQgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQodGFnbmFtZSk7XG5cdGxldCBlbGVtID0gbmV3IEN1c3RvbUNsYXNzKHBhcmFtcykgYXMgTElTU0hvc3Q8VD47XG5cblx0Ly8gRml4IGlzc3VlICMyXG5cdGlmKCBlbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGFnbmFtZSApXG5cdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoXCJpc1wiLCB0YWduYW1lKTtcblxuXHRpZiggaWQgIT09IHVuZGVmaW5lZCApXG5cdFx0ZWxlbS5pZCA9IGlkO1xuXG5cdGlmKCBjbGFzc2VzLmxlbmd0aCA+IDApXG5cdFx0ZWxlbS5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpO1xuXG5cdGZvcihsZXQgbmFtZSBpbiBjc3N2YXJzKVxuXHRcdGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtuYW1lfWAsIGNzc3ZhcnNbbmFtZV0pO1xuXG5cdGZvcihsZXQgbmFtZSBpbiBhdHRycykge1xuXG5cdFx0bGV0IHZhbHVlID0gYXR0cnNbbmFtZV07XG5cdFx0aWYoIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpXG5cdFx0XHRlbGVtLnRvZ2dsZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHR9XG5cblx0Zm9yKGxldCBuYW1lIGluIGRhdGEpIHtcblxuXHRcdGxldCB2YWx1ZSA9IGRhdGFbbmFtZV07XG5cdFx0aWYoIHZhbHVlID09PSBmYWxzZSlcblx0XHRcdGRlbGV0ZSBlbGVtLmRhdGFzZXRbbmFtZV07XG5cdFx0ZWxzZSBpZih2YWx1ZSA9PT0gdHJ1ZSlcblx0XHRcdGVsZW0uZGF0YXNldFtuYW1lXSA9IFwiXCI7XG5cdFx0ZWxzZVxuXHRcdFx0ZWxlbS5kYXRhc2V0W25hbWVdID0gdmFsdWU7XG5cdH1cblxuXHRpZiggISBBcnJheS5pc0FycmF5KGNvbnRlbnQpIClcblx0XHRjb250ZW50ID0gW2NvbnRlbnQgYXMgYW55XTtcblx0ZWxlbS5yZXBsYWNlQ2hpbGRyZW4oLi4uY29udGVudCk7XG5cblx0Zm9yKGxldCBuYW1lIGluIGxpc3RlbmVycylcblx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXJzW25hbWVdKTtcblxuXHRpZiggcGFyZW50ICE9PSB1bmRlZmluZWQgKVxuXHRcdHBhcmVudC5hcHBlbmQoZWxlbSk7XG5cblx0aWYoICEgZWxlbS5pc0luaXQgJiYgaW5pdGlhbGl6ZSApXG5cdFx0cmV0dXJuIGF3YWl0IExJU1MuaW5pdGlhbGl6ZShlbGVtKTtcblxuXHRyZXR1cm4gYXdhaXQgTElTUy5nZXRMSVNTKGVsZW0pO1xufVxuTElTUy5idWlsZCA9IGJ1aWxkO1xuXG5cbmZ1bmN0aW9uIGJ1aWxkU3luYzxUIGV4dGVuZHMga2V5b2YgQ29tcG9uZW50cz4odGFnbmFtZTogVCwgb3B0aW9ucz86IEJVSUxEX09QVElPTlM8Q29tcG9uZW50c1tUXT4pOiBDb21wb25lbnRzW1RdO1xuZnVuY3Rpb24gYnVpbGRTeW5jPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+Pih0YWduYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBCVUlMRF9PUFRJT05TPFQ+KTogVDtcbmZ1bmN0aW9uIGJ1aWxkU3luYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4odGFnbmFtZTogc3RyaW5nLCB7XG5cdFx0cGFyYW1zICAgID0ge30sXG5cdFx0aW5pdGlhbGl6ZT0gdHJ1ZSxcblx0XHRjb250ZW50ICAgPSBbXSxcblx0XHRwYXJlbnQgICAgPSB1bmRlZmluZWQsXG5cdFx0aWQgXHRcdCAgPSB1bmRlZmluZWQsXG5cdFx0Y2xhc3NlcyAgID0gW10sXG5cdFx0Y3NzdmFycyAgID0ge30sXG5cdFx0YXR0cnMgICAgID0ge30sXG5cdFx0ZGF0YSBcdCAgPSB7fSxcblx0XHRsaXN0ZW5lcnMgPSB7fVxuXHR9OiBCVUlMRF9PUFRJT05TPFQ+ID0ge30pOiBUIHtcblxuXHRpZiggISBpbml0aWFsaXplICYmIHBhcmVudCA9PT0gbnVsbClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBIHBhcmVudCBtdXN0IGJlIGdpdmVuIGlmIGluaXRpYWxpemUgaXMgZmFsc2VcIik7XG5cblx0bGV0IEN1c3RvbUNsYXNzID0gY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ25hbWUpO1xuXHRpZihDdXN0b21DbGFzcyA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IG5ldyBFcnJvcihgJHt0YWduYW1lfSBub3QgZGVmaW5lZGApO1xuXHRsZXQgZWxlbSA9IG5ldyBDdXN0b21DbGFzcyhwYXJhbXMpIGFzIExJU1NIb3N0PFQ+O1xuXG5cdC8vVE9ETzogZmFjdG9yaXplLi4uXG5cblx0Ly8gRml4IGlzc3VlICMyXG5cdGlmKCBlbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGFnbmFtZSApXG5cdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoXCJpc1wiLCB0YWduYW1lKTtcblxuXHRpZiggaWQgIT09IHVuZGVmaW5lZCApXG5cdFx0ZWxlbS5pZCA9IGlkO1xuXG5cdGlmKCBjbGFzc2VzLmxlbmd0aCA+IDApXG5cdFx0ZWxlbS5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXMpO1xuXG5cdGZvcihsZXQgbmFtZSBpbiBjc3N2YXJzKVxuXHRcdGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtuYW1lfWAsIGNzc3ZhcnNbbmFtZV0pO1xuXG5cdGZvcihsZXQgbmFtZSBpbiBhdHRycykge1xuXG5cdFx0bGV0IHZhbHVlID0gYXR0cnNbbmFtZV07XG5cdFx0aWYoIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpXG5cdFx0XHRlbGVtLnRvZ2dsZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHR9XG5cblx0Zm9yKGxldCBuYW1lIGluIGRhdGEpIHtcblxuXHRcdGxldCB2YWx1ZSA9IGRhdGFbbmFtZV07XG5cdFx0aWYoIHZhbHVlID09PSBmYWxzZSlcblx0XHRcdGRlbGV0ZSBlbGVtLmRhdGFzZXRbbmFtZV07XG5cdFx0ZWxzZSBpZih2YWx1ZSA9PT0gdHJ1ZSlcblx0XHRcdGVsZW0uZGF0YXNldFtuYW1lXSA9IFwiXCI7XG5cdFx0ZWxzZVxuXHRcdFx0ZWxlbS5kYXRhc2V0W25hbWVdID0gdmFsdWU7XG5cdH1cblxuXHRpZiggISBBcnJheS5pc0FycmF5KGNvbnRlbnQpIClcblx0XHRjb250ZW50ID0gW2NvbnRlbnQgYXMgYW55XTtcblx0ZWxlbS5yZXBsYWNlQ2hpbGRyZW4oLi4uY29udGVudCk7XG5cblx0Zm9yKGxldCBuYW1lIGluIGxpc3RlbmVycylcblx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXJzW25hbWVdKTtcblxuXHRpZiggcGFyZW50ICE9PSB1bmRlZmluZWQgKVxuXHRcdHBhcmVudC5hcHBlbmQoZWxlbSk7XG5cblx0aWYoICEgZWxlbS5pc0luaXQgJiYgaW5pdGlhbGl6ZSApXG5cdFx0TElTUy5pbml0aWFsaXplU3luYyhlbGVtKTtcblxuXHRyZXR1cm4gTElTUy5nZXRMSVNTU3luYyhlbGVtKTtcbn1cbkxJU1MuYnVpbGRTeW5jID0gYnVpbGRTeW5jO1xuXG5MSVNTLndoZW5EZWZpbmVkICAgID0gYXN5bmMgZnVuY3Rpb24odGFnbmFtZTogc3RyaW5nLCBjYWxsYmFjaz86ICgpID0+IHZvaWQgKSA6IFByb21pc2U8dm9pZD4ge1xuXG5cdGF3YWl0IGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKHRhZ25hbWUpO1xuXG5cdGlmKCBjYWxsYmFjayAhPT0gdW5kZWZpbmVkKVxuXHRcdGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuO1xufVxuTElTUy53aGVuQWxsRGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uKHRhZ25hbWVzOiByZWFkb25seSBzdHJpbmdbXSwgY2FsbGJhY2s/OiAoKSA9PiB2b2lkICkgOiBQcm9taXNlPHZvaWQ+IHtcblxuXHRhd2FpdCBQcm9taXNlLmFsbCggdGFnbmFtZXMubWFwKCB0ID0+IGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKHQpICkgKVxuXG5cdGlmKCBjYWxsYmFjayAhPT0gdW5kZWZpbmVkKVxuXHRcdGNhbGxiYWNrKCk7XG5cbn1cblxuTElTUy5pc0RlZmluZWQgPSBmdW5jdGlvbihuYW1lOiBzdHJpbmcpIHtcblx0cmV0dXJuIGN1c3RvbUVsZW1lbnRzLmdldChuYW1lKTtcbn1cblxuTElTUy5zZWxlY3RvciA9IGZ1bmN0aW9uKG5hbWU/OiBzdHJpbmcpIHtcblx0aWYobmFtZSA9PT0gdW5kZWZpbmVkKSAvLyBqdXN0IGFuIGg0Y2tcblx0XHRyZXR1cm4gXCJcIjtcblx0cmV0dXJuIGA6aXMoJHtuYW1lfSwgW2lzPVwiJHtuYW1lfVwiXSlgO1xufVxuXG5MSVNTLmdldExJU1MgICAgPSBhc3luYyBmdW5jdGlvbjxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oIGVsZW1lbnQ6IEVsZW1lbnQgKSB7XG5cblx0YXdhaXQgTElTUy53aGVuRGVmaW5lZCggTElTUy5nZXROYW1lKGVsZW1lbnQpICk7XG5cblx0cmV0dXJuIChlbGVtZW50IGFzIExJU1NIb3N0PFQ+KS5MSVNTOyAvLyBlbnN1cmUgaW5pdGlhbGl6ZWQuXG59XG5MSVNTLmdldExJU1NTeW5jPSBmdW5jdGlvbjxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oIGVsZW1lbnQ6IEVsZW1lbnQgKSB7XG5cblx0Y29uc3QgbmFtZSA9IExJU1MuZ2V0TmFtZShlbGVtZW50KTtcblx0aWYoICEgTElTUy5pc0RlZmluZWQoIG5hbWUgKSApXG5cdFx0dGhyb3cgbmV3IEVycm9yKGAke25hbWV9IGhhc24ndCBiZWVuIGRlZmluZWQgeWV0LmApO1xuXG5cdGxldCBob3N0ID0gZWxlbWVudCBhcyBMSVNTSG9zdDxUPjtcblxuXHRpZiggISBob3N0LmlzSW5pdCApXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW5zdGFuY2UgaGFzbid0IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlwiKTtcblxuXHRyZXR1cm4gaG9zdC5MSVNTU3luYztcbn1cbkxJU1MuaW5pdGlhbGl6ZSA9IGFzeW5jIGZ1bmN0aW9uPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PiggZWxlbWVudDogRWxlbWVudCkge1xuXG5cdGF3YWl0IExJU1Mud2hlbkRlZmluZWQoIExJU1MuZ2V0TmFtZShlbGVtZW50KSApO1xuXG5cdHJldHVybiBhd2FpdCAoZWxlbWVudCBhcyBMSVNTSG9zdDxUPikuaW5pdGlhbGl6ZSgpOyAvLyBlbnN1cmUgaW5pdGlhbGl6YXRpb24uXG59XG5cbkxJU1MuaW5pdGlhbGl6ZVN5bmMgPSBmdW5jdGlvbjxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oIGVsZW1lbnQ6IEVsZW1lbnQpIHtcblxuXHRjb25zdCBuYW1lID0gTElTUy5nZXROYW1lKGVsZW1lbnQpO1xuXHRpZiggISBMSVNTLmlzRGVmaW5lZChuYW1lKSApXG5cdFx0dGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG5vdCBkZWZpbmVkYCk7XG5cblx0cmV0dXJuIChlbGVtZW50IGFzIExJU1NIb3N0PFQ+KS5pbml0aWFsaXplKCk7IC8vIGVuc3VyZSBpbml0aWFsaXphdGlvbi5cbn1cblxuTElTUy5nZXROYW1lID0gZnVuY3Rpb24oIGVsZW1lbnQ6IEVsZW1lbnQgKTogc3RyaW5nIHtcblxuXHRjb25zdCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lzJykgPz8gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFxuXHRpZiggISBuYW1lLmluY2x1ZGVzKCctJykgKVxuXHRcdHRocm93IG5ldyBFcnJvcihgRWxlbWVudCAke25hbWV9IGlzIG5vdCBhIFdlYkNvbXBvbmVudGApO1xuXG5cdHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBfYnVpbGRRUyhzZWxlY3Rvcjogc3RyaW5nLCB0YWduYW1lX29yX3BhcmVudD86IHN0cmluZyB8IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCwgcGFyZW50OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQgPSBkb2N1bWVudCkge1xuXHRcblx0aWYoIHRhZ25hbWVfb3JfcGFyZW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRhZ25hbWVfb3JfcGFyZW50ICE9PSAnc3RyaW5nJykge1xuXHRcdHBhcmVudCA9IHRhZ25hbWVfb3JfcGFyZW50O1xuXHRcdHRhZ25hbWVfb3JfcGFyZW50ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0cmV0dXJuIFtgJHtzZWxlY3Rvcn0ke0xJU1Muc2VsZWN0b3IodGFnbmFtZV9vcl9wYXJlbnQgYXMgc3RyaW5nfHVuZGVmaW5lZCl9YCwgcGFyZW50XSBhcyBjb25zdDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT0gTElTUyBRdWVyeVNlbGVjdG9ycyA9PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBxczxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHBhcmVudCAgPzogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50KTogUHJvbWlzZTxUPjtcbmFzeW5jIGZ1bmN0aW9uIHFzPE4gZXh0ZW5kcyBrZXlvZiBDb21wb25lbnRzPihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZSAgOiBOLFxuXHRcdFx0XHRcdFx0cGFyZW50ICA/OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQpOiBQcm9taXNlPCBDb21wb25lbnRzW05dID47XG5hc3luYyBmdW5jdGlvbiBxczxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oXHRzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZV9vcl9wYXJlbnQ/OiBrZXlvZiBDb21wb25lbnRzIHwgRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50LFxuXHRcdFx0XHRcdFx0cGFyZW50ICA6IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCA9IGRvY3VtZW50KSB7XG5cblx0W3NlbGVjdG9yLCBwYXJlbnRdID0gX2J1aWxkUVMoc2VsZWN0b3IsIHRhZ25hbWVfb3JfcGFyZW50LCBwYXJlbnQpO1xuXG5cdGxldCByZXN1bHQgPSBhd2FpdCBMSVNTLnFzbzxUPihzZWxlY3RvciwgcGFyZW50KTtcblx0aWYocmVzdWx0ID09PSBudWxsKVxuXHRcdHRocm93IG5ldyBFcnJvcihgRWxlbWVudCAke3NlbGVjdG9yfSBub3QgZm91bmRgKTtcblxuXHRyZXR1cm4gcmVzdWx0IVxufVxuTElTUy5xcyAgPSBxc1xuXG5hc3luYyBmdW5jdGlvbiBxc288VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRwYXJlbnQgID86IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCk6IFByb21pc2U8VD47XG5hc3luYyBmdW5jdGlvbiBxc288TiBleHRlbmRzIGtleW9mIENvbXBvbmVudHM+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lICA6IE4sXG5cdFx0XHRcdFx0XHRwYXJlbnQgID86IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCk6IFByb21pc2U8IENvbXBvbmVudHNbTl0gPjtcbmFzeW5jIGZ1bmN0aW9uIHFzbzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oXHRzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZV9vcl9wYXJlbnQ/OiBrZXlvZiBDb21wb25lbnRzIHwgRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50LFxuXHRcdFx0XHRcdFx0cGFyZW50ICA6IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCA9IGRvY3VtZW50KSB7XG5cblx0W3NlbGVjdG9yLCBwYXJlbnRdID0gX2J1aWxkUVMoc2VsZWN0b3IsIHRhZ25hbWVfb3JfcGFyZW50LCBwYXJlbnQpO1xuXG5cdGNvbnN0IGVsZW1lbnQgPSBwYXJlbnQucXVlcnlTZWxlY3RvcjxMSVNTSG9zdDxUPj4oc2VsZWN0b3IpO1xuXHRpZiggZWxlbWVudCA9PT0gbnVsbCApXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0cmV0dXJuIGF3YWl0IExJU1MuZ2V0TElTUyggZWxlbWVudCApO1xufVxuTElTUy5xc28gPSBxc29cblxuYXN5bmMgZnVuY3Rpb24gcXNhPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0cGFyZW50ICA/OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQpOiBQcm9taXNlPFRbXT47XG5hc3luYyBmdW5jdGlvbiBxc2E8TiBleHRlbmRzIGtleW9mIENvbXBvbmVudHM+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lICA6IE4sXG5cdFx0XHRcdFx0XHRwYXJlbnQgID86IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCk6IFByb21pc2U8IENvbXBvbmVudHNbTl1bXSA+O1xuYXN5bmMgZnVuY3Rpb24gcXNhPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PihcdHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lX29yX3BhcmVudD86IGtleW9mIENvbXBvbmVudHMgfCBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQsXG5cdFx0XHRcdFx0XHRwYXJlbnQgIDogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50ID0gZG9jdW1lbnQpIHtcblxuXHRbc2VsZWN0b3IsIHBhcmVudF0gPSBfYnVpbGRRUyhzZWxlY3RvciwgdGFnbmFtZV9vcl9wYXJlbnQsIHBhcmVudCk7XG5cblx0Y29uc3QgZWxlbWVudHMgPSBwYXJlbnQucXVlcnlTZWxlY3RvckFsbDxMSVNTSG9zdDxUPj4oc2VsZWN0b3IpO1xuXG5cdGxldCBpZHggPSAwO1xuXHRjb25zdCBwcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPFQ+PiggZWxlbWVudHMubGVuZ3RoICk7XG5cdGZvcihsZXQgZWxlbWVudCBvZiBlbGVtZW50cylcblx0XHRwcm9taXNlc1tpZHgrK10gPSBMSVNTLmdldExJU1MoIGVsZW1lbnQgKTtcblxuXHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufVxuTElTUy5xc2EgPSBxc2E7XG5cbmFzeW5jIGZ1bmN0aW9uIHFzYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdGVsZW1lbnQgIDogRWxlbWVudCk6IFByb21pc2U8VD47XG5hc3luYyBmdW5jdGlvbiBxc2M8TiBleHRlbmRzIGtleW9mIENvbXBvbmVudHM+KHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lICA6IE4sXG5cdFx0XHRcdFx0XHRlbGVtZW50ICA6IEVsZW1lbnQpOiBQcm9taXNlPCBDb21wb25lbnRzW05dID47XG5hc3luYyBmdW5jdGlvbiBxc2M8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KFx0c2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWVfb3JfcGFyZW50Pzoga2V5b2YgQ29tcG9uZW50cyB8IEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRlbGVtZW50ICA/OiBFbGVtZW50KSB7XG5cblx0Y29uc3QgcmVzID0gX2J1aWxkUVMoc2VsZWN0b3IsIHRhZ25hbWVfb3JfcGFyZW50LCBlbGVtZW50KTtcblx0XG5cdGNvbnN0IHJlc3VsdCA9IChyZXNbMV0gYXMgdW5rbm93biBhcyBFbGVtZW50KS5jbG9zZXN0PExJU1NIb3N0PFQ+PihyZXNbMF0pO1xuXHRpZihyZXN1bHQgPT09IG51bGwpXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0cmV0dXJuIGF3YWl0IExJU1MuZ2V0TElTUyhyZXN1bHQpO1xufVxuTElTUy5xc2MgPSBxc2M7XG5cbmZ1bmN0aW9uIHFzU3luYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHBhcmVudCAgPzogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50KTogVDtcbmZ1bmN0aW9uIHFzU3luYzxOIGV4dGVuZHMga2V5b2YgQ29tcG9uZW50cz4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWUgIDogTixcblx0XHRcdFx0XHRcdHBhcmVudCAgPzogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50KTogQ29tcG9uZW50c1tOXTtcbmZ1bmN0aW9uIHFzU3luYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oXHRzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZV9vcl9wYXJlbnQ/OiBrZXlvZiBDb21wb25lbnRzIHwgRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50LFxuXHRcdFx0XHRcdFx0cGFyZW50ICA6IEVsZW1lbnR8RG9jdW1lbnRGcmFnbWVudHxEb2N1bWVudCA9IGRvY3VtZW50KSB7XG5cblx0W3NlbGVjdG9yLCBwYXJlbnRdID0gX2J1aWxkUVMoc2VsZWN0b3IsIHRhZ25hbWVfb3JfcGFyZW50LCBwYXJlbnQpO1xuXG5cdGNvbnN0IGVsZW1lbnQgPSBwYXJlbnQucXVlcnlTZWxlY3RvcjxMSVNTSG9zdDxUPj4oc2VsZWN0b3IpO1xuXG5cdGlmKCBlbGVtZW50ID09PSBudWxsIClcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnQgJHtzZWxlY3Rvcn0gbm90IGZvdW5kYCk7XG5cblx0cmV0dXJuIExJU1MuZ2V0TElTU1N5bmMoIGVsZW1lbnQgKTtcbn1cbkxJU1MucXNTeW5jID0gcXNTeW5jO1xuXG5mdW5jdGlvbiBxc2FTeW5jPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0cGFyZW50ICA/OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQpOiBUW107XG5mdW5jdGlvbiBxc2FTeW5jPE4gZXh0ZW5kcyBrZXlvZiBDb21wb25lbnRzPihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZSAgOiBOLFxuXHRcdFx0XHRcdFx0cGFyZW50ICA/OiBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQpOiBDb21wb25lbnRzW05dW107XG5mdW5jdGlvbiBxc2FTeW5jPFQgZXh0ZW5kcyBMSVNTQmFzZTxhbnksYW55LGFueSxhbnk+PihcdHNlbGVjdG9yOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHR0YWduYW1lX29yX3BhcmVudD86IGtleW9mIENvbXBvbmVudHMgfCBFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8RG9jdW1lbnQsXG5cdFx0XHRcdFx0XHRwYXJlbnQgIDogRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fERvY3VtZW50ID0gZG9jdW1lbnQpIHtcblxuXHRbc2VsZWN0b3IsIHBhcmVudF0gPSBfYnVpbGRRUyhzZWxlY3RvciwgdGFnbmFtZV9vcl9wYXJlbnQsIHBhcmVudCk7XG5cblx0Y29uc3QgZWxlbWVudHMgPSBwYXJlbnQucXVlcnlTZWxlY3RvckFsbDxMSVNTSG9zdDxUPj4oc2VsZWN0b3IpO1xuXG5cdGxldCBpZHggPSAwO1xuXHRjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8VD4oIGVsZW1lbnRzLmxlbmd0aCApO1xuXHRmb3IobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpXG5cdFx0cmVzdWx0W2lkeCsrXSA9IExJU1MuZ2V0TElTU1N5bmMoIGVsZW1lbnQgKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuTElTUy5xc2FTeW5jID0gcXNhU3luYztcblxuZnVuY3Rpb24gcXNjU3luYzxUIGV4dGVuZHMgTElTU0Jhc2U8YW55LGFueSxhbnksYW55Pj4oc2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdGVsZW1lbnQgIDogRWxlbWVudCk6IFQ7XG5mdW5jdGlvbiBxc2NTeW5jPE4gZXh0ZW5kcyBrZXlvZiBDb21wb25lbnRzPihzZWxlY3Rvcjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0dGFnbmFtZSAgOiBOLFxuXHRcdFx0XHRcdFx0ZWxlbWVudCAgOiBFbGVtZW50KTogQ29tcG9uZW50c1tOXTtcbmZ1bmN0aW9uIHFzY1N5bmM8VCBleHRlbmRzIExJU1NCYXNlPGFueSxhbnksYW55LGFueT4+KFx0c2VsZWN0b3I6IHN0cmluZyxcblx0XHRcdFx0XHRcdHRhZ25hbWVfb3JfcGFyZW50Pzoga2V5b2YgQ29tcG9uZW50cyB8IEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRlbGVtZW50ICA/OiBFbGVtZW50KSB7XG5cblx0Y29uc3QgcmVzID0gX2J1aWxkUVMoc2VsZWN0b3IsIHRhZ25hbWVfb3JfcGFyZW50LCBlbGVtZW50KTtcblx0XG5cdGNvbnN0IHJlc3VsdCA9IChyZXNbMV0gYXMgdW5rbm93biBhcyBFbGVtZW50KS5jbG9zZXN0PExJU1NIb3N0PFQ+PihyZXNbMF0pO1xuXHRpZihyZXN1bHQgPT09IG51bGwpXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0cmV0dXJuIExJU1MuZ2V0TElTU1N5bmMocmVzdWx0KTtcbn1cbkxJU1MucXNjU3luYyA9IHFzY1N5bmM7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09IExJU1MgQXV0byA9PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGNsYXNzIExJU1NfQXV0byBleHRlbmRzIExJU1Moe2F0dHJpYnV0ZXM6IFtcInNyY1wiXX0pIHtcblxuXHRyZWFkb25seSAja25vd25fdGFnID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdHJlYWRvbmx5ICNkaXJlY3Rvcnk6IHN0cmluZztcblx0cmVhZG9ubHkgI3N3OiBQcm9taXNlPHZvaWQ+O1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuI3N3ID0gbmV3IFByb21pc2UoIGFzeW5jIChyZXNvbHZlKSA9PiB7XG5cdFx0XHRcblx0XHRcdGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlZ2lzdGVyKGAuL3N3LmpzYCk7XG5cblx0XHRcdGlmKCBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5jb250cm9sbGVyIClcblx0XHRcdFx0cmVzb2x2ZSgpO1xuXG5cdFx0XHRuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdjb250cm9sbGVyY2hhbmdlJywgKCkgPT4ge1xuXHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXG5cdFx0Y29uc3Qgc3JjID0gdGhpcy5hdHRycy5zcmM7XG5cdFx0aWYoc3JjID09PSBudWxsKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwic3JjIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLlwiKTtcblx0XHR0aGlzLiNkaXJlY3RvcnkgPSBzcmNbMF0gPT09ICcuJ1xuXHRcdFx0XHRcdFx0XHRcdD8gYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfS8ke3NyY31gXG5cdFx0XHRcdFx0XHRcdFx0OiBzcmM7XG5cblx0XHRuZXcgTXV0YXRpb25PYnNlcnZlciggKG11dGF0aW9ucykgPT4ge1xuXG5cdFx0XHRmb3IobGV0IG11dGF0aW9uIG9mIG11dGF0aW9ucylcblx0XHRcdFx0Zm9yKGxldCBhZGRpdGlvbiBvZiBtdXRhdGlvbi5hZGRlZE5vZGVzKVxuXHRcdFx0XHRcdGlmKGFkZGl0aW9uIGluc3RhbmNlb2YgRWxlbWVudClcblx0XHRcdFx0XHRcdHRoaXMuI2FkZFRhZyhhZGRpdGlvbi50YWdOYW1lKVxuXG5cdFx0fSkub2JzZXJ2ZSggZG9jdW1lbnQsIHsgY2hpbGRMaXN0OnRydWUsIHN1YnRyZWU6dHJ1ZSB9KTtcblxuXG5cdFx0Zm9yKCBsZXQgZWxlbSBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSApXG5cdFx0XHR0aGlzLiNhZGRUYWcoZWxlbS50YWdOYW1lKTtcblx0fVxuXG5cbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VzKCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRcImluZGV4LmpzXCIsXG5cdFx0XHRcImluZGV4Lmh0bWxcIixcblx0XHRcdFwiaW5kZXguY3NzXCJcblx0XHRdO1xuICAgIH1cblxuXHRwcm90ZWN0ZWQgZGVmaW5lV2ViQ29tcG9uZW50KHRhZ25hbWU6IHN0cmluZywgZmlsZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdHM6IFBhcnRpYWw8e2NvbnRlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmd9Pikge1xuXG5cdFx0Y29uc3QganMgPSBmaWxlc1tcImluZGV4LmpzXCJdO1xuXHRcdGNvbnN0IGNvbnRlbnQgPSBmaWxlc1tcImluZGV4Lmh0bWxcIl07XG5cblx0XHRsZXQga2xhc3M6IG51bGx8IFJldHVyblR5cGU8dHlwZW9mIExJU1M+ID0gbnVsbDtcblx0XHRpZigganMgIT09IHVuZGVmaW5lZCApXG5cdFx0XHRrbGFzcyA9IGpzKG9wdHMpO1xuXHRcdGVsc2UgaWYoIGNvbnRlbnQgIT09IHVuZGVmaW5lZCApXG5cdFx0XHRrbGFzcyA9IGNsYXNzIFdlYkNvbXBvbmVudCBleHRlbmRzIExJU1Mob3B0cykge307XG5cblx0XHRpZihrbGFzcyA9PT0gbnVsbClcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBmaWxlcyBmb3IgV2ViQ29tcG9uZW50ICR7dGFnbmFtZX0uYCk7XG5cblx0XHRyZXR1cm4gTElTUy5kZWZpbmUodGFnbmFtZSwga2xhc3MpO1xuXHR9XG5cblx0YXN5bmMgI2FkZFRhZyh0YWduYW1lOiBzdHJpbmcpIHtcblxuXHRcdHRhZ25hbWUgPSB0YWduYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiggdGFnbmFtZSA9PT0gJ2xpc3MtYXV0bycgfHwgdGFnbmFtZSA9PT0gJ2JsaXNzLWF1dG8nIHx8ICEgdGFnbmFtZS5pbmNsdWRlcygnLScpIHx8IHRoaXMuI2tub3duX3RhZy5oYXMoIHRhZ25hbWUgKSApXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLiNrbm93bl90YWcuYWRkKHRhZ25hbWUpO1xuXG5cdFx0YXdhaXQgdGhpcy4jc3c7IC8vIGVuc3VyZSBTVyBpcyBpbnN0YWxsZWQuXG5cblx0XHRjb25zdCBmaWxlbmFtZXMgPSB0aGlzLnJlc291cmNlcygpO1xuXHRcdGNvbnN0IHJlc291cmNlcyA9IGF3YWl0IFByb21pc2UuYWxsKCBmaWxlbmFtZXMubWFwKCBmaWxlID0+IGZpbGUuZW5kc1dpdGgoJy5qcycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdD8gX2ltcG9ydCAgIChgJHt0aGlzLiNkaXJlY3Rvcnl9LyR7dGFnbmFtZX0vJHtmaWxlfWAsIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDogX2ZldGNoVGV4dChgJHt0aGlzLiNkaXJlY3Rvcnl9LyR7dGFnbmFtZX0vJHtmaWxlfWAsIHRydWUpICkgKTtcblxuXHRcdGNvbnN0IGZpbGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IGZpbGVuYW1lcy5sZW5ndGg7ICsraSlcblx0XHRcdGlmKCByZXNvdXJjZXNbaV0gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0ZmlsZXNbZmlsZW5hbWVzW2ldXSA9IHJlc291cmNlc1tpXTtcblxuXHRcdGNvbnN0IGNvbnRlbnQgPSBmaWxlc1tcImluZGV4Lmh0bWxcIl07XG5cdFx0Y29uc3QgY3NzICAgICA9IGZpbGVzW1wiaW5kZXguY3NzXCJdO1xuXG5cdFx0Y29uc3Qgb3B0czogUGFydGlhbDx7Y29udGVudDogc3RyaW5nLCBjc3M6IHN0cmluZ30+ID0ge1xuXHRcdFx0Li4uY29udGVudCAhPT0gdW5kZWZpbmVkICYmIHtjb250ZW50fSxcblx0XHRcdC4uLmNzcyAgICAgIT09IHVuZGVmaW5lZCAmJiB7Y3NzfSxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHRoaXMuZGVmaW5lV2ViQ29tcG9uZW50KHRhZ25hbWUsIGZpbGVzLCBvcHRzKTtcblx0XHRcblx0fVxufVxuTElTUy5kZWZpbmUoXCJsaXNzLWF1dG9cIiwgTElTU19BdXRvKTtcblxuZXhwb3J0IGludGVyZmFjZSBDb21wb25lbnRzIHtcblx0XCJsaXNzLWF1dG9cIjogTElTU19BdXRvXG59O1xuLypcbiAqIGRlY2xhcmUgbW9kdWxlICckTElTUycge1xuICogXHRcdGludGVyZmFjZSBDb21wb25lbnRzIHtcbiAqIFx0XHRcdFwibmFtZVwiOiBjbGFzc1xuICogXHRcdH1cbiAqIH1cbiAqL1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PSBMSVNTIEV2ZW50c1RhcmdldCA9PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnR5cGUgQ3N0RXZlbnQ8RXZlbnQgZXh0ZW5kcyBzdHJpbmcsIEFyZ3M+ID0gQ3VzdG9tRXZlbnQ8QXJncz4gJiB7dHlwZTogRXZlbnR9O1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50c1RhcmdldDxFdmVudHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PntcblxuXHRhZGRFdmVudExpc3RlbmVyPEV2ZW50IGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBFdmVudHMsIHN5bWJvbHxudW1iZXI+Pih0eXBlOiBFdmVudCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBsaXN0ZW5lcjogbnVsbHwgKChldjogQ3N0RXZlbnQ8RXZlbnQsIEV2ZW50c1tFdmVudF0+KSA9PiB2b2lkKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBvcHRpb25zPzogYm9vbGVhbnxBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQ7XG5cblx0ZGlzcGF0Y2hFdmVudDxFdmVudCBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgRXZlbnRzLCBzeW1ib2x8bnVtYmVyPj4oZXZlbnQ6IENzdEV2ZW50PEV2ZW50LCBFdmVudHNbRXZlbnRdPik6IGJvb2xlYW47XG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjxFdmVudCBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgRXZlbnRzLCBzeW1ib2x8bnVtYmVyPj4odHlwZTogRXZlbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxpc3RlbmVyOiBudWxsfCAoKGV2OiBDc3RFdmVudDxFdmVudCwgRXZlbnRzW0V2ZW50XT4pID0+IHZvaWQpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zPzogYm9vbGVhbnxBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBDc3RtRXZlbnQ8RXZlbnQgZXh0ZW5kcyBzdHJpbmcsIEFyZ3M+IGV4dGVuZHMgQ3VzdG9tRXZlbnQ8QXJncz4ge1xuXG5cdG92ZXJyaWRlIGdldCB0eXBlKCk6IEV2ZW50IHsgcmV0dXJuIHN1cGVyLnR5cGUgYXMgRXZlbnQ7IH1cblxuXHRjb25zdHJ1Y3Rvcih0eXBlOiBFdmVudCwgYXJnczogQXJncykge1xuXHRcdHN1cGVyKHR5cGUsIHtkZXRhaWw6IGFyZ3N9KTtcblx0fVxufVxuXG5leHBvcnQgdHlwZSBFdmVudHNUYXJnZXRDc3RyPEV2ZW50cyBleHRlbmRzIFJlY29yZDxzdHJpbmcsYW55Pj4gPSBDb25zdHJ1Y3RvcjxFdmVudHNUYXJnZXQ8RXZlbnRzPj47XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT0gTElTUyBpbnRlcm5hbCB0b29scyA9PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlc291cmNlKHJlc291cmNlOiBSZXNvdXJjZXxQcm9taXNlPFJlc291cmNlPikge1xuXG5cdHJlc291cmNlID0gYXdhaXQgcmVzb3VyY2U7XG5cblx0aWYoICEgKHJlc291cmNlIGluc3RhbmNlb2YgUmVzcG9uc2UpIClcblx0XHRyZXNvdXJjZSA9IGF3YWl0IGZldGNoKHJlc291cmNlKTtcblxuXHRyZXR1cm4gYXdhaXQgcmVzb3VyY2UudGV4dCgpO1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIF9mZXRjaFRleHQodXJpOiBzdHJpbmd8VVJMLCBpc0xpc3NBdXRvOiBib29sZWFuID0gZmFsc2UpIHtcblxuXHRjb25zdCBvcHRpb25zID0gaXNMaXNzQXV0b1xuXHRcdFx0XHRcdFx0PyB7aGVhZGVyczp7XCJsaXNzLWF1dG9cIjogXCJ0cnVlXCJ9fVxuXHRcdFx0XHRcdFx0OiB7fTtcblxuXG5cdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJpLCBvcHRpb25zKTtcblx0aWYocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgKVxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0aWYoIGlzTGlzc0F1dG8gJiYgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJzdGF0dXNcIikhID09PSBcIjQwNFwiIClcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdHJldHVybiBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG59XG5hc3luYyBmdW5jdGlvbiBfaW1wb3J0KHVyaTogc3RyaW5nLCBpc0xpc3NBdXRvOiBib29sZWFuID0gZmFsc2UpIHtcblxuXHQvLyB0ZXN0IGZvciB0aGUgbW9kdWxlIGV4aXN0YW5jZS5cblx0aWYoaXNMaXNzQXV0byAmJiBhd2FpdCBfZmV0Y2hUZXh0KHVyaSwgaXNMaXNzQXV0bykgPT09IHVuZGVmaW5lZCApXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHR0cnkge1xuXHRcdHJldHVybiAoYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gdXJpKSkuZGVmYXVsdDtcblx0fSBjYXRjaChlKSB7XG5cdFx0Y29uc29sZS5sb2coZSk7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxufVxuXG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzUxMDAwNDYxL2h0bWwtZWxlbWVudC10YWctbmFtZS1mcm9tLWNvbnN0cnVjdG9yXG5jb25zdCBIVE1MQ0xBU1NfUkVHRVggPSAgL0hUTUwoXFx3KylFbGVtZW50LztcbmNvbnN0IGVsZW1lbnROYW1lTG9va3VwVGFibGUgPSB7XG4gICAgJ1VMaXN0JzogJ3VsJyxcbiAgICAnVGFibGVDYXB0aW9uJzogJ2NhcHRpb24nLFxuICAgICdUYWJsZUNlbGwnOiAndGQnLCAvLyB0aFxuICAgICdUYWJsZUNvbCc6ICdjb2wnLCAgLy8nY29sZ3JvdXAnLFxuICAgICdUYWJsZVJvdyc6ICd0cicsXG4gICAgJ1RhYmxlU2VjdGlvbic6ICd0Ym9keScsIC8vWyd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCddLFxuICAgICdRdW90ZSc6ICdxJyxcbiAgICAnUGFyYWdyYXBoJzogJ3AnLFxuICAgICdPTGlzdCc6ICdvbCcsXG4gICAgJ01vZCc6ICdpbnMnLCAvLywgJ2RlbCddLFxuICAgICdNZWRpYSc6ICd2aWRlbycsLy8gJ2F1ZGlvJ10sXG4gICAgJ0ltYWdlJzogJ2ltZycsXG4gICAgJ0hlYWRpbmcnOiAnaDEnLCAvLywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J10sXG4gICAgJ0RpcmVjdG9yeSc6ICdkaXInLFxuICAgICdETGlzdCc6ICdkbCcsXG4gICAgJ0FuY2hvcic6ICdhJ1xuICB9O1xuZnVuY3Rpb24gX2VsZW1lbnQydGFnbmFtZShDbGFzczogdHlwZW9mIEhUTUxFbGVtZW50KTogc3RyaW5nfG51bGwge1xuXG5cdGlmKCBDbGFzcyA9PT0gSFRNTEVsZW1lbnQgKVxuXHRcdHJldHVybiBudWxsO1xuXHRcblx0bGV0IGh0bWx0YWcgPSBIVE1MQ0xBU1NfUkVHRVguZXhlYyhDbGFzcy5uYW1lKSFbMV07XG5cdHJldHVybiBlbGVtZW50TmFtZUxvb2t1cFRhYmxlW2h0bWx0YWcgYXMga2V5b2YgdHlwZW9mIGVsZW1lbnROYW1lTG9va3VwVGFibGVdID8/IGh0bWx0YWcudG9Mb3dlckNhc2UoKVxufSIsImltcG9ydCBcIi4uLy4uLy4uL3N0cnVjdC9zcWwtaW50ZXJhY3RpdmUuanNcIjtcbmltcG9ydCBcIi4uLy4uLy4uL3N0cnVjdC9zcWwtZHltLXRhYmxlLmpzXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9zdHJ1Y3QvYW5pbS1wbGF5ZXIuanNcIjtcblxuaW1wb3J0IFwiLi4vLi4vLi4vc3RydWN0L21lbnUudHNcIjsiLCIvL1RPRE86IGJldHRlciAoYXNzZXRzKVxuaW1wb3J0IFwiLi9zcWxpdGUvc3FsaXRlMy5qc1wiO1xucmVxdWlyZShcIi4uL3BhZ2VzL1IxLTAyL0NNL3NxbGl0ZTMud2FzbVwiKTtcbi8vcmVxdWlyZShcIi4uLy4uLy4uL3N0cnVjdC9zcWxpdGUvc3FsaXRlMy53YXNtXCIpO1xuXG5pbXBvcnQgKiBhcyBzIGZyb20gXCIuL3NxbGl0ZS9zcWxpdGUzLmpzXCI7XG5jb25zdCBzcWxpdGUzID0gKGF3YWl0IHMoKSkuc3FsaXRlMy5vbzE7XG5cbi8vIEB0cy1pZ25vcmVcbi8vIGNvbnN0IHNxbGl0ZTMgPSAoYXdhaXQgc3FsaXRlM0luaXRNb2R1bGUhKCkpLm9vMTtcbnR5cGUgVEFCTEVfREVTQyA9IHtcbiAgICBzY2hlbWEgICAgICA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgY29uc3RyYWludHM/OiBzdHJpbmcsXG4gICAgZW50cmllcyAgICAgOiAobnVsbHxzdHJpbmd8bnVtYmVyKVtdW11cbn07XG50eXBlIERCX0RFU0MgPSBSZWNvcmQ8c3RyaW5nLCBUQUJMRV9ERVNDPjtcblxuZnVuY3Rpb24ganMyc3FsKHZhbHVlOiBudWxsfHN0cmluZ3xudW1iZXIpIHtcbiAgICBpZih2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiTlVMTFwiO1xuICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIGlmKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBgJyR7dmFsdWV9J2A7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc/Pz8nKTtcbn1cblxuLy9UT0RPIG1lcmdlIHF1ZXJpZXMuLi5cbmNsYXNzIERCIHtcblxuICAgIHJlYWRvbmx5ICNkZXNjOiBEQl9ERVNDO1xuICAgIHJlYWRvbmx5ICNkYiAgOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIGRlc2M6IERCX0RFU0MpIHtcblxuICAgICAgICB0aGlzLiNkZXNjID0gZGVzYztcblxuICAgICAgICAvLyBhZGQgdCBmb3IgdHJhY2luZy5cbiAgICAgICAgdGhpcy4jZGIgPSBuZXcgc3FsaXRlMy5EQihuYW1lLCdjJyk7IFxuICAgICAgICB0aGlzLiNkYi5leGVjKCdQUkFHTUEgZm9yZWlnbl9rZXlzPU9OOycpO1xuXG4gICAgICAgIHRoaXMuZnVsbFJlc2V0KCk7XG4gICAgfVxuXG4gICAgI2Ryb3BUYWJsZShuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy4jZGIuZXhlYyhgZHJvcCB0YWJsZSBpZiBleGlzdHMgJHtuYW1lfWApO1xuICAgIH1cbiAgICAjY3JlYXRlVGFibGUobmFtZTogc3RyaW5nKSB7XG5cbiAgICAgICAgY29uc3QgZGVzYyA9IHRoaXMuI2Rlc2NbbmFtZV07XG5cbiAgICAgICAgY29uc3QgY29scyA9IE9iamVjdC5lbnRyaWVzKGRlc2Muc2NoZW1hKS5tYXAoIChbbmFtZSwgdHlwZV0pID0+IGAke25hbWV9ICR7dHlwZX1gKS5qb2luKFwiLCBcIik7XG4gICAgICAgIGxldCBjb25zdHJhaW50cyA9IFwiXCI7XG4gICAgICAgIGlmKCBcImNvbnN0cmFpbnRzXCIgaW4gZGVzYylcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gYCwgJHtkZXNjLmNvbnN0cmFpbnRzfWA7IFxuICAgICAgICB0aGlzLiNkYi5leGVjKGBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAke25hbWV9KCR7Y29sc30ke2NvbnN0cmFpbnRzfSkgU1RSSUNUO2ApO1xuXG4gICAgICAgIC8vIFBvcHVsYXRlLi4uXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGRlc2MuZW50cmllcy5tYXAoIGUgPT4gYCgkeyBlLm1hcChjID0+IGpzMnNxbChjKSkuam9pbignLCAnKSB9KWApLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdGhpcy4jZGIuZXhlYyhgSU5TRVJUIElOVE8gJHtuYW1lfSBWQUxVRVMgJHt2YWx1ZXN9O2ApO1xuICAgIH1cblxuICAgIHJlc2V0VGFibGUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuI2Ryb3BUYWJsZShuYW1lKTtcbiAgICAgICAgdGhpcy4jY3JlYXRlVGFibGUobmFtZSk7XG4gICAgfVxuXG4gICAgI2NyZWF0ZWRfdGFibGUgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAjdXBkYXRlZF90YWJsZSA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgcmVzZXQoKSB7XG5cbiAgICAgICAgZm9yKCBsZXQgbmFtZSBvZiBbLi4udGhpcy4jY3JlYXRlZF90YWJsZS52YWx1ZXMoKV0ucmV2ZXJzZSgpIClcbiAgICAgICAgICAgIHRoaXMuI2RiLmV4ZWMoYGRyb3AgdGFibGUgaWYgZXhpc3RzICR7bmFtZX07YCk7XG5cbiAgICAgICAgZm9yKGxldCBuYW1lIGluIHRoaXMuI2Rlc2MpXG4gICAgICAgICAgICBpZiggdGhpcy4jdXBkYXRlZF90YWJsZS5oYXMobmFtZSkgKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUYWJsZShuYW1lKTtcblxuICAgICAgICB0aGlzLiNjcmVhdGVkX3RhYmxlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuI3VwZGF0ZWRfdGFibGUuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBmdWxsUmVzZXQoKSB7XG4gICAgICAgIGZvciggbGV0IG5hbWUgb2YgWy4uLnRoaXMuI2NyZWF0ZWRfdGFibGUudmFsdWVzKCldLnJldmVyc2UoKSApXG4gICAgICAgICAgICB0aGlzLiNkYi5leGVjKGBkcm9wIHRhYmxlIGlmIGV4aXN0cyAke25hbWV9YCk7XG5cbiAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLiNkZXNjKTtcblxuICAgICAgICAvLyByZXF1aXJlZCBkdWUgdG8gRksuLi5cbiAgICAgICAgZm9yKGxldCB0YWJsZSBvZiBuYW1lcy5yZXZlcnNlKCkgKVxuICAgICAgICAgICAgdGhpcy4jZHJvcFRhYmxlKHRhYmxlKVxuICAgICAgICBmb3IobGV0IHRhYmxlIG9mIG5hbWVzLnJldmVyc2UoKSApXG4gICAgICAgICAgICB0aGlzLiNjcmVhdGVUYWJsZSh0YWJsZSlcblxuICAgICAgICB0aGlzLiNjcmVhdGVkX3RhYmxlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuI3VwZGF0ZWRfdGFibGUuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAjaXNUYWJsZU5hbWUoYzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBjICE9PSBcIiBcIiAmJiBjICE9PSBcIjtcIiAmJiBjICE9PSBcIlxcblwiO1xuICAgIH1cblxuICAgICNleHRyYWN0VGFibGVOYW1lRnJvbVNRTChzcWw6IHN0cmluZykge1xuXG4gICAgICAgIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgICAgXCJDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBcIixcbiAgICAgICAgICAgIFwiQ1JFQVRFIFRBQkxFIFwiLFxuICAgICAgICAgICAgXCJBTFRFUiBUQUJMRSBcIixcbiAgICAgICAgICAgIFwiRFJPUCBUQUJMRSBcIixcbiAgICAgICAgICAgIFwiVVBEQVRFIFwiLFxuICAgICAgICAgICAgXCJJTlNFUlQgSU5UTyBcIixcbiAgICAgICAgICAgIFwiREVMRVRFIEZST00gXCJcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBzcWxfdHlwZSA9IHR5cGVzLmZpbmQoIHYgPT4gc3FsLnN0YXJ0c1dpdGgodikgKSE7XG5cbiAgICAgICAgbGV0IHN0YXJ0X3BvcyAgPSBzcWxfdHlwZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlKCAhIHRoaXMuI2lzVGFibGVOYW1lKCBzcWxbc3RhcnRfcG9zXSApIClcbiAgICAgICAgICAgICsrc3RhcnRfcG9zO1xuXG4gICAgICAgIGxldCBlbmRfcG9zID0gc3RhcnRfcG9zO1xuICAgICAgICB3aGlsZSggdGhpcy4jaXNUYWJsZU5hbWUoIHNxbFtlbmRfcG9zXSApIClcbiAgICAgICAgICAgICsrZW5kX3BvcztcbiAgICBcbiAgICAgICAgY29uc3QgdGFibGVfbmFtZSA9IHNxbC5zbGljZShzdGFydF9wb3MsIGVuZF9wb3MgKTtcbiAgICAgICAgcmV0dXJuIFsgc3FsX3R5cGUsIHRhYmxlX25hbWVdO1xuICAgIH1cblxuICAgIGV4ZWNfb25lKHNxbDogc3RyaW5nKSB7XG5cbiAgICAgICAgaWYoIHNxbC5zdGFydHNXaXRoKFwiU0VMRUNUIFwiKSApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZGIuc2VsZWN0T2JqZWN0cyhzcWwpO1xuXG4gICAgICAgIHRoaXMuI2RiLmV4ZWMoc3FsKTtcblxuICAgICAgICBjb25zdCBbdHlwZSwgbmFtZV0gPSB0aGlzLiNleHRyYWN0VGFibGVOYW1lRnJvbVNRTChzcWwpO1xuXG4gICAgICAgIGlmKCBuYW1lIGluIHRoaXMuI2Rlc2MgKVxuICAgICAgICAgICAgdGhpcy4jdXBkYXRlZF90YWJsZS5hZGQobmFtZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuI2NyZWF0ZWRfdGFibGUuYWRkKG5hbWUpO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGV4ZWNfbWFueShzcWw6IHN0cmluZ1tdKSB7XG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3FsLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIHRoaXMuZXhlY19vbmUoc3FsW2ldKSApO1xuXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiRXJyb3I6XCIgKyAoZSBhcyBFcnJvcikubWVzc2FnZS5zcGxpdCgnOicpLnNsaWNlKDIpLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxufVxuXG5jb25zdCBkYjIgPSBuZXcgREIoXCJCRFIxX0NNXCIsXG4gICAge1xuICAgICAgICBVc2Vyczoge1xuICAgICAgICAgICAgc2NoZW1hIDoge1xuICAgICAgICAgICAgICAgIElEICAgIDogXCJJTlRFR0VSIFBSSU1BUlkgS0VZIEFVVE9JTkNSRU1FTlRcIixcbiAgICAgICAgICAgICAgICBOb20gICA6IFwiVEVYVFwiLFxuICAgICAgICAgICAgICAgIFByZW5vbTogXCJURVhUXCIsXG4gICAgICAgICAgICAgICAgQWdlICAgOiBcIklOVFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIFtudWxsLCAnRG9lJywgICAgJ0pvaG4nLCAgIDQzXSxcbiAgICAgICAgICAgICAgICBbbnVsbCwgJ0R1cmFudCcsICdQYXVsJywgICAgOV0sXG4gICAgICAgICAgICAgICAgW251bGwsICdOZXNjaW8nLCAnTm9tZW4nLCAgNDNdXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFByb2R1aXRzOiB7XG4gICAgICAgICAgICBzY2hlbWEgOiB7XG4gICAgICAgICAgICAgICAgRGF0ZTogXCJURVhUXCIsXG4gICAgICAgICAgICAgICAgUmVmIDogXCJURVhUXCIsXG4gICAgICAgICAgICAgICAgUSAgIDogXCJJTlRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICBbJzIwMjMtMDEtMDEnLCAnR29tbWUnICwgMTBdLFxuICAgICAgICAgICAgICAgIFsnMjAyMy0wMi0yMycsICdHb21tZScgLCAgOV0sXG4gICAgICAgICAgICAgICAgWycyMDIzLTA2LTEzJywgJ0dvbW1lJyAsIDI0XSxcbiAgICAgICAgICAgICAgICBbJzIwMjMtMDEtMDEnLCAnQ3JheW9uJywgMjBdLFxuICAgICAgICAgICAgICAgIFsnMjAyMy0wMi0yMycsICdDcmF5b24nLCAxOF0sXG4gICAgICAgICAgICAgICAgWycyMDIzLTA2LTEzJywgJ0NyYXlvbicsIDUwXVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBUMToge1xuICAgICAgICAgICAgc2NoZW1hIDoge1xuICAgICAgICAgICAgICAgIElEOiBcIklOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVFwiLFxuICAgICAgICAgICAgICAgIFQxOiBcIlRFWFRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudHJpZXM6IFtcbiAgICAgICAgICAgICAgICBbbnVsbCwgJzEnXSxcbiAgICAgICAgICAgICAgICBbbnVsbCwgJzInXSxcbiAgICAgICAgICAgICAgICBbbnVsbCwgJzMnXVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBUMjoge1xuICAgICAgICAgICAgc2NoZW1hIDoge1xuICAgICAgICAgICAgICAgIElEOiBcIklOVFwiLFxuICAgICAgICAgICAgICAgIFQyOiBcIlRFWFRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBcIkZPUkVJR04gS0VZKElEKSBSRUZFUkVOQ0VTIFQxKElEKVwiLFxuICAgICAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAgICAgIFsxLCAgICAnMSddLFxuICAgICAgICAgICAgICAgIFszLCAgICAnMiddLFxuICAgICAgICAgICAgICAgIFszLCAgICAnMyddLFxuICAgICAgICAgICAgICAgIFtudWxsLCAnNCddXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9KTtcblxuZXhwb3J0IHtkYjJ9OyIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICB7XG4gICAgICAgIG5hbWUgOiBcIlIgMS0wMSBUYWJsZXVyIGV0IFJlcG9ydGluZ1wiLFxuICAgICAgICBzbmFtZTogXCJSMS0wMSBUYWJsZXVyXCIsXG4gICAgICAgIHBhdGggOiBcIlIxLTAxXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDTVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiQ01cIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBcIkNNMVwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNNMlwiXG4gICAgICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiVFBcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBcIlRQXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgXCJUUDFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJUUDJcIlxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lIDogXCJSIDEtMDIgQmFzZXMgZGUgRG9ubsOpZXMgUmVsYXRpb25uZWxsZXMgMVwiLFxuICAgICAgICBzbmFtZTogXCJSMS0wMiBCRFIxXCIsXG4gICAgICAgIHBhdGggOiBcIlIxLTAyXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBcIkNNXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJTbGlkZXNcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBcIlNsaWRlc1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiQ00xXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ00yXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiVFBcIiAsXG4gICAgICAgICAgICAgICAgcGF0aCA6IFwiVFBcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBcIlRQMVwiLFxuICAgICAgICAgICAgICAgICAgICBcIlRQMlwiLFxuICAgICAgICAgICAgICAgICAgICBcIlRQM1wiLFxuICAgICAgICAgICAgICAgICAgICBcIlRQNFwiLFxuICAgICAgICAgICAgICAgICAgICBcIlRQNVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWUgOiBcIlIgMy0wMyBUZWNobm9sb2dpZXMgV2ViXCIsXG4gICAgICAgIHNuYW1lOiBcIlIzLTAzIFdlYjFcIixcbiAgICAgICAgcGF0aCA6IFwiUjMtMDNcIixcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNNXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogXCJDTVwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiQ00xXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG5dO1xuXG5leHBvcnQgY29uc3Qgcm9vdF9wYXRoID0gW1wibG9jYWxob3N0XCIsIFwiMTI3LjAuMC4xXCJdLmluY2x1ZGVzKGxvY2F0aW9uLmhvc3RuYW1lKSA/IFwiL2Rpc3QvZGV2L3BhZ2VzL1wiIDogXCIvQ291cnMvZGlzdC9kZXYvcGFnZXMvXCI7IiwiXG5pbXBvcnQgcGFnZXMsIHtyb290X3BhdGh9IGZyb20gXCIuL2NvbnRlbnRcIjtcblxuLypcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmVwcmludCcsICgpID0+IHtcbiAgLy8uLi5cbn0pO1xuKi9cblxuLy9UT0RPOiBsaW5rcy4uLlxuY29uc3QgbWFpbiAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm1haW5cIikhO1xuY29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImhlYWRlclwiKSE7XG5cbmNvbnN0IHRpdGxlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEVsZW1lbnQ+KFwiaDEsIGgyLCBoMywgaDRcIik7XG5cbnR5cGUgTm9kZSA9IHtcbiAgICBodG1sICAgIDogSFRNTEVsZW1lbnQsXG4gICAgbGV2ZWwgICA6IG51bWJlcixcbiAgICBwYXJlbnQgIDogbnVsbHxOb2RlLFxuICAgIGNoaWxkcmVuOiBOb2RlW11cbn07XG5cbmNvbnN0IGh0cmVlOiBOb2RlID0ge1xuICAgIGh0bWwgICAgOiBtYWluLFxuICAgIGxldmVsICAgOiAwLFxuICAgIHBhcmVudCAgOiBudWxsLFxuICAgIGNoaWxkcmVuOiBbXSxcbn07XG5sZXQgaHRyZWVfY3Vyc29yID0gaHRyZWU7XG5mb3IobGV0IHRpdGxlIG9mIHRpdGxlcykge1xuICAgIGNvbnN0IGxldmVsID0gK3RpdGxlLnRhZ05hbWUuc2xpY2UoMSk7XG4gICAgXG4gICAgd2hpbGUoIGxldmVsIDw9IGh0cmVlX2N1cnNvci5sZXZlbCApXG4gICAgICAgIGh0cmVlX2N1cnNvciA9IGh0cmVlX2N1cnNvci5wYXJlbnQhO1xuXG4gICAgY29uc3QgZWxlbTogTm9kZSA9IHtcbiAgICAgICAgaHRtbDogdGl0bGUsXG4gICAgICAgIGxldmVsLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHBhcmVudDogaHRyZWVfY3Vyc29yXG4gICAgfTtcblxuXG4gICAgaHRyZWVfY3Vyc29yLmNoaWxkcmVuLnB1c2goZWxlbSk7XG5cbiAgICBodHJlZV9jdXJzb3IgPSBlbGVtO1xufVxuXG5mdW5jdGlvbiBzZWFyY2hDdXJIZWFkZXIoaHRyZWU6IE5vZGUsIHBvc2l0aW9uOiBudW1iZXIpOiBudWxsIHwgTm9kZSB7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gaHRyZWUuY2hpbGRyZW47XG5cbiAgICBmb3IobGV0IGkgPSBoZWFkZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICBpZiggaGVhZGVyc1tpXS5odG1sLm9mZnNldFRvcCA8PSBwb3NpdGlvbiArIDMyIClcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hDdXJIZWFkZXIoaGVhZGVyc1tpXSwgcG9zaXRpb24pID8/IGhlYWRlcnNbaV07XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgaGlkID0gW1xuICAgIFtdLFxuICAgIFtcIklcIiwgXCJJSVwiLCBcIklJSVwiLCBcIklWXCJdLFxuICAgIFtcIjFcIiwgXCIyXCIsXCIzXCIsXCI1XCIsXCI2XCIsXCI3XCIsXCI4XCIsXCI5XCJdLFxuICAgIFtcImFcIiwgXCJiXCIsXCJjXCIsXCJkXCIsXCJlXCIsXCJmXCIsXCJnXCIsXCJoXCJdLFxuXVxuXG5mdW5jdGlvbiBnZXRUaXRsZVByZWZpeChzOiBOb2RlKSB7XG5cbiAgICBpZiggcy5sZXZlbCA+PSBoaWQubGVuZ3RoIClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG5cbiAgICBjb25zdCBpZHggPSBzLnBhcmVudCEuY2hpbGRyZW4uaW5kZXhPZihzKTtcblxuICAgIGNvbnN0IG51bSA9IGhpZFtzLmxldmVsXVtpZHhdO1xuXG4gICAgcmV0dXJuIGAke251bX0uIGA7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTWVudShub2RlczogTm9kZVtdKSB7XG5cbiAgICBjb25zdCBtZW51ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBtZW51LmNsYXNzTGlzdC5hZGQoXCJtZW51XCIpO1xuXG4gICAgbWVudS5hcHBlbmQoIC4uLiBub2Rlcy5tYXAoIChzLGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIGl0ZW0udGV4dENvbnRlbnQ9IGAke2dldFRpdGxlUHJlZml4KHMpfSR7cy5odG1sLnRleHRDb250ZW50fWA7XG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cy5odG1sLmlkfWApO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9KSApO1xuXG4gICAgcmV0dXJuIG1lbnU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhlYWRlcigpIHtcblxuICAgIGNvbnN0IGxhc3QgPSBzZWFyY2hDdXJIZWFkZXIoIGh0cmVlLCBtYWluLnNjcm9sbFRvcCkhO1xuXG4gICAgbGV0IGhlYWRlcnMgPSBbXTtcbiAgICBsZXQgY3Vyc29yICA9IGxhc3Q7XG5cbiAgICB3aGlsZShjdXJzb3IuaHRtbCAhPT0gbWFpbikge1xuICAgICAgICBoZWFkZXJzLnB1c2goY3Vyc29yKTtcbiAgICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudCE7XG4gICAgfVxuXG4gICAgY29uc3QgaHRtbCA9IGhlYWRlcnMucmV2ZXJzZSgpLm1hcCggKGhub2RlLGkpID0+IHtcblxuICAgICAgICBjb25zdCBoID0gaG5vZGUuaHRtbDtcbiAgICAgICAgY29uc3QgaF9odG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG5cbiAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gYCR7Z2V0VGl0bGVQcmVmaXgoaG5vZGUpfSR7aC50ZXh0Q29udGVudH1gO1xuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIGAjJHtoLmlkfWApO1xuXG4gICAgICAgIGNvbnN0IG1lbnUgPSBidWlsZE1lbnUoaG5vZGUucGFyZW50IS5jaGlsZHJlbik7XG4gICAgICAgIGhfaHRtbC5hcHBlbmQobGluaywgbWVudSk7XG5cbiAgICAgICAgcmV0dXJuIGhfaHRtbDtcbiAgICB9KTtcblxuICAgIGlmKCBsYXN0LmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBlbXB0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgIGVtcHR5LmFwcGVuZCggYnVpbGRNZW51KGxhc3QuY2hpbGRyZW4pICk7XG5cbiAgICAgICAgaHRtbC5wdXNoKGVtcHR5KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VfcGFnZV9ocmVmKHBhdGhwcmVmaXg6IHN0cmluZywgcGF0aDogc3RyaW5nLCBkZXNjOiBhbnkpIHtcblxuICAgICAgICBsZXQgaHJlZiA9IGAke3BhdGhwcmVmaXh9JHtwYXRofS9gO1xuXG4gICAgICAgIHdoaWxlKGRlc2MuY2hpbGRyZW4/Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzYyA9IGRlc2MuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBocmVmICs9IGAke2Rlc2MucGF0aCA/PyBkZXNjfS9gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZV9wYWdlX21lbnUocGF0aHByZWZpeDogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIHBhZ2VzOiBhbnkpIHtcbiAgICAgICAgY29uc3QgZGVzYyA9IHBhZ2VzLmZpbmQoIChwYWdlOiBhbnkpID0+IHBhZ2UgPT09IHBhdGggfHwgcGFnZS5wYXRoID09PSBwYXRoICkhO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gZGVzYy5zbmFtZSA/PyBkZXNjLm5hbWUgPz8gZGVzYztcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgbWFrZV9wYWdlX2hyZWYocGF0aHByZWZpeCwgcGF0aCwgZGVzYykgKTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IG1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgbWVudS5jbGFzc0xpc3QuYWRkKFwibWVudVwiKTtcbiAgICBcbiAgICAgICAgICAgIG1lbnUuYXBwZW5kKCAuLi4gcGFnZXMubWFwKCAocGFnZTphbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICAgICAgaXRlbS50ZXh0Q29udGVudD0gcGFnZS5uYW1lID8/IHBhZ2U7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIG1ha2VfcGFnZV9ocmVmKHBhdGhwcmVmaXgsIHBhZ2UucGF0aD8/cGFnZSwgcGFnZSkgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pICk7XG4gICAgXG4gICAgICAgICAgICBodG1sLmFwcGVuZChsaW5rLCBtZW51KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICBcbiAgICBsZXQgY3VycGFnZSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zbGljZShyb290X3BhdGgubGVuZ3RoKS5zcGxpdCgnLycpO1xuXG4gICAgY29uc3QgbW9kdWxlX2h0bWwgPSBtYWtlX3BhZ2VfbWVudShyb290X3BhdGgsIGN1cnBhZ2VbMF0sIHBhZ2VzKTtcblxuICAgIGNvbnN0IGRlc2MgPSBwYWdlcy5maW5kKCAocGFnZTogYW55KSA9PiBwYWdlLnBhdGggPT09IGN1cnBhZ2VbMF0gKSE7XG4gICAgY29uc3QgdHlwZV9odG1sICAgPSBtYWtlX3BhZ2VfbWVudShyb290X3BhdGggKyBjdXJwYWdlWzBdICsgXCIvXCIsIGN1cnBhZ2VbMV0sIGRlc2MuY2hpbGRyZW4pO1xuXG4gICAgY29uc3QgZGVzY190eXBlID0gZGVzYy5jaGlsZHJlbi5maW5kKCAocGFnZTogYW55KSA9PiAocGFnZT8ucGF0aCA/PyBwYWdlKSA9PT0gY3VycGFnZVsxXSApITtcbiAgICBpZiggdHlwZW9mIGRlc2NfdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyB0aXRsZSBudW1cbiAgICAgICAgY29uc3QgZGVzYzJfaWR4ID0gZGVzY190eXBlLmNoaWxkcmVuLmZpbmRJbmRleCggKHBhZ2U6IGFueSkgPT4gcGFnZT8ucGF0aCA/PyBwYWdlID09PSBjdXJwYWdlWzJdICkhO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5KFwiLS1oZWFkZXJfc3RhcnRfaWRcIiwgYCR7ZGVzYzJfaWR4fWApO1xuICAgICAgICAvLyBtZW51XG4gICAgICAgIGNvbnN0IHNlc3Npb25faHRtbCAgID0gbWFrZV9wYWdlX21lbnUocm9vdF9wYXRoICsgY3VycGFnZVswXSArIFwiL1wiKyBjdXJwYWdlWzFdICsgXCIvXCIsIGN1cnBhZ2VbMl0sIGRlc2NfdHlwZS5jaGlsZHJlbik7XG4gICAgICAgIGh0bWxbMF0gPSBzZXNzaW9uX2h0bWw7XG4gICAgfVxuXG4gICAgaGVhZGVyLnJlcGxhY2VDaGlsZHJlbihtb2R1bGVfaHRtbCwgdHlwZV9odG1sLCAuLi5odG1sKTtcbn1cblxubWFpbi5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGVIZWFkZXIpO1xudXBkYXRlSGVhZGVyKCk7IiwiaW1wb3J0IExJU1MgZnJvbSBcImh0dHBzOi8vcmF3LmdpdGhhY2suY29tL2RlbmlzLW1pZ2RhbC9MSVNTL21haW4vaW5kZXguanNcIlxuXG5cbmNvbnN0IGNvbnRlbnQgPSBgPHNwYW4gY2xhc3M9XCJyZXNldFwiPltSZXNldF08L3NwYW4+PHNwYW4gY2xhc3M9XCJwcmV2XCI+W1ByZXZdPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxheVwiPltQbGF5L1BhdXNlXTwvc3Bhbj48c3BhbiBjbGFzcz1cIm5leHRcIj5bTmV4dF08L3NwYW4+YDtcblxuY29uc3QgY3NzID0gYFxuYDtcblxuY29uc3Qgc3R5bGVzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyldLm1hcChzID0+IHtcbiAgICBsZXQgc3R5bGUgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgIHN0eWxlLnJlcGxhY2VTeW5jKHMudGV4dENvbnRlbnQpO1xuICAgIHJldHVybiBzdHlsZTtcbn0pO1xuXG5jbGFzcyBBbmltUGxheWVyIGV4dGVuZHMgTElTUyh7XG4gICAgY29udGVudCxcbiAgICBjc3M6IFtjc3MsIC4uLnN0eWxlc10sXG4gICAgYXR0cmlidXRlczogW1wic3BlZWRcIl1cbn0pIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0ZXBJRCA9IDA7XG5cbiAgICAgICAgdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIucHJldlwiICkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMucHJldigpKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmV4dFwiICkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMubmV4dCgpKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIucGxheVwiICkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMucGxheSgpKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIucmVzZXRcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMucmVzZXQoKSk7XG4gICAgfVxuXG4gICAgbmV4dFN0ZXAoKSB7XG4gICAgICAgICsrdGhpcy5zdGVwSUQ7XG4gICAgICAgIHRoaXMuaG9zdC5kaXNwYXRjaEV2ZW50KCBuZXcgQ3VzdG9tRXZlbnQoXCJzdGVwXCIsIHtkZXRhaWw6IHRoaXMuc3RlcElEfSkgKTtcbiAgICB9XG5cblxuICAgIGNhbmNlbEF1dG9QbGF5KCkge1xuXG4gICAgICAgIGlmKHRoaXMuaWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByZXYoKSB7XG4gICAgICAgIGNvbnN0IG5ld1N0ZXBJRCA9IHRoaXMuc3RlcElEIC0gMTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB3aGlsZSh0aGlzLnN0ZXBJRCAhPT0gbmV3U3RlcElEKVxuICAgICAgICAgICAgdGhpcy5uZXh0U3RlcCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLmNhbmNlbEF1dG9QbGF5KCk7XG4gICAgICAgIHRoaXMubmV4dFN0ZXAoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsQXV0b1BsYXkoKTtcbiAgICAgICAgdGhpcy5zdGVwSUQgPSAwO1xuICAgICAgICB0aGlzLmhvc3QuZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KFwicmVzZXRcIikgKTtcbiAgICB9XG4gICAgcGxheSgpIHtcblxuICAgICAgICBpZiggdGhpcy5jYW5jZWxBdXRvUGxheSgpIClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5pZCA9IHNldEludGVydmFsKCAoKSA9PiB0aGlzLm5leHRTdGVwKCksICsodGhpcy5hdHRycy5zcGVlZCA/PyA1MDApICk7XG4gICAgfVxufVxuXG5MSVNTLmRlZmluZShcImFuaW0tcGxheWVyXCIsIEFuaW1QbGF5ZXIpIiwiaW1wb3J0IExJU1MgZnJvbSBcImh0dHBzOi8vcmF3LmdpdGhhY2suY29tL2RlbmlzLW1pZ2RhbC9MSVNTL21haW4vaW5kZXguanNcIlxuXG5pbXBvcnQge2RiMn0gZnJvbSBcIi4vU1FMaXRlXCI7XG5cbmNvbnN0IENTUyA9XG5gOmhvc3Qge1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbn1cblxuOmhvc3QgdGFibGUge1xuICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XG5cbiAgICAmIGNhcHRpb24ge1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMjZweDtcbiAgICAgICAgZm9udC1zdHlsZTogaXRhbGljO1xuICAgIH1cbiAgICBcbiAgICAmIC5oaWdobGlnaHQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjOEI4MDAwO1xuICAgICAgICBwcmludC1jb2xvci1hZGp1c3Q6IGV4YWN0O1xuICAgIH1cblxuICAgIC8qIFRPRE86IG1ha2Ugc3R5bGUgYWRvcHRhYmxlIHRocm91Z2ggTElTUy4uLiAqL1xuICAgIC5oaWdoXzEge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XG4gICAgfVxuICAgIC5oaWdoXzIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibHVlO1xuICAgIH1cbiAgICAuaGlnaF8zIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogZ3JlZW47XG4gICAgfVxuICAgIC5oaWdoX251bGwge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBvcmFuZ2U7XG4gICAgfVxuICAgIC5oaWRlIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gICAgLmN1ciB7XG4gICAgICAgIGJvcmRlciA6IDRweCBzb2xpZCB5ZWxsb3c7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICB9XG4gICAgLmxvd2xpZ2h0IHtcbiAgICAgICAgb3BhY2l0eTogMC4yNTtcbiAgICB9XG5cbiAgICAmIHRkLCAmIHRoIHtcbiAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgfVxuXG4gICAgJiB0ZCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDIycHg7XG4gICAgfVxuXG4gICAgJiB0aCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI2cHg7XG4gICAgfVxuICAgIFxuICAgICYgPiB0Ym9keSA+IHRyICsgdHIgPiB0ZCB7XG4gICAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZDtcbiAgICB9XG59YDtcblxuY2xhc3MgU1FMRHltVGFibGUgZXh0ZW5kcyBMSVNTKHtcbiAgICBhdHRyaWJ1dGVzOiBbXCJ0YWJsZVwiLCBcImhlYWRlclwiLCBcImNvbHNcIl0sXG4gICAgY3NzOiBDU1Ncbn0pIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBsZXQgY29scyA9IHRoaXMuYXR0cnMuY29scyA/PyBcIipcIjtcblxuICAgICAgICB0aGlzLmV4ZWMoYFNFTEVDVCAke2NvbHN9IEZST00gJHt0aGlzLmF0dHJzLnRhYmxlfTtgKVxuICAgIH1cblxuICAgIGdldCBuYlJvd3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd3MubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRSb3cocm93aWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93c1tyb3dpZF07XG4gICAgfVxuXG4gICAgZXhlYyhxdWVyeSkge1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IGRiMi5leGVjX29uZShxdWVyeSk7XG5cbiAgICAgICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuXG4gICAgICAgIGNvbnN0IGNhcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYXB0aW9uJyk7XG5cbiAgICAgICAgaWYoIHRoaXMuYXR0cnMuaGVhZGVyID09PSBudWxsKVxuICAgICAgICAgICAgY2FwdGlvbi50ZXh0Q29udGVudCA9IGBUYWJsZSAke3RoaXMuYXR0cnMudGFibGV9IDpgO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYXB0aW9uLnRleHRDb250ZW50ID0gdGhpcy5hdHRycy5oZWFkZXI7XG5cbiAgICAgICAgLy9UT0RPOiBjb2xncm91cCAoZm9yIGhpZ2hsaWdodCkuXG5cbiAgICAgICAgY29uc3QgY29sZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xncm91cCcpO1xuICAgICAgICBjb25zdCB0aGVhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoZWFkJyk7XG4gICAgICAgIGNvbnN0IHRyaGVhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cbiAgICAgICAgdGhpcy5jb2xzID0ge307XG5cbiAgICAgICAgY29uc3QgY29sbmFtZXMgPSAgT2JqZWN0LmtleXModGhpcy5kYXRhWzBdKTtcbiAgICAgICAgZm9yKGxldCBjb2xuYW1lIG9mIGNvbG5hbWVzKSB7XG4gICAgICAgICAgICBjb25zdCBjb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2wnKTtcbiAgICAgICAgICAgIC8vY29sLmNsYXNzTGlzdC5hZGQoJ2hpZ2hsaWdodCcpO1xuICAgICAgICAgICAgY29sZ3JvdXAuYXBwZW5kKGNvbCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29sc1tjb2xuYW1lXSA9IGNvbDtcblxuICAgICAgICAgICAgY29uc3QgdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgICAgICAgICAgdGgudGV4dENvbnRlbnQgPSBjb2xuYW1lO1xuICAgICAgICAgICAgdHJoZWFkLmFwcGVuZCh0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhlYWQuYXBwZW5kKHRyaGVhZCk7XG5cbiAgICAgICAgdGhpcy5yb3dzID0gW107XG5cbiAgICAgICAgY29uc3QgdGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xuICAgICAgICBmb3IobGV0IGxpbmUgb2YgdGhpcy5kYXRhKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgICAgIGZvcihsZXQgY29sbmFtZSBvZiBjb2xuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICB0ZC50ZXh0Q29udGVudCA9IGxpbmVbY29sbmFtZV0gPz8gXCJOL0FcIjtcbiAgICAgICAgICAgICAgICB0ci5hcHBlbmQodGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGJvZHkuYXBwZW5kKHRyKTtcblxuICAgICAgICAgICAgdGhpcy5yb3dzLnB1c2goW2xpbmUsdHJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlLmFwcGVuZChjYXB0aW9uLCBjb2xncm91cCwgdGhlYWQsIHRib2R5KTtcbiAgICAgICAgdGhpcy5jb250ZW50LnJlcGxhY2VDaGlsZHJlbih0YWJsZSk7XG4gICAgfVxuXG4gICAgZ3JvdXBCeSggZ3JvdXBfY29sbmFtZSApIHtcblxuICAgICAgICBjb25zdCB0Ym9keSA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwidGJvZHlcIik7XG5cbiAgICAgICAgbGV0IGdyb3VwcyA9IHt9O1xuXG4gICAgICAgIGZvcihsZXQgbGluZSBvZiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gbGluZVtncm91cF9jb2xuYW1lXTtcbiAgICAgICAgICAgIChncm91cHNbZ3JvdXBdID8/PSBbXSkucHVzaCggbGluZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJvd3MgPSBbXTtcbiAgICAgICAgZm9yKGxldCBncm91cG5hbWUgaW4gZ3JvdXBzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2dyb3VwbmFtZV07XG5cbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBncm91cFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IobGV0IGNvbCBpbiBncm91cFtpXSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnRleHRDb250ZW50ID0gZW50cnlbY29sXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiggY29sID09PSBncm91cF9jb2xuYW1lICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnNldEF0dHJpYnV0ZShcInJvd3NwYW5cIiwgZ3JvdXAubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRyLmFwcGVuZChjZWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHJvd3MucHVzaChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGJvZHkucmVwbGFjZUNoaWxkcmVuKC4uLnJvd3MpO1xuICAgIH1cblxuICAgIGhpZ2hsaWdodENvbCggZmlsdGVyICkge1xuICAgICAgICBmb3IobGV0IGNvbG5hbWUgaW4gdGhpcy5jb2xzKVxuICAgICAgICAgICAgdGhpcy4jaGlnaGxpZ2h0KHRoaXMuY29sc1tjb2xuYW1lXSwgZmlsdGVyKGNvbG5hbWUpICk7XG4gICAgfVxuXG4gICAgI2hpZ2hsaWdodCh0YXJnZXQsIGhpZ2hsaWdodCkgeyAvLyB0YXJnZXQ6IEhUTUxFbGVtZW50LCBoaWdobGlnaHQ6IGJvb2xlYW58c3RyaW5nfFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ICkge1xuXG4gICAgICAgIGlmKCB0eXBlb2YgaGlnaGxpZ2h0ID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnaGlnaGxpZ2h0JywgaGlnaGxpZ2h0KTtcbiAgICAgICAgaWYoIHR5cGVvZiBoaWdobGlnaHQgPT09IFwic3RyaW5nXCIgKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5jbGFzc0xpc3QuYWRkKGhpZ2hsaWdodCk7XG4gICAgICAgIFxuICAgICAgICBmb3IobGV0IG5hbWUgaW4gaGlnaGxpZ2h0KVxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUobmFtZSwgaGlnaGxpZ2h0W25hbWVdKTtcblxuICAgIH1cblxuICAgIGhpZ2hsaWdodFJvdyggZmlsdGVyICkge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGhpcy4jaGlnaGxpZ2h0KCB0aGlzLnJvd3NbaV1bMV0sIGZpbHRlcih0aGlzLnJvd3NbaV1bMF0sIGkpICk7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0Q2VsbHMoIGZpbHRlciApIHtcblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IFtyb3dfZGF0YSwgcm93X2h0bWxdID0gdGhpcy5yb3dzW2ldO1xuICAgICAgICAgICAgY29uc3QgY29scyA9IE9iamVjdC5rZXlzKHJvd19kYXRhKTtcblxuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGNvbHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgdGhpcy4jaGlnaGxpZ2h0KCByb3dfaHRtbC5jaGlsZHJlbltqXSAsIGZpbHRlcihyb3dfZGF0YSwgY29sc1tqXSkgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuTElTUy5kZWZpbmUoXCJzcWwtZHltdGFibGVcIiwgU1FMRHltVGFibGUpIiwiaW1wb3J0IHtkYjJ9IGZyb20gXCIuL1NRTGl0ZVwiO1xuXG4vLyBMSVNTXG5cbmltcG9ydCBMSVNTIGZyb20gXCJMSVNTXCI7XG5cbmNvbnN0IGNvbnRlbnQgPSBgXG4gICAgPHNsb3QgbmFtZT1cInNlbGVjdFwiPjwvc2xvdD5cbiAgICA8c2xvdCBuYW1lPVwib3B0aW9uc1wiPjwvc2xvdD5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPHNsb3QgbmFtZT1cInByZVwiPjwvc2xvdD5cbiAgICA8ZGl2IGNsYXNzPVwiY2hvaWNlc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwib3B0aW9uc1wiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicXVlcnlcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPjxkaXYgY2xhc3M9XCJyZXN1bHRcIj48L2Rpdj48L2NvZGU+PC9wcmU+XG4gICAgPGRpdiBjbGFzcz1cInNwYWNpbmdcIj48L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwicG9zdFwiPjwvc2xvdD5gO1xuXG5jb25zdCBjc3MgPSBgXG4gICAgOmhvc3QoW29wdGlvbl0pIHByZSB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICB9XG5cbiAgICA6aG9zdCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDE5cHg7XG4gICAgfVxuXG4gICAgLnNlbGVjdGVkLCAuaGlnaGxpZ2h0IHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogZ29sZDtcbiAgICB9XG4gICAgOmhvc3QgLnNwYWNpbmcge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgfVxuICAgIDpob3N0IC5xdWVyeSBwcmUuaGxqcyB7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDA7XG5cbiAgICAgICAgJiA+IGNvZGUgPiBkaXYge1xuICAgICAgICAgICAgcGFkZGluZy1yaWdodDogMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA6aG9zdCBwcmUuaGxqcyB7XG5cbiAgICAgICAgbWFyZ2luOiAycHg7XG5cbiAgICAgICAgJiA+IGNvZGUgPiBkaXYge1xuICAgICAgICAgICBwYWRkaW5nOiA4cHg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLm9wdGlvbnMgcHJlIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogNHB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAyNXB4O1xuXG4gICAgICAgICYud2l0aGRlc2Mge1xuICAgICAgICAgICAgcGFkZGluZy10b3A6IDBweDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAub3B0aW9ucyBwcmU6OmFmdGVyIHtcbiAgICAgICAgY29udGVudDogXCI+XCI7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgcmlnaHQ6IDBweDtcbiAgICAgICAgdG9wOiAwcHg7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgd2lkdGg6IDI1cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IG9yYW5nZTtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBcbiAgICB9XG4gICAgLm9wdGlvbnMgcHJlOmhvdmVyIHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgIH1cbiAgICA6aG9zdCB7XG4gICAgICAgIC8qZGlzcGxheTogaW5saW5lLWZsZXg7Ki9cbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZ2FwOiA1cHg7XG4gICAgfVxuICAgIHNsb3Q6bm90KFtuYW1lPVwicG9zdFwiXSk6bm90KFtuYW1lPVwicHJlXCJdKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICAgIHNwYW4udmFsdWUge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA1cHg7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbiAgICB9XG5cbiAgICAub3B0aW9uIHtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cblxuICAgIC5lcnJvciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNGRkEwN0EgIWltcG9ydGFudDtcbiAgICB9XG5cbiAgICAucXVlcnkgPiBwcmUgLnZhbHVlIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDEzcHg7XG4gICAgfVxuXG4gICAgLnF1ZXJ5ID4gcHJlIC52YWx1ZTo6YWZ0ZXIge1xuXG4gICAgICAgIHJpZ2h0OiAtMThweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBjb250ZW50OiBcIvCflolcIjtcbiAgICB9XG5cbiAgICA6aG9zdCA+IHByZS5obGpzIHtcbiAgICAgICAgLypmbGV4LWdyb3c6IDE7Ki9cbiAgICB9XG5cbiAgICA6aG9zdCAuZGVzYyB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiAtMC41ZW07XG4gICAgICAgIC8qcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDBweDtcbiAgICAgICAgbGVmdDogMHB4OyovXG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMTlweDtcblxuICAgICAgICB3aWR0aDogY2FsYygxMDAlICsgMC41ZW0pO1xuICAgICAgICBib3JkZXItbGVmdDogbm9uZTtcbiAgICAgICAgYm9yZGVyLXRvcDogbm9uZTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiA1cHg7XG4gICAgICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcblxuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Z3JheTtcbiAgICAgICAgb3BhY2l0eTogMC42O1xuICAgIH1cblxuICAgIHByZSB7XG4gICAgICAgIHBhZGRpbmc6IDAuNWVtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgICAgY29sb3I6IGJsYWNrO1xuICAgIH1cblxuICAgIGNvZGUge1xuICAgICAgICBmb250LWZhbWlseTogTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFwiRHJvaWQgU2FucyBNb25vXCIsIFwiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlLCBcIkRyb2lkIFNhbnMgRmFsbGJhY2tcIjtcbiAgICB9XG5cbiAgICAvKiBUb21vcnJvdyBUaGVtZSAqL1xuICAgIC8qIGh0dHA6Ly9qbWJsb2cuZ2l0aHViLmNvbS9jb2xvci10aGVtZXMtZm9yLWdvb2dsZS1jb2RlLWhpZ2hsaWdodGpzICovXG4gICAgLyogT3JpZ2luYWwgdGhlbWUgLSBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNrZW1wc29uL3RvbW9ycm93LXRoZW1lICovXG5cbiAgICAvKiBUb21vcnJvdyBDb21tZW50ICovXG4gICAgLmhsanMtY29tbWVudCxcbiAgICAuaGxqcy1xdW90ZSB7XG4gICAgICAgIGNvbG9yOiAjOGU5MDhjO1xuICAgIH1cblxuICAgIC8qIFRvbW9ycm93IFJlZCAqL1xuICAgIC5obGpzLXZhcmlhYmxlLFxuICAgIC5obGpzLXRlbXBsYXRlLXZhcmlhYmxlLFxuICAgIC5obGpzLXRhZyxcbiAgICAuaGxqcy1uYW1lLFxuICAgIC5obGpzLXNlbGVjdG9yLWlkLFxuICAgIC5obGpzLXNlbGVjdG9yLWNsYXNzLFxuICAgIC5obGpzLXJlZ2V4cCxcbiAgICAuaGxqcy1kZWxldGlvbiB7XG4gICAgICAgIGNvbG9yOiAjYzgyODI5O1xuICAgIH1cblxuICAgIC8qIFRvbW9ycm93IE9yYW5nZSAqL1xuICAgIC5obGpzLW51bWJlcixcbiAgICAuaGxqcy1idWlsdF9pbixcbiAgICAuaGxqcy1idWlsdGluLW5hbWUsXG4gICAgLmhsanMtbGl0ZXJhbCxcbiAgICAuaGxqcy10eXBlLFxuICAgIC5obGpzLXBhcmFtcyxcbiAgICAuaGxqcy1tZXRhLFxuICAgIC5obGpzLWxpbmsge1xuICAgICAgICBjb2xvcjogI2Y1ODcxZjtcbiAgICB9XG5cbiAgICAvKiBUb21vcnJvdyBZZWxsb3cgKi9cbiAgICAuaGxqcy1hdHRyaWJ1dGUge1xuICAgICAgICBjb2xvcjogI2VhYjcwMDtcbiAgICB9XG5cbiAgICAvKiBUb21vcnJvdyBHcmVlbiAqL1xuICAgIC5obGpzLXN0cmluZyxcbiAgICAuaGxqcy1zeW1ib2wsXG4gICAgLmhsanMtYnVsbGV0LFxuICAgIC5obGpzLWFkZGl0aW9uIHtcbiAgICAgICAgY29sb3I6ICM3MThjMDA7XG4gICAgfVxuXG4gICAgLyogVG9tb3Jyb3cgQmx1ZSAqL1xuICAgIC5obGpzLXRpdGxlLFxuICAgIC5obGpzLXNlY3Rpb24ge1xuICAgICAgICBjb2xvcjogIzQyNzFhZTtcbiAgICB9XG5cbiAgICAvKiBUb21vcnJvdyBQdXJwbGUgKi9cbiAgICAuaGxqcy1rZXl3b3JkLFxuICAgIC5obGpzLXNlbGVjdG9yLXRhZyB7XG4gICAgICAgIGNvbG9yOiAjODk1OWE4O1xuICAgIH1cblxuICAgIC5obGpzIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgICAgIGNvbG9yOiAjNGQ0ZDRjO1xuICAgICAgICBwYWRkaW5nOiAwLjVlbTtcbiAgICB9XG5cbiAgICAuaGxqcy1lbXBoYXNpcyB7XG4gICAgICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcbiAgICB9XG5cbiAgICAuaGxqcy1zdHJvbmcge1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5gO1xuXG4vKlxuY29uc3Qgc3R5bGVzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyldLm1hcChzID0+IHtcbiAgICBsZXQgc3R5bGUgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgIHN0eWxlLnJlcGxhY2VTeW5jKHMudGV4dENvbnRlbnQpO1xuICAgIHJldHVybiBzdHlsZTtcbn0pOyovXG5cbmNsYXNzIFNRTEludGVyYWN0aXZlIGV4dGVuZHMgTElTUyh7XG4gICAgY29udGVudCxcbiAgICBjc3M6IFtjc3NdLFxuICAgIGF0dHJpYnV0ZXM6IFtcImZ1bGwtcmVzZXRcIiwgXCJvcHRpb25cIl1cbn0pIHtcblxuICAgICNyZXN1bHQgICA9IFwiXCI7XG4gICAgI3F1ZXJ5ICAgID0gbnVsbDtcbiAgICAjb3B0aW9ucyAgPSBudWxsO1xuICAgICNpbnB1dCAgICA9IG51bGw7XG4gICAgI3NlbGVjdGVkID0gbnVsbDtcblxuICAgICNzZWxlY3RRdWVyeSA9IG51bGw7XG5cbiAgICBvbkF0dHJDaGFuZ2VkKG5hbWUsIF9vbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmKG5hbWUgIT09IFwib3B0aW9uXCIpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2V0T3B0aW9uKCt2YWx1ZSk7XG4gICAgfVxuXG4gICAgc2V0T3B0aW9uKGlkeCkge1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLiNvcHRpb25zLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB0aGlzLiNvcHRpb25zLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgb3B0LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBpID09PSBpZHggPyBudWxsIDogXCJub25lXCIpO1xuICAgICAgICAgICAgaWYoIGkgPT09IGlkeClcbiAgICAgICAgICAgICAgICBvcHQuY2xpY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNxdWVyeS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXG4gICAgICAgIHRoaXMuaG9zdC5zdHlsZS5zZXRQcm9wZXJ0eShcImZsZXgtd3JhcFwiLCBcIndyYXBcIik7XG5cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLiNyZXN1bHQgICA9IHRoaXMuY29udGVudC5xdWVyeVNlbGVjdG9yKFwiLnJlc3VsdFwiKTtcbiAgICAgICAgdGhpcy4jcXVlcnkgICAgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5xdWVyeVwiKTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyAgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcIi5vcHRpb25zXCIpO1xuIFxuICAgICAgICBsZXQgc2VsZWN0UXVlcnkgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcInNsb3RbbmFtZT0nc2VsZWN0J11cIikuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgICBpZihzZWxlY3RRdWVyeS5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICB0aGlzLiNzZWxlY3RRdWVyeSAgPSBzZWxlY3RRdWVyeVswXS50ZXh0Q29udGVudDtcblxuICAgICAgICB0aGlzLiNvcHRpb25zLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXYpID0+IHtcblxuICAgICAgICAgICAgbGV0IG9wdGlvbiA9IGV2LnRhcmdldC5jbG9zZXN0KFwiLm9wdGlvblwiKTtcbiAgICAgICAgICAgIGlmKG9wdGlvbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZih0aGlzLiNzZWxlY3RlZCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLiNzZWxlY3RlZC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgb3B0aW9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLiNzZWxlY3RlZCA9IG9wdGlvbjtcblxuICAgICAgICAgICAgdGhpcy5sYXN0VmFycyA9IHt9O1xuXG4gICAgICAgICAgICBjb25zdCBvcHRzdmFsdWVzID0gb3B0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoJy52YWx1ZScpO1xuICAgICAgICAgICAgZm9yKCBsZXQgb3B0c3ZhbHVlIG9mIG9wdHN2YWx1ZXMpIHsgLy8gbm90IG9wdGltYWwgYnV0IGl0IHdvcmtzXG5cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RWYXJzW29wdHN2YWx1ZS5kYXRhc2V0Lm5hbWVdID0gb3B0c3ZhbHVlLnRleHRDb250ZW50O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy4jaW5wdXQucXVlcnlTZWxlY3RvckFsbChgLnZhbHVlW2RhdGEtbmFtZT1cIiR7b3B0c3ZhbHVlLmRhdGFzZXQubmFtZX1cIl1gKTtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHZhbHVlIG9mIHZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudGV4dENvbnRlbnQgPSBvcHRzdmFsdWUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuI2V4ZWNRdWVyeSggKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJzbG90Om5vdChbbmFtZV0pXCIpLmFzc2lnbmVkRWxlbWVudHMoKVswXTtcbiAgICAgICAgLy9UT0RPOiBmaW5kICYgcmVwbGFjZS4uLlxuXG4gICAgICAgIHRoaXMuI2lucHV0ID0gcXVlcnkuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIHRoaXMuI3F1ZXJ5LmFwcGVuZCh0aGlzLiNpbnB1dCk7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcInNsb3RbbmFtZT0nb3B0aW9ucyddXCIpLmFzc2lnbmVkRWxlbWVudHMoKTtcblxuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gWy4uLnRoaXMuI2lucHV0LmNoaWxkcmVuWzBdLmNoaWxkTm9kZXNdO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYoIG5vZGUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBsZXQgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0ZXh0LmluZGV4T2YoJyQnKTtcbiAgICAgICAgICAgIGlmKCBzdGFydCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgd2hpbGUoIHN0YXJ0ICE9PSAtMSkgeyAvLyBub3Qgb3B0aW1hbCBidXQgaXQgd29ya3MuLi5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gdGV4dC5zbGljZShzdGFydCsxKS5zZWFyY2goL1tcXFddLyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coIHRleHQsIHN0YXJ0LCB0ZXh0LnNsaWNlKHN0YXJ0KzEpICk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kIG9mIFNRTCB2YXJpYWJsZSBub3QgZm91bmQgKHlvdSBsaWtlbHkgdXNlZCBhIHJlc2VydmVkIGtleXdvcmQpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZCArPSBzdGFydCArIDE7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmNsYXNzTGlzdC5hZGQoXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5kYXRhc2V0Lm5hbWUgPSB0ZXh0LnNsaWNlKHN0YXJ0KzEsIGVuZCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKC4uLiB0ZXh0LnNsaWNlKDAsIHN0YXJ0KSwgdmFsdWUgKTtcblxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGVuZCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0ZXh0LmluZGV4T2YoJyQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGV4dCk7XG5cbiAgICAgICAgICAgIG5vZGUucmVwbGFjZVdpdGgoLi4ucmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvcHRpb25fdGVtcGxhdGUgPSB0aGlzLiNpbnB1dC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy4jaW5wdXQucXVlcnlTZWxlY3RvckFsbCgnLnZhbHVlJyk7XG4gICAgICAgIGZvcihsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG5cbiAgICAgICAgICAgIHZhbHVlLnRvZ2dsZUF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgICAgICAgICBpZiggISB2YWx1ZS5kYXRhc2V0Lm5hbWUuc3RhcnRzV2l0aCgnbV8nKSApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIChldikgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGV2LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFsdWUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZXYpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuI3NlbGVjdGVkICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzZWxlY3RlZC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2lucHV0LmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jc2VsZWN0ZWQgPSB0aGlzLiNpbnB1dDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNpbnB1dHMgPSB0aGlzLiNpbnB1dC5xdWVyeVNlbGVjdG9yQWxsKGAudmFsdWVbZGF0YS1uYW1lPVwiJHtldi50YXJnZXQuZGF0YXNldC5uYW1lfVwiXWApO1xuICAgICAgICAgICAgICAgIGZvciggbGV0IGlucHV0IG9mIHN5bmNpbnB1dHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGlucHV0ID09PSBldi50YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudGV4dENvbnRlbnQgPSBldi50YXJnZXQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy4jZXhlY1F1ZXJ5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgb3B0aW9uIG9mIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgY29uc3Qgb3B0ID0gb3B0aW9uX3RlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIG9wdC5jbGFzc0xpc3QuYWRkKFwib3B0aW9uXCIpO1xuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHQucXVlcnlTZWxlY3RvckFsbCgnLnZhbHVlJyk7XG4gICAgICAgICAgICBmb3IobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgID0gdmFsdWUuZGF0YXNldC5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnRleHRDb250ZW50ID0gb3B0aW9uLmRhdGFzZXRbIG5hbWUgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIG9wdGlvbi50ZXh0Q29udGVudCAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIG9wdC5jbGFzc0xpc3QuYWRkKCd3aXRoZGVzYycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGRlc2MuY2xhc3NMaXN0LmFkZChcImRlc2NcIik7XG4gICAgICAgICAgICAgICAgZGVzYy50ZXh0Q29udGVudCA9IG9wdGlvbi50ZXh0Q29udGVudC50cmltKCkgKyBcIiA6XCI7XG5cbiAgICAgICAgICAgICAgICBvcHQuZmlyc3RFbGVtZW50Q2hpbGQuYmVmb3JlKGRlc2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiNvcHRpb25zLmFwcGVuZCggb3B0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGhpcy5hdHRycy5vcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9uKCt0aGlzLmF0dHJzLm9wdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGhpcy4jc2VsZWN0UXVlcnkgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLiNvcHRpb25zLmZpcnN0RWxlbWVudENoaWxkLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgI2dldFF1ZXJ5KCkge1xuXG4gICAgICAgIGxldCBxdWVyeSA9IFwiXCI7XG4gICAgICAgIGZvcihsZXQgZWxlbSBvZiB0aGlzLiNpbnB1dC5maXJzdEVsZW1lbnRDaGlsZC5jaGlsZE5vZGVzICkge1xuXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZWxlbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGlmKGNvbnRlbnQgPT09IFwiXCIgJiYgZWxlbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiggcXVlcnlbcXVlcnkubGVuZ3RoLTFdID09PSBcIiBcIiApXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc2xpY2UoMCwtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyeSArPSBlbGVtLnRleHRDb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgICNleGVjUXVlcnkoKSB7XG5cblxuICAgICAgICBsZXQgcXVlcmllcyA9IHRoaXMuI2dldFF1ZXJ5KCkuc3BsaXQoJztcXG4nKS5zbGljZSgwLC0xKS5tYXAoIHEgPT4gcSArIFwiO1wiKTtcblxuICAgICAgICAvLyBidWlsZCBxdWVyaWVzIHRvIGV4ZWN1dGUuLi5cblxuICAgICAgICBjb25zdCBleGVjX3F1ZXJpZXMgPSBbXTtcbiAgICAgICAgbGV0IHNob3dfdGFibGUgPSB0cnVlO1xuXG4gICAgICAgIGxldCBzaG93X3F1ZXJpZXMgPSBudWxsO1xuICAgICAgICBpZiggdGhpcy4jc2VsZWN0UXVlcnkgIT09IG51bGwgKSB7XG4gICAgICAgICAgICBzaG93X3F1ZXJpZXMgPSB0aGlzLiNzZWxlY3RRdWVyeS5zcGxpdCgnOycpLnNsaWNlKDAsLTEpLm1hcCggcSA9PiBxLnRyaW0oKSArIFwiO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNob3cgPSAoKSA9PiB7XG4gICAgICAgICAgICBzaG93X3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiggc2hvd19xdWVyaWVzID09PSBudWxsIClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBleGVjX3F1ZXJpZXMucHVzaCguLi5zaG93X3F1ZXJpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHF1ZXJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcmllc1tpXTtcblxuICAgICAgICAgICAgaWYoIHF1ZXJ5LnN0YXJ0c1dpdGgoXCJTRUxFQ1QgXCIpICkge1xuICAgICAgICAgICAgICAgIGV4ZWNfcXVlcmllcy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHF1ZXJ5LnN0YXJ0c1dpdGgoXCJDUkVBVEUgVEFCTEUgXCIpICkge1xuXG4gICAgICAgICAgICAgICAgbGV0IHEgPSBcIkNSRUFURSBUQUJMRSBcIjtcbiAgICAgICAgICAgICAgICBpZiggcXVlcnkuc3RhcnRzV2l0aChcIkNSRUFURSBUQUJMRSBJRiBFWElTVFMgXCIpIClcbiAgICAgICAgICAgICAgICAgICAgcSA9IFwiQ1JFQVRFIFRBQkxFIElGIEVYSVNUUyBcIjtcblxuICAgICAgICAgICAgICAgIGV4ZWNfcXVlcmllcy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0Yl9uYW1lID0gcXVlcnkuc2xpY2UoMTMsIHF1ZXJ5LmluZGV4T2YoXCIgXCIsIHEubGVuZ3RoKSApO1xuICAgICAgICAgICAgICAgIGV4ZWNfcXVlcmllcy5wdXNoKGBTRUxFQ1QgbmFtZSwgdHlwZSwgXCJub3RudWxsXCIsIGRmbHRfdmFsdWUsIHBrLCBoaWRkZW5cXG4gICAgICAgIEZST00gcHJhZ21hX3RhYmxlX3hpbmZvKCcke3RiX25hbWV9Jyk7YCk7XG4gICAgICAgICAgICAgICAgc2hvd190YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggc2hvd190YWJsZSApXG4gICAgICAgICAgICAgICAgc2hvdygpO1xuXG4gICAgICAgICAgICBleGVjX3F1ZXJpZXMucHVzaChxdWVyeSk7XG5cbiAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHRzID0gZGIyLmV4ZWNfbWFueShleGVjX3F1ZXJpZXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdChleGVjX3F1ZXJpZXMsIHJlc3VsdHMpO1xuICAgICAgICBcbiAgICAgICAgaWYoIHRoaXMuYXR0cnNbXCJmdWxsLXJlc2V0XCJdID09PSBcInRydWVcIilcbiAgICAgICAgICAgIGRiMi5mdWxsUmVzZXQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGIyLnJlc2V0KCk7XG4gICAgfVxuXG5cbiAgICAjaGxpbmUoY29sc2l6ZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcrJztcbiAgICAgICAgZm9yKGxldCBjb2xzaXplIG9mIGNvbHNpemVzKVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXCIucGFkRW5kKGNvbHNpemUgKyAyLCBcIi1cIikgKyAnKyc7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAjcGFkUm93KHJvdywgY29sc2l6ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5tYXAoIChfLCBpKSA9PiByb3dbaV0ucGFkRW5kKGNvbHNpemVzW2ldICsgMSwgXCIgXCIpICk7XG4gICAgfVxuICAgICNyYXdsaW5lKHJvdykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJ8XCI7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCByb3cubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyByb3dbaV0gKyBcInxcIjtcblxuICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICAgICNsaW5lKHJvdywgY29sc2l6ZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwifFwiO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgY29sc2l6ZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyByb3dbaV0ucGFkRW5kKGNvbHNpemVzW2ldICsgMSwgXCIgXCIpICsgXCJ8XCI7XG5cbiAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdXBkYXRlUmVzdWx0KHF1ZXJpZXMsIGRhdGFzKSB7XG5cbiAgICAgICAgdGhpcy4jaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnZXJyb3InKTtcbiAgICAgICAgdGhpcy4jcmVzdWx0LmNsYXNzTGlzdC5yZW1vdmUoJ2Vycm9yJyk7XG4gICAgICAgIGxldCBjb250ZW50ID0gJyc7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgIGxldCBjb21wYXJlX3RvID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gY29ycmVjdCBzZWxlY3RcbiAgICAgICAgICAgIGlmKCBkYXRhc1tpXSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YXNbaV0gIT09IFwic3RyaW5nXCIpIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbXBhcmVfdG8gbGFzdCBvciBmaXJzdFxuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IGRhdGFzLmxlbmd0aCAtIDE7IGogPiBpOyAtLWopXG4gICAgICAgICAgICAgICAgICAgIGlmKCBxdWVyaWVzW2pdID09PSBxdWVyaWVzW2ldICYmIGRhdGFzW2pdICE9PSBudWxsICYmIHR5cGVvZiBkYXRhc1tqXSAhPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVfdG8gPSBkYXRhc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIGNvbXBhcmVfdG8gPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgaTsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHF1ZXJpZXNbal0gPT09IHF1ZXJpZXNbaV0gJiYgZGF0YXNbal0gIT09IG51bGwgJiYgdHlwZW9mIGRhdGFzW2pdICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVfdG8gPSBkYXRhc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gcXVlcmllc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgID0gZGF0YXNbaV07XG5cbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYHNxbGl0ZT4gJHtxdWVyeX1cXG5gO1xuXG4gICAgICAgICAgICBpZiggZGF0YSA9PT0gbnVsbCApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikgeyAvLyBleGNlcHRpb25cblxuICAgICAgICAgICAgICAgIHRoaXMuI2lucHV0LmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVzdWx0LmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IGRhdGE7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGRhdGEubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gYE5vIHJvdyByZXR1cm5lZC5cXG5gO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW1xuICAgICAgICAgICAgICAgIC4uLiBkYXRhLm1hcChlbnRyeSA9PiBPYmplY3QudmFsdWVzKGVudHJ5KS5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHZhbHVlID09PSBudWxsIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ04vQSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgJyR7dmFsdWV9J2A7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICB9KSApICAgXG4gICAgICAgICAgICBdO1xuICAgIFxuICAgICAgICAgICAgY29uc3QgY29sc2l6ZXMgPSBuZXcgQXJyYXkoaGVhZGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbHNpemVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29sc2l6ZXNbaV0gPSBoZWFkZXJzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJvdyBvZiByZXN1bHRzKVxuICAgICAgICAgICAgICAgICAgICBpZiggcm93W2ldLmxlbmd0aCA+IGNvbHNpemVzW2ldIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNpemVzW2ldID0gcm93W2ldLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICBcbiAgICAgICAgICAgIGxldCByZXN1bHRfdGV4dCA9IHRoaXMuI2hsaW5lKGNvbHNpemVzKSArIFwiXFxuXCI7XG4gICAgICAgICAgICByZXN1bHRfdGV4dCArPSAgdGhpcy4jbGluZShoZWFkZXJzLCBjb2xzaXplcyk7XG4gICAgICAgICAgICByZXN1bHRfdGV4dCArPSAgdGhpcy4jaGxpbmUoY29sc2l6ZXMpICsgXCJcXG5cIjtcbiAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCByZXN1bHRzLmxlbmd0aDsgKytqKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gcmVzdWx0c1tqXTtcblxuICAgICAgICAgICAgICAgIGlmKCBjb21wYXJlX3RvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9IHRoaXMuI2xpbmUocm93LCBjb2xzaXplcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGhpZ2hsaWdodCBjaGFuZ2VzXG5cbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gXCJJRFwiO1xuICAgICAgICAgICAgICAgIGlmKCAhIChrZXkgaW4gZGF0YVtqXSkgKVxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBcIm5hbWVcIjtcblxuICAgICAgICAgICAgICAgIGxldCBjbXBfbGluZSA9IGNvbXBhcmVfdG8uZmluZCggZSA9PiBlW2tleV0gPT09IGRhdGFbal1ba2V5XSk7IC8vIGg0Y2t5XG5cbiAgICAgICAgICAgICAgICByb3cgPSB0aGlzLiNwYWRSb3cocm93LCBjb2xzaXplcyk7XG5cbiAgICAgICAgICAgICAgICBpZiggY21wX2xpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSByb3cubWFwKCBjID0+IGA8c3Ryb25nPjxlbT4ke2N9PC9lbT48L3N0cm9uZz5gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLiNyYXdsaW5lKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF90ZXh0ICs9IGA8c3BhbiBjbGFzcz1cImhpZ2hsaWdodFwiPiR7bGluZX08L3NwYW4+YDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbmFtZSA9IGhlYWRlcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIGRhdGFbal1bY29sbmFtZV0gIT09IGNtcF9saW5lW2NvbG5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93W2ldID0gYDxzcGFuIGNsYXNzPWhpZ2hsaWdodD48ZW0+PHN0cm9uZz4ke3Jvd1tpXX08L3N0cm9uZz48L2VtPjwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRfdGV4dCArPSB0aGlzLiNyYXdsaW5lKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRfdGV4dCArPSAgdGhpcy4jaGxpbmUoY29sc2l6ZXMpO1xuICAgIFxuICAgICAgICAgICAgY29udGVudCArPSByZXN1bHRfdGV4dCArICdcXG4nOyAgIFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jcmVzdWx0LmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICAgICAgdGhpcy4jbGFzdERhdGFzID0gZGF0YXM7XG5cbiAgICAgICAgdGhpcy5ob3N0LmRpc3BhdGNoRXZlbnQoIG5ldyBDdXN0b21FdmVudChcImNoYW5nZVwiLCB7ZGV0YWlsOiB7XG4gICAgICAgICAgICBkYXRhc1xuICAgICAgICB9fSkgKTtcbiAgICB9XG5cbiAgICAjbGFzdERhdGFzID0gbnVsbDtcblxuICAgIGdldCBsYXN0RGF0YXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNsYXN0RGF0YXM7XG4gICAgfVxufVxuXG5MSVNTLmRlZmluZShcInNxbC1pbnRlcmFjdGl2ZVwiLCBTUUxJbnRlcmFjdGl2ZSkiLCIvKlxuKiogTElDRU5TRSBmb3IgdGhlIHNxbGl0ZTMgV2ViQXNzZW1ibHkvSmF2YVNjcmlwdCBBUElzLlxuKipcbioqIFRoaXMgYnVuZGxlICh0eXBpY2FsbHkgcmVsZWFzZWQgYXMgc3FsaXRlMy5qcyBvciBzcWxpdGUzLm1qcylcbioqIGlzIGFuIGFtYWxnYW1hdGlvbiBvZiBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIGZyb20gdHdvIHByb2plY3RzOlxuKipcbioqIDEpIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmc6IHRoZSBFbXNjcmlwdGVuIFwiZ2x1ZSBjb2RlXCIgaXMgY292ZXJlZCBieVxuKiogICAgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZSBhbmQgVW5pdmVyc2l0eSBvZiBJbGxpbm9pcy9OQ1NBXG4qKiAgICBPcGVuIFNvdXJjZSBMaWNlbnNlLCBhcyBkZXNjcmliZWQgYXQ6XG4qKlxuKiogICAgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2ludHJvZHVjaW5nX2Vtc2NyaXB0ZW4vZW1zY3JpcHRlbl9saWNlbnNlLmh0bWxcbioqXG4qKiAyKSBodHRwczovL3NxbGl0ZS5vcmc6IGFsbCBjb2RlIGFuZCBkb2N1bWVudGF0aW9uIGxhYmVsZWQgYXMgYmVpbmdcbioqICAgIGZyb20gdGhpcyBzb3VyY2UgYXJlIHJlbGVhc2VkIHVuZGVyIHRoZSBzYW1lIHRlcm1zIGFzIHRoZSBzcWxpdGUzXG4qKiAgICBDIGxpYnJhcnk6XG4qKlxuKiogMjAyMi0xMC0xNlxuKipcbioqIFRoZSBhdXRob3IgZGlzY2xhaW1zIGNvcHlyaWdodCB0byB0aGlzIHNvdXJjZSBjb2RlLiAgSW4gcGxhY2Ugb2YgYVxuKiogbGVnYWwgbm90aWNlLCBoZXJlIGlzIGEgYmxlc3Npbmc6XG4qKlxuKiogKiAgIE1heSB5b3UgZG8gZ29vZCBhbmQgbm90IGV2aWwuXG4qKiAqICAgTWF5IHlvdSBmaW5kIGZvcmdpdmVuZXNzIGZvciB5b3Vyc2VsZiBhbmQgZm9yZ2l2ZSBvdGhlcnMuXG4qKiAqICAgTWF5IHlvdSBzaGFyZSBmcmVlbHksIG5ldmVyIHRha2luZyBtb3JlIHRoYW4geW91IGdpdmUuXG4qL1xuLypcbioqIFRoaXMgY29kZSB3YXMgYnVpbHQgZnJvbSBzcWxpdGUzIHZlcnNpb24uLi5cbioqXG4qKiBTUUxJVEVfVkVSU0lPTiBcIjMuNDUuMlwiXG4qKiBTUUxJVEVfVkVSU0lPTl9OVU1CRVIgMzA0NTAwMlxuKiogU1FMSVRFX1NPVVJDRV9JRCBcIjIwMjQtMDMtMTIgMTE6MDY6MjMgZDhjZDZkNDliNDZhMzk1YjEzOTU1Mzg3ZDA1ZTllMWEyYTQ3ZTU0ZmI5OWYzYzliNTk4MzViYmVmYWQ2YWY3N1wiXG4qKlxuKiogVXNpbmcgdGhlIEVtc2NyaXB0ZW4gU0RLIHZlcnNpb24gMy4xLjMwLlxuKi9cblxudmFyIHNxbGl0ZTNJbml0TW9kdWxlID0gKCgpID0+IHtcbiAgLy92YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xuICBjb25zdCBST09UID0gW1wibG9jYWxob3N0XCIsIFwiMTI3LjAuMC4xXCJdLmluY2x1ZGVzKGxvY2F0aW9uLmhvc3RuYW1lKSA/IFwiL2Rpc3QvZGV2L1wiIDogXCIvQ291cnMvZGlzdC9kZXYvXCI7XG4gIGNvbnN0IF9zY3JpcHREaXIgPSBgJHtST09UfWFzc2V0cy9zcWwvc3FsaXRlMy53YXNtYDtcblxuICByZXR1cm4gKFxuZnVuY3Rpb24oY29uZmlnKSB7XG4gIHZhciBzcWxpdGUzSW5pdE1vZHVsZSA9IGNvbmZpZyB8fCB7fTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIE1vZHVsZSA9IHR5cGVvZiBzcWxpdGUzSW5pdE1vZHVsZSAhPSAndW5kZWZpbmVkJyA/IHNxbGl0ZTNJbml0TW9kdWxlIDoge307XG5cblxudmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDtcbk1vZHVsZVsncmVhZHknXSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICByZWFkeVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgcmVhZHlQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xufSk7XG5cblxuXG5cblxuXG5jb25zdCBzcWxpdGUzSW5pdE1vZHVsZVN0YXRlID0gZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlXG4gICAgICB8fCBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgICAgICBkZWJ1Z01vZHVsZTogKCk9Pnt9XG4gICAgICB9KTtcbmRlbGV0ZSBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGU7XG5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlLmRlYnVnTW9kdWxlKCdnbG9iYWxUaGlzLmxvY2F0aW9uID0nLGdsb2JhbFRoaXMubG9jYXRpb24pO1xuXG5cbk1vZHVsZVsnbG9jYXRlRmlsZSddID0gZnVuY3Rpb24ocGF0aCwgcHJlZml4KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgbGV0IHRoZUZpbGU7XG4gIGNvbnN0IHVwID0gdGhpcy51cmxQYXJhbXM7XG4gIGlmKHVwLmhhcyhwYXRoKSl7XG4gICAgdGhlRmlsZSA9IHVwLmdldChwYXRoKTtcbiAgfWVsc2UgaWYodGhpcy5zcWxpdGUzRGlyKXtcbiAgICB0aGVGaWxlID0gdGhpcy5zcWxpdGUzRGlyICsgcGF0aDtcbiAgfWVsc2UgaWYodGhpcy5zY3JpcHREaXIpe1xuICAgIHRoZUZpbGUgPSB0aGlzLnNjcmlwdERpciArIHBhdGg7XG4gIH1lbHNle1xuICAgIHRoZUZpbGUgPSBwcmVmaXggKyBwYXRoO1xuICB9XG4gIHNxbGl0ZTNJbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoXG4gICAgXCJsb2NhdGVGaWxlKFwiLGFyZ3VtZW50c1swXSwgJywnLCBhcmd1bWVudHNbMV0sXCIpXCIsXG4gICAgJ3NxbGl0ZTNJbml0TW9kdWxlU3RhdGUuc2NyaXB0RGlyID0nLHRoaXMuc2NyaXB0RGlyLFxuICAgICd1cC5lbnRyaWVzKCkgPScsQXJyYXkuZnJvbSh1cC5lbnRyaWVzKCkpLFxuICAgIFwicmVzdWx0ID1cIiwgdGhlRmlsZVxuICApO1xuICByZXR1cm4gdGhlRmlsZTtcbn0uYmluZChzcWxpdGUzSW5pdE1vZHVsZVN0YXRlKTtcblxuXG5jb25zdCB4TmFtZU9mSW5zdGFudGlhdGVXYXNtID0gZmFsc2VcbiAgICAgID8gJ2luc3RhbnRpYXRlV2FzbSdcbiAgICAgIDogJ2Vtc2NyaXB0ZW4tYnVnLTE3OTUxJztcbk1vZHVsZVt4TmFtZU9mSW5zdGFudGlhdGVXYXNtXSA9IGZ1bmN0aW9uIGNhbGxlZShpbXBvcnRzLG9uU3VjY2Vzcyl7XG4gIGltcG9ydHMuZW52LmZvbyA9IGZ1bmN0aW9uKCl7fTtcbiAgY29uc3QgdXJpID0gTW9kdWxlLmxvY2F0ZUZpbGUoXG4gICAgY2FsbGVlLnVyaSwgKFxuICAgICAgKCd1bmRlZmluZWQnPT09dHlwZW9mIHNjcmlwdERpcmVjdG9yeSlcbiAgICAgICAgPyBcIlwiIDogc2NyaXB0RGlyZWN0b3J5KVxuICApO1xuICBzcWxpdGUzSW5pdE1vZHVsZVN0YXRlLmRlYnVnTW9kdWxlKFxuICAgIFwiaW5zdGFudGlhdGVXYXNtKCkgdXJpID1cIiwgdXJpXG4gICk7XG4gIGNvbnN0IHdmZXRjaCA9ICgpPT5mZXRjaCh1cmksIHtjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ30pO1xuICBjb25zdCBsb2FkV2FzbSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nXG4gICAgICAgID8gYXN5bmMgKCk9PntcbiAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcod2ZldGNoKCksIGltcG9ydHMpXG4gICAgICAgICAgICAudGhlbigoYXJnKT0+b25TdWNjZXNzKGFyZy5pbnN0YW5jZSwgYXJnLm1vZHVsZSkpO1xuICAgICAgICB9XG4gICAgICAgIDogYXN5bmMgKCk9PnsgXG4gICAgICAgICAgcmV0dXJuIHdmZXRjaCgpXG4gICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgICAgLnRoZW4oYnl0ZXMgPT4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpKVxuICAgICAgICAgICAgLnRoZW4oKGFyZyk9Pm9uU3VjY2VzcyhhcmcuaW5zdGFuY2UsIGFyZy5tb2R1bGUpKTtcbiAgICAgICAgfTtcbiAgbG9hZFdhc20oKTtcbiAgcmV0dXJuIHt9O1xufTtcblxuTW9kdWxlW3hOYW1lT2ZJbnN0YW50aWF0ZVdhc21dLnVyaSA9ICdzcWxpdGUzLndhc20nO1xuXG5cblxuXG5cblxuXG5cbnZhciBtb2R1bGVPdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKHt9LCBNb2R1bGUpO1xuXG52YXIgYXJndW1lbnRzXyA9IFtdO1xudmFyIHRoaXNQcm9ncmFtID0gJy4vdGhpcy5wcm9ncmFtJztcbnZhciBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiAgdGhyb3cgdG9UaHJvdztcbn07XG5cblxuXG5cblxudmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCc7XG52YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gJ2Z1bmN0aW9uJztcblxuXG52YXIgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPT0gJ3N0cmluZyc7XG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG5cblxudmFyIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7XG4gIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgIHJldHVybiBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuICB9XG4gIHJldHVybiBzY3JpcHREaXJlY3RvcnkgKyBwYXRoO1xufVxuXG5cbnZhciByZWFkXyxcbiAgICByZWFkQXN5bmMsXG4gICAgcmVhZEJpbmFyeSxcbiAgICBzZXRXaW5kb3dUaXRsZTtcblxuXG5cblxuaWYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikgeyBcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBzZWxmLmxvY2F0aW9uLmhyZWY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHsgXG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gIH1cbiAgXG4gIFxuICBpZiAoX3NjcmlwdERpcikge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IF9zY3JpcHREaXI7XG4gIH1cbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgaWYgKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKCdibG9iOicpICE9PSAwKSB7XG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gc2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLCBzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywgXCJcIikubGFzdEluZGV4T2YoJy8nKSsxKTtcbiAgfSBlbHNlIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSAnJztcbiAgfVxuXG4gIFxuICBcbiAge1xuXG5cblxuICByZWFkXyA9ICh1cmwpID0+IHtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG4gIH1cblxuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICAgcmVhZEJpbmFyeSA9ICh1cmwpID0+IHtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCh4aHIucmVzcG9uc2UpKTtcbiAgICB9O1xuICB9XG5cbiAgcmVhZEFzeW5jID0gKHVybCwgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpKSB7IFxuICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25lcnJvcigpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICB9XG5cblxuICB9XG5cbiAgc2V0V2luZG93VGl0bGUgPSAodGl0bGUpID0+IGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG59IGVsc2Vcbntcbn1cblxudmFyIG91dCA9IE1vZHVsZVsncHJpbnQnXSB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xudmFyIGVyciA9IE1vZHVsZVsncHJpbnRFcnInXSB8fCBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcblxuXG5PYmplY3QuYXNzaWduKE1vZHVsZSwgbW9kdWxlT3ZlcnJpZGVzKTtcblxuXG5tb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuXG5cblxuXG5cblxuaWYgKE1vZHVsZVsnYXJndW1lbnRzJ10pIGFyZ3VtZW50c18gPSBNb2R1bGVbJ2FyZ3VtZW50cyddO1xuXG5pZiAoTW9kdWxlWyd0aGlzUHJvZ3JhbSddKSB0aGlzUHJvZ3JhbSA9IE1vZHVsZVsndGhpc1Byb2dyYW0nXTtcblxuaWYgKE1vZHVsZVsncXVpdCddKSBxdWl0XyA9IE1vZHVsZVsncXVpdCddO1xuXG5cblxuXG5cblxudmFyIFNUQUNLX0FMSUdOID0gMTY7XG52YXIgUE9JTlRFUl9TSVpFID0gNDtcblxuZnVuY3Rpb24gZ2V0TmF0aXZlVHlwZVNpemUodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpMSc6IGNhc2UgJ2k4JzogY2FzZSAndTgnOiByZXR1cm4gMTtcbiAgICBjYXNlICdpMTYnOiBjYXNlICd1MTYnOiByZXR1cm4gMjtcbiAgICBjYXNlICdpMzInOiBjYXNlICd1MzInOiByZXR1cm4gNDtcbiAgICBjYXNlICdpNjQnOiBjYXNlICd1NjQnOiByZXR1cm4gODtcbiAgICBjYXNlICdmbG9hdCc6IHJldHVybiA0O1xuICAgIGNhc2UgJ2RvdWJsZSc6IHJldHVybiA4O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgICByZXR1cm4gUE9JTlRFUl9TSVpFO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVbMF0gPT09ICdpJykge1xuICAgICAgICBjb25zdCBiaXRzID0gTnVtYmVyKHR5cGUuc3Vic3RyKDEpKTtcbiAgICAgICAgYXNzZXJ0KGJpdHMgJSA4ID09PSAwLCAnZ2V0TmF0aXZlVHlwZVNpemUgaW52YWxpZCBiaXRzICcgKyBiaXRzICsgJywgdHlwZSAnICsgdHlwZSk7XG4gICAgICAgIHJldHVybiBiaXRzIC8gODtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgd2FzbUJpbmFyeTtcbmlmIChNb2R1bGVbJ3dhc21CaW5hcnknXSkgd2FzbUJpbmFyeSA9IE1vZHVsZVsnd2FzbUJpbmFyeSddO1xudmFyIG5vRXhpdFJ1bnRpbWUgPSBNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSB8fCB0cnVlO1xuXG5pZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9ICdvYmplY3QnKSB7XG4gIGFib3J0KCdubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkJyk7XG59XG5cblxuXG52YXIgd2FzbU1lbW9yeTtcblxuXG5cblxuXG5cblxudmFyIEFCT1JUID0gZmFsc2U7XG5cblxuXG5cbnZhciBFWElUU1RBVFVTO1xuXG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICBcbiAgICBcbiAgICBcbiAgICBhYm9ydCh0ZXh0KTtcbiAgfVxufVxuXG5cblxuXG5cblxuXG52YXIgVVRGOERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuXG5mdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkge1xuICB2YXIgZW5kSWR4ID0gaWR4ICsgbWF4Qnl0ZXNUb1JlYWQ7XG4gIHZhciBlbmRQdHIgPSBpZHg7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgd2hpbGUgKGhlYXBPckFycmF5W2VuZFB0cl0gJiYgIShlbmRQdHIgPj0gZW5kSWR4KSkgKytlbmRQdHI7XG5cbiAgaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIGhlYXBPckFycmF5LmJ1ZmZlciAmJiBVVEY4RGVjb2Rlcikge1xuICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LCBlbmRQdHIpKTtcbiAgfVxuICB2YXIgc3RyID0gJyc7XG4gIFxuICBcbiAgd2hpbGUgKGlkeCA8IGVuZFB0cikge1xuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICBpZiAoISh1MCAmIDB4ODApKSB7IHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTsgY29udGludWU7IH1cbiAgICB2YXIgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgICBpZiAoKHUwICYgMHhFMCkgPT0gMHhDMCkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpOyBjb250aW51ZTsgfVxuICAgIHZhciB1MiA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICAgIGlmICgodTAgJiAweEYwKSA9PSAweEUwKSB7XG4gICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHUwID0gKCh1MCAmIDcpIDw8IDE4KSB8ICh1MSA8PCAxMikgfCAodTIgPDwgNikgfCAoaGVhcE9yQXJyYXlbaWR4KytdICYgNjMpO1xuICAgIH1cblxuICAgIGlmICh1MCA8IDB4MTAwMDApIHtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoID0gdTAgLSAweDEwMDAwO1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwIHwgKGNoID4+IDEwKSwgMHhEQzAwIHwgKGNoICYgMHgzRkYpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyLCBtYXhCeXRlc1RvUmVhZCkge1xuICByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6ICcnO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgXG4gIFxuICBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSlcbiAgICByZXR1cm4gMDtcblxuICB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XG4gIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxOyBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyBcbiAgICBpZiAodSA+PSAweEQ4MDAgJiYgdSA8PSAweERGRkYpIHtcbiAgICAgIHZhciB1MSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICAgICB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAodTEgJiAweDNGRik7XG4gICAgfVxuICAgIGlmICh1IDw9IDB4N0YpIHtcbiAgICAgIGlmIChvdXRJZHggPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gdTtcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHg3RkYpIHtcbiAgICAgIGlmIChvdXRJZHggKyAxID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4QzAgfCAodSA+PiA2KTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICh1ICYgNjMpO1xuICAgIH0gZWxzZSBpZiAodSA8PSAweEZGRkYpIHtcbiAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4RTAgfCAodSA+PiAxMik7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhGMCB8ICh1ID4+IDE4KTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9XG4gIH1cbiAgXG4gIGhlYXBbb3V0SWR4XSA9IDA7XG4gIHJldHVybiBvdXRJZHggLSBzdGFydElkeDtcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xuICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xufVxuXG5cbmZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHtcbiAgdmFyIGxlbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTsgXG4gICAgaWYgKGMgPD0gMHg3Rikge1xuICAgICAgbGVuKys7XG4gICAgfSBlbHNlIGlmIChjIDw9IDB4N0ZGKSB7XG4gICAgICBsZW4gKz0gMjtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhERkZGKSB7XG4gICAgICBsZW4gKz0gNDsgKytpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW4gKz0gMztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG5cblxudmFyIEhFQVAsXG5cbiAgSEVBUDgsXG5cbiAgSEVBUFU4LFxuXG4gIEhFQVAxNixcblxuICBIRUFQVTE2LFxuXG4gIEhFQVAzMixcblxuICBIRUFQVTMyLFxuXG4gIEhFQVBGMzIsXG5cbiAgSEVBUDY0LFxuXG4gIEhFQVBVNjQsXG5cbiAgSEVBUEY2NDtcblxuZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKSB7XG4gIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gIE1vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQMTYnXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQVTE2J10gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGIpO1xuICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUEYzMiddID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUEY2NCddID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG4gIE1vZHVsZVsnSEVBUDY0J10gPSBIRUFQNjQgPSBuZXcgQmlnSW50NjRBcnJheShiKTtcbiAgTW9kdWxlWydIRUFQVTY0J10gPSBIRUFQVTY0ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KGIpO1xufVxuXG52YXIgU1RBQ0tfU0laRSA9IDUyNDI4ODtcblxudmFyIElOSVRJQUxfTUVNT1JZID0gTW9kdWxlWydJTklUSUFMX01FTU9SWSddIHx8IDE2Nzc3MjE2O1xuXG5cblxuXG5cblxuXG4gIGlmIChNb2R1bGVbJ3dhc21NZW1vcnknXSkge1xuICAgIHdhc21NZW1vcnkgPSBNb2R1bGVbJ3dhc21NZW1vcnknXTtcbiAgfSBlbHNlXG4gIHtcbiAgICB3YXNtTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAnaW5pdGlhbCc6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzYsXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgJ21heGltdW0nOiAyMTQ3NDgzNjQ4IC8gNjU1MzZcbiAgICB9KTtcbiAgfVxuXG51cGRhdGVNZW1vcnlWaWV3cygpO1xuXG5cblxuSU5JVElBTF9NRU1PUlkgPSB3YXNtTWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cblxuXG5cblxuXG52YXIgd2FzbVRhYmxlO1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgX19BVFBSRVJVTl9fICA9IFtdOyBcbnZhciBfX0FUSU5JVF9fICAgID0gW107IFxudmFyIF9fQVRFWElUX18gICAgPSBbXTsgXG52YXIgX19BVFBPU1RSVU5fXyA9IFtdOyBcblxudmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuICByZXR1cm4gbm9FeGl0UnVudGltZTtcbn1cblxuZnVuY3Rpb24gcHJlUnVuKCkge1xuXG4gIGlmIChNb2R1bGVbJ3ByZVJ1biddKSB7XG4gICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZVJ1biddID09ICdmdW5jdGlvbicpIE1vZHVsZVsncHJlUnVuJ10gPSBbTW9kdWxlWydwcmVSdW4nXV07XG4gICAgd2hpbGUgKE1vZHVsZVsncHJlUnVuJ10ubGVuZ3RoKSB7XG4gICAgICBhZGRPblByZVJ1bihNb2R1bGVbJ3ByZVJ1biddLnNoaWZ0KCkpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuICBydW50aW1lSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gIFxuaWYgKCFNb2R1bGVbXCJub0ZTSW5pdFwiXSAmJiAhRlMuaW5pdC5pbml0aWFsaXplZClcbiAgRlMuaW5pdCgpO1xuRlMuaWdub3JlUGVybWlzc2lvbnMgPSBmYWxzZTtcblxuVFRZLmluaXQoKTtcbiAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RSdW4oKSB7XG5cbiAgaWYgKE1vZHVsZVsncG9zdFJ1biddKSB7XG4gICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3Bvc3RSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtNb2R1bGVbJ3Bvc3RSdW4nXV07XG4gICAgd2hpbGUgKE1vZHVsZVsncG9zdFJ1biddLmxlbmd0aCkge1xuICAgICAgYWRkT25Qb3N0UnVuKE1vZHVsZVsncG9zdFJ1biddLnNoaWZ0KCkpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pO1xufVxuXG5mdW5jdGlvbiBhZGRPblByZVJ1bihjYikge1xuICBfX0FUUFJFUlVOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xuICBfX0FUSU5JVF9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkV4aXQoY2IpIHtcbn1cblxuZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gIF9fQVRQT1NUUlVOX18udW5zaGlmdChjYik7XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG52YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xudmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7IFxuXG5mdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICBydW5EZXBlbmRlbmNpZXMrKztcblxuICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuICBydW5EZXBlbmRlbmNpZXMtLTtcblxuICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gICAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xuICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKCk7IFxuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcbiAgaWYgKE1vZHVsZVsnb25BYm9ydCddKSB7XG4gICAgTW9kdWxlWydvbkFib3J0J10od2hhdCk7XG4gIH1cblxuICB3aGF0ID0gJ0Fib3J0ZWQoJyArIHdoYXQgKyAnKSc7XG4gIFxuICBcbiAgZXJyKHdoYXQpO1xuXG4gIEFCT1JUID0gdHJ1ZTtcbiAgRVhJVFNUQVRVUyA9IDE7XG5cbiAgd2hhdCArPSAnLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLic7XG5cbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuXG4gIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiAgXG4gIFxuICBcbiAgdGhyb3cgZTtcbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgZGF0YVVSSVByZWZpeCA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsJztcblxuXG5mdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHtcbiAgXG4gIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRmlsZVVSSShmaWxlbmFtZSkge1xuICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aCgnZmlsZTovLycpO1xufVxuXG5cbnZhciB3YXNtQmluYXJ5RmlsZTtcbiAgd2FzbUJpbmFyeUZpbGUgPSAnc3FsaXRlMy53YXNtJztcbiAgaWYgKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICAgd2FzbUJpbmFyeUZpbGUgPSBsb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKTtcbiAgfVxuXG5mdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSkge1xuICB0cnkge1xuICAgIGlmIChmaWxlID09IHdhc21CaW5hcnlGaWxlICYmIHdhc21CaW5hcnkpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KTtcbiAgICB9XG4gICAgaWYgKHJlYWRCaW5hcnkpIHtcbiAgICAgIHJldHVybiByZWFkQmluYXJ5KGZpbGUpO1xuICAgIH1cbiAgICB0aHJvdyBcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCI7XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBpZiAoIXdhc21CaW5hcnkgJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpKSB7XG4gICAgaWYgKHR5cGVvZiBmZXRjaCA9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlWydvayddKSB7XG4gICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIHdhc21CaW5hcnlGaWxlICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpOyB9KTtcbn1cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVdhc20oKSB7XG4gIFxuICB2YXIgaW5mbyA9IHtcbiAgICAnZW52JzogYXNtTGlicmFyeUFyZyxcbiAgICAnd2FzaV9zbmFwc2hvdF9wcmV2aWV3MSc6IGFzbUxpYnJhcnlBcmcsXG4gIH07XG4gIFxuICBcbiAgXG4gIFxuICBmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsIG1vZHVsZSkge1xuICAgIHZhciBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcblxuICAgIE1vZHVsZVsnYXNtJ10gPSBleHBvcnRzO1xuXG4gICAgd2FzbVRhYmxlID0gTW9kdWxlWydhc20nXVsnX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZSddO1xuXG4gICAgYWRkT25Jbml0KE1vZHVsZVsnYXNtJ11bJ19fd2FzbV9jYWxsX2N0b3JzJ10pO1xuXG4gICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xuXG4gIH1cbiAgXG4gIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICBcbiAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KSB7XG4gICAgXG4gICAgXG4gICAgXG4gICAgXG4gICAgcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFsnaW5zdGFuY2UnXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKSB7XG4gICAgcmV0dXJuIGdldEJpbmFyeVByb21pc2UoKS50aGVuKGZ1bmN0aW9uKGJpbmFyeSkge1xuICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW5mbyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9KS50aGVuKHJlY2VpdmVyLCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIGVycignZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJyArIHJlYXNvbik7XG5cbiAgICAgIGFib3J0KHJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKCkge1xuICAgIGlmICghd2FzbUJpbmFyeSAmJlxuICAgICAgICB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJlxuICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgcmVzdWx0ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGluZm8pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbihcbiAgICAgICAgICByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCxcbiAgICAgICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBlcnIoJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTtcbiAgICAgICAgICAgIGVycignZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgXG4gIFxuICBcbiAgXG4gIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBleHBvcnRzID0gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBlcnIoJ01vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICcgKyBlKTtcbiAgICAgICAgXG4gICAgICAgIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiAgICB9XG4gIH1cblxuICBcbiAgaW5zdGFudGlhdGVBc3luYygpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7XG4gIHJldHVybiB7fTsgXG59XG5cblxudmFyIHRlbXBEb3VibGU7XG52YXIgdGVtcEk2NDtcblxuXG5cbnZhciBBU01fQ09OU1RTID0ge1xuICBcbn07XG5cblxuXG5cblxuICBcbiAgZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgIHRoaXMubmFtZSA9ICdFeGl0U3RhdHVzJztcbiAgICAgIHRoaXMubWVzc2FnZSA9ICdQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCcgKyBzdGF0dXMgKyAnKSc7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG5cbiAgZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gICAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgXG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIFxuICAgIFxuICBmdW5jdGlvbiBnZXRWYWx1ZShwdHIsIHR5cGUgPSAnaTgnKSB7XG4gICAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gJyonO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2kxJzogcmV0dXJuIEhFQVA4WygocHRyKT4+MCldO1xuICAgICAgICBjYXNlICdpOCc6IHJldHVybiBIRUFQOFsoKHB0cik+PjApXTtcbiAgICAgICAgY2FzZSAnaTE2JzogcmV0dXJuIEhFQVAxNlsoKHB0cik+PjEpXTtcbiAgICAgICAgY2FzZSAnaTMyJzogcmV0dXJuIEhFQVAzMlsoKHB0cik+PjIpXTtcbiAgICAgICAgY2FzZSAnaTY0JzogcmV0dXJuIEhFQVA2NFsoKHB0cik+PjMpXTtcbiAgICAgICAgY2FzZSAnZmxvYXQnOiByZXR1cm4gSEVBUEYzMlsoKHB0cik+PjIpXTtcbiAgICAgICAgY2FzZSAnZG91YmxlJzogcmV0dXJuIEhFQVBGNjRbKChwdHIpPj4zKV07XG4gICAgICAgIGNhc2UgJyonOiByZXR1cm4gSEVBUFUzMlsoKHB0cik+PjIpXTtcbiAgICAgICAgZGVmYXVsdDogYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICcgKyB0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICBcbiAgICBcbiAgZnVuY3Rpb24gc2V0VmFsdWUocHRyLCB2YWx1ZSwgdHlwZSA9ICdpOCcpIHtcbiAgICAgIGlmICh0eXBlLmVuZHNXaXRoKCcqJykpIHR5cGUgPSAnKic7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaTEnOiBIRUFQOFsoKHB0cik+PjApXSA9IHZhbHVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnaTgnOiBIRUFQOFsoKHB0cik+PjApXSA9IHZhbHVlOyBicmVhaztcbiAgICAgICAgY2FzZSAnaTE2JzogSEVBUDE2WygocHRyKT4+MSldID0gdmFsdWU7IGJyZWFrO1xuICAgICAgICBjYXNlICdpMzInOiBIRUFQMzJbKChwdHIpPj4yKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2k2NCc6ICh0ZW1wSTY0ID0gW3ZhbHVlPj4+MCwodGVtcERvdWJsZT12YWx1ZSwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKHB0cik+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKHB0cikrKDQpKT4+MildID0gdGVtcEk2NFsxXSk7IGJyZWFrO1xuICAgICAgICBjYXNlICdmbG9hdCc6IEhFQVBGMzJbKChwdHIpPj4yKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RvdWJsZSc6IEhFQVBGNjRbKChwdHIpPj4zKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJyonOiBIRUFQVTMyWygocHRyKT4+MildID0gdmFsdWU7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiBhYm9ydCgnaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJyArIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICB2YXIgUEFUSCA9IHtpc0FiczoocGF0aCkgPT4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyxzcGxpdFBhdGg6KGZpbGVuYW1lKSA9PiB7XG4gICAgICAgIHZhciBzcGxpdFBhdGhSZSA9IC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xuICAgICAgICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG4gICAgICB9LG5vcm1hbGl6ZUFycmF5OihwYXJ0cywgYWxsb3dBYm92ZVJvb3QpID0+IHtcbiAgICAgICAgXG4gICAgICAgIHZhciB1cCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgZm9yICg7IHVwOyB1cC0tKSB7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9LG5vcm1hbGl6ZToocGF0aCkgPT4ge1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IFBBVEguaXNBYnMocGF0aCksXG4gICAgICAgICAgICB0cmFpbGluZ1NsYXNoID0gcGF0aC5zdWJzdHIoLTEpID09PSAnLyc7XG4gICAgICAgIFxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShwYXRoLnNwbGl0KCcvJykuZmlsdGVyKChwKSA9PiAhIXApLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuICAgICAgICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgICBwYXRoID0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xuICAgICAgfSxkaXJuYW1lOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciByZXN1bHQgPSBQQVRILnNwbGl0UGF0aChwYXRoKSxcbiAgICAgICAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICAgICAgICBkaXIgPSByZXN1bHRbMV07XG4gICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3QgKyBkaXI7XG4gICAgICB9LGJhc2VuYW1lOihwYXRoKSA9PiB7XG4gICAgICAgIFxuICAgICAgICBpZiAocGF0aCA9PT0gJy8nKSByZXR1cm4gJy8nO1xuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICAgICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gLTEpIHJldHVybiBwYXRoO1xuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoKzEpO1xuICAgICAgfSxqb2luOmZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbignLycpKTtcbiAgICAgIH0sam9pbjI6KGwsIHIpID0+IHtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKTtcbiAgICAgIH19O1xuICBcbiAgZnVuY3Rpb24gZ2V0UmFuZG9tRGV2aWNlKCkge1xuICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT0gJ29iamVjdCcgJiYgdHlwZW9mIGNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBcbiAgICAgICAgdmFyIHJhbmRvbUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ1ZmZlcik7IHJldHVybiByYW5kb21CdWZmZXJbMF07IH07XG4gICAgICB9IGVsc2VcbiAgICAgIFxuICAgICAgcmV0dXJuICgpID0+IGFib3J0KFwicmFuZG9tRGV2aWNlXCIpO1xuICAgIH1cbiAgXG4gIFxuICBcbiAgdmFyIFBBVEhfRlMgPSB7cmVzb2x2ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogRlMuY3dkKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJzsgXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IFBBVEguaXNBYnMocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICByZXNvbHZlZFBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLmZpbHRlcigocCkgPT4gISFwKSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcbiAgICAgICAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xuICAgICAgfSxyZWxhdGl2ZTooZnJvbSwgdG8pID0+IHtcbiAgICAgICAgZnJvbSA9IFBBVEhfRlMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gICAgICAgIHRvID0gUEFUSF9GUy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG4gICAgICAgIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgICAgICAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICAgICAgICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbiAgICAgIH19O1xuICBcbiAgXG4gIFxuICBmdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSwgZG9udEFkZE51bGwsIGxlbmd0aCkge1xuICAgIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpKzE7XG4gICAgdmFyIHU4YXJyYXkgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSwgdThhcnJheSwgMCwgdThhcnJheS5sZW5ndGgpO1xuICAgIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XG4gICAgcmV0dXJuIHU4YXJyYXk7XG4gIH1cbiAgdmFyIFRUWSA9IHt0dHlzOltdLGluaXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICB9LHNodXRkb3duOmZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgfSxyZWdpc3RlcjpmdW5jdGlvbihkZXYsIG9wcykge1xuICAgICAgICBUVFkudHR5c1tkZXZdID0geyBpbnB1dDogW10sIG91dHB1dDogW10sIG9wczogb3BzIH07XG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwgVFRZLnN0cmVhbV9vcHMpO1xuICAgICAgfSxzdHJlYW1fb3BzOntvcGVuOmZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciB0dHkgPSBUVFkudHR5c1tzdHJlYW0ubm9kZS5yZGV2XTtcbiAgICAgICAgICBpZiAoIXR0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0udHR5ID0gdHR5O1xuICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICB9LGNsb3NlOmZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIFxuICAgICAgICAgIHN0cmVhbS50dHkub3BzLmZzeW5jKHN0cmVhbS50dHkpO1xuICAgICAgICB9LGZzeW5jOmZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHN0cmVhbS50dHkub3BzLmZzeW5jKHN0cmVhbS50dHkpO1xuICAgICAgICB9LHJlYWQ6ZnVuY3Rpb24oc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MgKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIoc3RyZWFtLnR0eSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgICAgIGJ5dGVzUmVhZCsrO1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldCtpXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgfSx3cml0ZTpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIoc3RyZWFtLnR0eSwgYnVmZmVyW29mZnNldCtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfX0sZGVmYXVsdF90dHlfb3BzOntnZXRfY2hhcjpmdW5jdGlvbih0dHkpIHtcbiAgICAgICAgICBpZiAoIXR0eS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdy5wcm9tcHQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93LnByb21wdCgnSW5wdXQ6ICcpOyAgXG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRsaW5lID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlYWRsaW5lKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHR5LmlucHV0ID0gaW50QXJyYXlGcm9tU3RyaW5nKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0dHkuaW5wdXQuc2hpZnQoKTtcbiAgICAgICAgfSxwdXRfY2hhcjpmdW5jdGlvbih0dHksIHZhbCkge1xuICAgICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSAxMCkge1xuICAgICAgICAgICAgb3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbCAhPSAwKSB0dHkub3V0cHV0LnB1c2godmFsKTsgXG4gICAgICAgICAgfVxuICAgICAgICB9LGZzeW5jOmZ1bmN0aW9uKHR0eSkge1xuICAgICAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH19LGRlZmF1bHRfdHR5MV9vcHM6e3B1dF9jaGFyOmZ1bmN0aW9uKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxmc3luYzpmdW5jdGlvbih0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9fX07XG4gIFxuICBcbiAgZnVuY3Rpb24gemVyb01lbW9yeShhZGRyZXNzLCBzaXplKSB7XG4gICAgICBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XG4gICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLCBhbGlnbm1lbnQpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoc2l6ZSAvIGFsaWdubWVudCkgKiBhbGlnbm1lbnQ7XG4gICAgfVxuICBmdW5jdGlvbiBtbWFwQWxsb2Moc2l6ZSkge1xuICAgICAgc2l6ZSA9IGFsaWduTWVtb3J5KHNpemUsIDY1NTM2KTtcbiAgICAgIHZhciBwdHIgPSBfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduKDY1NTM2LCBzaXplKTtcbiAgICAgIGlmICghcHRyKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiB6ZXJvTWVtb3J5KHB0ciwgc2l6ZSk7XG4gICAgfVxuICB2YXIgTUVNRlMgPSB7b3BzX3RhYmxlOm51bGwsbW91bnQ6ZnVuY3Rpb24obW91bnQpIHtcbiAgICAgICAgcmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCAxNjM4NCB8IDUxMSAsIDApO1xuICAgICAgfSxjcmVhdGVOb2RlOmZ1bmN0aW9uKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7XG4gICAgICAgIGlmIChGUy5pc0Jsa2Rldihtb2RlKSB8fCBGUy5pc0ZJRk8obW9kZSkpIHtcbiAgICAgICAgICBcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFNRU1GUy5vcHNfdGFibGUpIHtcbiAgICAgICAgICBNRU1GUy5vcHNfdGFibGUgPSB7XG4gICAgICAgICAgICBkaXI6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgICBsb29rdXA6IE1FTUZTLm5vZGVfb3BzLmxvb2t1cCxcbiAgICAgICAgICAgICAgICBta25vZDogTUVNRlMubm9kZV9vcHMubWtub2QsXG4gICAgICAgICAgICAgICAgcmVuYW1lOiBNRU1GUy5ub2RlX29wcy5yZW5hbWUsXG4gICAgICAgICAgICAgICAgdW5saW5rOiBNRU1GUy5ub2RlX29wcy51bmxpbmssXG4gICAgICAgICAgICAgICAgcm1kaXI6IE1FTUZTLm5vZGVfb3BzLnJtZGlyLFxuICAgICAgICAgICAgICAgIHJlYWRkaXI6IE1FTUZTLm5vZGVfb3BzLnJlYWRkaXIsXG4gICAgICAgICAgICAgICAgc3ltbGluazogTUVNRlMubm9kZV9vcHMuc3ltbGlua1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayxcbiAgICAgICAgICAgICAgICByZWFkOiBNRU1GUy5zdHJlYW1fb3BzLnJlYWQsXG4gICAgICAgICAgICAgICAgd3JpdGU6IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUsXG4gICAgICAgICAgICAgICAgYWxsb2NhdGU6IE1FTUZTLnN0cmVhbV9vcHMuYWxsb2NhdGUsXG4gICAgICAgICAgICAgICAgbW1hcDogTUVNRlMuc3RyZWFtX29wcy5tbWFwLFxuICAgICAgICAgICAgICAgIG1zeW5jOiBNRU1GUy5zdHJlYW1fb3BzLm1zeW5jXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rOiB7XG4gICAgICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgICAgIHNldGF0dHI6IE1FTUZTLm5vZGVfb3BzLnNldGF0dHIsXG4gICAgICAgICAgICAgICAgcmVhZGxpbms6IE1FTUZTLm5vZGVfb3BzLnJlYWRsaW5rXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbToge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaHJkZXY6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0clxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IEZTLmNocmRldl9zdHJlYW1fb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5zdHJlYW07XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUuc3RyZWFtO1xuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gMDsgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7IFxuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmNocmRldi5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYuc3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuY29udGVudHNbbmFtZV0gPSBub2RlO1xuICAgICAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBub2RlLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6ZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpIHJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKTsgXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShub2RlLmNvbnRlbnRzKTtcbiAgICAgIH0sZXhwYW5kRmlsZVN0b3JhZ2U6ZnVuY3Rpb24obm9kZSwgbmV3Q2FwYWNpdHkpIHtcbiAgICAgICAgdmFyIHByZXZDYXBhY2l0eSA9IG5vZGUuY29udGVudHMgPyBub2RlLmNvbnRlbnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgPj0gbmV3Q2FwYWNpdHkpIHJldHVybjsgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBDQVBBQ0lUWV9ET1VCTElOR19NQVggPSAxMDI0ICogMTAyNDtcbiAgICAgICAgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChuZXdDYXBhY2l0eSwgKHByZXZDYXBhY2l0eSAqIChwcmV2Q2FwYWNpdHkgPCBDQVBBQ0lUWV9ET1VCTElOR19NQVggPyAyLjAgOiAxLjEyNSkpID4+PiAwKTtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSAhPSAwKSBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAyNTYpOyBcbiAgICAgICAgdmFyIG9sZENvbnRlbnRzID0gbm9kZS5jb250ZW50cztcbiAgICAgICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ld0NhcGFjaXR5KTsgXG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA+IDApIG5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKSwgMCk7IFxuICAgICAgfSxyZXNpemVGaWxlU3RvcmFnZTpmdW5jdGlvbihub2RlLCBuZXdTaXplKSB7XG4gICAgICAgIGlmIChub2RlLnVzZWRCeXRlcyA9PSBuZXdTaXplKSByZXR1cm47XG4gICAgICAgIGlmIChuZXdTaXplID09IDApIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDsgXG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ld1NpemUpOyBcbiAgICAgICAgICBpZiAob2xkQ29udGVudHMpIHtcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsIE1hdGgubWluKG5ld1NpemUsIG5vZGUudXNlZEJ5dGVzKSkpOyBcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBuZXdTaXplO1xuICAgICAgICB9XG4gICAgICB9LG5vZGVfb3BzOntnZXRhdHRyOmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgIFxuICAgICAgICAgIGF0dHIuZGV2ID0gRlMuaXNDaHJkZXYobm9kZS5tb2RlKSA/IG5vZGUuaWQgOiAxO1xuICAgICAgICAgIGF0dHIuaW5vID0gbm9kZS5pZDtcbiAgICAgICAgICBhdHRyLm1vZGUgPSBub2RlLm1vZGU7XG4gICAgICAgICAgYXR0ci5ubGluayA9IDE7XG4gICAgICAgICAgYXR0ci51aWQgPSAwO1xuICAgICAgICAgIGF0dHIuZ2lkID0gMDtcbiAgICAgICAgICBhdHRyLnJkZXYgPSBub2RlLnJkZXY7XG4gICAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDQwOTY7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS5saW5rLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0ci5hdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICBhdHRyLm10aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgYXR0ci5ibGtzaXplID0gNDA5NjtcbiAgICAgICAgICBhdHRyLmJsb2NrcyA9IE1hdGguY2VpbChhdHRyLnNpemUgLyBhdHRyLmJsa3NpemUpO1xuICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9LHNldGF0dHI6ZnVuY3Rpb24obm9kZSwgYXR0cikge1xuICAgICAgICAgIGlmIChhdHRyLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS5tb2RlID0gYXR0ci5tb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBhdHRyLnRpbWVzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLCBhdHRyLnNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxsb29rdXA6ZnVuY3Rpb24ocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgRlMuZ2VuZXJpY0Vycm9yc1s0NF07XG4gICAgICAgIH0sbWtub2Q6ZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICAgIH0scmVuYW1lOmZ1bmN0aW9uKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSkge1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChGUy5pc0RpcihvbGRfbm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV3X25vZGUgPSBGUy5sb29rdXBOb2RlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdfbm9kZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG5ld19ub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGRlbGV0ZSBvbGRfbm9kZS5wYXJlbnQuY29udGVudHNbb2xkX25vZGUubmFtZV07XG4gICAgICAgICAgb2xkX25vZGUucGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgICAgICAgICBvbGRfbm9kZS5uYW1lID0gbmV3X25hbWU7XG4gICAgICAgICAgbmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV0gPSBvbGRfbm9kZTtcbiAgICAgICAgICBuZXdfZGlyLnRpbWVzdGFtcCA9IG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgb2xkX25vZGUucGFyZW50ID0gbmV3X2RpcjtcbiAgICAgICAgfSx1bmxpbms6ZnVuY3Rpb24ocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxybWRpcjpmdW5jdGlvbihwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG5vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgICAgICBwYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfSxyZWFkZGlyOmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IFsnLicsICcuLiddO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxzeW1saW5rOmZ1bmN0aW9uKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCkge1xuICAgICAgICAgIHZhciBub2RlID0gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5ld25hbWUsIDUxMSAgfCA0MDk2MCwgMCk7XG4gICAgICAgICAgbm9kZS5saW5rID0gb2xkcGF0aDtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSxyZWFkbGluazpmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5saW5rO1xuICAgICAgICB9fSxzdHJlYW1fb3BzOntyZWFkOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50cztcbiAgICAgICAgICBpZiAocG9zaXRpb24gPj0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHN0cmVhbS5ub2RlLnVzZWRCeXRlcyAtIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICAgIGlmIChzaXplID4gOCAmJiBjb250ZW50cy5zdWJhcnJheSkgeyBcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSksIG9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfSx3cml0ZTpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlciA9PT0gSEVBUDguYnVmZmVyKSB7XG4gICAgICAgICAgICBjYW5Pd24gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0cmVhbS5ub2RlO1xuICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHsgXG4gICAgICAgICAgICBpZiAoY2FuT3duKSB7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS51c2VkQnl0ZXMgPT09IDAgJiYgcG9zaXRpb24gPT09IDApIHsgXG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gKyBsZW5ndGggPD0gbm9kZS51c2VkQnl0ZXMpIHsgXG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIFxuICAgICAgICAgIE1FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKG5vZGUsIHBvc2l0aW9uK2xlbmd0aCk7XG4gICAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkgJiYgYnVmZmVyLnN1YmFycmF5KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgIG5vZGUuY29udGVudHNbcG9zaXRpb24gKyBpXSA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LGxsc2VlazpmdW5jdGlvbihzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9LGFsbG9jYXRlOmZ1bmN0aW9uKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShzdHJlYW0ubm9kZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChzdHJlYW0ubm9kZS51c2VkQnl0ZXMsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sbW1hcDpmdW5jdGlvbihzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHB0cjtcbiAgICAgICAgICB2YXIgYWxsb2NhdGVkO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghKGZsYWdzICYgMikgJiYgY29udGVudHMuYnVmZmVyID09PSBIRUFQOC5idWZmZXIpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHB0ciA9IGNvbnRlbnRzLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMCB8fCBwb3NpdGlvbiArIGxlbmd0aCA8IGNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoY29udGVudHMuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cywgcG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsb2NhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHB0ciA9IG1tYXBBbGxvYyhsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSEVBUDguc2V0KGNvbnRlbnRzLCBwdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBwdHI6IHB0ciwgYWxsb2NhdGVkOiBhbGxvY2F0ZWQgfTtcbiAgICAgICAgfSxtc3luYzpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykge1xuICAgICAgICAgIE1FTUZTLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIDAsIGxlbmd0aCwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH19fTtcbiAgXG4gIFxuICBmdW5jdGlvbiBhc3luY0xvYWQodXJsLCBvbmxvYWQsIG9uZXJyb3IsIG5vUnVuRGVwKSB7XG4gICAgICB2YXIgZGVwID0gIW5vUnVuRGVwID8gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeSgnYWwgJyArIHVybCkgOiAnJztcbiAgICAgIHJlYWRBc3luYyh1cmwsIChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICBhc3NlcnQoYXJyYXlCdWZmZXIsICdMb2FkaW5nIGRhdGEgZmlsZSBcIicgKyB1cmwgKyAnXCIgZmFpbGVkIChubyBhcnJheUJ1ZmZlcikuJyk7XG4gICAgICAgIG9ubG9hZChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgICBpZiAoZGVwKSByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICB9LCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ0xvYWRpbmcgZGF0YSBmaWxlIFwiJyArIHVybCArICdcIiBmYWlsZWQuJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZGVwKSBhZGRSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgfVxuICBcbiAgdmFyIEZTID0ge3Jvb3Q6bnVsbCxtb3VudHM6W10sZGV2aWNlczp7fSxzdHJlYW1zOltdLG5leHRJbm9kZToxLG5hbWVUYWJsZTpudWxsLGN1cnJlbnRQYXRoOlwiL1wiLGluaXRpYWxpemVkOmZhbHNlLGlnbm9yZVBlcm1pc3Npb25zOnRydWUsRXJybm9FcnJvcjpudWxsLGdlbmVyaWNFcnJvcnM6e30sZmlsZXN5c3RlbXM6bnVsbCxzeW5jRlNSZXF1ZXN0czowLGxvb2t1cFBhdGg6KHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBwYXRoID0gUEFUSF9GUy5yZXNvbHZlKHBhdGgpO1xuICBcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4geyBwYXRoOiAnJywgbm9kZTogbnVsbCB9O1xuICBcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgIGZvbGxvd19tb3VudDogdHJ1ZSxcbiAgICAgICAgICByZWN1cnNlX2NvdW50OiAwXG4gICAgICAgIH07XG4gICAgICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKVxuICBcbiAgICAgICAgaWYgKG9wdHMucmVjdXJzZV9jb3VudCA+IDgpIHsgIFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMyKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgXG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCk7XG4gIFxuICAgICAgICBcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5yb290O1xuICAgICAgICB2YXIgY3VycmVudF9wYXRoID0gJy8nO1xuICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpc2xhc3QgPSAoaSA9PT0gcGFydHMubGVuZ3RoLTEpO1xuICAgICAgICAgIGlmIChpc2xhc3QgJiYgb3B0cy5wYXJlbnQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTtcbiAgXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChjdXJyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFpc2xhc3QgfHwgKGlzbGFzdCAmJiBvcHRzLmZvbGxvd19tb3VudCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubW91bnRlZC5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFpc2xhc3QgfHwgb3B0cy5mb2xsb3cpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoRlMuaXNMaW5rKGN1cnJlbnQubW9kZSkpIHtcbiAgICAgICAgICAgICAgdmFyIGxpbmsgPSBGUy5yZWFkbGluayhjdXJyZW50X3BhdGgpO1xuICAgICAgICAgICAgICBjdXJyZW50X3BhdGggPSBQQVRIX0ZTLnJlc29sdmUoUEFUSC5kaXJuYW1lKGN1cnJlbnRfcGF0aCksIGxpbmspO1xuICBcbiAgICAgICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoY3VycmVudF9wYXRoLCB7IHJlY3Vyc2VfY291bnQ6IG9wdHMucmVjdXJzZV9jb3VudCArIDEgfSk7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBsb29rdXAubm9kZTtcbiAgXG4gICAgICAgICAgICAgIGlmIChjb3VudCsrID4gNDApIHsgIFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogY3VycmVudF9wYXRoLCBub2RlOiBjdXJyZW50IH07XG4gICAgICB9LGdldFBhdGg6KG5vZGUpID0+IHtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSkge1xuICAgICAgICAgICAgdmFyIG1vdW50ID0gbm9kZS5tb3VudC5tb3VudHBvaW50O1xuICAgICAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbW91bnQ7XG4gICAgICAgICAgICByZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoLTFdICE9PSAnLycgPyBtb3VudCArICcvJyArIHBhdGggOiBtb3VudCArIHBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGggPSBwYXRoID8gbm9kZS5uYW1lICsgJy8nICsgcGF0aCA6IG5vZGUubmFtZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0saGFzaE5hbWU6KHBhcmVudGlkLCBuYW1lKSA9PiB7XG4gICAgICAgIHZhciBoYXNoID0gMDtcbiAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZS5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgocGFyZW50aWQgKyBoYXNoKSA+Pj4gMCkgJSBGUy5uYW1lVGFibGUubGVuZ3RoO1xuICAgICAgfSxoYXNoQWRkTm9kZToobm9kZSkgPT4ge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBub2RlLm5hbWVfbmV4dCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZTtcbiAgICAgIH0saGFzaFJlbW92ZU5vZGU6KG5vZGUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKEZTLm5hbWVUYWJsZVtoYXNoXSA9PT0gbm9kZSkge1xuICAgICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5uYW1lX25leHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5uYW1lX25leHQgPSBub2RlLm5hbWVfbmV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uYW1lX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LGxvb2t1cE5vZGU6KHBhcmVudCwgbmFtZSkgPT4ge1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUxvb2t1cChwYXJlbnQpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShwYXJlbnQuaWQsIG5hbWUpO1xuICAgICAgICBmb3IgKHZhciBub2RlID0gRlMubmFtZVRhYmxlW2hhc2hdOyBub2RlOyBub2RlID0gbm9kZS5uYW1lX25leHQpIHtcbiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50LmlkID09PSBwYXJlbnQuaWQgJiYgbm9kZU5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIEZTLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICAgICAgfSxjcmVhdGVOb2RlOihwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpID0+IHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgRlMuRlNOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldik7XG4gIFxuICAgICAgICBGUy5oYXNoQWRkTm9kZShub2RlKTtcbiAgXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxkZXN0cm95Tm9kZToobm9kZSkgPT4ge1xuICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShub2RlKTtcbiAgICAgIH0saXNSb290Oihub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBub2RlLnBhcmVudDtcbiAgICAgIH0saXNNb3VudHBvaW50Oihub2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAhIW5vZGUubW91bnRlZDtcbiAgICAgIH0saXNGaWxlOihtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMzI3Njg7XG4gICAgICB9LGlzRGlyOihtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMTYzODQ7XG4gICAgICB9LGlzTGluazoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTYwO1xuICAgICAgfSxpc0NocmRldjoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDgxOTI7XG4gICAgICB9LGlzQmxrZGV2Oihtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gMjQ1NzY7XG4gICAgICB9LGlzRklGTzoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTY7XG4gICAgICB9LGlzU29ja2V0Oihtb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiAobW9kZSAmIDQ5MTUyKSA9PT0gNDkxNTI7XG4gICAgICB9LGZsYWdNb2Rlczp7XCJyXCI6MCxcInIrXCI6MixcIndcIjo1NzcsXCJ3K1wiOjU3OCxcImFcIjoxMDg5LFwiYStcIjoxMDkwfSxtb2RlU3RyaW5nVG9GbGFnczooc3RyKSA9PiB7XG4gICAgICAgIHZhciBmbGFncyA9IEZTLmZsYWdNb2Rlc1tzdHJdO1xuICAgICAgICBpZiAodHlwZW9mIGZsYWdzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpbGUgb3BlbiBtb2RlOiAnICsgc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgICB9LGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nOihmbGFnKSA9PiB7XG4gICAgICAgIHZhciBwZXJtcyA9IFsncicsICd3JywgJ3J3J11bZmxhZyAmIDNdO1xuICAgICAgICBpZiAoKGZsYWcgJiA1MTIpKSB7XG4gICAgICAgICAgcGVybXMgKz0gJ3cnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwZXJtcztcbiAgICAgIH0sbm9kZVBlcm1pc3Npb25zOihub2RlLCBwZXJtcykgPT4ge1xuICAgICAgICBpZiAoRlMuaWdub3JlUGVybWlzc2lvbnMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHBlcm1zLmluY2x1ZGVzKCdyJykgJiYgIShub2RlLm1vZGUgJiAyOTIpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3cnKSAmJiAhKG5vZGUubW9kZSAmIDE0NikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygneCcpICYmICEobm9kZS5tb2RlICYgNzMpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LG1heUxvb2t1cDooZGlyKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHJldHVybiBlcnJDb2RlO1xuICAgICAgICBpZiAoIWRpci5ub2RlX29wcy5sb29rdXApIHJldHVybiAyO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sbWF5Q3JlYXRlOihkaXIsIG5hbWUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm4gMjA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgICB9LG1heURlbGV0ZTooZGlyLCBuYW1lLCBpc2RpcikgPT4ge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gZXJyQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNkaXIpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA1NDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSB8fCBGUy5nZXRQYXRoKG5vZGUpID09PSBGUy5jd2QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDMxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sbWF5T3Blbjoobm9kZSwgZmxhZ3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIDQ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgaWYgKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSAhPT0gJ3InIHx8IFxuICAgICAgICAgICAgICAoZmxhZ3MgJiA1MTIpKSB7IFxuICAgICAgICAgICAgcmV0dXJuIDMxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSk7XG4gICAgICB9LE1BWF9PUEVOX0ZEUzo0MDk2LG5leHRmZDooZmRfc3RhcnQgPSAwLCBmZF9lbmQgPSBGUy5NQVhfT1BFTl9GRFMpID0+IHtcbiAgICAgICAgZm9yICh2YXIgZmQgPSBmZF9zdGFydDsgZmQgPD0gZmRfZW5kOyBmZCsrKSB7XG4gICAgICAgICAgaWYgKCFGUy5zdHJlYW1zW2ZkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMyk7XG4gICAgICB9LGdldFN0cmVhbTooZmQpID0+IEZTLnN0cmVhbXNbZmRdLGNyZWF0ZVN0cmVhbTooc3RyZWFtLCBmZF9zdGFydCwgZmRfZW5kKSA9PiB7XG4gICAgICAgIGlmICghRlMuRlNTdHJlYW0pIHtcbiAgICAgICAgICBGUy5GU1N0cmVhbSA9ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkID0geyB9O1xuICAgICAgICAgIH07XG4gICAgICAgICAgRlMuRlNTdHJlYW0ucHJvdG90eXBlID0ge307XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlMuRlNTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vZGU7IH0sXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkgeyB0aGlzLm5vZGUgPSB2YWw7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1JlYWQ6IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAxOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNXcml0ZToge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDA7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0FwcGVuZDoge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMTAyNCk7IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2hhcmVkLmZsYWdzOyB9LFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHsgdGhpcy5zaGFyZWQuZmxhZ3MgPSB2YWw7IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb24gOiB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zaGFyZWQucG9zaXRpb247IH0sXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkgeyB0aGlzLnNoYXJlZC5wb3NpdGlvbiA9IHZhbDsgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN0cmVhbSA9IE9iamVjdC5hc3NpZ24obmV3IEZTLkZTU3RyZWFtKCksIHN0cmVhbSk7XG4gICAgICAgIHZhciBmZCA9IEZTLm5leHRmZChmZF9zdGFydCwgZmRfZW5kKTtcbiAgICAgICAgc3RyZWFtLmZkID0gZmQ7XG4gICAgICAgIEZTLnN0cmVhbXNbZmRdID0gc3RyZWFtO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxjbG9zZVN0cmVhbTooZmQpID0+IHtcbiAgICAgICAgRlMuc3RyZWFtc1tmZF0gPSBudWxsO1xuICAgICAgfSxjaHJkZXZfc3RyZWFtX29wczp7b3Blbjooc3RyZWFtKSA9PiB7XG4gICAgICAgICAgdmFyIGRldmljZSA9IEZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcyA9IGRldmljZS5zdHJlYW1fb3BzO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LGxsc2VlazooKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgICAgICB9fSxtYWpvcjooZGV2KSA9PiAoKGRldikgPj4gOCksbWlub3I6KGRldikgPT4gKChkZXYpICYgMHhmZiksbWFrZWRldjoobWEsIG1pKSA9PiAoKG1hKSA8PCA4IHwgKG1pKSkscmVnaXN0ZXJEZXZpY2U6KGRldiwgb3BzKSA9PiB7XG4gICAgICAgIEZTLmRldmljZXNbZGV2XSA9IHsgc3RyZWFtX29wczogb3BzIH07XG4gICAgICB9LGdldERldmljZTooZGV2KSA9PiBGUy5kZXZpY2VzW2Rldl0sZ2V0TW91bnRzOihtb3VudCkgPT4ge1xuICAgICAgICB2YXIgbW91bnRzID0gW107XG4gICAgICAgIHZhciBjaGVjayA9IFttb3VudF07XG4gIFxuICAgICAgICB3aGlsZSAoY2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG0gPSBjaGVjay5wb3AoKTtcbiAgXG4gICAgICAgICAgbW91bnRzLnB1c2gobSk7XG4gIFxuICAgICAgICAgIGNoZWNrLnB1c2guYXBwbHkoY2hlY2ssIG0ubW91bnRzKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIG1vdW50cztcbiAgICAgIH0sc3luY2ZzOihwb3B1bGF0ZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3B1bGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBwb3B1bGF0ZTtcbiAgICAgICAgICBwb3B1bGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gIFxuICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cysrO1xuICBcbiAgICAgICAgaWYgKEZTLnN5bmNGU1JlcXVlc3RzID4gMSkge1xuICAgICAgICAgIGVycignd2FybmluZzogJyArIEZTLnN5bmNGU1JlcXVlc3RzICsgJyBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrJyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMoRlMucm9vdC5tb3VudCk7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICBcbiAgICAgICAgZnVuY3Rpb24gZG9DYWxsYmFjayhlcnJDb2RlKSB7XG4gICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyQ29kZSkge1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWRvbmUuZXJyb3JlZCkge1xuICAgICAgICAgICAgICBkb25lLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZG9DYWxsYmFjayhlcnJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsrY29tcGxldGVkID49IG1vdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvQ2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICBcbiAgICAgICAgXG4gICAgICAgIG1vdW50cy5mb3JFYWNoKChtb3VudCkgPT4ge1xuICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sbW91bnQ6KHR5cGUsIG9wdHMsIG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgdmFyIHJvb3QgPSBtb3VudHBvaW50ID09PSAnLyc7XG4gICAgICAgIHZhciBwc2V1ZG8gPSAhbW91bnRwb2ludDtcbiAgICAgICAgdmFyIG5vZGU7XG4gIFxuICAgICAgICBpZiAocm9vdCAmJiBGUy5yb290KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9IGVsc2UgaWYgKCFyb290ICYmICFwc2V1ZG8pIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChtb3VudHBvaW50LCB7IGZvbGxvd19tb3VudDogZmFsc2UgfSk7XG4gIFxuICAgICAgICAgIG1vdW50cG9pbnQgPSBsb29rdXAucGF0aDsgIFxuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgXG4gICAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKCFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgbW91bnQgPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBvcHRzOiBvcHRzLFxuICAgICAgICAgIG1vdW50cG9pbnQ6IG1vdW50cG9pbnQsXG4gICAgICAgICAgbW91bnRzOiBbXVxuICAgICAgICB9O1xuICBcbiAgICAgICAgXG4gICAgICAgIHZhciBtb3VudFJvb3QgPSB0eXBlLm1vdW50KG1vdW50KTtcbiAgICAgICAgbW91bnRSb290Lm1vdW50ID0gbW91bnQ7XG4gICAgICAgIG1vdW50LnJvb3QgPSBtb3VudFJvb3Q7XG4gIFxuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIEZTLnJvb3QgPSBtb3VudFJvb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgICAgIFxuICAgICAgICAgIG5vZGUubW91bnRlZCA9IG1vdW50O1xuICBcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAobm9kZS5tb3VudCkge1xuICAgICAgICAgICAgbm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4gbW91bnRSb290O1xuICAgICAgfSx1bm1vdW50Oihtb3VudHBvaW50KSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG1vdW50cG9pbnQsIHsgZm9sbG93X21vdW50OiBmYWxzZSB9KTtcbiAgXG4gICAgICAgIGlmICghRlMuaXNNb3VudHBvaW50KGxvb2t1cC5ub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgXG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBtb3VudCA9IG5vZGUubW91bnRlZDtcbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhtb3VudCk7XG4gIFxuICAgICAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goKGhhc2gpID0+IHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudC5uYW1lX25leHQ7XG4gIFxuICAgICAgICAgICAgaWYgKG1vdW50cy5pbmNsdWRlcyhjdXJyZW50Lm1vdW50KSkge1xuICAgICAgICAgICAgICBGUy5kZXN0cm95Tm9kZShjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICBcbiAgICAgICAgXG4gICAgICAgIG5vZGUubW91bnRlZCA9IG51bGw7XG4gIFxuICAgICAgICBcbiAgICAgICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO1xuICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH0sbG9va3VwOihwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sbWtub2Q6KHBhdGgsIG1vZGUsIGRldikgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lID09PSAnLicgfHwgbmFtZSA9PT0gJy4uJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLm1rbm9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubWtub2QocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgfSxjcmVhdGU6KHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA0MzggO1xuICAgICAgICBtb2RlICY9IDQwOTU7XG4gICAgICAgIG1vZGUgfD0gMzI3Njg7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgIH0sbWtkaXI6KHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA1MTEgO1xuICAgICAgICBtb2RlICY9IDUxMSB8IDUxMjtcbiAgICAgICAgbW9kZSB8PSAxNjM4NDtcbiAgICAgICAgcmV0dXJuIEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgfSxta2RpclRyZWU6KHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgdmFyIGRpcnMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIHZhciBkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICghZGlyc1tpXSkgY29udGludWU7XG4gICAgICAgICAgZCArPSAnLycgKyBkaXJzW2ldO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBGUy5ta2RpcihkLCBtb2RlKTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmVycm5vICE9IDIwKSB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxta2RldjoocGF0aCwgbW9kZSwgZGV2KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZGV2ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGV2ID0gbW9kZTtcbiAgICAgICAgICBtb2RlID0gNDM4IDtcbiAgICAgICAgfVxuICAgICAgICBtb2RlIHw9IDgxOTI7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxzeW1saW5rOihvbGRwYXRoLCBuZXdwYXRoKSA9PiB7XG4gICAgICAgIGlmICghUEFUSF9GUy5yZXNvbHZlKG9sZHBhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXduYW1lID0gUEFUSC5iYXNlbmFtZShuZXdwYXRoKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuZXduYW1lKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5zeW1saW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMuc3ltbGluayhwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpO1xuICAgICAgfSxyZW5hbWU6KG9sZF9wYXRoLCBuZXdfcGF0aCkgPT4ge1xuICAgICAgICB2YXIgb2xkX2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUob2xkX3BhdGgpO1xuICAgICAgICB2YXIgbmV3X2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUobmV3X3BhdGgpO1xuICAgICAgICB2YXIgb2xkX25hbWUgPSBQQVRILmJhc2VuYW1lKG9sZF9wYXRoKTtcbiAgICAgICAgdmFyIG5ld19uYW1lID0gUEFUSC5iYXNlbmFtZShuZXdfcGF0aCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbG9va3VwLCBvbGRfZGlyLCBuZXdfZGlyO1xuICBcbiAgICAgICAgXG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgob2xkX3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBvbGRfZGlyID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3X3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBuZXdfZGlyID0gbG9va3VwLm5vZGU7XG4gIFxuICAgICAgICBpZiAoIW9sZF9kaXIgfHwgIW5ld19kaXIpIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvbGRfZGlyLm1vdW50ICE9PSBuZXdfZGlyLm1vdW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgb2xkX25vZGUgPSBGUy5sb29rdXBOb2RlKG9sZF9kaXIsIG9sZF9uYW1lKTtcbiAgICAgICAgXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUob2xkX3BhdGgsIG5ld19kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUobmV3X3BhdGgsIG9sZF9kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgbmV3X25vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3X25vZGUgPSBGUy5sb29rdXBOb2RlKG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAob2xkX25vZGUgPT09IG5ld19ub2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgaXNkaXIgPSBGUy5pc0RpcihvbGRfbm9kZS5tb2RlKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUob2xkX2Rpciwgb2xkX25hbWUsIGlzZGlyKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGVyckNvZGUgPSBuZXdfbm9kZSA/XG4gICAgICAgICAgRlMubWF5RGVsZXRlKG5ld19kaXIsIG5ld19uYW1lLCBpc2RpcikgOlxuICAgICAgICAgIEZTLm1heUNyZWF0ZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG9sZF9ub2RlKSB8fCAobmV3X25vZGUgJiYgRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChuZXdfZGlyICE9PSBvbGRfZGlyKSB7XG4gICAgICAgICAgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhvbGRfZGlyLCAndycpO1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIEZTLmhhc2hSZW1vdmVOb2RlKG9sZF9ub2RlKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgRlMuaGFzaEFkZE5vZGUob2xkX25vZGUpO1xuICAgICAgICB9XG4gICAgICB9LHJtZGlyOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMucm1kaXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMucm1kaXIocGFyZW50LCBuYW1lKTtcbiAgICAgICAgRlMuZGVzdHJveU5vZGUobm9kZSk7XG4gICAgICB9LHJlYWRkaXI6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5yZWFkZGlyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSk7XG4gICAgICB9LHVubGluazoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy51bmxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxyZWFkbGluazoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcbiAgICAgICAgdmFyIGxpbmsgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluay5ub2RlX29wcy5yZWFkbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSF9GUy5yZXNvbHZlKEZTLmdldFBhdGgobGluay5wYXJlbnQpLCBsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKGxpbmspKTtcbiAgICAgIH0sc3RhdDoocGF0aCwgZG9udEZvbGxvdykgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5nZXRhdHRyKG5vZGUpO1xuICAgICAgfSxsc3RhdDoocGF0aCkgPT4ge1xuICAgICAgICByZXR1cm4gRlMuc3RhdChwYXRoLCB0cnVlKTtcbiAgICAgIH0sY2htb2Q6KHBhdGgsIG1vZGUsIGRvbnRGb2xsb3cpID0+IHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICBtb2RlOiAobW9kZSAmIDQwOTUpIHwgKG5vZGUubW9kZSAmIH40MDk1KSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfSk7XG4gICAgICB9LGxjaG1vZDoocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICBGUy5jaG1vZChwYXRoLCBtb2RlLCB0cnVlKTtcbiAgICAgIH0sZmNobW9kOihmZCwgbW9kZSkgPT4ge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jaG1vZChzdHJlYW0ubm9kZSwgbW9kZSk7XG4gICAgICB9LGNob3duOihwYXRoLCB1aWQsIGdpZCwgZG9udEZvbGxvdykgPT4ge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICAgIH0sbGNob3duOihwYXRoLCB1aWQsIGdpZCkgPT4ge1xuICAgICAgICBGUy5jaG93bihwYXRoLCB1aWQsIGdpZCwgdHJ1ZSk7XG4gICAgICB9LGZjaG93bjooZmQsIHVpZCwgZ2lkKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNob3duKHN0cmVhbS5ub2RlLCB1aWQsIGdpZCk7XG4gICAgICB9LHRydW5jYXRlOihwYXRoLCBsZW4pID0+IHtcbiAgICAgICAgaWYgKGxlbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsICd3Jyk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICBzaXplOiBsZW4sXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pO1xuICAgICAgfSxmdHJ1bmNhdGU6KGZkLCBsZW4pID0+IHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy50cnVuY2F0ZShzdHJlYW0ubm9kZSwgbGVuKTtcbiAgICAgIH0sdXRpbWU6KHBhdGgsIGF0aW1lLCBtdGltZSkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICB0aW1lc3RhbXA6IE1hdGgubWF4KGF0aW1lLCBtdGltZSlcbiAgICAgICAgfSk7XG4gICAgICB9LG9wZW46KHBhdGgsIGZsYWdzLCBtb2RlKSA9PiB7XG4gICAgICAgIGlmIChwYXRoID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGZsYWdzID0gdHlwZW9mIGZsYWdzID09ICdzdHJpbmcnID8gRlMubW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpIDogZmxhZ3M7XG4gICAgICAgIG1vZGUgPSB0eXBlb2YgbW9kZSA9PSAndW5kZWZpbmVkJyA/IDQzOCAgOiBtb2RlO1xuICAgICAgICBpZiAoKGZsYWdzICYgNjQpKSB7XG4gICAgICAgICAgbW9kZSA9IChtb2RlICYgNDA5NSkgfCAzMjc2ODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7XG4gICAgICAgICAgICAgIGZvbGxvdzogIShmbGFncyAmIDEzMTA3MilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChmbGFncyAmIDY0KSkge1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAxMjgpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBub2RlID0gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICAgICAgICBjcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xuICAgICAgICAgIGZsYWdzICY9IH41MTI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICgoZmxhZ3MgJiA2NTUzNikgJiYgIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKCFjcmVhdGVkKSB7XG4gICAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlPcGVuKG5vZGUsIGZsYWdzKTtcbiAgICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoKGZsYWdzICYgNTEyKSAmJiAhY3JlYXRlZCkge1xuICAgICAgICAgIEZTLnRydW5jYXRlKG5vZGUsIDApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmbGFncyAmPSB+KDEyOCB8IDUxMiB8IDEzMTA3Mik7XG4gIFxuICAgICAgICBcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbSh7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBwYXRoOiBGUy5nZXRQYXRoKG5vZGUpLCAgXG4gICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgIHNlZWthYmxlOiB0cnVlLFxuICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgIHN0cmVhbV9vcHM6IG5vZGUuc3RyZWFtX29wcyxcbiAgICAgICAgICBcbiAgICAgICAgICB1bmdvdHRlbjogW10sXG4gICAgICAgICAgZXJyb3I6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pIHtcbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1vZHVsZVsnbG9nUmVhZEZpbGVzJ10gJiYgIShmbGFncyAmIDEpKSB7XG4gICAgICAgICAgaWYgKCFGUy5yZWFkRmlsZXMpIEZTLnJlYWRGaWxlcyA9IHt9O1xuICAgICAgICAgIGlmICghKHBhdGggaW4gRlMucmVhZEZpbGVzKSkge1xuICAgICAgICAgICAgRlMucmVhZEZpbGVzW3BhdGhdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sY2xvc2U6KHN0cmVhbSkgPT4ge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMpIHN0cmVhbS5nZXRkZW50cyA9IG51bGw7IFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5jbG9zZSkge1xuICAgICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIEZTLmNsb3NlU3RyZWFtKHN0cmVhbS5mZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmZkID0gbnVsbDtcbiAgICAgIH0saXNDbG9zZWQ6KHN0cmVhbSkgPT4ge1xuICAgICAgICByZXR1cm4gc3RyZWFtLmZkID09PSBudWxsO1xuICAgICAgfSxsbHNlZWs6KHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpID0+IHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zZWVrYWJsZSB8fCAhc3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGVuY2UgIT0gMCAmJiB3aGVuY2UgIT0gMSAmJiB3aGVuY2UgIT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucG9zaXRpb24gPSBzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7XG4gICAgICAgIHN0cmVhbS51bmdvdHRlbiA9IFtdO1xuICAgICAgICByZXR1cm4gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgfSxyZWFkOihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5yZWFkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVraW5nID0gdHlwZW9mIHBvc2l0aW9uICE9ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoIXNlZWtpbmcpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyZWFtLnNlZWthYmxlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXRlc1JlYWQgPSBzdHJlYW0uc3RyZWFtX29wcy5yZWFkKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICBpZiAoIXNlZWtpbmcpIHN0cmVhbS5wb3NpdGlvbiArPSBieXRlc1JlYWQ7XG4gICAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgICB9LHdyaXRlOihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pID0+IHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uc2Vla2FibGUgJiYgc3RyZWFtLmZsYWdzICYgMTAyNCkge1xuICAgICAgICAgIFxuICAgICAgICAgIEZTLmxsc2VlayhzdHJlYW0sIDAsIDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVraW5nID0gdHlwZW9mIHBvc2l0aW9uICE9ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoIXNlZWtpbmcpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyZWFtLnNlZWthYmxlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXRlc1dyaXR0ZW4gPSBzdHJlYW0uc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pO1xuICAgICAgICBpZiAoIXNlZWtpbmcpIHN0cmVhbS5wb3NpdGlvbiArPSBieXRlc1dyaXR0ZW47XG4gICAgICAgIHJldHVybiBieXRlc1dyaXR0ZW47XG4gICAgICB9LGFsbG9jYXRlOihzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgbGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpICYmICFGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTM4KTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZShzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIH0sbW1hcDooc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykgPT4ge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoKHByb3QgJiAyKSAhPT0gMFxuICAgICAgICAgICAgJiYgKGZsYWdzICYgMikgPT09IDBcbiAgICAgICAgICAgICYmIChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLm1tYXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1tYXAoc3RyZWFtLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncyk7XG4gICAgICB9LG1zeW5jOihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykgPT4ge1xuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKTtcbiAgICAgIH0sbXVubWFwOihzdHJlYW0pID0+IDAsaW9jdGw6KHN0cmVhbSwgY21kLCBhcmcpID0+IHtcbiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwoc3RyZWFtLCBjbWQsIGFyZyk7XG4gICAgICB9LHJlYWRGaWxlOihwYXRoLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgMDtcbiAgICAgICAgb3B0cy5lbmNvZGluZyA9IG9wdHMuZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nICE9PSAndXRmOCcgJiYgb3B0cy5lbmNvZGluZyAhPT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSBcIicgKyBvcHRzLmVuY29kaW5nICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncyk7XG4gICAgICAgIHZhciBzdGF0ID0gRlMuc3RhdChwYXRoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIEZTLnJlYWQoc3RyZWFtLCBidWYsIDAsIGxlbmd0aCwgMCk7XG4gICAgICAgIGlmIChvcHRzLmVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgICAgICByZXQgPSBVVEY4QXJyYXlUb1N0cmluZyhidWYsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgICAgICAgcmV0ID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LHdyaXRlRmlsZToocGF0aCwgZGF0YSwgb3B0cyA9IHt9KSA9PiB7XG4gICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IDU3NztcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncywgb3B0cy5tb2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSsxKTtcbiAgICAgICAgICB2YXIgYWN0dWFsTnVtQnl0ZXMgPSBzdHJpbmdUb1VURjhBcnJheShkYXRhLCBidWYsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgYnVmLCAwLCBhY3R1YWxOdW1CeXRlcywgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgsIHVuZGVmaW5lZCwgb3B0cy5jYW5Pd24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIH0sY3dkOigpID0+IEZTLmN1cnJlbnRQYXRoLGNoZGlyOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICBpZiAobG9va3VwLm5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0Rpcihsb29rdXAubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhsb29rdXAubm9kZSwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jdXJyZW50UGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgfSxjcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXM6KCkgPT4ge1xuICAgICAgICBGUy5ta2RpcignL3RtcCcpO1xuICAgICAgICBGUy5ta2RpcignL2hvbWUnKTtcbiAgICAgICAgRlMubWtkaXIoJy9ob21lL3dlYl91c2VyJyk7XG4gICAgICB9LGNyZWF0ZURlZmF1bHREZXZpY2VzOigpID0+IHtcbiAgICAgICAgXG4gICAgICAgIEZTLm1rZGlyKCcvZGV2Jyk7XG4gICAgICAgIFxuICAgICAgICBGUy5yZWdpc3RlckRldmljZShGUy5tYWtlZGV2KDEsIDMpLCB7XG4gICAgICAgICAgcmVhZDogKCkgPT4gMCxcbiAgICAgICAgICB3cml0ZTogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSA9PiBsZW5ndGgsXG4gICAgICAgIH0pO1xuICAgICAgICBGUy5ta2RldignL2Rldi9udWxsJywgRlMubWFrZWRldigxLCAzKSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDUsIDApLCBUVFkuZGVmYXVsdF90dHlfb3BzKTtcbiAgICAgICAgVFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNiwgMCksIFRUWS5kZWZhdWx0X3R0eTFfb3BzKTtcbiAgICAgICAgRlMubWtkZXYoJy9kZXYvdHR5JywgRlMubWFrZWRldig1LCAwKSk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eTEnLCBGUy5tYWtlZGV2KDYsIDApKTtcbiAgICAgICAgXG4gICAgICAgIHZhciByYW5kb21fZGV2aWNlID0gZ2V0UmFuZG9tRGV2aWNlKCk7XG4gICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdyYW5kb20nLCByYW5kb21fZGV2aWNlKTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3VyYW5kb20nLCByYW5kb21fZGV2aWNlKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0nKTtcbiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htL3RtcCcpO1xuICAgICAgfSxjcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXM6KCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIEZTLm1rZGlyKCcvcHJvYycpO1xuICAgICAgICB2YXIgcHJvY19zZWxmID0gRlMubWtkaXIoJy9wcm9jL3NlbGYnKTtcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jL3NlbGYvZmQnKTtcbiAgICAgICAgRlMubW91bnQoe1xuICAgICAgICAgIG1vdW50OiAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocHJvY19zZWxmLCAnZmQnLCAxNjM4NCB8IDUxMSAsIDczKTtcbiAgICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSB7XG4gICAgICAgICAgICAgIGxvb2t1cDogKHBhcmVudCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBmZCA9ICtuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICAgICAgICAgIGlmICghc3RyZWFtKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgbW91bnQ6IHsgbW91bnRwb2ludDogJ2Zha2UnIH0sXG4gICAgICAgICAgICAgICAgICBub2RlX29wczogeyByZWFkbGluazogKCkgPT4gc3RyZWFtLnBhdGggfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldC5wYXJlbnQgPSByZXQ7IFxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHt9LCAnL3Byb2Mvc2VsZi9mZCcpO1xuICAgICAgfSxjcmVhdGVTdGFuZGFyZFN0cmVhbXM6KCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGluJ10pIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkaW4nLCBNb2R1bGVbJ3N0ZGluJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3RkaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydzdGRvdXQnXSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRvdXQnLCBudWxsLCBNb2R1bGVbJ3N0ZG91dCddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZG91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGVyciddKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIE1vZHVsZVsnc3RkZXJyJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBcbiAgICAgICAgdmFyIHN0ZGluID0gRlMub3BlbignL2Rldi9zdGRpbicsIDApO1xuICAgICAgICB2YXIgc3Rkb3V0ID0gRlMub3BlbignL2Rldi9zdGRvdXQnLCAxKTtcbiAgICAgICAgdmFyIHN0ZGVyciA9IEZTLm9wZW4oJy9kZXYvc3RkZXJyJywgMSk7XG4gICAgICB9LGVuc3VyZUVycm5vRXJyb3I6KCkgPT4ge1xuICAgICAgICBpZiAoRlMuRXJybm9FcnJvcikgcmV0dXJuO1xuICAgICAgICBGUy5FcnJub0Vycm9yID0gIGZ1bmN0aW9uIEVycm5vRXJyb3IoZXJybm8sIG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICAgIHRoaXMuc2V0RXJybm8gPSAgZnVuY3Rpb24oZXJybm8pIHtcbiAgICAgICAgICAgIHRoaXMuZXJybm8gPSBlcnJubztcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuc2V0RXJybm8oZXJybm8pO1xuICAgICAgICAgIHRoaXMubWVzc2FnZSA9ICdGUyBlcnJvcic7XG4gIFxuICAgICAgICB9O1xuICAgICAgICBGUy5FcnJub0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICAgICAgICBGUy5FcnJub0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZTLkVycm5vRXJyb3I7XG4gICAgICAgIFxuICAgICAgICBbNDRdLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdID0gbmV3IEZTLkVycm5vRXJyb3IoY29kZSk7XG4gICAgICAgICAgRlMuZ2VuZXJpY0Vycm9yc1tjb2RlXS5zdGFjayA9ICc8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+JztcbiAgICAgICAgfSk7XG4gICAgICB9LHN0YXRpY0luaXQ6KCkgPT4ge1xuICAgICAgICBGUy5lbnN1cmVFcnJub0Vycm9yKCk7XG4gIFxuICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7XG4gIFxuICAgICAgICBGUy5tb3VudChNRU1GUywge30sICcvJyk7XG4gIFxuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKTtcbiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERldmljZXMoKTtcbiAgICAgICAgRlMuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCk7XG4gIFxuICAgICAgICBGUy5maWxlc3lzdGVtcyA9IHtcbiAgICAgICAgICAnTUVNRlMnOiBNRU1GUyxcbiAgICAgICAgfTtcbiAgICAgIH0saW5pdDooaW5wdXQsIG91dHB1dCwgZXJyb3IpID0+IHtcbiAgICAgICAgRlMuaW5pdC5pbml0aWFsaXplZCA9IHRydWU7XG4gIFxuICAgICAgICBGUy5lbnN1cmVFcnJub0Vycm9yKCk7XG4gIFxuICAgICAgICBcbiAgICAgICAgTW9kdWxlWydzdGRpbiddID0gaW5wdXQgfHwgTW9kdWxlWydzdGRpbiddO1xuICAgICAgICBNb2R1bGVbJ3N0ZG91dCddID0gb3V0cHV0IHx8IE1vZHVsZVsnc3Rkb3V0J107XG4gICAgICAgIE1vZHVsZVsnc3RkZXJyJ10gPSBlcnJvciB8fCBNb2R1bGVbJ3N0ZGVyciddO1xuICBcbiAgICAgICAgRlMuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCk7XG4gICAgICB9LHF1aXQ6KCkgPT4ge1xuICAgICAgICBGUy5pbml0LmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLnN0cmVhbXNbaV07XG4gICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9LGdldE1vZGU6KGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBtb2RlID0gMDtcbiAgICAgICAgaWYgKGNhblJlYWQpIG1vZGUgfD0gMjkyIHwgNzM7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfSxmaW5kT2JqZWN0OihwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICAgICAgaWYgKCFyZXQuZXhpc3RzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5vYmplY3Q7XG4gICAgICB9LGFuYWx5emVQYXRoOihwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgICAgICBwYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGlzUm9vdDogZmFsc2UsIGV4aXN0czogZmFsc2UsIGVycm9yOiAwLCBuYW1lOiBudWxsLCBwYXRoOiBudWxsLCBvYmplY3Q6IG51bGwsXG4gICAgICAgICAgcGFyZW50RXhpc3RzOiBmYWxzZSwgcGFyZW50UGF0aDogbnVsbCwgcGFyZW50T2JqZWN0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgICAgcmV0LnBhcmVudEV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgcmV0LnBhcmVudFBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgICByZXQucGFyZW50T2JqZWN0ID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgcmV0Lm5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgICAgIHJldC5leGlzdHMgPSB0cnVlO1xuICAgICAgICAgIHJldC5wYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICAgICAgcmV0Lm9iamVjdCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICAgIHJldC5uYW1lID0gbG9va3VwLm5vZGUubmFtZTtcbiAgICAgICAgICByZXQuaXNSb290ID0gbG9va3VwLnBhdGggPT09ICcvJztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldC5lcnJvciA9IGUuZXJybm87XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LGNyZWF0ZVBhdGg6KHBhcmVudCwgcGF0aCwgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLnJldmVyc2UoKTtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IFBBVEguam9pbjIocGFyZW50LCBwYXJ0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRlMubWtkaXIoY3VycmVudCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9LGNyZWF0ZUZpbGU6KHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpO1xuICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICByZXR1cm4gRlMuY3JlYXRlKHBhdGgsIG1vZGUpO1xuICAgICAgfSxjcmVhdGVEYXRhRmlsZToocGFyZW50LCBuYW1lLCBkYXRhLCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gbmFtZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XG4gICAgICAgICAgcGF0aCA9IG5hbWUgPyBQQVRILmpvaW4yKHBhcmVudCwgbmFtZSkgOiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBkYXRhID0gYXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBGUy5jaG1vZChub2RlLCBtb2RlIHwgMTQ2KTtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMub3Blbihub2RlLCA1NzcpO1xuICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDAsIGNhbk93bik7XG4gICAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgICBGUy5jaG1vZChub2RlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sY3JlYXRlRGV2aWNlOihwYXJlbnQsIG5hbWUsIGlucHV0LCBvdXRwdXQpID0+IHtcbiAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpO1xuICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoISFpbnB1dCwgISFvdXRwdXQpO1xuICAgICAgICBpZiAoIUZTLmNyZWF0ZURldmljZS5tYWpvcikgRlMuY3JlYXRlRGV2aWNlLm1ham9yID0gNjQ7XG4gICAgICAgIHZhciBkZXYgPSBGUy5tYWtlZGV2KEZTLmNyZWF0ZURldmljZS5tYWpvcisrLCAwKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIHtcbiAgICAgICAgICBvcGVuOiAoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlOiAoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgb3V0cHV0LmJ1ZmZlciAmJiBvdXRwdXQuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBvdXRwdXQoMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVhZDogKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zICkgPT4ge1xuICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICAgIGJ5dGVzUmVhZCsrO1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRlOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQoYnVmZmVyW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBGUy5ta2RldihwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxmb3JjZUxvYWRGaWxlOihvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5pc0RldmljZSB8fCBvYmouaXNGb2xkZXIgfHwgb2JqLmxpbmsgfHwgb2JqLmNvbnRlbnRzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkXykge1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb2JqLmNvbnRlbnRzID0gaW50QXJyYXlGcm9tU3RyaW5nKHJlYWRfKG9iai51cmwpLCB0cnVlKTtcbiAgICAgICAgICAgIG9iai51c2VkQnl0ZXMgPSBvYmouY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4nKTtcbiAgICAgICAgfVxuICAgICAgfSxjcmVhdGVMYXp5RmlsZToocGFyZW50LCBuYW1lLCB1cmwsIGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXkoKSB7XG4gICAgICAgICAgdGhpcy5sZW5ndGhLbm93biA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY2h1bmtzID0gW107IFxuICAgICAgICB9XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQgPSAgZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfZ2V0KGlkeCkge1xuICAgICAgICAgIGlmIChpZHggPiB0aGlzLmxlbmd0aC0xIHx8IGlkeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaHVua09mZnNldCA9IGlkeCAlIHRoaXMuY2h1bmtTaXplO1xuICAgICAgICAgIHZhciBjaHVua051bSA9IChpZHggLyB0aGlzLmNodW5rU2l6ZSl8MDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoY2h1bmtOdW0pW2NodW5rT2Zmc2V0XTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLnNldERhdGFHZXR0ZXIgPSBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9zZXREYXRhR2V0dGVyKGdldHRlcikge1xuICAgICAgICAgIHRoaXMuZ2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICB9O1xuICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuY2FjaGVMZW5ndGggPSBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9jYWNoZUxlbmd0aCgpIHtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICBpZiAoISh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwIHx8IHhoci5zdGF0dXMgPT09IDMwNCkpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyBcIi4gU3RhdHVzOiBcIiArIHhoci5zdGF0dXMpO1xuICAgICAgICAgIHZhciBkYXRhbGVuZ3RoID0gTnVtYmVyKHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtbGVuZ3RoXCIpKTtcbiAgICAgICAgICB2YXIgaGVhZGVyO1xuICAgICAgICAgIHZhciBoYXNCeXRlU2VydmluZyA9IChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJBY2NlcHQtUmFuZ2VzXCIpKSAmJiBoZWFkZXIgPT09IFwiYnl0ZXNcIjtcbiAgICAgICAgICB2YXIgdXNlc0d6aXAgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1FbmNvZGluZ1wiKSkgJiYgaGVhZGVyID09PSBcImd6aXBcIjtcbiAgXG4gICAgICAgICAgdmFyIGNodW5rU2l6ZSA9IDEwMjQqMTAyNDsgXG4gIFxuICAgICAgICAgIGlmICghaGFzQnl0ZVNlcnZpbmcpIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XG4gIFxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBkb1hIUiA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPiB0bykgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByYW5nZSAoXCIgKyBmcm9tICsgXCIsIFwiICsgdG8gKyBcIikgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkIVwiKTtcbiAgICAgICAgICAgIGlmICh0byA+IGRhdGFsZW5ndGgtMSkgdGhyb3cgbmV3IEVycm9yKFwib25seSBcIiArIGRhdGFsZW5ndGggKyBcIiBieXRlcyBhdmFpbGFibGUhIHByb2dyYW1tZXIgZXJyb3IhXCIpO1xuICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGRhdGFsZW5ndGggIT09IGNodW5rU2l6ZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBcImJ5dGVzPVwiICsgZnJvbSArIFwiLVwiICsgdG8pO1xuICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICBpZiAoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgIGlmICghKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArIFwiLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCh4aHIucmVzcG9uc2UgfHwgW10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCB8fCAnJywgdHJ1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gdGhpcztcbiAgICAgICAgICBsYXp5QXJyYXkuc2V0RGF0YUdldHRlcigoY2h1bmtOdW0pID0+IHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNodW5rTnVtICogY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGVuZCA9IChjaHVua051bSsxKSAqIGNodW5rU2l6ZSAtIDE7IFxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBkYXRhbGVuZ3RoLTEpOyBcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPSBkb1hIUihzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcignZG9YSFIgZmFpbGVkIScpO1xuICAgICAgICAgICAgcmV0dXJuIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dO1xuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBpZiAodXNlc0d6aXAgfHwgIWRhdGFsZW5ndGgpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2h1bmtTaXplID0gZGF0YWxlbmd0aCA9IDE7IFxuICAgICAgICAgICAgZGF0YWxlbmd0aCA9IHRoaXMuZ2V0dGVyKDApLmxlbmd0aDtcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICBvdXQoXCJMYXp5RmlsZXMgb24gZ3ppcCBmb3JjZXMgZG93bmxvYWQgb2YgdGhlIHdob2xlIGZpbGUgd2hlbiBsZW5ndGggaXMgYWNjZXNzZWRcIik7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICB0aGlzLl9sZW5ndGggPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICghRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyc7XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSwge1xuICAgICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICAgIGdldDogIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2h1bmtTaXplOiB7XG4gICAgICAgICAgICAgIGdldDogIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2h1bmtTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0geyBpc0RldmljZTogZmFsc2UsIGNvbnRlbnRzOiBsYXp5QXJyYXkgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCB1cmw6IHVybCB9O1xuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZUZpbGUocGFyZW50LCBuYW1lLCBwcm9wZXJ0aWVzLCBjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbnRlbnRzKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IHByb3BlcnRpZXMuY29udGVudHM7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy51cmwpIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICBub2RlLnVybCA9IHByb3BlcnRpZXMudXJsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLCB7XG4gICAgICAgICAgdXNlZEJ5dGVzOiB7XG4gICAgICAgICAgICBnZXQ6ICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29udGVudHMubGVuZ3RoOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdHJlYW1fb3BzID0ge307XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICB2YXIgZm4gPSBub2RlLnN0cmVhbV9vcHNba2V5XTtcbiAgICAgICAgICBzdHJlYW1fb3BzW2tleV0gPSBmdW5jdGlvbiBmb3JjZUxvYWRMYXp5RmlsZSgpIHtcbiAgICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDaHVua3Moc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjb250ZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKGNvbnRlbnRzLmxlbmd0aCAtIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICAgIGlmIChjb250ZW50cy5zbGljZSkgeyBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7IFxuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50cy5nZXQocG9zaXRpb24gKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN0cmVhbV9vcHMucmVhZCA9IChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVDaHVua3Moc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHN0cmVhbV9vcHMubW1hcCA9IChzdHJlYW0sIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgICAgICB2YXIgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3JpdGVDaHVua3Moc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICByZXR1cm4geyBwdHI6IHB0ciwgYWxsb2NhdGVkOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IHN0cmVhbV9vcHM7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxjcmVhdGVQcmVsb2FkZWRGaWxlOihwYXJlbnQsIG5hbWUsIHVybCwgY2FuUmVhZCwgY2FuV3JpdGUsIG9ubG9hZCwgb25lcnJvciwgZG9udENyZWF0ZUZpbGUsIGNhbk93biwgcHJlRmluaXNoKSA9PiB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIGZ1bGxuYW1lID0gbmFtZSA/IFBBVEhfRlMucmVzb2x2ZShQQVRILmpvaW4yKHBhcmVudCwgbmFtZSkpIDogcGFyZW50O1xuICAgICAgICB2YXIgZGVwID0gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeSgnY3AgJyArIGZ1bGxuYW1lKTsgXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NEYXRhKGJ5dGVBcnJheSkge1xuICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaChieXRlQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChwcmVGaW5pc2gpIHByZUZpbmlzaCgpO1xuICAgICAgICAgICAgaWYgKCFkb250Q3JlYXRlRmlsZSkge1xuICAgICAgICAgICAgICBGUy5jcmVhdGVEYXRhRmlsZShwYXJlbnQsIG5hbWUsIGJ5dGVBcnJheSwgY2FuUmVhZCwgY2FuV3JpdGUsIGNhbk93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25sb2FkKSBvbmxvYWQoKTtcbiAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEJyb3dzZXIuaGFuZGxlZEJ5UHJlbG9hZFBsdWdpbihieXRlQXJyYXksIGZ1bGxuYW1lLCBmaW5pc2gsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvbmVycm9yKSBvbmVycm9yKCk7XG4gICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoKGJ5dGVBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGFzeW5jTG9hZCh1cmwsIChieXRlQXJyYXkpID0+IHByb2Nlc3NEYXRhKGJ5dGVBcnJheSksIG9uZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3NEYXRhKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH0saW5kZXhlZERCOigpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbmRleGVkREIgfHwgd2luZG93Lm1vekluZGV4ZWREQiB8fCB3aW5kb3cud2Via2l0SW5kZXhlZERCIHx8IHdpbmRvdy5tc0luZGV4ZWREQjtcbiAgICAgIH0sREJfTkFNRTooKSA9PiB7XG4gICAgICAgIHJldHVybiAnRU1fRlNfJyArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgIH0sREJfVkVSU0lPTjoyMCxEQl9TVE9SRV9OQU1FOlwiRklMRV9EQVRBXCIsc2F2ZUZpbGVzVG9EQjoocGF0aHMsIG9ubG9hZCwgb25lcnJvcikgPT4ge1xuICAgICAgICBvbmxvYWQgPSBvbmxvYWQgfHwgKCgpID0+IHt9KTtcbiAgICAgICAgb25lcnJvciA9IG9uZXJyb3IgfHwgKCgpID0+IHt9KTtcbiAgICAgICAgdmFyIGluZGV4ZWREQiA9IEZTLmluZGV4ZWREQigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBvcGVuUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKEZTLkRCX05BTUUoKSwgRlMuREJfVkVSU0lPTik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gb25lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgb3V0KCdjcmVhdGluZyBkYicpO1xuICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgICAgfTtcbiAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbRlMuREJfU1RPUkVfTkFNRV0sICdyZWFkd3JpdGUnKTtcbiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgICAgICB2YXIgb2sgPSAwLCBmYWlsID0gMCwgdG90YWwgPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAgICAgaWYgKGZhaWwgPT0gMCkgb25sb2FkKCk7IGVsc2Ugb25lcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICB2YXIgcHV0UmVxdWVzdCA9IGZpbGVzLnB1dChGUy5hbmFseXplUGF0aChwYXRoKS5vYmplY3QuY29udGVudHMsIHBhdGgpO1xuICAgICAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7IG9rKys7IGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpIH07XG4gICAgICAgICAgICBwdXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7IGZhaWwrKzsgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCkgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICB9LGxvYWRGaWxlc0Zyb21EQjoocGF0aHMsIG9ubG9hZCwgb25lcnJvcikgPT4ge1xuICAgICAgICBvbmxvYWQgPSBvbmxvYWQgfHwgKCgpID0+IHt9KTtcbiAgICAgICAgb25lcnJvciA9IG9uZXJyb3IgfHwgKCgpID0+IHt9KTtcbiAgICAgICAgdmFyIGluZGV4ZWREQiA9IEZTLmluZGV4ZWREQigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBvcGVuUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKEZTLkRCX05BTUUoKSwgRlMuREJfVkVSU0lPTik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gb25lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBvbmVycm9yOyBcbiAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZG9ubHknKTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmaWxlcyA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgICAgIHZhciBvayA9IDAsIGZhaWwgPSAwLCB0b3RhbCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgICAgICBpZiAoZmFpbCA9PSAwKSBvbmxvYWQoKTsgZWxzZSBvbmVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHZhciBnZXRSZXF1ZXN0ID0gZmlsZXMuZ2V0KHBhdGgpO1xuICAgICAgICAgICAgZ2V0UmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChGUy5hbmFseXplUGF0aChwYXRoKS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICBGUy51bmxpbmsocGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgRlMuY3JlYXRlRGF0YUZpbGUoUEFUSC5kaXJuYW1lKHBhdGgpLCBQQVRILmJhc2VuYW1lKHBhdGgpLCBnZXRSZXF1ZXN0LnJlc3VsdCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9rKys7XG4gICAgICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdldFJlcXVlc3Qub25lcnJvciA9ICgpID0+IHsgZmFpbCsrOyBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICB9O1xuICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgIH19O1xuICB2YXIgU1lTQ0FMTFMgPSB7REVGQVVMVF9QT0xMTUFTSzo1LGNhbGN1bGF0ZUF0OmZ1bmN0aW9uKGRpcmZkLCBwYXRoLCBhbGxvd0VtcHR5KSB7XG4gICAgICAgIGlmIChQQVRILmlzQWJzKHBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBkaXI7XG4gICAgICAgIGlmIChkaXJmZCA9PT0gLTEwMCkge1xuICAgICAgICAgIGRpciA9IEZTLmN3ZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkaXJzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZGlyZmQpO1xuICAgICAgICAgIGRpciA9IGRpcnN0cmVhbS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgaWYgKCFhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVRILmpvaW4yKGRpciwgcGF0aCk7XG4gICAgICB9LGRvU3RhdDpmdW5jdGlvbihmdW5jLCBwYXRoLCBidWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc3RhdCA9IGZ1bmMocGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLm5vZGUgJiYgUEFUSC5ub3JtYWxpemUocGF0aCkgIT09IFBBVEgubm9ybWFsaXplKEZTLmdldFBhdGgoZS5ub2RlKSkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIC01NDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBIRUFQMzJbKChidWYpPj4yKV0gPSBzdGF0LmRldjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDgpKT4+MildID0gc3RhdC5pbm87XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygxMikpPj4yKV0gPSBzdGF0Lm1vZGU7XG4gICAgICAgIEhFQVBVMzJbKCgoYnVmKSsoMTYpKT4+MildID0gc3RhdC5ubGluaztcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDIwKSk+PjIpXSA9IHN0YXQudWlkO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMjQpKT4+MildID0gc3RhdC5naWQ7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygyOCkpPj4yKV0gPSBzdGF0LnJkZXY7XG4gICAgICAgICh0ZW1wSTY0ID0gW3N0YXQuc2l6ZT4+PjAsKHRlbXBEb3VibGU9c3RhdC5zaXplLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGJ1ZikrKDQwKSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDQ0KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNDgpKT4+MildID0gNDA5NjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDUyKSk+PjIpXSA9IHN0YXQuYmxvY2tzO1xuICAgICAgICB2YXIgYXRpbWUgPSBzdGF0LmF0aW1lLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIG10aW1lID0gc3RhdC5tdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xuICAgICAgICAodGVtcEk2NCA9IFtNYXRoLmZsb29yKGF0aW1lIC8gMTAwMCk+Pj4wLCh0ZW1wRG91YmxlPU1hdGguZmxvb3IoYXRpbWUgLyAxMDAwKSwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKChidWYpKyg1NikpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChidWYpKyg2MCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUFUzMlsoKChidWYpKyg2NCkpPj4yKV0gPSAoYXRpbWUgJSAxMDAwKSAqIDEwMDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW01hdGguZmxvb3IobXRpbWUgLyAxMDAwKT4+PjAsKHRlbXBEb3VibGU9TWF0aC5mbG9vcihtdGltZSAvIDEwMDApLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGJ1ZikrKDcyKSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDc2KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQVTMyWygoKGJ1ZikrKDgwKSk+PjIpXSA9IChtdGltZSAlIDEwMDApICogMTAwMDtcbiAgICAgICAgKHRlbXBJNjQgPSBbTWF0aC5mbG9vcihjdGltZSAvIDEwMDApPj4+MCwodGVtcERvdWJsZT1NYXRoLmZsb29yKGN0aW1lIC8gMTAwMCksKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgoYnVmKSsoODgpKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoOTIpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIEhFQVBVMzJbKCgoYnVmKSsoOTYpKT4+MildID0gKGN0aW1lICUgMTAwMCkgKiAxMDAwO1xuICAgICAgICAodGVtcEk2NCA9IFtzdGF0Lmlubz4+PjAsKHRlbXBEb3VibGU9c3RhdC5pbm8sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgoYnVmKSsoMTA0KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDEwOCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LGRvTXN5bmM6ZnVuY3Rpb24oYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBIRUFQVTguc2xpY2UoYWRkciwgYWRkciArIGxlbik7XG4gICAgICAgIEZTLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbiwgZmxhZ3MpO1xuICAgICAgfSx2YXJhcmdzOnVuZGVmaW5lZCxnZXQ6ZnVuY3Rpb24oKSB7XG4gICAgICAgIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgICAgICAgdmFyIHJldCA9IEhFQVAzMlsoKChTWVNDQUxMUy52YXJhcmdzKS0oNCkpPj4yKV07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LGdldFN0cjpmdW5jdGlvbihwdHIpIHtcbiAgICAgICAgdmFyIHJldCA9IFVURjhUb1N0cmluZyhwdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxnZXRTdHJlYW1Gcm9tRkQ6ZnVuY3Rpb24oZmQpIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgICAgIGlmICghc3RyZWFtKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH19O1xuICBmdW5jdGlvbiBfX19zeXNjYWxsX2NobW9kKHBhdGgsIG1vZGUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgRlMuY2htb2QocGF0aCwgbW9kZSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmFjY2Vzc2F0KGRpcmZkLCBwYXRoLCBhbW9kZSwgZmxhZ3MpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIGlmIChhbW9kZSAmIH43KSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgfVxuICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiAtNDQ7XG4gICAgICB9XG4gICAgICB2YXIgcGVybXMgPSAnJztcbiAgICAgIGlmIChhbW9kZSAmIDQpIHBlcm1zICs9ICdyJztcbiAgICAgIGlmIChhbW9kZSAmIDIpIHBlcm1zICs9ICd3JztcbiAgICAgIGlmIChhbW9kZSAmIDEpIHBlcm1zICs9ICd4JztcbiAgICAgIGlmIChwZXJtcyAgJiYgRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSkge1xuICAgICAgICByZXR1cm4gLTI7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNobW9kKGZkLCBtb2RlKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgRlMuZmNobW9kKGZkLCBtb2RlKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9mY2hvd24zMihmZCwgb3duZXIsIGdyb3VwKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgRlMuZmNob3duKGZkLCBvd25lciwgZ3JvdXApO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRFcnJObyh2YWx1ZSkge1xuICAgICAgSEVBUDMyWygoX19fZXJybm9fbG9jYXRpb24oKSk+PjIpXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNudGw2NChmZCwgY21kLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIGlmIChhcmcgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV3U3RyZWFtO1xuICAgICAgICAgIG5ld1N0cmVhbSA9IEZTLmNyZWF0ZVN0cmVhbShzdHJlYW0sIGFyZyk7XG4gICAgICAgICAgcmV0dXJuIG5ld1N0cmVhbS5mZDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gMDsgIFxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbS5mbGFncztcbiAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIHN0cmVhbS5mbGFncyB8PSBhcmc7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAge1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBhcmcgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBcbiAgICAgICAgICBIRUFQMTZbKCgoYXJnKSsob2Zmc2V0KSk+PjEpXSA9IDI7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gMDsgXG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gLTI4OyBcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIFxuICAgICAgICAgIHNldEVyck5vKDI4KTtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsIGJ1Zikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBzdHJlYW0ucGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIHZhciBNQVhfSU5UNTMgPSA5MDA3MTk5MjU0NzQwOTkyO1xuICBcbiAgdmFyIE1JTl9JTlQ1MyA9IC05MDA3MTk5MjU0NzQwOTkyO1xuICBmdW5jdGlvbiBiaWdpbnRUb0k1M0NoZWNrZWQobnVtKSB7XG4gICAgICByZXR1cm4gKG51bSA8IE1JTl9JTlQ1MyB8fCBudW0gPiBNQVhfSU5UNTMpID8gTmFOIDogTnVtYmVyKG51bSk7XG4gICAgfVxuICBcbiAgXG4gIFxuICBcbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9mdHJ1bmNhdGU2NChmZCwgIGxlbmd0aCkge1xuICB0cnkge1xuICBcbiAgICAgIGxlbmd0aCA9IGJpZ2ludFRvSTUzQ2hlY2tlZChsZW5ndGgpOyBpZiAoaXNOYU4obGVuZ3RoKSkgcmV0dXJuIC02MTtcbiAgICAgIEZTLmZ0cnVuY2F0ZShmZCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9nZXRjd2QoYnVmLCBzaXplKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgaWYgKHNpemUgPT09IDApIHJldHVybiAtMjg7XG4gICAgICB2YXIgY3dkID0gRlMuY3dkKCk7XG4gICAgICB2YXIgY3dkTGVuZ3RoSW5CeXRlcyA9IGxlbmd0aEJ5dGVzVVRGOChjd2QpICsgMTtcbiAgICAgIGlmIChzaXplIDwgY3dkTGVuZ3RoSW5CeXRlcykgcmV0dXJuIC02ODtcbiAgICAgIHN0cmluZ1RvVVRGOChjd2QsIGJ1Ziwgc2l6ZSk7XG4gICAgICByZXR1cm4gY3dkTGVuZ3RoSW5CeXRlcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIDIxNTA5OlxuICAgICAgICBjYXNlIDIxNTA1OiB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MTA6XG4gICAgICAgIGNhc2UgMjE1MTE6XG4gICAgICAgIGNhc2UgMjE1MTI6XG4gICAgICAgIGNhc2UgMjE1MDY6XG4gICAgICAgIGNhc2UgMjE1MDc6XG4gICAgICAgIGNhc2UgMjE1MDg6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIDA7IFxuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MTk6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgdmFyIGFyZ3AgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICBIRUFQMzJbKChhcmdwKT4+MildID0gMDtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTIwOiB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHJldHVybiAtMjg7IFxuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MzE6IHtcbiAgICAgICAgICB2YXIgYXJncCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIHJldHVybiBGUy5pb2N0bChzdHJlYW0sIG9wLCBhcmdwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTIzOiB7XG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MjQ6IHtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIC0yODsgXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2xzdGF0NjQocGF0aCwgYnVmKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQoRlMubHN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX21rZGlyYXQoZGlyZmQsIHBhdGgsIG1vZGUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIFxuICAgICAgXG4gICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAocGF0aFtwYXRoLmxlbmd0aC0xXSA9PT0gJy8nKSBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5sZW5ndGgtMSk7XG4gICAgICBGUy5ta2RpcihwYXRoLCBtb2RlLCAwKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9uZXdmc3RhdGF0KGRpcmZkLCBwYXRoLCBidWYsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHZhciBub2ZvbGxvdyA9IGZsYWdzICYgMjU2O1xuICAgICAgdmFyIGFsbG93RW1wdHkgPSBmbGFncyAmIDQwOTY7XG4gICAgICBmbGFncyA9IGZsYWdzICYgKH42NDAwKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCwgYWxsb3dFbXB0eSk7XG4gICAgICByZXR1cm4gU1lTQ0FMTFMuZG9TdGF0KG5vZm9sbG93ID8gRlMubHN0YXQgOiBGUy5zdGF0LCBwYXRoLCBidWYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9vcGVuYXQoZGlyZmQsIHBhdGgsIGZsYWdzLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgdmFyIG1vZGUgPSB2YXJhcmdzID8gU1lTQ0FMTFMuZ2V0KCkgOiAwO1xuICAgICAgcmV0dXJuIEZTLm9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUpLmZkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9yZWFkbGlua2F0KGRpcmZkLCBwYXRoLCBidWYsIGJ1ZnNpemUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIGlmIChidWZzaXplIDw9IDApIHJldHVybiAtMjg7XG4gICAgICB2YXIgcmV0ID0gRlMucmVhZGxpbmsocGF0aCk7XG4gIFxuICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGJ1ZnNpemUsIGxlbmd0aEJ5dGVzVVRGOChyZXQpKTtcbiAgICAgIHZhciBlbmRDaGFyID0gSEVBUDhbYnVmK2xlbl07XG4gICAgICBzdHJpbmdUb1VURjgocmV0LCBidWYsIGJ1ZnNpemUrMSk7XG4gICAgICBcbiAgICAgIFxuICAgICAgSEVBUDhbYnVmK2xlbl0gPSBlbmRDaGFyO1xuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9zdGF0NjQocGF0aCwgYnVmKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQoRlMuc3RhdCwgcGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfdW5saW5rYXQoZGlyZmQsIHBhdGgsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICBpZiAoZmxhZ3MgPT09IDApIHtcbiAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgfSBlbHNlIGlmIChmbGFncyA9PT0gNTEyKSB7XG4gICAgICAgIEZTLnJtZGlyKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWJvcnQoJ0ludmFsaWQgZmxhZ3MgcGFzc2VkIHRvIHVubGlua2F0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRJNTNGcm9tSTY0KHB0cikge1xuICAgICAgcmV0dXJuIEhFQVBVMzJbcHRyPj4yXSArIEhFQVAzMltwdHIrND4+Ml0gKiA0Mjk0OTY3Mjk2O1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfdXRpbWVuc2F0KGRpcmZkLCBwYXRoLCB0aW1lcywgZmxhZ3MpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCB0cnVlKTtcbiAgICAgIGlmICghdGltZXMpIHtcbiAgICAgICAgdmFyIGF0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIG10aW1lID0gYXRpbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2Vjb25kcyA9IHJlYWRJNTNGcm9tSTY0KHRpbWVzKTtcbiAgICAgICAgdmFyIG5hbm9zZWNvbmRzID0gSEVBUDMyWygoKHRpbWVzKSsoOCkpPj4yKV07XG4gICAgICAgIGF0aW1lID0gKHNlY29uZHMqMTAwMCkgKyAobmFub3NlY29uZHMvKDEwMDAqMTAwMCkpO1xuICAgICAgICB0aW1lcyArPSAxNjtcbiAgICAgICAgc2Vjb25kcyA9IHJlYWRJNTNGcm9tSTY0KHRpbWVzKTtcbiAgICAgICAgbmFub3NlY29uZHMgPSBIRUFQMzJbKCgodGltZXMpKyg4KSk+PjIpXTtcbiAgICAgICAgbXRpbWUgPSAoc2Vjb25kcyoxMDAwKSArIChuYW5vc2Vjb25kcy8oMTAwMCoxMDAwKSk7XG4gICAgICB9XG4gICAgICBGUy51dGltZShwYXRoLCBhdGltZSwgbXRpbWUpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICB2YXIgbm93SXNNb25vdG9uaWMgPSB0cnVlOztcbiAgZnVuY3Rpb24gX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKCkge1xuICAgICAgcmV0dXJuIG5vd0lzTW9ub3RvbmljO1xuICAgIH1cblxuICBcbiAgZnVuY3Rpb24gX19pc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIHllYXIlNCA9PT0gMCAmJiAoeWVhciUxMDAgIT09IDAgfHwgeWVhciU0MDAgPT09IDApO1xuICAgIH1cbiAgXG4gIHZhciBfX01PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFID0gWzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV07XG4gIFxuICB2YXIgX19NT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRSA9IFswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO1xuICBmdW5jdGlvbiBfX3lkYXlfZnJvbV9kYXRlKGRhdGUpIHtcbiAgICAgIHZhciBpc0xlYXBZZWFyID0gX19pc0xlYXBZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICB2YXIgbW9udGhEYXlzQ3VtdWxhdGl2ZSA9IChpc0xlYXBZZWFyID8gX19NT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA6IF9fTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUpO1xuICAgICAgdmFyIHlkYXkgPSBtb250aERheXNDdW11bGF0aXZlW2RhdGUuZ2V0TW9udGgoKV0gKyBkYXRlLmdldERhdGUoKSAtIDE7IFxuICBcbiAgICAgIHJldHVybiB5ZGF5O1xuICAgIH1cbiAgZnVuY3Rpb24gX19sb2NhbHRpbWVfanModGltZSwgdG1QdHIpIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUocmVhZEk1M0Zyb21JNjQodGltZSkqMTAwMCk7XG4gICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoNCkpPj4yKV0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDgpKT4+MildID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTIpKT4+MildID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0gPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gPSBkYXRlLmdldEZ1bGxZZWFyKCktMTkwMDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0RGF5KCk7XG4gIFxuICAgICAgdmFyIHlkYXkgPSBfX3lkYXlfZnJvbV9kYXRlKGRhdGUpfDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyOCkpPj4yKV0gPSB5ZGF5O1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMzYpKT4+MildID0gLShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCk7XG4gIFxuICAgICAgXG4gICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIGRzdCA9IChzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PSBNYXRoLm1pbih3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCkpfDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygzMikpPj4yKV0gPSBkc3Q7XG4gICAgfVxuXG4gIFxuICBcbiAgZnVuY3Rpb24gX19tbWFwX2pzKGxlbiwgcHJvdCwgZmxhZ3MsIGZkLCBvZmYsIGFsbG9jYXRlZCwgYWRkcikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgdmFyIHJlcyA9IEZTLm1tYXAoc3RyZWFtLCBsZW4sIG9mZiwgcHJvdCwgZmxhZ3MpO1xuICAgICAgdmFyIHB0ciA9IHJlcy5wdHI7XG4gICAgICBIRUFQMzJbKChhbGxvY2F0ZWQpPj4yKV0gPSByZXMuYWxsb2NhdGVkO1xuICAgICAgSEVBUFUzMlsoKGFkZHIpPj4yKV0gPSBwdHI7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIFxuICBcbiAgZnVuY3Rpb24gX19tdW5tYXBfanMoYWRkciwgbGVuLCBwcm90LCBmbGFncywgZmQsIG9mZnNldCkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgaWYgKHByb3QgJiAyKSB7XG4gICAgICAgIFNZU0NBTExTLmRvTXN5bmMoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgRlMubXVubWFwKHN0cmVhbSk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG9jYXRlVVRGOChzdHIpIHtcbiAgICAgIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xuICAgICAgdmFyIHJldCA9IF9tYWxsb2Moc2l6ZSk7XG4gICAgICBpZiAocmV0KSBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVA4LCByZXQsIHNpemUpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIGZ1bmN0aW9uIF9fdHpzZXRfanModGltZXpvbmUsIGRheWxpZ2h0LCB0em5hbWUpIHtcbiAgICAgIFxuICAgICAgdmFyIGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICAgICAgdmFyIHdpbnRlciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCAwLCAxKTtcbiAgICAgIHZhciBzdW1tZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgNiwgMSk7XG4gICAgICB2YXIgd2ludGVyT2Zmc2V0ID0gd2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgc3VtbWVyT2Zmc2V0ID0gc3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgod2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpO1xuICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBIRUFQVTMyWygodGltZXpvbmUpPj4yKV0gPSBzdGRUaW1lem9uZU9mZnNldCAqIDYwO1xuICBcbiAgICAgIEhFQVAzMlsoKGRheWxpZ2h0KT4+MildID0gTnVtYmVyKHdpbnRlck9mZnNldCAhPSBzdW1tZXJPZmZzZXQpO1xuICBcbiAgICAgIGZ1bmN0aW9uIGV4dHJhY3Rab25lKGRhdGUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZGF0ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiR01UXCI7XG4gICAgICB9O1xuICAgICAgdmFyIHdpbnRlck5hbWUgPSBleHRyYWN0Wm9uZSh3aW50ZXIpO1xuICAgICAgdmFyIHN1bW1lck5hbWUgPSBleHRyYWN0Wm9uZShzdW1tZXIpO1xuICAgICAgdmFyIHdpbnRlck5hbWVQdHIgPSBhbGxvY2F0ZVVURjgod2ludGVyTmFtZSk7XG4gICAgICB2YXIgc3VtbWVyTmFtZVB0ciA9IGFsbG9jYXRlVVRGOChzdW1tZXJOYW1lKTtcbiAgICAgIGlmIChzdW1tZXJPZmZzZXQgPCB3aW50ZXJPZmZzZXQpIHtcbiAgICAgICAgXG4gICAgICAgIEhFQVBVMzJbKCh0em5hbWUpPj4yKV0gPSB3aW50ZXJOYW1lUHRyO1xuICAgICAgICBIRUFQVTMyWygoKHR6bmFtZSkrKDQpKT4+MildID0gc3VtbWVyTmFtZVB0cjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEhFQVBVMzJbKCh0em5hbWUpPj4yKV0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgICBIRUFQVTMyWygoKHR6bmFtZSkrKDQpKT4+MildID0gd2ludGVyTmFtZVB0cjtcbiAgICAgIH1cbiAgICB9XG5cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZGF0ZV9ub3coKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgdmFyIF9lbXNjcmlwdGVuX2dldF9ub3c7X2Vtc2NyaXB0ZW5fZ2V0X25vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xuICA7XG5cbiAgZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgcmV0dXJuIDIxNDc0ODM2NDg7XG4gICAgfVxuICBcbiAgZnVuY3Rpb24gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihzaXplKSB7XG4gICAgICB2YXIgYiA9IHdhc21NZW1vcnkuYnVmZmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgXG4gICAgICAgIHdhc21NZW1vcnkuZ3Jvdygoc2l6ZSAtIGIuYnl0ZUxlbmd0aCArIDY1NTM1KSA+Pj4gMTYpOyBcbiAgICAgICAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcbiAgICAgICAgcmV0dXJuIDEgO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgIH1cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuICAgICAgdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuICAgICAgcmVxdWVzdGVkU2l6ZSA9IHJlcXVlc3RlZFNpemUgPj4+IDA7XG4gICAgICBcbiAgICAgIFxuICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICBcbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gICAgICBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgXG4gICAgICBsZXQgYWxpZ25VcCA9ICh4LCBtdWx0aXBsZSkgPT4geCArIChtdWx0aXBsZSAtIHggJSBtdWx0aXBsZSkgJSBtdWx0aXBsZTtcbiAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBmb3IgKHZhciBjdXREb3duID0gMTsgY3V0RG93biA8PSA0OyBjdXREb3duICo9IDIpIHtcbiAgICAgICAgdmFyIG92ZXJHcm93bkhlYXBTaXplID0gb2xkU2l6ZSAqICgxICsgMC4yIC8gY3V0RG93bik7IFxuICAgICAgICBcbiAgICAgICAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSwgcmVxdWVzdGVkU2l6ZSArIDEwMDY2MzI5NiApO1xuICBcbiAgICAgICAgdmFyIG5ld1NpemUgPSBNYXRoLm1pbihtYXhIZWFwU2l6ZSwgYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLCBvdmVyR3Jvd25IZWFwU2l6ZSksIDY1NTM2KSk7XG4gIFxuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKG5ld1NpemUpO1xuICAgICAgICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgdmFyIEVOViA9IHt9O1xuICBcbiAgZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpc1Byb2dyYW0gfHwgJy4vdGhpcy5wcm9ncmFtJztcbiAgICB9XG4gIGZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gICAgICBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBsYW5nID0gKCh0eXBlb2YgbmF2aWdhdG9yID09ICdvYmplY3QnICYmIG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSkgfHwgJ0MnKS5yZXBsYWNlKCctJywgJ18nKSArICcuVVRGLTgnO1xuICAgICAgICB2YXIgZW52ID0ge1xuICAgICAgICAgICdVU0VSJzogJ3dlYl91c2VyJyxcbiAgICAgICAgICAnTE9HTkFNRSc6ICd3ZWJfdXNlcicsXG4gICAgICAgICAgJ1BBVEgnOiAnLycsXG4gICAgICAgICAgJ1BXRCc6ICcvJyxcbiAgICAgICAgICAnSE9NRSc6ICcvaG9tZS93ZWJfdXNlcicsXG4gICAgICAgICAgJ0xBTkcnOiBsYW5nLFxuICAgICAgICAgICdfJzogZ2V0RXhlY3V0YWJsZU5hbWUoKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgeCBpbiBFTlYpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07XG4gICAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goeCArICc9JyArIGVudlt4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3M7XG4gICAgfVxuICBcbiAgXG4gIGZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIEhFQVA4WygoYnVmZmVyKyspPj4wKV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFkb250QWRkTnVsbCkgSEVBUDhbKChidWZmZXIpPj4wKV0gPSAwO1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX2dldChfX2Vudmlyb24sIGVudmlyb25fYnVmKSB7XG4gICAgICB2YXIgYnVmU2l6ZSA9IDA7XG4gICAgICBnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcsIGkpIHtcbiAgICAgICAgdmFyIHB0ciA9IGVudmlyb25fYnVmICsgYnVmU2l6ZTtcbiAgICAgICAgSEVBUFUzMlsoKChfX2Vudmlyb24pKyhpKjQpKT4+MildID0gcHRyO1xuICAgICAgICB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyaW5nLCBwdHIpO1xuICAgICAgICBidWZTaXplICs9IHN0cmluZy5sZW5ndGggKyAxO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiAgICAgIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuICAgICAgSEVBUFUzMlsoKHBlbnZpcm9uX2NvdW50KT4+MildID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgICB2YXIgYnVmU2l6ZSA9IDA7XG4gICAgICBzdHJpbmdzLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIEhFQVBVMzJbKChwZW52aXJvbl9idWZfc2l6ZSk+PjIpXSA9IGJ1ZlNpemU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgZnVuY3Rpb24gX2ZkX2Nsb3NlKGZkKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9mZF9mZHN0YXRfZ2V0KGZkLCBwYnVmKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIHR5cGUgPSBzdHJlYW0udHR5ID8gMiA6XG4gICAgICAgICAgICAgICAgIEZTLmlzRGlyKHN0cmVhbS5tb2RlKSA/IDMgOlxuICAgICAgICAgICAgICAgICBGUy5pc0xpbmsoc3RyZWFtLm1vZGUpID8gNyA6XG4gICAgICAgICAgICAgICAgIDQ7XG4gICAgICBIRUFQOFsoKHBidWYpPj4wKV0gPSB0eXBlO1xuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbiAgfVxuXG4gIFxuICBmdW5jdGlvbiBkb1JlYWR2KHN0cmVhbSwgaW92LCBpb3ZjbnQsIG9mZnNldCkge1xuICAgICAgdmFyIHJldCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICAgIHZhciBwdHIgPSBIRUFQVTMyWygoaW92KT4+MildO1xuICAgICAgICB2YXIgbGVuID0gSEVBUFUzMlsoKChpb3YpKyg0KSk+PjIpXTtcbiAgICAgICAgaW92ICs9IDg7XG4gICAgICAgIHZhciBjdXJyID0gRlMucmVhZChzdHJlYW0sIEhFQVA4LHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgcmV0ICs9IGN1cnI7XG4gICAgICAgIGlmIChjdXJyIDwgbGVuKSBicmVhazsgXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9mZnNldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIF9mZF9yZWFkKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgdmFyIG51bSA9IGRvUmVhZHYoc3RyZWFtLCBpb3YsIGlvdmNudCk7XG4gICAgICBIRUFQVTMyWygocG51bSk+PjIpXSA9IG51bTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICBcbiAgXG4gIFxuICBcbiAgZnVuY3Rpb24gX2ZkX3NlZWsoZmQsICBvZmZzZXQsIHdoZW5jZSwgbmV3T2Zmc2V0KSB7XG4gIHRyeSB7XG4gIFxuICAgICAgb2Zmc2V0ID0gYmlnaW50VG9JNTNDaGVja2VkKG9mZnNldCk7IGlmIChpc05hTihvZmZzZXQpKSByZXR1cm4gNjE7XG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIEZTLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICAgICh0ZW1wSTY0ID0gW3N0cmVhbS5wb3NpdGlvbj4+PjAsKHRlbXBEb3VibGU9c3RyZWFtLnBvc2l0aW9uLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygobmV3T2Zmc2V0KT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgobmV3T2Zmc2V0KSsoNCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgIGlmIChzdHJlYW0uZ2V0ZGVudHMgJiYgb2Zmc2V0ID09PSAwICYmIHdoZW5jZSA9PT0gMCkgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsgXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2ZkX3N5bmMoZmQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcyAmJiBzdHJlYW0uc3RyZWFtX29wcy5mc3luYykge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMuZnN5bmMoc3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwOyBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgXG4gIGZ1bmN0aW9uIGRvV3JpdGV2KHN0cmVhbSwgaW92LCBpb3ZjbnQsIG9mZnNldCkge1xuICAgICAgdmFyIHJldCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICAgIHZhciBwdHIgPSBIRUFQVTMyWygoaW92KT4+MildO1xuICAgICAgICB2YXIgbGVuID0gSEVBUFUzMlsoKChpb3YpKyg0KSk+PjIpXTtcbiAgICAgICAgaW92ICs9IDg7XG4gICAgICAgIHZhciBjdXJyID0gRlMud3JpdGUoc3RyZWFtLCBIRUFQOCxwdHIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGN1cnIgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIHJldCArPSBjdXJyO1xuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gY3VycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBfZmRfd3JpdGUoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgbnVtID0gZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCk7XG4gICAgICBIRUFQVTMyWygocG51bSk+PjIpXSA9IG51bTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cblxuICB2YXIgRlNOb2RlID0gIGZ1bmN0aW9uKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldikge1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSB0aGlzOyAgXG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMubW91bnQgPSBwYXJlbnQubW91bnQ7XG4gICAgdGhpcy5tb3VudGVkID0gbnVsbDtcbiAgICB0aGlzLmlkID0gRlMubmV4dElub2RlKys7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMubm9kZV9vcHMgPSB7fTtcbiAgICB0aGlzLnN0cmVhbV9vcHMgPSB7fTtcbiAgICB0aGlzLnJkZXYgPSByZGV2O1xuICB9O1xuICB2YXIgcmVhZE1vZGUgPSAyOTIgfCA3MztcbiAgdmFyIHdyaXRlTW9kZSA9IDE0NjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlNOb2RlLnByb3RvdHlwZSwge1xuICAgcmVhZDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiAodGhpcy5tb2RlICYgcmVhZE1vZGUpID09PSByZWFkTW9kZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgIHZhbCA/IHRoaXMubW9kZSB8PSByZWFkTW9kZSA6IHRoaXMubW9kZSAmPSB+cmVhZE1vZGU7XG4gICAgfVxuICAgfSxcbiAgIHdyaXRlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiB3cml0ZU1vZGUpID09PSB3cml0ZU1vZGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICB2YWwgPyB0aGlzLm1vZGUgfD0gd3JpdGVNb2RlIDogdGhpcy5tb2RlICY9IH53cml0ZU1vZGU7XG4gICAgfVxuICAgfSxcbiAgIGlzRm9sZGVyOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSk7XG4gICAgfVxuICAgfSxcbiAgIGlzRGV2aWNlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuIEZTLmlzQ2hyZGV2KHRoaXMubW9kZSk7XG4gICAgfVxuICAgfVxuICB9KTtcbiAgRlMuRlNOb2RlID0gRlNOb2RlO1xuICBGUy5zdGF0aWNJbml0KCk7O1xudmFyIEFTU0VSVElPTlMgPSBmYWxzZTtcblxudmFyIGFzbUxpYnJhcnlBcmcgPSB7XG4gIFwiX19zeXNjYWxsX2NobW9kXCI6IF9fX3N5c2NhbGxfY2htb2QsXG4gIFwiX19zeXNjYWxsX2ZhY2Nlc3NhdFwiOiBfX19zeXNjYWxsX2ZhY2Nlc3NhdCxcbiAgXCJfX3N5c2NhbGxfZmNobW9kXCI6IF9fX3N5c2NhbGxfZmNobW9kLFxuICBcIl9fc3lzY2FsbF9mY2hvd24zMlwiOiBfX19zeXNjYWxsX2ZjaG93bjMyLFxuICBcIl9fc3lzY2FsbF9mY250bDY0XCI6IF9fX3N5c2NhbGxfZmNudGw2NCxcbiAgXCJfX3N5c2NhbGxfZnN0YXQ2NFwiOiBfX19zeXNjYWxsX2ZzdGF0NjQsXG4gIFwiX19zeXNjYWxsX2Z0cnVuY2F0ZTY0XCI6IF9fX3N5c2NhbGxfZnRydW5jYXRlNjQsXG4gIFwiX19zeXNjYWxsX2dldGN3ZFwiOiBfX19zeXNjYWxsX2dldGN3ZCxcbiAgXCJfX3N5c2NhbGxfaW9jdGxcIjogX19fc3lzY2FsbF9pb2N0bCxcbiAgXCJfX3N5c2NhbGxfbHN0YXQ2NFwiOiBfX19zeXNjYWxsX2xzdGF0NjQsXG4gIFwiX19zeXNjYWxsX21rZGlyYXRcIjogX19fc3lzY2FsbF9ta2RpcmF0LFxuICBcIl9fc3lzY2FsbF9uZXdmc3RhdGF0XCI6IF9fX3N5c2NhbGxfbmV3ZnN0YXRhdCxcbiAgXCJfX3N5c2NhbGxfb3BlbmF0XCI6IF9fX3N5c2NhbGxfb3BlbmF0LFxuICBcIl9fc3lzY2FsbF9yZWFkbGlua2F0XCI6IF9fX3N5c2NhbGxfcmVhZGxpbmthdCxcbiAgXCJfX3N5c2NhbGxfcm1kaXJcIjogX19fc3lzY2FsbF9ybWRpcixcbiAgXCJfX3N5c2NhbGxfc3RhdDY0XCI6IF9fX3N5c2NhbGxfc3RhdDY0LFxuICBcIl9fc3lzY2FsbF91bmxpbmthdFwiOiBfX19zeXNjYWxsX3VubGlua2F0LFxuICBcIl9fc3lzY2FsbF91dGltZW5zYXRcIjogX19fc3lzY2FsbF91dGltZW5zYXQsXG4gIFwiX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWNcIjogX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljLFxuICBcIl9sb2NhbHRpbWVfanNcIjogX19sb2NhbHRpbWVfanMsXG4gIFwiX21tYXBfanNcIjogX19tbWFwX2pzLFxuICBcIl9tdW5tYXBfanNcIjogX19tdW5tYXBfanMsXG4gIFwiX3R6c2V0X2pzXCI6IF9fdHpzZXRfanMsXG4gIFwiZW1zY3JpcHRlbl9kYXRlX25vd1wiOiBfZW1zY3JpcHRlbl9kYXRlX25vdyxcbiAgXCJlbXNjcmlwdGVuX2dldF9ub3dcIjogX2Vtc2NyaXB0ZW5fZ2V0X25vdyxcbiAgXCJlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwXCI6IF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwLFxuICBcImVudmlyb25fZ2V0XCI6IF9lbnZpcm9uX2dldCxcbiAgXCJlbnZpcm9uX3NpemVzX2dldFwiOiBfZW52aXJvbl9zaXplc19nZXQsXG4gIFwiZmRfY2xvc2VcIjogX2ZkX2Nsb3NlLFxuICBcImZkX2Zkc3RhdF9nZXRcIjogX2ZkX2Zkc3RhdF9nZXQsXG4gIFwiZmRfcmVhZFwiOiBfZmRfcmVhZCxcbiAgXCJmZF9zZWVrXCI6IF9mZF9zZWVrLFxuICBcImZkX3N5bmNcIjogX2ZkX3N5bmMsXG4gIFwiZmRfd3JpdGVcIjogX2ZkX3dyaXRlLFxuICBcIm1lbW9yeVwiOiB3YXNtTWVtb3J5XG59O1xudmFyIGFzbSA9IGNyZWF0ZVdhc20oKTtcblxudmFyIF9fX3dhc21fY2FsbF9jdG9ycyA9IE1vZHVsZVtcIl9fX3dhc21fY2FsbF9jdG9yc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9fX3dhc21fY2FsbF9jdG9ycyA9IE1vZHVsZVtcIl9fX3dhc21fY2FsbF9jdG9yc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcIl9fd2FzbV9jYWxsX2N0b3JzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RhdHVzNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19zdGF0dXM2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0YXR1czY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RhdHVzNjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0YXR1czY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RhdHVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RhdHVzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RhdHVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RhdHVzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdGF0dXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kYl9zdGF0dXMgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9zdGF0dXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kYl9zdGF0dXMgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9zdGF0dXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2RiX3N0YXR1c1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX21zaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfbXNpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19tc2l6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX21zaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19tc2l6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Zmc19maW5kID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmZzX2ZpbmRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192ZnNfZmluZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Zmc19maW5kXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192ZnNfZmluZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2luaXRpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19pbml0aWFsaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfaW5pdGlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2luaXRpYWxpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2luaXRpYWxpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19tYWxsb2MgPSBNb2R1bGVbXCJfc3FsaXRlM19tYWxsb2NcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19tYWxsb2MgPSBNb2R1bGVbXCJfc3FsaXRlM19tYWxsb2NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX21hbGxvY1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2ZyZWUgPSBNb2R1bGVbXCJfc3FsaXRlM19mcmVlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZnJlZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2ZyZWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2ZyZWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192ZnNfcmVnaXN0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM192ZnNfcmVnaXN0ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192ZnNfcmVnaXN0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM192ZnNfcmVnaXN0ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Zmc19yZWdpc3RlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Zmc191bnJlZ2lzdGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmZzX3VucmVnaXN0ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192ZnNfdW5yZWdpc3RlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Zmc191bnJlZ2lzdGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192ZnNfdW5yZWdpc3RlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX21hbGxvYzY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfbWFsbG9jNjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19tYWxsb2M2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX21hbGxvYzY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19tYWxsb2M2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3JlYWxsb2MgPSBNb2R1bGVbXCJfc3FsaXRlM19yZWFsbG9jXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVhbGxvYyA9IE1vZHVsZVtcIl9zcWxpdGUzX3JlYWxsb2NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3JlYWxsb2NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZWFsbG9jNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZWFsbG9jNjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZWFsbG9jNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZWFsbG9jNjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3JlYWxsb2M2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV90ZXh0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3RleHRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX3RleHRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yYW5kb21uZXNzID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmFuZG9tbmVzc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3JhbmRvbW5lc3MgPSBNb2R1bGVbXCJfc3FsaXRlM19yYW5kb21uZXNzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yYW5kb21uZXNzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RyaWNtcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cmljbXBcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdHJpY21wID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RyaWNtcFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RyaWNtcFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0cm5pY21wID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RybmljbXBcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdHJuaWNtcCA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cm5pY21wXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdHJuaWNtcFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3VyaV9wYXJhbWV0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfcGFyYW1ldGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdXJpX3BhcmFtZXRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9wYXJhbWV0ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3VyaV9wYXJhbWV0ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfX19lcnJub19sb2NhdGlvbiA9IE1vZHVsZVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX19fZXJybm9fbG9jYXRpb24gPSBNb2R1bGVbXCJfX19lcnJub19sb2NhdGlvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcIl9fZXJybm9fbG9jYXRpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM191cmlfYm9vbGVhbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9ib29sZWFuXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdXJpX2Jvb2xlYW4gPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfYm9vbGVhblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdXJpX2Jvb2xlYW5cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zZXJpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXJpYWxpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zZXJpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXJpYWxpemVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3NlcmlhbGl6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXBhcmVfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmVwYXJlX3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJlcGFyZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXBhcmVfdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXBhcmVfdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdGVwID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RlcFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3N0ZXAgPSBNb2R1bGVbXCJfc3FsaXRlM19zdGVwXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zdGVwXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2ludDY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2ludDY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5faW50NjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXNldCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc2V0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXNldFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzZXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19leGVjID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXhlY1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2V4ZWMgPSBNb2R1bGVbXCJfc3FsaXRlM19leGVjXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19leGVjXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbHVtbl9pbnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb2x1bW5faW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2ludFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29sdW1uX2ludFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2ZpbmFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfZmluYWxpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19maW5hbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2ZpbmFsaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19maW5hbGl6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2ZpbGVfY29udHJvbCA9IE1vZHVsZVtcIl9zcWxpdGUzX2ZpbGVfY29udHJvbFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2ZpbGVfY29udHJvbCA9IE1vZHVsZVtcIl9zcWxpdGUzX2ZpbGVfY29udHJvbFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZmlsZV9jb250cm9sXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX25hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fbmFtZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9uYW1lID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX25hbWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl9uYW1lXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX3RleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fdGV4dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX3RleHRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl90ZXh0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX3R5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fdHlwZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl90eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX3R5cGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl90eXBlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXJybXNnID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJybXNnXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXJybXNnID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJybXNnXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19lcnJtc2dcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kZXNlcmlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2Rlc2VyaWFsaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZGVzZXJpYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM19kZXNlcmlhbGl6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZGVzZXJpYWxpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jbGVhcl9iaW5kaW5ncyA9IE1vZHVsZVtcIl9zcWxpdGUzX2NsZWFyX2JpbmRpbmdzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY2xlYXJfYmluZGluZ3MgPSBNb2R1bGVbXCJfc3FsaXRlM19jbGVhcl9iaW5kaW5nc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY2xlYXJfYmluZGluZ3NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfYmxvYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9ibG9iXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9ibG9iXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfYnl0ZXMgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9ieXRlc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2J5dGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfYnl0ZXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2J5dGVzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZG91YmxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZG91YmxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9kb3VibGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9pbnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9pbnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX2ludFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2ludDY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfaW50NjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2ludDY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9pbnQ2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX3N1YnR5cGUgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9zdWJ0eXBlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdmFsdWVfc3VidHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3N1YnR5cGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ZhbHVlX3N1YnR5cGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192YWx1ZV9wb2ludGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfcG9pbnRlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX3BvaW50ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM192YWx1ZV9wb2ludGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9wb2ludGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfdHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX3R5cGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV90eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfdHlwZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfdHlwZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX25vY2hhbmdlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfbm9jaGFuZ2VcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9ub2NoYW5nZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX25vY2hhbmdlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9ub2NoYW5nZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2Zyb21iaW5kID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZnJvbWJpbmRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9mcm9tYmluZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2Zyb21iaW5kXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192YWx1ZV9mcm9tYmluZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX2R1cCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2R1cFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX2R1cCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2R1cFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfZHVwXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdmFsdWVfZnJlZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192YWx1ZV9mcmVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdmFsdWVfZnJlZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Jsb2JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9ibG9iXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfYmxvYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWcgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3JfdG9vYmlnXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX3Rvb2JpZyA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0gPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0gPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZG91YmxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9kb3VibGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9kb3VibGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfZXJyb3IgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfZXJyb3IgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9lcnJvclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9pbnQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfaW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcmVzdWx0X2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9pbnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9pbnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19yZXN1bHRfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfaW50NjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfaW50NjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9pbnQ2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9udWxsID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X251bGxcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfbnVsbCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9udWxsXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfbnVsbFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9wb2ludGVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3BvaW50ZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfcG9pbnRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9wb2ludGVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfcG9pbnRlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3N1YnR5cGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfc3VidHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfc3VidHlwZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3RleHRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXN1bHRfdGV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF90ZXh0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXN1bHRfdGV4dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcmVzdWx0X3plcm9ibG9iXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjQgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfemVyb2Jsb2I2NFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYjY0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGUgPSBNb2R1bGVbXCJfc3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzdWx0X2Vycm9yX2NvZGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Jlc3VsdF9lcnJvcl9jb2RlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdXNlcl9kYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXNlcl9kYXRhXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdXNlcl9kYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXNlcl9kYXRhXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM191c2VyX2RhdGFcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbnRleHRfZGJfaGFuZGxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb250ZXh0X2RiX2hhbmRsZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX25vY2hhbmdlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9ub2NoYW5nZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfbm9jaGFuZ2UgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX25vY2hhbmdlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX25vY2hhbmdlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9pbl9maXJzdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfaW5fZmlyc3RcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX2luX2ZpcnN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9pbl9maXJzdFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9pbl9maXJzdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfaW5fbmV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfaW5fbmV4dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfaW5fbmV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfaW5fbmV4dFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9pbl9uZXh0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQgPSBNb2R1bGVbXCJfc3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZ2V0X2F1eGRhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM19nZXRfYXV4ZGF0YVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2dldF9hdXhkYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfZ2V0X2F1eGRhdGFcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2dldF9hdXhkYXRhXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc2V0X2F1eGRhdGEgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXRfYXV4ZGF0YVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3NldF9hdXhkYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2V0X2F1eGRhdGFcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3NldF9hdXhkYXRhXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2NvdW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2NvdW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fY291bnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kYXRhX2NvdW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGF0YV9jb3VudFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2RhdGFfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19kYXRhX2NvdW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kYXRhX2NvdW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fYmxvYlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9ibG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2Jsb2JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbHVtbl9ibG9iXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX2J5dGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2J5dGVzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX2J5dGVzID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2J5dGVzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fYnl0ZXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2x1bW5fZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX2RvdWJsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbHVtbl9kb3VibGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2x1bW5fZG91YmxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fZG91YmxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29sdW1uX3ZhbHVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX3ZhbHVlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY29sdW1uX3ZhbHVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sdW1uX3ZhbHVlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2x1bW5fdmFsdWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2Jsb2JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX2Jsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2Jsb2JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfYmxvYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfZG91YmxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9kb3VibGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX2RvdWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfZG91YmxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX2RvdWJsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfaW50ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF9pbnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX2ludCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfaW50XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX2ludFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX2ludDY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9pbnQ2NCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfaW50NjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfaW50NjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX251bGwgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX251bGxcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19iaW5kX251bGwgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX251bGxcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2JpbmRfbnVsbFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2JpbmRfcG9pbnRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfcG9pbnRlclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2JpbmRfcG9pbnRlciA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfcG9pbnRlclwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9wb2ludGVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfYmluZF90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF90ZXh0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF90ZXh0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfYmluZF90ZXh0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19iaW5kX3RleHRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2NvdW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCA9IE1vZHVsZVtcIl9zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXggPSBNb2R1bGVbXCJfc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXhcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kYl9oYW5kbGUgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9oYW5kbGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19kYl9oYW5kbGUgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9oYW5kbGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2RiX2hhbmRsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0bXRfcmVhZG9ubHkgPSBNb2R1bGVbXCJfc3FsaXRlM19zdG10X3JlYWRvbmx5XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RtdF9yZWFkb25seSA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0bXRfcmVhZG9ubHlcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0bXRfcmVhZG9ubHlcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdG10X2lzZXhwbGFpbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0bXRfaXNleHBsYWluXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RtdF9pc2V4cGxhaW4gPSBNb2R1bGVbXCJfc3FsaXRlM19zdG10X2lzZXhwbGFpblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RtdF9pc2V4cGxhaW5cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zdG10X3N0YXR1cyA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0bXRfc3RhdHVzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RtdF9zdGF0dXMgPSBNb2R1bGVbXCJfc3FsaXRlM19zdG10X3N0YXR1c1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RtdF9zdGF0dXNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zcWwgPSBNb2R1bGVbXCJfc3FsaXRlM19zcWxcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zcWwgPSBNb2R1bGVbXCJfc3FsaXRlM19zcWxcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3NxbFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2V4cGFuZGVkX3NxbCA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4cGFuZGVkX3NxbFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2V4cGFuZGVkX3NxbCA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4cGFuZGVkX3NxbFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXhwYW5kZWRfc3FsXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJldXBkYXRlX29sZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9vbGRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfb2xkID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX29sZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJldXBkYXRlX29sZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9jb3VudFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJldXBkYXRlX2NvdW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2RlcHRoXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmV1cGRhdGVfZGVwdGhcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ByZXVwZGF0ZV9ibG9id3JpdGUgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmV1cGRhdGVfYmxvYndyaXRlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcHJldXBkYXRlX25ldyA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9uZXdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfbmV3ID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX25ld1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcHJldXBkYXRlX25ld1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdmFsdWVfbnVtZXJpY190eXBlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19zZXRfYXV0aG9yaXplclwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3NldF9hdXRob3JpemVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2V0X2F1dGhvcml6ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3NldF9hdXRob3JpemVyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfc3RyZ2xvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cmdsb2JcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zdHJnbG9iID0gTW9kdWxlW1wiX3NxbGl0ZTNfc3RyZ2xvYlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc3RyZ2xvYlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3N0cmxpa2UgPSBNb2R1bGVbXCJfc3FsaXRlM19zdHJsaWtlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc3RybGlrZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3N0cmxpa2VcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3N0cmxpa2VcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19hdXRvX2V4dGVuc2lvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfYXV0b19leHRlbnNpb25cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Jlc2V0X2F1dG9fZXh0ZW5zaW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19yZXNldF9hdXRvX2V4dGVuc2lvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXBhcmVfdjMgPSBNb2R1bGVbXCJfc3FsaXRlM19wcmVwYXJlX3YzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJlcGFyZV92MyA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXBhcmVfdjNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3ByZXBhcmVfdjNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jcmVhdGVfbW9kdWxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX21vZHVsZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9tb2R1bGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfbW9kdWxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jcmVhdGVfbW9kdWxlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9tb2R1bGVfdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfbW9kdWxlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX21vZHVsZV92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY3JlYXRlX21vZHVsZV92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2Ryb3BfbW9kdWxlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2Ryb3BfbW9kdWxlc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2Ryb3BfbW9kdWxlcyA9IE1vZHVsZVtcIl9zcWxpdGUzX2Ryb3BfbW9kdWxlc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZHJvcF9tb2R1bGVzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZGVjbGFyZV92dGFiID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGVjbGFyZV92dGFiXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZGVjbGFyZV92dGFiID0gTW9kdWxlW1wiX3NxbGl0ZTNfZGVjbGFyZV92dGFiXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19kZWNsYXJlX3Z0YWJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9vbl9jb25mbGljdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfb25fY29uZmxpY3QgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX29uX2NvbmZsaWN0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX29uX2NvbmZsaWN0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb24gPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2NvbGxhdGlvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3Z0YWJfY29sbGF0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9jb2xsYXRpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfY29sbGF0aW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdnRhYl9pbiA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfaW5cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX2luID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9pblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfdnRhYl9pblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdnRhYl9yaHNfdmFsdWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM192dGFiX3Joc192YWx1ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM192dGFiX3Joc192YWx1ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Z0YWJfZGlzdGluY3QgPSBNb2R1bGVbXCJfc3FsaXRlM192dGFiX2Rpc3RpbmN0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdnRhYl9kaXN0aW5jdCA9IE1vZHVsZVtcIl9zcWxpdGUzX3Z0YWJfZGlzdGluY3RcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Z0YWJfZGlzdGluY3RcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19rZXl3b3JkX25hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19rZXl3b3JkX25hbWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19rZXl3b3JkX25hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19rZXl3b3JkX25hbWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2tleXdvcmRfbmFtZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2tleXdvcmRfY291bnQgPSBNb2R1bGVbXCJfc3FsaXRlM19rZXl3b3JkX2NvdW50XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfa2V5d29yZF9jb3VudCA9IE1vZHVsZVtcIl9zcWxpdGUzX2tleXdvcmRfY291bnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2tleXdvcmRfY291bnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19rZXl3b3JkX2NoZWNrID0gTW9kdWxlW1wiX3NxbGl0ZTNfa2V5d29yZF9jaGVja1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2tleXdvcmRfY2hlY2sgPSBNb2R1bGVbXCJfc3FsaXRlM19rZXl3b3JkX2NoZWNrXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19rZXl3b3JkX2NoZWNrXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29tcGxldGUgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21wbGV0ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbXBsZXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tcGxldGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbXBsZXRlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfbGlidmVyc2lvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2xpYnZlcnNpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19saWJ2ZXJzaW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGlidmVyc2lvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfbGlidmVyc2lvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGlidmVyc2lvbl9udW1iZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19saWJ2ZXJzaW9uX251bWJlciA9IE1vZHVsZVtcIl9zcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19saWJ2ZXJzaW9uX251bWJlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3NodXRkb3duID0gTW9kdWxlW1wiX3NxbGl0ZTNfc2h1dGRvd25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19zaHV0ZG93biA9IE1vZHVsZVtcIl9zcWxpdGUzX3NodXRkb3duXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19zaHV0ZG93blwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19sYXN0X2luc2VydF9yb3dpZCA9IE1vZHVsZVtcIl9zcWxpdGUzX2xhc3RfaW5zZXJ0X3Jvd2lkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19sYXN0X2luc2VydF9yb3dpZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3NldF9sYXN0X2luc2VydF9yb3dpZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY2hhbmdlczY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2hhbmdlczY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY2hhbmdlczY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2hhbmdlczY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jaGFuZ2VzNjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jaGFuZ2VzID0gTW9kdWxlW1wiX3NxbGl0ZTNfY2hhbmdlc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NoYW5nZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19jaGFuZ2VzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jaGFuZ2VzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfdG90YWxfY2hhbmdlczY0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM190b3RhbF9jaGFuZ2VzNjRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM190b3RhbF9jaGFuZ2VzID0gTW9kdWxlW1wiX3NxbGl0ZTNfdG90YWxfY2hhbmdlc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3RvdGFsX2NoYW5nZXMgPSBNb2R1bGVbXCJfc3FsaXRlM190b3RhbF9jaGFuZ2VzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM190b3RhbF9jaGFuZ2VzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdHhuX3N0YXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdHhuX3N0YXRlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdHhuX3N0YXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNfdHhuX3N0YXRlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM190eG5fc3RhdGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jbG9zZV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2Nsb3NlX3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY2xvc2VfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jbG9zZV92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY2xvc2VfdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19idXN5X2hhbmRsZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19idXN5X2hhbmRsZXJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19idXN5X2hhbmRsZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19idXN5X2hhbmRsZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2J1c3lfaGFuZGxlclwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXIgPSBNb2R1bGVbXCJfc3FsaXRlM19wcm9ncmVzc19oYW5kbGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlciA9IE1vZHVsZVtcIl9zcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19idXN5X3RpbWVvdXQgPSBNb2R1bGVbXCJfc3FsaXRlM19idXN5X3RpbWVvdXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19idXN5X3RpbWVvdXQgPSBNb2R1bGVbXCJfc3FsaXRlM19idXN5X3RpbWVvdXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2J1c3lfdGltZW91dFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb24gPSBNb2R1bGVbXCJfc3FsaXRlM19vdmVybG9hZF9mdW5jdGlvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfb3ZlcmxvYWRfZnVuY3Rpb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX292ZXJsb2FkX2Z1bmN0aW9uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdHJhY2VfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM190cmFjZV92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3RyYWNlX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfdHJhY2VfdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3RyYWNlX3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY29tbWl0X2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21taXRfaG9va1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbW1pdF9ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tbWl0X2hvb2tcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbW1pdF9ob29rXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdXBkYXRlX2hvb2sgPSBNb2R1bGVbXCJfc3FsaXRlM191cGRhdGVfaG9va1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3VwZGF0ZV9ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfdXBkYXRlX2hvb2tcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3VwZGF0ZV9ob29rXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfcm9sbGJhY2tfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX3JvbGxiYWNrX2hvb2tcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19yb2xsYmFja19ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfcm9sbGJhY2tfaG9va1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfcm9sbGJhY2tfaG9va1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rID0gTW9kdWxlW1wiX3NxbGl0ZTNfcHJldXBkYXRlX2hvb2tcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19wcmV1cGRhdGVfaG9vayA9IE1vZHVsZVtcIl9zcWxpdGUzX3ByZXVwZGF0ZV9ob29rXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19wcmV1cGRhdGVfaG9va1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2Vycm9yX29mZnNldCA9IE1vZHVsZVtcIl9zcWxpdGUzX2Vycm9yX29mZnNldFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2Vycm9yX29mZnNldCA9IE1vZHVsZVtcIl9zcWxpdGUzX2Vycm9yX29mZnNldFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXJyb3Jfb2Zmc2V0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZXJyY29kZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2VycmNvZGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19lcnJjb2RlID0gTW9kdWxlW1wiX3NxbGl0ZTNfZXJyY29kZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZXJyY29kZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2V4dGVuZGVkX2VycmNvZGUgPSBNb2R1bGVbXCJfc3FsaXRlM19leHRlbmRlZF9lcnJjb2RlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZXh0ZW5kZWRfZXJyY29kZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2V4dGVuZGVkX2VycmNvZGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2V4dGVuZGVkX2VycmNvZGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19lcnJzdHIgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJzdHJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19lcnJzdHIgPSBNb2R1bGVbXCJfc3FsaXRlM19lcnJzdHJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2VycnN0clwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2xpbWl0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfbGltaXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19saW1pdCA9IE1vZHVsZVtcIl9zcWxpdGUzX2xpbWl0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19saW1pdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX29wZW4gPSBNb2R1bGVbXCJfc3FsaXRlM19vcGVuXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfb3BlbiA9IE1vZHVsZVtcIl9zcWxpdGUzX29wZW5cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX29wZW5cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19vcGVuX3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNfb3Blbl92MlwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX29wZW5fdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19vcGVuX3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19vcGVuX3YyXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uID0gTW9kdWxlW1wiX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIgPSBNb2R1bGVbXCJfc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IE1vZHVsZVtcIl9zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29sbGF0aW9uX25lZWRlZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2NvbGxhdGlvbl9uZWVkZWQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb2xsYXRpb25fbmVlZGVkXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb2xsYXRpb25fbmVlZGVkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXQgPSBNb2R1bGVbXCJfc3FsaXRlM19nZXRfYXV0b2NvbW1pdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX2dldF9hdXRvY29tbWl0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfZ2V0X2F1dG9jb21taXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2dldF9hdXRvY29tbWl0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhID0gTW9kdWxlW1wiX3NxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM190YWJsZV9jb2x1bW5fbWV0YWRhdGFcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXNcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXMgPSBNb2R1bGVbXCJfc3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXNcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2V4dGVuZGVkX3Jlc3VsdF9jb2Rlc1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3VyaV9rZXkgPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfa2V5XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfdXJpX2tleSA9IE1vZHVsZVtcIl9zcWxpdGUzX3VyaV9rZXlcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3VyaV9rZXlcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM191cmlfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfaW50NjRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM191cmlfaW50NjQgPSBNb2R1bGVbXCJfc3FsaXRlM191cmlfaW50NjRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3VyaV9pbnQ2NFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2RiX25hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9uYW1lXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZGJfbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX25hbWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2RiX25hbWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19kYl9maWxlbmFtZSA9IE1vZHVsZVtcIl9zcWxpdGUzX2RiX2ZpbGVuYW1lXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfZGJfZmlsZW5hbWUgPSBNb2R1bGVbXCJfc3FsaXRlM19kYl9maWxlbmFtZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfZGJfZmlsZW5hbWVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWQgPSBNb2R1bGVbXCJfc3FsaXRlM19jb21waWxlb3B0aW9uX3VzZWRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM19jb21waWxlb3B0aW9uX2dldCA9IE1vZHVsZVtcIl9zcWxpdGUzX2NvbXBpbGVvcHRpb25fZ2V0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM19jb21waWxlb3B0aW9uX2dldFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9kaWZmID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2RpZmZcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fZGlmZiA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9kaWZmXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fZGlmZlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9hdHRhY2ggPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fYXR0YWNoXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2F0dGFjaCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9hdHRhY2hcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9hdHRhY2hcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fY3JlYXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NyZWF0ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9jcmVhdGUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY3JlYXRlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fY3JlYXRlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9kZWxldGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fZGVsZXRlID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX2RlbGV0ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX3RhYmxlX2ZpbHRlciA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0X3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fcGF0Y2hzZXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9lbmFibGUgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fZW5hYmxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2VuYWJsZSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9lbmFibGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9lbmFibGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25faW5kaXJlY3RcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25faW5kaXJlY3QgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25faW5kaXJlY3RcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5ID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2lzZW1wdHlcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM3Nlc3Npb25faXNlbXB0eSA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9pc2VtcHR5XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25faXNlbXB0eVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZCA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9tZW1vcnlfdXNlZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNzZXNzaW9uX21lbW9yeV91c2VkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWcgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fb2JqZWN0X2NvbmZpZ1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX29iamVjdF9jb25maWdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldF9zaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9zdGFydCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MiA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjIgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92MlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9zdGFydF9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9zdGFydF92Ml9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfc3RhcnRfdjJfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X25leHQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9uZXh0XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfbmV4dCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X25leHRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X25leHRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9vcCA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X29wXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfb3AgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9vcFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfb3BcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9wayA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X3BrXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfcGsgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9wa1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfcGtcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9vbGQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9vbGRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9vbGQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9vbGRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X29sZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X25ldyA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X25ld1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X25ldyA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X25ld1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfbmV3XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3QgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9jb25mbGljdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfY29uZmxpY3RcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9ma19jb25mbGljdHNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemUgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9maW5hbGl6ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2VzZXRfZmluYWxpemVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2ludmVydFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfaW52ZXJ0X3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2ludmVydF9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MiA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9hcHBseV92MlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9hcHBseSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9hcHBseVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseV92Ml9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3YyX3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlc2V0X2FwcGx5X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9hcHBseV9zdHJtXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX25ld1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlZ3JvdXBfbmV3ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlZ3JvdXBfbmV3XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlZ3JvdXBfYWRkXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0ID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfYWRkX3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZWdyb3VwX2FkZF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm0gPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dF9zdHJtXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm1cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlZ3JvdXBfb3V0cHV0X3N0cm1cIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlZ3JvdXBfZGVsZXRlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZWdyb3VwX2RlbGV0ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9jb25jYXQgPSBNb2R1bGVbXCJfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzY2hhbmdlc2V0X2NvbmNhdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtID0gTW9kdWxlW1wiX3NxbGl0ZTNjaGFuZ2VzZXRfY29uY2F0X3N0cm1cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybSA9IE1vZHVsZVtcIl9zcWxpdGUzY2hhbmdlc2V0X2NvbmNhdF9zdHJtXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzc2Vzc2lvbl9jb25maWcgPSBNb2R1bGVbXCJfc3FsaXRlM3Nlc3Npb25fY29uZmlnXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNzZXNzaW9uX2NvbmZpZyA9IE1vZHVsZVtcIl9zcWxpdGUzc2Vzc2lvbl9jb25maWdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzc2Vzc2lvbl9jb25maWdcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM19zb3VyY2VpZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3NvdXJjZWlkXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfc291cmNlaWQgPSBNb2R1bGVbXCJfc3FsaXRlM19zb3VyY2VpZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfc291cmNlaWRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3BzdGFja19wdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19wdHJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19wdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19wdHJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fcHN0YWNrX3B0clwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19yZXN0b3JlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fcHN0YWNrX3Jlc3RvcmVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3BzdGFja19hbGxvYyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wc3RhY2tfYWxsb2MgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19hbGxvY1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9wc3RhY2tfYWxsb2NcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmcgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmdcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmcgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmdcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fcHN0YWNrX3JlbWFpbmluZ1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9wc3RhY2tfcXVvdGFcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3BzdGFja19xdW90YSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3BzdGFja19xdW90YVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfZXJyb3IgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2Vycm9yXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9lcnJvciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfZXJyb3JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfZXJyb3JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cnVjdFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9zdHJ1Y3QgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3Rfc3RydWN0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb24gPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2VudW1fanNvblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZW51bV9qc29uID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9lbnVtX2pzb25cIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZW51bV9qc29uXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV92ZnNfdW5saW5rID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV92ZnNfdW5saW5rXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV92ZnNfdW5saW5rID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV92ZnNfdW5saW5rXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Zmc191bmxpbmtcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX3ZmcyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfdmZzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl92ZnMgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX3Zmc1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl92ZnNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX3Jlc2V0ID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9yZXNldFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfcmVzZXQgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX3Jlc2V0XCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX3Jlc2V0XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfZXhwb3J0X2NodW5rZWRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX2V4cG9ydF9jaHVua2VkID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9kYl9leHBvcnRfY2h1bmtlZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9zZXJpYWxpemVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fZGJfc2VyaWFsaXplXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGUgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Bvc2l4X2NyZWF0ZV9maWxlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fcG9zaXhfY3JlYXRlX2ZpbGVcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9rdnZmc01ha2VLZXlPblBzdGFja1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fa3Z2ZnNNYWtlS2V5T25Qc3RhY2sgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9rdnZmc19tZXRob2RzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2t2dmZzX21ldGhvZHNcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Z0YWJfY29uZmlnID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV92dGFiX2NvbmZpZ1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdnRhYl9jb25maWcgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Z0YWJfY29uZmlnXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Z0YWJfY29uZmlnXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfaXAgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19pcFwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfaXBcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfcGlpXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX2NvbmZpZ19waWlcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19zID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9kYl9jb25maWdfc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fZGJfY29uZmlnX3MgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2RiX2NvbmZpZ19zXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2RiX2NvbmZpZ19zXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV9jb25maWdfaSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fY29uZmlnX2lcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2NvbmZpZ19pID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9jb25maWdfaVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV9jb25maWdfaVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fY29uZmlnX2lpID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9jb25maWdfaWlcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX2NvbmZpZ19paSA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fY29uZmlnX2lpXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2NvbmZpZ19paVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fY29uZmlnX2ogPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2NvbmZpZ19qXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9jb25maWdfaiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fY29uZmlnX2pcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fY29uZmlnX2pcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX2luaXRfd2FzbWZzID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV9pbml0X3dhc21mc1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21faW5pdF93YXNtZnMgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX2luaXRfd2FzbWZzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX2luaXRfd2FzbWZzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnRwdHJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50cHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludHB0clwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X2ludHB0clwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3ZvaWRwdHJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0ciA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF92b2lkcHRyXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3Rfdm9pZHB0clwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9tYXggPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWF4XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21heCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9tYXhcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9tYXhcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pblwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW4gPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wic3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWluXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X3RpbWVzMiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF90aW1lczJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfdGltZXMyID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X3RpbWVzMlwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X3RpbWVzMlwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5tYXggPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRfbWlubWF4XCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV90ZXN0X2ludDY0X21pbm1heCA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5tYXhcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NF9taW5tYXhcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHJcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHIgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX3Rlc3RfaW50NjRwdHJcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fdGVzdF9pbnQ2NHB0clwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9zdGFja19vdmVyZmxvd1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9zcWxpdGUzX3dhc21fdGVzdF9zdGFja19vdmVyZmxvdyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9zdGFja19vdmVyZmxvd1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X3N0YWNrX292ZXJmbG93XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsbyA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fdGVzdF9zdHJfaGVsbG9cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfc3FsaXRlM193YXNtX3Rlc3Rfc3RyX2hlbGxvID0gTW9kdWxlW1wiX3NxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsb1wiXSA9IE1vZHVsZVtcImFzbVwiXVtcInNxbGl0ZTNfd2FzbV90ZXN0X3N0cl9oZWxsb1wiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIF9zcWxpdGUzX3dhc21fU1FMVGVzdGVyX3N0cmdsb2IgPSBNb2R1bGVbXCJfc3FsaXRlM193YXNtX1NRTFRlc3Rlcl9zdHJnbG9iXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX3NxbGl0ZTNfd2FzbV9TUUxUZXN0ZXJfc3RyZ2xvYiA9IE1vZHVsZVtcIl9zcWxpdGUzX3dhc21fU1FMVGVzdGVyX3N0cmdsb2JcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzcWxpdGUzX3dhc21fU1FMVGVzdGVyX3N0cmdsb2JcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbnZhciBfbWFsbG9jID0gTW9kdWxlW1wiX21hbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wibWFsbG9jXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX2ZyZWUgPSBNb2R1bGVbXCJfZnJlZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJmcmVlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX3JlYWxsb2MgPSBNb2R1bGVbXCJfcmVhbGxvY1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9yZWFsbG9jID0gTW9kdWxlW1wiX3JlYWxsb2NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJyZWFsbG9jXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG52YXIgX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnbiA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX2J1aWx0aW5fbWVtYWxpZ25cIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnblwiXSA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fYnVpbHRpbl9tZW1hbGlnblwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIHN0YWNrU2F2ZSA9IE1vZHVsZVtcInN0YWNrU2F2ZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHN0YWNrU2F2ZSA9IE1vZHVsZVtcInN0YWNrU2F2ZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInN0YWNrU2F2ZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIHN0YWNrUmVzdG9yZSA9IE1vZHVsZVtcInN0YWNrUmVzdG9yZVwiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHN0YWNrUmVzdG9yZSA9IE1vZHVsZVtcInN0YWNrUmVzdG9yZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcInN0YWNrUmVzdG9yZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cblxudmFyIHN0YWNrQWxsb2MgPSBNb2R1bGVbXCJzdGFja0FsbG9jXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoc3RhY2tBbGxvYyA9IE1vZHVsZVtcInN0YWNrQWxsb2NcIl0gPSBNb2R1bGVbXCJhc21cIl1bXCJzdGFja0FsbG9jXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuXG5cblxuXG5cblxuTW9kdWxlW1wid2FzbU1lbW9yeVwiXSA9IHdhc21NZW1vcnk7XG5cblxudmFyIGNhbGxlZFJ1bjtcblxuZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuICBcbiAgaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuICBpZiAoIWNhbGxlZFJ1bikgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyOyBcbn07XG5cblxuZnVuY3Rpb24gcnVuKGFyZ3MpIHtcbiAgYXJncyA9IGFyZ3MgfHwgYXJndW1lbnRzXztcblxuICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByZVJ1bigpO1xuXG4gIFxuICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvUnVuKCkge1xuICAgIFxuICAgIFxuICAgIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgICBjYWxsZWRSdW4gPSB0cnVlO1xuICAgIE1vZHVsZVsnY2FsbGVkUnVuJ10gPSB0cnVlO1xuXG4gICAgaWYgKEFCT1JUKSByZXR1cm47XG5cbiAgICBpbml0UnVudGltZSgpO1xuXG4gICAgcmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO1xuICAgIGlmIChNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10pIE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSgpO1xuXG4gICAgcG9zdFJ1bigpO1xuICB9XG5cbiAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcbiAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCdSdW5uaW5nLi4uJyk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpO1xuICAgICAgfSwgMSk7XG4gICAgICBkb1J1bigpO1xuICAgIH0sIDEpO1xuICB9IGVsc2VcbiAge1xuICAgIGRvUnVuKCk7XG4gIH1cbn1cblxuaWYgKE1vZHVsZVsncHJlSW5pdCddKSB7XG4gIGlmICh0eXBlb2YgTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVJbml0J10gPSBbTW9kdWxlWydwcmVJbml0J11dO1xuICB3aGlsZSAoTW9kdWxlWydwcmVJbml0J10ubGVuZ3RoID4gMCkge1xuICAgIE1vZHVsZVsncHJlSW5pdCddLnBvcCgpKCk7XG4gIH1cbn1cblxucnVuKCk7XG5cblxuXG5cblxuaWYoIU1vZHVsZS5wb3N0UnVuKSBNb2R1bGUucG9zdFJ1biA9IFtdO1xuTW9kdWxlLnBvc3RSdW4ucHVzaChmdW5jdGlvbihNb2R1bGUpe1xuICAndXNlIHN0cmljdCc7XG4gIFxuXG5cblxuXG5cblxuXG5cblxuXG4ndXNlIHN0cmljdCc7XG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAgPSBmdW5jdGlvbiBzcWxpdGUzQXBpQm9vdHN0cmFwKFxuICBhcGlDb25maWcgPSAoZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQ29uZmlnIHx8IHNxbGl0ZTNBcGlCb290c3RyYXAuZGVmYXVsdENvbmZpZylcbil7XG4gIGlmKHNxbGl0ZTNBcGlCb290c3RyYXAuc3FsaXRlMyl7IFxuICAgIGNvbnNvbGUud2FybihcInNxbGl0ZTNBcGlCb290c3RyYXAoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXCIsXG4gICAgICAgICAgICAgICAgIFwiQ29uZmlnIGFuZCBleHRlcm5hbCBpbml0aWFsaXplcnMgYXJlIGlnbm9yZWQgb24gY2FsbHMgYWZ0ZXIgdGhlIGZpcnN0LlwiKTtcbiAgICByZXR1cm4gc3FsaXRlM0FwaUJvb3RzdHJhcC5zcWxpdGUzO1xuICB9XG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgZXhwb3J0czogdW5kZWZpbmVkLFxuICAgIG1lbW9yeTogdW5kZWZpbmVkLFxuICAgIGJpZ0ludEVuYWJsZWQ6ICgoKT0+e1xuICAgICAgaWYoJ3VuZGVmaW5lZCchPT10eXBlb2YgTW9kdWxlKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAhIU1vZHVsZS5IRUFQVTY0O1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhZ2xvYmFsVGhpcy5CaWdJbnQ2NEFycmF5O1xuICAgIH0pKCksXG4gICAgZGVidWc6IGNvbnNvbGUuZGVidWcuYmluZChjb25zb2xlKSxcbiAgICB3YXJuOiBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKSxcbiAgICBlcnJvcjogY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpLFxuICAgIGxvZzogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgICB3YXNtZnNPcGZzRGlyOiAnL29wZnMnLFxuICAgIFxuICAgIHVzZVN0ZEFsbG9jOiBmYWxzZVxuICB9LCBhcGlDb25maWcgfHwge30pO1xuXG4gIE9iamVjdC5hc3NpZ24oY29uZmlnLCB7XG4gICAgYWxsb2NFeHBvcnROYW1lOiBjb25maWcudXNlU3RkQWxsb2MgPyAnbWFsbG9jJyA6ICdzcWxpdGUzX21hbGxvYycsXG4gICAgZGVhbGxvY0V4cG9ydE5hbWU6IGNvbmZpZy51c2VTdGRBbGxvYyA/ICdmcmVlJyA6ICdzcWxpdGUzX2ZyZWUnLFxuICAgIHJlYWxsb2NFeHBvcnROYW1lOiBjb25maWcudXNlU3RkQWxsb2MgPyAncmVhbGxvYycgOiAnc3FsaXRlM19yZWFsbG9jJ1xuICB9LCBjb25maWcpO1xuXG4gIFtcbiAgICBcbiAgICBcbiAgICAnZXhwb3J0cycsICdtZW1vcnknLCAnd2FzbWZzT3Bmc0RpcidcbiAgXS5mb3JFYWNoKChrKT0+e1xuICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiBjb25maWdba10pe1xuICAgICAgY29uZmlnW2tdID0gY29uZmlnW2tdKCk7XG4gICAgfVxuICB9KTtcbiAgXG4gIGNvbnN0IGNhcGkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBcbiAgY29uc3Qgd2FzbSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgXG4gIGNvbnN0IF9fcmNTdHIgPSAocmMpPT57XG4gICAgcmV0dXJuIChjYXBpLnNxbGl0ZTNfanNfcmNfc3RyICYmIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpKVxuICAgICAgICAgICB8fCAoXCJVbmtub3duIHJlc3VsdCBjb2RlICNcIityYyk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9faXNJbnQgPSAobik9PidudW1iZXInPT09dHlwZW9mIG4gJiYgbj09PShuIHwgMCk7XG5cbiAgXG4gIGNsYXNzIFNRTGl0ZTNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgIGxldCByYztcbiAgICAgIGlmKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgaWYoX19pc0ludChhcmdzWzBdKSl7XG4gICAgICAgICAgcmMgPSBhcmdzWzBdO1xuICAgICAgICAgIGlmKDE9PT1hcmdzLmxlbmd0aCl7XG4gICAgICAgICAgICBzdXBlcihfX3JjU3RyKGFyZ3NbMF0pKTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNvbnN0IHJjU3RyID0gX19yY1N0cihyYyk7XG4gICAgICAgICAgICBpZignb2JqZWN0Jz09PXR5cGVvZiBhcmdzWzFdKXtcbiAgICAgICAgICAgICAgc3VwZXIocmNTdHIsYXJnc1sxXSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgYXJnc1swXSA9IHJjU3RyKyc6JztcbiAgICAgICAgICAgICAgc3VwZXIoYXJncy5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgaWYoMj09PWFyZ3MubGVuZ3RoICYmICdvYmplY3QnPT09dHlwZW9mIGFyZ3NbMV0pe1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBzdXBlcihhcmdzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdENvZGUgPSByYyB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgICAgIHRoaXMubmFtZSA9ICdTUUxpdGUzRXJyb3InO1xuICAgIH1cbiAgfTtcblxuICBcbiAgU1FMaXRlM0Vycm9yLnRvc3MgPSAoLi4uYXJncyk9PntcbiAgICB0aHJvdyBuZXcgU1FMaXRlM0Vycm9yKC4uLmFyZ3MpO1xuICB9O1xuICBjb25zdCB0b3NzMyA9IFNRTGl0ZTNFcnJvci50b3NzO1xuXG4gIGlmKGNvbmZpZy53YXNtZnNPcGZzRGlyICYmICEvXlxcL1teL10rJC8udGVzdChjb25maWcud2FzbWZzT3Bmc0Rpcikpe1xuICAgIHRvc3MzKFwiY29uZmlnLndhc21mc09wZnNEaXIgbXVzdCBiZSBmYWxzeSBvciBpbiB0aGUgZm9ybSAnL2Rpci1uYW1lJy5cIik7XG4gIH1cblxuICBcbiAgY29uc3QgaXNJbnQzMiA9IChuKT0+e1xuICAgIHJldHVybiAoJ2JpZ2ludCchPT10eXBlb2YgbiApXG4gICAgICAmJiAhIShuPT09KG58MCkgJiYgbjw9MjE0NzQ4MzY0NyAmJiBuPj0tMjE0NzQ4MzY0OCk7XG4gIH07XG4gIFxuICBjb25zdCBiaWdJbnRGaXRzNjQgPSBmdW5jdGlvbiBmKGIpe1xuICAgIGlmKCFmLl9tYXgpe1xuICAgICAgZi5fbWF4ID0gQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpO1xuICAgICAgZi5fbWluID0gfmYuX21heDtcbiAgICB9XG4gICAgcmV0dXJuIGIgPj0gZi5fbWluICYmIGIgPD0gZi5fbWF4O1xuICB9O1xuXG4gIFxuICBjb25zdCBiaWdJbnRGaXRzMzIgPSAoYik9PihiID49ICgtMHg3ZmZmZmZmZm4gLSAxbikgJiYgYiA8PSAweDdmZmZmZmZmbik7XG5cbiAgXG4gIGNvbnN0IGJpZ0ludEZpdHNEb3VibGUgPSBmdW5jdGlvbiBmKGIpe1xuICAgIGlmKCFmLl9taW4pe1xuICAgICAgZi5fbWluID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICBmLl9tYXggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG4gICAgcmV0dXJuIGIgPj0gZi5fbWluICYmIGIgPD0gZi5fbWF4O1xuICB9O1xuXG4gIFxuICBjb25zdCBpc1R5cGVkQXJyYXkgPSAodik9PntcbiAgICByZXR1cm4gKHYgJiYgdi5jb25zdHJ1Y3RvciAmJiBpc0ludDMyKHYuY29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQpKSA/IHYgOiBmYWxzZTtcbiAgfTtcblxuXG4gIFxuICBjb25zdCBfX1NBQiA9ICgndW5kZWZpbmVkJz09PXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBmdW5jdGlvbigpe30gOiBTaGFyZWRBcnJheUJ1ZmZlcjtcbiAgXG4gIGNvbnN0IGlzU2hhcmVkVHlwZWRBcnJheSA9IChhVHlwZWRBcnJheSk9PihhVHlwZWRBcnJheS5idWZmZXIgaW5zdGFuY2VvZiBfX1NBQik7XG5cbiAgXG4gIGNvbnN0IHR5cGVkQXJyYXlQYXJ0ID0gKGFUeXBlZEFycmF5LCBiZWdpbiwgZW5kKT0+e1xuICAgIHJldHVybiBpc1NoYXJlZFR5cGVkQXJyYXkoYVR5cGVkQXJyYXkpXG4gICAgICA/IGFUeXBlZEFycmF5LnNsaWNlKGJlZ2luLCBlbmQpXG4gICAgICA6IGFUeXBlZEFycmF5LnN1YmFycmF5KGJlZ2luLCBlbmQpO1xuICB9O1xuXG4gIFxuICBjb25zdCBpc0JpbmRhYmxlVHlwZWRBcnJheSA9ICh2KT0+e1xuICAgIHJldHVybiB2ICYmICh2IGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICAgICAgICAgICB8fCB2IGluc3RhbmNlb2YgSW50OEFycmF5XG4gICAgICAgICAgICAgICAgIHx8IHYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGlzU1FMYWJsZVR5cGVkQXJyYXkgPSAodik9PntcbiAgICByZXR1cm4gdiAmJiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgfHwgdiBpbnN0YW5jZW9mIEludDhBcnJheVxuICAgICAgICAgICAgICAgICB8fCB2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9O1xuXG4gIFxuICBjb25zdCBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXkgPSAodik9PntcbiAgICByZXR1cm4gaXNCaW5kYWJsZVR5cGVkQXJyYXkodilcbiAgICAgIHx8IHRvc3MzKFwiVmFsdWUgaXMgbm90IG9mIGEgc3VwcG9ydGVkIFR5cGVkQXJyYXkgdHlwZS5cIik7XG4gIH07XG5cbiAgY29uc3QgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG5cbiAgXG4gIGNvbnN0IHR5cGVkQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uKHR5cGVkQXJyYXksIGJlZ2luLCBlbmQpe1xuICAgIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodHlwZWRBcnJheVBhcnQodHlwZWRBcnJheSwgYmVnaW4sZW5kKSk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGZsZXhpYmxlU3RyaW5nID0gZnVuY3Rpb24odil7XG4gICAgaWYoaXNTUUxhYmxlVHlwZWRBcnJheSh2KSl7XG4gICAgICByZXR1cm4gdHlwZWRBcnJheVRvU3RyaW5nKFxuICAgICAgICAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSA/IG5ldyBVaW50OEFycmF5KHYpIDogdlxuICAgICAgKTtcbiAgICB9XG4gICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gdi5qb2luKFwiXCIpO1xuICAgIGVsc2UgaWYod2FzbS5pc1B0cih2KSkgdiA9IHdhc20uY3N0clRvSnModik7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgXG4gIGNsYXNzIFdhc21BbGxvY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgaWYoMj09PWFyZ3MubGVuZ3RoICYmICdvYmplY3QnPT09dHlwZW9mIGFyZ3NbMV0pe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIH1lbHNlIGlmKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgc3VwZXIoYXJncy5qb2luKCcgJykpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHN1cGVyKFwiQWxsb2NhdGlvbiBmYWlsZWQuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRDb2RlID0gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICB0aGlzLm5hbWUgPSAnV2FzbUFsbG9jRXJyb3InO1xuICAgIH1cbiAgfTtcbiAgXG4gIFdhc21BbGxvY0Vycm9yLnRvc3MgPSAoLi4uYXJncyk9PntcbiAgICB0aHJvdyBuZXcgV2FzbUFsbG9jRXJyb3IoLi4uYXJncyk7XG4gIH07XG5cbiAgT2JqZWN0LmFzc2lnbihjYXBpLCB7XG4gICAgXG4gICAgc3FsaXRlM19iaW5kX2Jsb2I6IHVuZGVmaW5lZCxcblxuICAgIFxuICAgIHNxbGl0ZTNfYmluZF90ZXh0OiB1bmRlZmluZWQsXG5cbiAgICBcbiAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MjogKFxuICAgICAgcERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsIHBBcHAsXG4gICAgICB4RnVuYywgeFN0ZXAsIHhGaW5hbCwgeERlc3Ryb3lcbiAgICApPT57fSxcbiAgICBcbiAgICBzcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbjogKFxuICAgICAgcERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsIHBBcHAsXG4gICAgICB4RnVuYywgeFN0ZXAsIHhGaW5hbFxuICAgICk9Pnt9LFxuICAgIFxuICAgIHNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbjogKFxuICAgICAgcERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsIHBBcHAsXG4gICAgICB4U3RlcCwgeEZpbmFsLCB4VmFsdWUsIHhJbnZlcnNlLCB4RGVzdHJveVxuICAgICk9Pnt9LFxuICAgIFxuICAgIHNxbGl0ZTNfcHJlcGFyZV92MzogKGRiUHRyLCBzcWwsIHNxbEJ5dGVMZW4sIHByZXBGbGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBzdG10UHRyUHRyLCBzdHJQdHJQdHIpPT57fSxcblxuICAgIFxuICAgIHNxbGl0ZTNfcHJlcGFyZV92MjogKGRiUHRyLCBzcWwsIHNxbEJ5dGVMZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgc3RtdFB0clB0cixzdHJQdHJQdHIpPT57fSxcblxuICAgIFxuICAgIHNxbGl0ZTNfZXhlYzogKHBEYiwgc3FsLCBjYWxsYmFjaywgcFZvaWQsIHBFcnJNc2cpPT57fSxcblxuICAgIFxuICAgIHNxbGl0ZTNfcmFuZG9tbmVzczogKG4sIG91dFB0cik9Pnt9LFxuICB9KTtcblxuICBcbiAgY29uc3QgdXRpbCA9IHtcbiAgICBhZmZpcm1CaW5kYWJsZVR5cGVkQXJyYXksIGZsZXhpYmxlU3RyaW5nLFxuICAgIGJpZ0ludEZpdHMzMiwgYmlnSW50Rml0czY0LCBiaWdJbnRGaXRzRG91YmxlLFxuICAgIGlzQmluZGFibGVUeXBlZEFycmF5LFxuICAgIGlzSW50MzIsIGlzU1FMYWJsZVR5cGVkQXJyYXksIGlzVHlwZWRBcnJheSxcbiAgICB0eXBlZEFycmF5VG9TdHJpbmcsXG4gICAgaXNVSVRocmVhZDogKCk9PihnbG9iYWxUaGlzLndpbmRvdz09PWdsb2JhbFRoaXMgJiYgISFnbG9iYWxUaGlzLmRvY3VtZW50KSxcbiAgICBcbiAgICBpc1NoYXJlZFR5cGVkQXJyYXksXG4gICAgdG9zczogZnVuY3Rpb24oLi4uYXJncyl7dGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKX0sXG4gICAgdG9zczMsXG4gICAgdHlwZWRBcnJheVBhcnQsXG4gICAgXG4gICAgYWZmaXJtRGJIZWFkZXI6IGZ1bmN0aW9uKGJ5dGVzKXtcbiAgICAgIGlmKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgY29uc3QgaGVhZGVyID0gXCJTUUxpdGUgZm9ybWF0IDNcIjtcbiAgICAgIGlmKCBoZWFkZXIubGVuZ3RoID4gYnl0ZXMuYnl0ZUxlbmd0aCApe1xuICAgICAgICB0b3NzMyhcIklucHV0IGRvZXMgbm90IGNvbnRhaW4gYW4gU1FMaXRlMyBkYXRhYmFzZSBoZWFkZXIuXCIpO1xuICAgICAgfVxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGhlYWRlci5sZW5ndGg7ICsraSl7XG4gICAgICAgIGlmKCBoZWFkZXIuY2hhckNvZGVBdChpKSAhPT0gYnl0ZXNbaV0gKXtcbiAgICAgICAgICB0b3NzMyhcIklucHV0IGRvZXMgbm90IGNvbnRhaW4gYW4gU1FMaXRlMyBkYXRhYmFzZSBoZWFkZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBhZmZpcm1Jc0RiOiBmdW5jdGlvbihieXRlcyl7XG4gICAgICBpZihieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgIGNvbnN0IG4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgaWYobjw1MTIgfHwgbiU1MTIhPT0wKSB7XG4gICAgICAgIHRvc3MzKFwiQnl0ZSBhcnJheSBzaXplXCIsbixcImlzIGludmFsaWQgZm9yIGFuIFNRTGl0ZTMgZGIuXCIpO1xuICAgICAgfVxuICAgICAgdXRpbC5hZmZpcm1EYkhlYWRlcihieXRlcyk7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24od2FzbSwge1xuICAgIFxuICAgIHB0clNpemVvZjogY29uZmlnLndhc21QdHJTaXplb2YgfHwgNCxcbiAgICBcbiAgICBwdHJJUjogY29uZmlnLndhc21QdHJJUiB8fCBcImkzMlwiLFxuICAgIFxuICAgIGJpZ0ludEVuYWJsZWQ6ICEhY29uZmlnLmJpZ0ludEVuYWJsZWQsXG4gICAgXG4gICAgZXhwb3J0czogY29uZmlnLmV4cG9ydHNcbiAgICAgIHx8IHRvc3MzKFwiTWlzc2luZyBBUEkgY29uZmlnLmV4cG9ydHMgKFdBU00gbW9kdWxlIGV4cG9ydHMpLlwiKSxcblxuICAgIFxuICAgIG1lbW9yeTogY29uZmlnLm1lbW9yeSB8fCBjb25maWcuZXhwb3J0c1snbWVtb3J5J11cbiAgICAgIHx8IHRvc3MzKFwiQVBJIGNvbmZpZyBvYmplY3QgcmVxdWlyZXMgYSBXZWJBc3NlbWJseS5NZW1vcnkgb2JqZWN0XCIsXG4gICAgICAgICAgICAgIFwiaW4gZWl0aGVyIGNvbmZpZy5leHBvcnRzLm1lbW9yeSAoZXhwb3J0ZWQpXCIsXG4gICAgICAgICAgICAgIFwib3IgY29uZmlnLm1lbW9yeSAoaW1wb3J0ZWQpLlwiKSxcblxuICAgIFxuICAgIGFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICBcbiAgICByZWFsbG9jOiB1bmRlZmluZWQsXG5cbiAgICBcbiAgICBkZWFsbG9jOiB1bmRlZmluZWRcblxuICAgIFxuICB9KTtcblxuICBcbiAgd2FzbS5hbGxvY0Zyb21UeXBlZEFycmF5ID0gZnVuY3Rpb24oc3JjVHlwZWRBcnJheSl7XG4gICAgaWYoc3JjVHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtcbiAgICAgIHNyY1R5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheShzcmNUeXBlZEFycmF5KTtcbiAgICB9XG4gICAgYWZmaXJtQmluZGFibGVUeXBlZEFycmF5KHNyY1R5cGVkQXJyYXkpO1xuICAgIGNvbnN0IHBSZXQgPSB3YXNtLmFsbG9jKHNyY1R5cGVkQXJyYXkuYnl0ZUxlbmd0aCB8fCAxKTtcbiAgICB3YXNtLmhlYXBGb3JTaXplKHNyY1R5cGVkQXJyYXkuY29uc3RydWN0b3IpLnNldChcbiAgICAgIHNyY1R5cGVkQXJyYXkuYnl0ZUxlbmd0aCA/IHNyY1R5cGVkQXJyYXkgOiBbMF0sIHBSZXRcbiAgICApO1xuICAgIHJldHVybiBwUmV0O1xuICB9O1xuXG4gIHtcbiAgICBcbiAgICBjb25zdCBrZXlBbGxvYyA9IGNvbmZpZy5hbGxvY0V4cG9ydE5hbWUsXG4gICAgICAgICAga2V5RGVhbGxvYyA9IGNvbmZpZy5kZWFsbG9jRXhwb3J0TmFtZSxcbiAgICAgICAgICBrZXlSZWFsbG9jID0gY29uZmlnLnJlYWxsb2NFeHBvcnROYW1lO1xuICAgIGZvcihjb25zdCBrZXkgb2YgW2tleUFsbG9jLCBrZXlEZWFsbG9jLCBrZXlSZWFsbG9jXSl7XG4gICAgICBjb25zdCBmID0gd2FzbS5leHBvcnRzW2tleV07XG4gICAgICBpZighKGYgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHRvc3MzKFwiTWlzc2luZyByZXF1aXJlZCBleHBvcnRzW1wiLGtleSxcIl0gZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHdhc20uYWxsb2MgPSBmdW5jdGlvbiBmKG4pe1xuICAgICAgcmV0dXJuIGYuaW1wbChuKSB8fCBXYXNtQWxsb2NFcnJvci50b3NzKFwiRmFpbGVkIHRvIGFsbG9jYXRlXCIsbixcIiBieXRlcy5cIik7XG4gICAgfTtcbiAgICB3YXNtLmFsbG9jLmltcGwgPSB3YXNtLmV4cG9ydHNba2V5QWxsb2NdO1xuICAgIHdhc20ucmVhbGxvYyA9IGZ1bmN0aW9uIGYobSxuKXtcbiAgICAgIGNvbnN0IG0yID0gZi5pbXBsKG0sbik7XG4gICAgICByZXR1cm4gbiA/IChtMiB8fCBXYXNtQWxsb2NFcnJvci50b3NzKFwiRmFpbGVkIHRvIHJlYWxsb2NhdGVcIixuLFwiIGJ5dGVzLlwiKSkgOiAwO1xuICAgIH07XG4gICAgd2FzbS5yZWFsbG9jLmltcGwgPSB3YXNtLmV4cG9ydHNba2V5UmVhbGxvY107XG4gICAgd2FzbS5kZWFsbG9jID0gd2FzbS5leHBvcnRzW2tleURlYWxsb2NdO1xuICB9XG5cbiAgXG4gIHdhc20uY29tcGlsZU9wdGlvblVzZWQgPSBmdW5jdGlvbiBmKG9wdE5hbWUpe1xuICAgIGlmKCFhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgIGlmKGYuX3Jlc3VsdCkgcmV0dXJuIGYuX3Jlc3VsdDtcbiAgICAgIGVsc2UgaWYoIWYuX29wdCl7XG4gICAgICAgIGYuX3J4ID0gL14oW149XSspPSguKykvO1xuICAgICAgICBmLl9yeEludCA9IC9eLT9cXGQrJC87XG4gICAgICAgIGYuX29wdCA9IGZ1bmN0aW9uKG9wdCwgcnYpe1xuICAgICAgICAgIGNvbnN0IG0gPSBmLl9yeC5leGVjKG9wdCk7XG4gICAgICAgICAgcnZbMF0gPSAobSA/IG1bMV0gOiBvcHQpO1xuICAgICAgICAgIHJ2WzFdID0gbSA/IChmLl9yeEludC50ZXN0KG1bMl0pID8gK21bMl0gOiBtWzJdKSA6IHRydWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByYyA9IHt9LCBvdiA9IFswLDBdO1xuICAgICAgbGV0IGkgPSAwLCBrO1xuICAgICAgd2hpbGUoKGsgPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl9nZXQoaSsrKSkpe1xuICAgICAgICBmLl9vcHQoayxvdik7XG4gICAgICAgIHJjW292WzBdXSA9IG92WzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGYuX3Jlc3VsdCA9IHJjO1xuICAgIH1lbHNlIGlmKEFycmF5LmlzQXJyYXkob3B0TmFtZSkpe1xuICAgICAgY29uc3QgcmMgPSB7fTtcbiAgICAgIG9wdE5hbWUuZm9yRWFjaCgodik9PntcbiAgICAgICAgcmNbdl0gPSBjYXBpLnNxbGl0ZTNfY29tcGlsZW9wdGlvbl91c2VkKHYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfWVsc2UgaWYoJ29iamVjdCcgPT09IHR5cGVvZiBvcHROYW1lKXtcbiAgICAgIE9iamVjdC5rZXlzKG9wdE5hbWUpLmZvckVhY2goKGspPT4ge1xuICAgICAgICBvcHROYW1lW2tdID0gY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZChrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9wdE5hbWU7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAnc3RyaW5nJz09PXR5cGVvZiBvcHROYW1lXG4gICAgKSA/ICEhY2FwaS5zcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZChvcHROYW1lKSA6IGZhbHNlO1xuICB9O1xuXG4gIFxuICB3YXNtLnBzdGFjayA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgXG4gICAgcmVzdG9yZTogd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9wc3RhY2tfcmVzdG9yZSxcbiAgICBcbiAgICBhbGxvYzogZnVuY3Rpb24obil7XG4gICAgICBpZignc3RyaW5nJz09PXR5cGVvZiBuICYmICEobiA9IHdhc20uc2l6ZW9mSVIobikpKXtcbiAgICAgICAgV2FzbUFsbG9jRXJyb3IudG9zcyhcIkludmFsaWQgdmFsdWUgZm9yIHBzdGFjay5hbGxvYyhcIixhcmd1bWVudHNbMF0sXCIpXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX2FsbG9jKG4pXG4gICAgICAgIHx8IFdhc21BbGxvY0Vycm9yLnRvc3MoXCJDb3VsZCBub3QgYWxsb2NhdGVcIixuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnl0ZXMgZnJvbSB0aGUgcHN0YWNrLlwiKTtcbiAgICB9LFxuICAgIFxuICAgIGFsbG9jQ2h1bmtzOiBmdW5jdGlvbihuLHN6KXtcbiAgICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIHN6ICYmICEoc3ogPSB3YXNtLnNpemVvZklSKHN6KSkpe1xuICAgICAgICBXYXNtQWxsb2NFcnJvci50b3NzKFwiSW52YWxpZCBzaXplIHZhbHVlIGZvciBhbGxvY0NodW5rcyhcIixhcmd1bWVudHNbMV0sXCIpXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVtID0gd2FzbS5wc3RhY2suYWxsb2MobiAqIHN6KTtcbiAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICBsZXQgaSA9IDAsIG9mZnNldCA9IDA7XG4gICAgICBmb3IoOyBpIDwgbjsgKytpLCBvZmZzZXQgKz0gc3opIHJjLnB1c2gobWVtICsgb2Zmc2V0KTtcbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuICAgIFxuICAgIGFsbG9jUHRyOiAobj0xLHNhZmVQdHJTaXplPXRydWUpPT57XG4gICAgICByZXR1cm4gMT09PW5cbiAgICAgICAgPyB3YXNtLnBzdGFjay5hbGxvYyhzYWZlUHRyU2l6ZSA/IDggOiB3YXNtLnB0clNpemVvZilcbiAgICAgICAgOiB3YXNtLnBzdGFjay5hbGxvY0NodW5rcyhuLCBzYWZlUHRyU2l6ZSA/IDggOiB3YXNtLnB0clNpemVvZik7XG4gICAgfSxcblxuICAgIFxuICAgIGNhbGw6IGZ1bmN0aW9uKGYpe1xuICAgICAgY29uc3Qgc3RhY2tQb3MgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgdHJ5eyByZXR1cm4gZihzcWxpdGUzKSB9IGZpbmFsbHl7XG4gICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2tQb3MpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2FzbS5wc3RhY2ssIHtcbiAgICBcbiAgICBwb2ludGVyOiB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLCBpdGVyYWJsZTogdHJ1ZSwgd3JpdGVhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9wc3RhY2tfcHRyXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBxdW90YToge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSwgaXRlcmFibGU6IHRydWUsIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fcHN0YWNrX3F1b3RhXG4gICAgfSxcbiAgICBcbiAgICByZW1haW5pbmc6IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGl0ZXJhYmxlOiB0cnVlLCB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX3BzdGFja19yZW1haW5pbmdcbiAgICB9XG4gIH0pO1xuXG4gIGNhcGkuc3FsaXRlM19yYW5kb21uZXNzID0gKC4uLmFyZ3MpPT57XG4gICAgaWYoMT09PWFyZ3MubGVuZ3RoICYmIHV0aWwuaXNUeXBlZEFycmF5KGFyZ3NbMF0pXG4gICAgICAmJiAxPT09YXJnc1swXS5CWVRFU19QRVJfRUxFTUVOVCl7XG4gICAgICBjb25zdCB0YSA9IGFyZ3NbMF07XG4gICAgICBpZigwPT09dGEuYnl0ZUxlbmd0aCl7XG4gICAgICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX3JhbmRvbW5lc3MoMCwwKTtcbiAgICAgICAgcmV0dXJuIHRhO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IG4gPSB0YS5ieXRlTGVuZ3RoLCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCByID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmFuZG9tbmVzcztcbiAgICAgICAgY29uc3QgaGVhcCA9IHdhc20uaGVhcDh1KCk7XG4gICAgICAgIGNvbnN0IG5BbGxvYyA9IG4gPCA1MTIgPyBuIDogNTEyO1xuICAgICAgICBjb25zdCBwdHIgPSB3YXNtLnBzdGFjay5hbGxvYyhuQWxsb2MpO1xuICAgICAgICBkb3tcbiAgICAgICAgICBjb25zdCBqID0gKG4+bkFsbG9jID8gbkFsbG9jIDogbik7XG4gICAgICAgICAgcihqLCBwdHIpO1xuICAgICAgICAgIHRhLnNldCh0eXBlZEFycmF5UGFydChoZWFwLCBwdHIsIHB0citqKSwgb2Zmc2V0KTtcbiAgICAgICAgICBuIC09IGo7XG4gICAgICAgICAgb2Zmc2V0ICs9IGo7XG4gICAgICAgIH0gd2hpbGUobiA+IDApO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiSGlnaGx5IHVuZXhwZWN0ZWQgKGFuZCBpZ25vcmVkISkgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgXCJleGNlcHRpb24gaW4gc3FsaXRlM19yYW5kb21uZXNzKCk6XCIsZSk7XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgd2FzbS5wc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGE7XG4gICAgfVxuICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX3JhbmRvbW5lc3MoLi4uYXJncyk7XG4gIH07XG5cbiAgXG4gIGxldCBfX3dhc21mc09wZnNEaXIgPSB1bmRlZmluZWQ7XG4gIFxuICBjYXBpLnNxbGl0ZTNfd2FzbWZzX29wZnNfZGlyID0gZnVuY3Rpb24oKXtcbiAgICBpZih1bmRlZmluZWQgIT09IF9fd2FzbWZzT3Bmc0RpcikgcmV0dXJuIF9fd2FzbWZzT3Bmc0RpcjtcbiAgICBcbiAgICBjb25zdCBwZGlyID0gY29uZmlnLndhc21mc09wZnNEaXI7XG4gICAgaWYoIXBkaXJcbiAgICAgICB8fCAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlXG4gICAgICAgfHwgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZVxuICAgICAgIHx8ICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlKXtcbiAgICAgIHJldHVybiBfX3dhc21mc09wZnNEaXIgPSBcIlwiO1xuICAgIH1cbiAgICB0cnl7XG4gICAgICBpZihwZGlyICYmIDA9PT13YXNtLnhDYWxsV3JhcHBlZChcbiAgICAgICAgJ3NxbGl0ZTNfd2FzbV9pbml0X3dhc21mcycsICdpMzInLCBbJ3N0cmluZyddLCBwZGlyXG4gICAgICApKXtcbiAgICAgICAgcmV0dXJuIF9fd2FzbWZzT3Bmc0RpciA9IHBkaXI7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIF9fd2FzbWZzT3Bmc0RpciA9IFwiXCI7XG4gICAgICB9XG4gICAgfWNhdGNoKGUpe1xuICAgICAgXG4gICAgICByZXR1cm4gX193YXNtZnNPcGZzRGlyID0gXCJcIjtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM193YXNtZnNfZmlsZW5hbWVfaXNfcGVyc2lzdGVudCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIGNvbnN0IHAgPSBjYXBpLnNxbGl0ZTNfd2FzbWZzX29wZnNfZGlyKCk7XG4gICAgcmV0dXJuIChwICYmIG5hbWUpID8gbmFtZS5zdGFydHNXaXRoKHArJy8nKSA6IGZhbHNlO1xuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfZGJfdXNlc192ZnMgPSBmdW5jdGlvbihwRGIsdmZzTmFtZSxkYk5hbWU9MCl7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcEsgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQodmZzTmFtZSk7XG4gICAgICBpZighcEspIHJldHVybiBmYWxzZTtcbiAgICAgIGVsc2UgaWYoIXBEYil7XG4gICAgICAgIHJldHVybiBwSz09PWNhcGkuc3FsaXRlM192ZnNfZmluZCgwKSA/IHBLIDogZmFsc2U7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIHBLPT09Y2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyhwRGIsZGJOYW1lKSA/IHBLIDogZmFsc2U7XG4gICAgICB9XG4gICAgfWNhdGNoKGUpe1xuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfdmZzX2xpc3QgPSBmdW5jdGlvbigpe1xuICAgIGNvbnN0IHJjID0gW107XG4gICAgbGV0IHBWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQoMCk7XG4gICAgd2hpbGUocFZmcyl7XG4gICAgICBjb25zdCBvVmZzID0gbmV3IGNhcGkuc3FsaXRlM192ZnMocFZmcyk7XG4gICAgICByYy5wdXNoKHdhc20uY3N0clRvSnMob1Zmcy4kek5hbWUpKTtcbiAgICAgIHBWZnMgPSBvVmZzLiRwTmV4dDtcbiAgICAgIG9WZnMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmM7XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc19kYl9leHBvcnQgPSBmdW5jdGlvbihwRGIsIHNjaGVtYT0wKXtcbiAgICBwRGIgPSB3YXNtLnhXcmFwLnRlc3RDb252ZXJ0QXJnKCdzcWxpdGUzKicsIHBEYik7XG4gICAgaWYoIXBEYikgdG9zczMoJ0ludmFsaWQgc3FsaXRlMyogYXJndW1lbnQuJyk7XG4gICAgaWYoIXdhc20uYmlnSW50RW5hYmxlZCkgdG9zczMoJ0JpZ0ludDY0IHN1cHBvcnQgaXMgbm90IGVuYWJsZWQuJyk7XG4gICAgY29uc3Qgc2NvcGUgPSB3YXNtLnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgIGxldCBwT3V0O1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IHBTaXplID0gd2FzbS5zY29wZWRBbGxvYyg4ICsgd2FzbS5wdHJTaXplb2YpO1xuICAgICAgY29uc3QgcHBPdXQgPSBwU2l6ZSArIDg7XG4gICAgICBcbiAgICAgIGNvbnN0IHpTY2hlbWEgPSBzY2hlbWFcbiAgICAgICAgICAgID8gKHdhc20uaXNQdHIoc2NoZW1hKSA/IHNjaGVtYSA6IHdhc20uc2NvcGVkQWxsb2NDU3RyaW5nKCcnK3NjaGVtYSkpXG4gICAgICAgICAgICA6IDA7XG4gICAgICBsZXQgcmMgPSB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2RiX3NlcmlhbGl6ZShcbiAgICAgICAgcERiLCB6U2NoZW1hLCBwcE91dCwgcFNpemUsIDBcbiAgICAgICk7XG4gICAgICBpZihyYyl7XG4gICAgICAgIHRvc3MzKFwiRGF0YWJhc2Ugc2VyaWFsaXphdGlvbiBmYWlsZWQgd2l0aCBjb2RlXCIsXG4gICAgICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfanNfcmNfc3RyKHJjKSk7XG4gICAgICB9XG4gICAgICBwT3V0ID0gd2FzbS5wZWVrUHRyKHBwT3V0KTtcbiAgICAgIGNvbnN0IG5PdXQgPSB3YXNtLnBlZWsocFNpemUsICdpNjQnKTtcbiAgICAgIHJjID0gbk91dFxuICAgICAgICA/IHdhc20uaGVhcDh1KCkuc2xpY2UocE91dCwgcE91dCArIE51bWJlcihuT3V0KSlcbiAgICAgICAgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH1maW5hbGx5e1xuICAgICAgaWYocE91dCkgd2FzbS5leHBvcnRzLnNxbGl0ZTNfZnJlZShwT3V0KTtcbiAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX2RiX3ZmcyA9XG4gICAgKGRiUG9pbnRlciwgZGJOYW1lPTApPT53YXNtLnNxbGl0ZTNfd2FzbV9kYl92ZnMoZGJQb2ludGVyLCBkYk5hbWUpO1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfYWdncmVnYXRlX2NvbnRleHQgPSAocEN0eCwgbik9PntcbiAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2FnZ3JlZ2F0ZV9jb250ZXh0KHBDdHgsIG4pXG4gICAgICB8fCAobiA/IFdhc21BbGxvY0Vycm9yLnRvc3MoXCJDYW5ub3QgYWxsb2NhdGVcIixuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnl0ZXMgZm9yIHNxbGl0ZTNfYWdncmVnYXRlX2NvbnRleHQoKVwiKVxuICAgICAgICAgIDogMCk7XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBkYXRhLCBkYXRhTGVuKXtcbiAgICBsZXQgcERhdGE7XG4gICAgaWYoZGF0YSAmJiB3YXNtLmlzUHRyKGRhdGEpKXtcbiAgICAgIHBEYXRhID0gZGF0YTtcbiAgICB9ZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe1xuICAgICAgcERhdGEgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkoZGF0YSk7XG4gICAgICBpZihhcmd1bWVudHMubGVuZ3RoPDMgfHwgIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fCBkYXRhTGVuPDApe1xuICAgICAgICBkYXRhTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXCJJbnZhbGlkIDJuZCBhcmd1bWVudCBmb3Igc3FsaXRlM19qc19wb3NpeF9jcmVhdGVfZmlsZSgpLlwiKTtcbiAgICB9XG4gICAgdHJ5e1xuICAgICAgaWYoIXV0aWwuaXNJbnQzMihkYXRhTGVuKSB8fCBkYXRhTGVuPDApe1xuICAgICAgICBTUUxpdGUzRXJyb3IudG9zcyhcIkludmFsaWQgM3JkIGFyZ3VtZW50IGZvciBzcWxpdGUzX2pzX3Bvc2l4X2NyZWF0ZV9maWxlKCkuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmMgPSB3YXNtLnNxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZShmaWxlbmFtZSwgcERhdGEsIGRhdGFMZW4pO1xuICAgICAgaWYocmMpIFNRTGl0ZTNFcnJvci50b3NzKFwiQ3JlYXRpb24gb2YgZmlsZSBmYWlsZWQgd2l0aCBzcWxpdGUzIHJlc3VsdCBjb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYykpO1xuICAgIH1maW5hbGx5e1xuICAgICAgIHdhc20uZGVhbGxvYyhwRGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfanNfdmZzX2NyZWF0ZV9maWxlID0gZnVuY3Rpb24odmZzLCBmaWxlbmFtZSwgZGF0YSwgZGF0YUxlbil7XG4gICAgY29uZmlnLndhcm4oXCJzcWxpdGUzX2pzX3Zmc19jcmVhdGVfZmlsZSgpIGlzIGRlcHJlY2F0ZWQgYW5kXCIsXG4gICAgICAgICAgICAgICAgXCJzaG91bGQgYmUgYXZvaWRlZCBiZWNhdXNlIGl0IGNhbiBsZWFkIHRvIEMtbGV2ZWwgY3Jhc2hlcy5cIixcbiAgICAgICAgICAgICAgICBcIlNlZSBpdHMgZG9jdW1lbnRhdGlvbiBmb3IgYWx0ZXJuYXRpdmUgb3B0aW9ucy5cIik7XG4gICAgbGV0IHBEYXRhO1xuICAgIGlmKGRhdGEpe1xuICAgICAgaWYod2FzbS5pc1B0cihkYXRhKSl7XG4gICAgICAgIHBEYXRhID0gZGF0YTtcbiAgICAgIH1lbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtcbiAgICAgICAgcERhdGEgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkoZGF0YSk7XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGg8NCB8fCAhdXRpbC5pc0ludDMyKGRhdGFMZW4pIHx8IGRhdGFMZW48MCl7XG4gICAgICAgICAgZGF0YUxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIFNRTGl0ZTNFcnJvci50b3NzKFwiSW52YWxpZCAzcmQgYXJndW1lbnQgdHlwZSBmb3Igc3FsaXRlM19qc192ZnNfY3JlYXRlX2ZpbGUoKS5cIik7XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAgcERhdGEgPSAwO1xuICAgIH1cbiAgICBpZighdXRpbC5pc0ludDMyKGRhdGFMZW4pIHx8IGRhdGFMZW48MCl7XG4gICAgICB3YXNtLmRlYWxsb2MocERhdGEpO1xuICAgICAgU1FMaXRlM0Vycm9yLnRvc3MoXCJJbnZhbGlkIDR0aCBhcmd1bWVudCBmb3Igc3FsaXRlM19qc192ZnNfY3JlYXRlX2ZpbGUoKS5cIik7XG4gICAgfVxuICAgIHRyeXtcbiAgICAgIGNvbnN0IHJjID0gd2FzbS5zcWxpdGUzX3dhc21fdmZzX2NyZWF0ZV9maWxlKHZmcywgZmlsZW5hbWUsIHBEYXRhLCBkYXRhTGVuKTtcbiAgICAgIGlmKHJjKSBTUUxpdGUzRXJyb3IudG9zcyhcIkNyZWF0aW9uIG9mIGZpbGUgZmFpbGVkIHdpdGggc3FsaXRlMyByZXN1bHQgY29kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19qc19yY19zdHIocmMpKTtcbiAgICB9ZmluYWxseXtcbiAgICAgICB3YXNtLmRlYWxsb2MocERhdGEpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX2pzX3NxbF90b19zdHJpbmcgPSAoc3FsKT0+e1xuICAgIGlmKCdzdHJpbmcnID09PSB0eXBlb2Ygc3FsKXtcbiAgICAgIHJldHVybiBzcWw7XG4gICAgfVxuICAgIGNvbnN0IHggPSBmbGV4aWJsZVN0cmluZyh2KTtcbiAgICByZXR1cm4geD09PXYgPyB1bmRlZmluZWQgOiB4O1xuICB9XG5cbiAgaWYoIHV0aWwuaXNVSVRocmVhZCgpICl7XG4gICAgXG5cbiAgICBcbiAgICBjb25zdCBfX2t2dmZzSW5mbyA9IGZ1bmN0aW9uKHdoaWNoKXtcbiAgICAgIGNvbnN0IHJjID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJjLnByZWZpeCA9ICdrdnZmcy0nK3doaWNoO1xuICAgICAgcmMuc3RvcmVzID0gW107XG4gICAgICBpZignc2Vzc2lvbic9PT13aGljaCB8fCBcIlwiPT09d2hpY2gpIHJjLnN0b3Jlcy5wdXNoKGdsb2JhbFRoaXMuc2Vzc2lvblN0b3JhZ2UpO1xuICAgICAgaWYoJ2xvY2FsJz09PXdoaWNoIHx8IFwiXCI9PT13aGljaCkgcmMuc3RvcmVzLnB1c2goZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH07XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfanNfa3Z2ZnNfY2xlYXIgPSBmdW5jdGlvbih3aGljaD1cIlwiKXtcbiAgICAgIGxldCByYyA9IDA7XG4gICAgICBjb25zdCBrdmluZm8gPSBfX2t2dmZzSW5mbyh3aGljaCk7XG4gICAgICBrdmluZm8uc3RvcmVzLmZvckVhY2goKHMpPT57XG4gICAgICAgIGNvbnN0IHRvUm0gPSBbXSA7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSApe1xuICAgICAgICAgIGNvbnN0IGsgPSBzLmtleShpKTtcbiAgICAgICAgICBpZihrLnN0YXJ0c1dpdGgoa3ZpbmZvLnByZWZpeCkpIHRvUm0ucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICB0b1JtLmZvckVhY2goKGtrKT0+cy5yZW1vdmVJdGVtKGtrKSk7XG4gICAgICAgIHJjICs9IHRvUm0ubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19qc19rdnZmc19zaXplID0gZnVuY3Rpb24od2hpY2g9XCJcIil7XG4gICAgICBsZXQgc3ogPSAwO1xuICAgICAgY29uc3Qga3ZpbmZvID0gX19rdnZmc0luZm8od2hpY2gpO1xuICAgICAga3ZpbmZvLnN0b3Jlcy5mb3JFYWNoKChzKT0+e1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgY29uc3QgayA9IHMua2V5KGkpO1xuICAgICAgICAgIGlmKGsuc3RhcnRzV2l0aChrdmluZm8ucHJlZml4KSl7XG4gICAgICAgICAgICBzeiArPSBrLmxlbmd0aDtcbiAgICAgICAgICAgIHN6ICs9IHMuZ2V0SXRlbShrKS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzeiAqIDIgO1xuICAgIH07XG5cbiAgfVxuXG4gIFxuICBjYXBpLnNxbGl0ZTNfZGJfY29uZmlnID0gZnVuY3Rpb24ocERiLCBvcCwgLi4uYXJncyl7XG4gICAgaWYoIXRoaXMucyl7XG4gICAgICB0aGlzLnMgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX3dhc21fZGJfY29uZmlnX3MnLCdpbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbJ3NxbGl0ZTMqJywgJ2ludCcsICdzdHJpbmc6c3RhdGljJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgIHRoaXMucGlpID0gd2FzbS54V3JhcCgnc3FsaXRlM193YXNtX2RiX2NvbmZpZ19waWknLCAnaW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbJ3NxbGl0ZTMqJywgJ2ludCcsICcqJywnaW50JywgJ2ludCddKTtcbiAgICAgIHRoaXMuaXAgPSB3YXNtLnhXcmFwKCdzcWxpdGUzX3dhc21fZGJfY29uZmlnX2lwJywnaW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnc3FsaXRlMyonLCAnaW50JywgJ2ludCcsJyonXSk7XG4gICAgfVxuICAgIHN3aXRjaChvcCl7XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZLRVk6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX1RSSUdHRVI6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRU5BQkxFX0ZUUzNfVE9LRU5JWkVSOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9MT0FEX0VYVEVOU0lPTjpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19OT19DS1BUX09OX0NMT1NFOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0VOQUJMRV9RUFNHOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1RSSUdHRVJfRVFQOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1JFU0VUX0RBVEFCQVNFOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0RFRkVOU0lWRTpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19XUklUQUJMRV9TQ0hFTUE6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTEVHQUNZX0FMVEVSX1RBQkxFOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX0RRU19ETUw6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfRFFTX0RETDpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19FTkFCTEVfVklFVzpcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19MRUdBQ1lfRklMRV9GT1JNQVQ6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfVFJVU1RFRF9TQ0hFTUE6XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfU1RNVF9TQ0FOU1RBVFVTOlxuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0RCQ09ORklHX1JFVkVSU0VfU0NBTk9SREVSOlxuICAgICAgICAgIHJldHVybiB0aGlzLmlwKHBEYiwgb3AsIGFyZ3NbMF0sIGFyZ3NbMV0gfHwgMCk7XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfREJDT05GSUdfTE9PS0FTSURFOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBpaShwRGIsIG9wLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9EQkNPTkZJR19NQUlOREJOQU1FOlxuICAgICAgICAgIHJldHVybiB0aGlzLnMocERiLCBvcCwgYXJnc1swXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICB9XG4gIH0uYmluZChPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzID0gZnVuY3Rpb24ocFZhbCx0aHJvd0lmQ2Fubm90Q29udmVydD10cnVlKXtcbiAgICBsZXQgYXJnO1xuICAgIGNvbnN0IHZhbFR5cGUgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfdHlwZShwVmFsKTtcbiAgICBzd2l0Y2godmFsVHlwZSl7XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfSU5URUdFUjpcbiAgICAgICAgICBpZih3YXNtLmJpZ0ludEVuYWJsZWQpe1xuICAgICAgICAgICAgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2ludDY0KHBWYWwpO1xuICAgICAgICAgICAgaWYodXRpbC5iaWdJbnRGaXRzRG91YmxlKGFyZykpIGFyZyA9IE51bWJlcihhcmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV9kb3VibGUocFZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRkxPQVQ6XG4gICAgICAgICAgYXJnID0gY2FwaS5zcWxpdGUzX3ZhbHVlX2RvdWJsZShwVmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9URVhUOlxuICAgICAgICAgIGFyZyA9IGNhcGkuc3FsaXRlM192YWx1ZV90ZXh0KHBWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0JMT0I6e1xuICAgICAgICAgIGNvbnN0IG4gPSBjYXBpLnNxbGl0ZTNfdmFsdWVfYnl0ZXMocFZhbCk7XG4gICAgICAgICAgY29uc3QgcEJsb2IgPSBjYXBpLnNxbGl0ZTNfdmFsdWVfYmxvYihwVmFsKTtcbiAgICAgICAgICBpZihuICYmICFwQmxvYikgc3FsaXRlMy5XYXNtQWxsb2NFcnJvci50b3NzKFxuICAgICAgICAgICAgXCJDYW5ub3QgYWxsb2NhdGUgbWVtb3J5IGZvciBibG9iIGFyZ3VtZW50IG9mXCIsbixcImJ5dGUocylcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgYXJnID0gbiA/IHdhc20uaGVhcDh1KCkuc2xpY2UocEJsb2IsIHBCbG9iICsgTnVtYmVyKG4pKSA6IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBjYXBpLlNRTElURV9OVUxMOlxuICAgICAgICAgIGFyZyA9IG51bGw7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmKHRocm93SWZDYW5ub3RDb252ZXJ0KXtcbiAgICAgICAgICAgIHRvc3MzKGNhcGkuU1FMSVRFX01JU01BVENILFxuICAgICAgICAgICAgICAgICAgXCJVbmhhbmRsZWQgc3FsaXRlM192YWx1ZV90eXBlKCk6XCIsdmFsVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3ZhbHVlc190b19qcyA9IGZ1bmN0aW9uKGFyZ2MscEFyZ3YsdGhyb3dJZkNhbm5vdENvbnZlcnQ9dHJ1ZSl7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgdGd0ID0gW107XG4gICAgZm9yKGkgPSAwOyBpIDwgYXJnYzsgKytpKXtcbiAgICAgIFxuICAgICAgdGd0LnB1c2goY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzKFxuICAgICAgICB3YXNtLnBlZWtQdHIocEFyZ3YgKyAod2FzbS5wdHJTaXplb2YgKiBpKSksXG4gICAgICAgIHRocm93SWZDYW5ub3RDb252ZXJ0XG4gICAgICApKTtcbiAgICB9XG4gICAgcmV0dXJuIHRndDtcbiAgfTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyA9IGZ1bmN0aW9uKHBDdHgsZSl7XG4gICAgaWYoZSBpbnN0YW5jZW9mIFdhc21BbGxvY0Vycm9yKXtcbiAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3Jfbm9tZW0ocEN0eCk7XG4gICAgfWVsc2V7XG4gICAgICA7XG4gICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Vycm9yKHBDdHgsICcnK2UsIC0xKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19yZXN1bHRfanMgPSBmdW5jdGlvbihwQ3R4LHZhbCl7XG4gICAgaWYodmFsIGluc3RhbmNlb2YgRXJyb3Ipe1xuICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCB2YWwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnl7XG4gICAgICBzd2l0Y2godHlwZW9mIHZhbCkge1xuICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQocEN0eCwgdmFsID8gMSA6IDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgICAgIGlmKHV0aWwuYmlnSW50Rml0czMyKHZhbCkpe1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2ludChwQ3R4LCBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9ZWxzZSBpZih1dGlsLmJpZ0ludEZpdHNEb3VibGUodmFsKSl7XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZG91YmxlKHBDdHgsIE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgIH1lbHNlIGlmKHdhc20uYmlnSW50RW5hYmxlZCl7XG4gICAgICAgICAgICAgIGlmKHV0aWwuYmlnSW50Rml0czY0KHZhbCkpIGNhcGkuc3FsaXRlM19yZXN1bHRfaW50NjQocEN0eCwgdmFsKTtcbiAgICAgICAgICAgICAgZWxzZSB0b3NzMyhcIkJpZ0ludCB2YWx1ZVwiLHZhbC50b1N0cmluZygpLFwiaXMgdG9vIEJpZ0ludCBmb3IgaW50NjQuXCIpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHRvc3MzKFwiQmlnSW50IHZhbHVlXCIsdmFsLnRvU3RyaW5nKCksXCJpcyB0b28gQmlnSW50LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgIGxldCBmO1xuICAgICAgICAgICAgaWYodXRpbC5pc0ludDMyKHZhbCkpe1xuICAgICAgICAgICAgICBmID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9pbnQ7XG4gICAgICAgICAgICB9ZWxzZSBpZih3YXNtLmJpZ0ludEVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICYmIE51bWJlci5pc0ludGVnZXIodmFsKVxuICAgICAgICAgICAgICAgICAgICAgJiYgdXRpbC5iaWdJbnRGaXRzNjQoQmlnSW50KHZhbCkpKXtcbiAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfaW50NjQ7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgZiA9IGNhcGkuc3FsaXRlM19yZXN1bHRfZG91YmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwQ3R4LCB2YWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgIGNvbnN0IFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHZhbCx0cnVlKTtcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfdGV4dChwQ3R4LCBwLCBuLCBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZihudWxsPT09dmFsKSB7XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfbnVsbChwQ3R4KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ZWxzZSBpZih1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHZhbCkpe1xuICAgICAgICAgICAgICBjb25zdCBwQmxvYiA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheSh2YWwpO1xuICAgICAgICAgICAgICBjYXBpLnNxbGl0ZTNfcmVzdWx0X2Jsb2IoXG4gICAgICAgICAgICAgICAgcEN0eCwgcEJsb2IsIHZhbC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0b3NzMyhcIkRvbid0IG5vdCBob3cgdG8gaGFuZGxlIHRoaXMgVURGIHJlc3VsdCB2YWx1ZTpcIiwodHlwZW9mIHZhbCksIHZhbCk7XG4gICAgICB9XG4gICAgfWNhdGNoKGUpe1xuICAgICAgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCBlKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19jb2x1bW5fanMgPSBmdW5jdGlvbihwU3RtdCwgaUNvbCwgdGhyb3dJZkNhbm5vdENvbnZlcnQ9dHJ1ZSl7XG4gICAgY29uc3QgdiA9IGNhcGkuc3FsaXRlM19jb2x1bW5fdmFsdWUocFN0bXQsIGlDb2wpO1xuICAgIHJldHVybiAoMD09PXYpID8gdW5kZWZpbmVkIDogY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzKHYsIHRocm93SWZDYW5ub3RDb252ZXJ0KTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19uZXdPbGRWYWx1ZSA9IGZ1bmN0aW9uKHBPYmosIGlDb2wsIGltcGwpe1xuICAgIGltcGwgPSBjYXBpW2ltcGxdO1xuICAgIGlmKCF0aGlzLnB0cikgdGhpcy5wdHIgPSB3YXNtLmFsbG9jUHRyKCk7XG4gICAgZWxzZSB3YXNtLnBva2VQdHIodGhpcy5wdHIsIDApO1xuICAgIGNvbnN0IHJjID0gaW1wbChwT2JqLCBpQ29sLCB0aGlzLnB0cik7XG4gICAgaWYocmMpIHJldHVybiBTUUxpdGUzRXJyb3IudG9zcyhyYyxhcmd1bWVudHNbMl0rXCIoKSBmYWlsZWQgd2l0aCBjb2RlIFwiK3JjKTtcbiAgICBjb25zdCBwdiA9IHdhc20ucGVla1B0cih0aGlzLnB0cik7XG4gICAgcmV0dXJuIHB2ID8gY2FwaS5zcWxpdGUzX3ZhbHVlX3RvX2pzKCBwdiwgdHJ1ZSApIDogdW5kZWZpbmVkO1xuICB9LmJpbmQoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19wcmV1cGRhdGVfbmV3X2pzID1cbiAgICAocERiLCBpQ29sKT0+X19uZXdPbGRWYWx1ZShwRGIsIGlDb2wsICdzcWxpdGUzX3ByZXVwZGF0ZV9uZXcnKTtcblxuICBcbiAgY2FwaS5zcWxpdGUzX3ByZXVwZGF0ZV9vbGRfanMgPVxuICAgIChwRGIsIGlDb2wpPT5fX25ld09sZFZhbHVlKHBEYiwgaUNvbCwgJ3NxbGl0ZTNfcHJldXBkYXRlX29sZCcpO1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNjaGFuZ2VzZXRfbmV3X2pzID1cbiAgICAocENoYW5nZXNldEl0ZXIsIGlDb2wpID0+IF9fbmV3T2xkVmFsdWUocENoYW5nZXNldEl0ZXIsIGlDb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcWxpdGUzY2hhbmdlc2V0X25ldycpO1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNjaGFuZ2VzZXRfb2xkX2pzID1cbiAgICAocENoYW5nZXNldEl0ZXIsIGlDb2wpPT5fX25ld09sZFZhbHVlKHBDaGFuZ2VzZXRJdGVyLCBpQ29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNjaGFuZ2VzZXRfb2xkJyk7XG5cbiAgXG4gIGNvbnN0IHNxbGl0ZTMgPSB7XG4gICAgV2FzbUFsbG9jRXJyb3I6IFdhc21BbGxvY0Vycm9yLFxuICAgIFNRTGl0ZTNFcnJvcjogU1FMaXRlM0Vycm9yLFxuICAgIGNhcGksXG4gICAgdXRpbCxcbiAgICB3YXNtLFxuICAgIGNvbmZpZyxcbiAgICBcbiAgICB2ZXJzaW9uOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgXG4gICAgY2xpZW50OiB1bmRlZmluZWQsXG5cbiAgICBcbiAgICBhc3luY1Bvc3RJbml0OiBhc3luYyBmdW5jdGlvbiBmZigpe1xuICAgICAgaWYoZmYuaXNSZWFkeSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBmZi5pc1JlYWR5O1xuICAgICAgbGV0IGxpYSA9IHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzQXN5bmM7XG4gICAgICBkZWxldGUgc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYztcbiAgICAgIGNvbnN0IHBvc3RJbml0ID0gYXN5bmMgKCk9PntcbiAgICAgICAgaWYoIXNxbGl0ZTMuX19pc1VuZGVyVGVzdCl7XG4gICAgICAgICAgXG4gICAgICAgICAgZGVsZXRlIHNxbGl0ZTMudXRpbDtcbiAgICAgICAgICBcbiAgICAgICAgICBkZWxldGUgc3FsaXRlMy5TdHJ1Y3RCaW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNxbGl0ZTM7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2F0Y2hlciA9IChlKT0+e1xuICAgICAgICBjb25maWcuZXJyb3IoXCJhbiBhc3luYyBzcWxpdGUzIGluaXRpYWxpemVyIGZhaWxlZDpcIixlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH07XG4gICAgICBpZighbGlhIHx8ICFsaWEubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIGZmLmlzUmVhZHkgPSBwb3N0SW5pdCgpLmNhdGNoKGNhdGNoZXIpO1xuICAgICAgfVxuICAgICAgbGlhID0gbGlhLm1hcCgoZik9PntcbiAgICAgICAgcmV0dXJuIChmIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gYXN5bmMgeD0+ZihzcWxpdGUzKSA6IGY7XG4gICAgICB9KTtcbiAgICAgIGxpYS5wdXNoKHBvc3RJbml0KTtcbiAgICAgIGxldCBwID0gUHJvbWlzZS5yZXNvbHZlKHNxbGl0ZTMpO1xuICAgICAgd2hpbGUobGlhLmxlbmd0aCkgcCA9IHAudGhlbihsaWEuc2hpZnQoKSk7XG4gICAgICByZXR1cm4gZmYuaXNSZWFkeSA9IHAuY2F0Y2goY2F0Y2hlcik7XG4gICAgfSxcbiAgICBcbiAgICBzY3JpcHRJbmZvOiB1bmRlZmluZWRcbiAgfTtcbiAgdHJ5e1xuICAgIHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLmZvckVhY2goKGYpPT57XG4gICAgICBmKHNxbGl0ZTMpO1xuICAgIH0pO1xuICB9Y2F0Y2goZSl7XG4gICAgXG4gICAgY29uc29sZS5lcnJvcihcInNxbGl0ZTMgYm9vdHN0cmFwIGluaXRpYWxpemVyIHRocmV3OlwiLGUpO1xuICAgIHRocm93IGU7XG4gIH1cbiAgZGVsZXRlIHNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzO1xuICBzcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTMgPSBzcWxpdGUzO1xuICByZXR1cm4gc3FsaXRlMztcbn07XG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMgPSBbXTtcblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVyc0FzeW5jID0gW107XG5cbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5kZWZhdWx0Q29uZmlnID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLnNxbGl0ZTMgPSB1bmRlZmluZWQ7XG5cblxuXG5cbmdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlciA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYodW5kZWZpbmVkPT09dGFyZ2V0LmJpZ0ludEVuYWJsZWQpe1xuICAgIHRhcmdldC5iaWdJbnRFbmFibGVkID0gISFnbG9iYWxUaGlzWydCaWdJbnQ2NEFycmF5J107XG4gIH1cblxuICBcbiAgY29uc3QgdG9zcyA9ICguLi5hcmdzKT0+e3Rocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSl9O1xuXG4gIGlmKCF0YXJnZXQuZXhwb3J0cyl7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJ2V4cG9ydHMnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6ICgpPT4odGFyZ2V0Lmluc3RhbmNlICYmIHRhcmdldC5pbnN0YW5jZS5leHBvcnRzKVxuICAgIH0pO1xuICB9XG5cbiAgXG4gIFxuXG4gIFxuICBjb25zdCBwdHJJUiA9IHRhcmdldC5wb2ludGVySVIgfHwgJ2kzMic7XG4gIGNvbnN0IHB0clNpemVvZiA9IHRhcmdldC5wdHJTaXplb2YgPVxuICAgICAgICAoJ2kzMic9PT1wdHJJUiA/IDRcbiAgICAgICAgIDogKCdpNjQnPT09cHRySVJcbiAgICAgICAgICAgID8gOCA6IHRvc3MoXCJVbmhhbmRsZWQgcHRyU2l6ZW9mOlwiLHB0cklSKSkpO1xuICBcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBcbiAgY2FjaGUuaGVhcFNpemUgPSAwO1xuICBcbiAgY2FjaGUubWVtb3J5ID0gbnVsbDtcbiAgXG4gIGNhY2hlLmZyZWVGdW5jSW5kZXhlcyA9IFtdO1xuICBcbiAgY2FjaGUuc2NvcGVkQWxsb2MgPSBbXTtcblxuICBjYWNoZS51dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjYWNoZS51dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKTtcblxuICBcbiAgdGFyZ2V0LnNpemVvZklSID0gKG4pPT57XG4gICAgc3dpdGNoKG4pe1xuICAgICAgICBjYXNlICdpOCc6IHJldHVybiAxO1xuICAgICAgICBjYXNlICdpMTYnOiByZXR1cm4gMjtcbiAgICAgICAgY2FzZSAnaTMyJzogY2FzZSAnZjMyJzogY2FzZSAnZmxvYXQnOiByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAnaTY0JzogY2FzZSAnZjY0JzogY2FzZSAnZG91YmxlJzogcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgJyonOiByZXR1cm4gcHRyU2l6ZW9mO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAoJycrbikuZW5kc1dpdGgoJyonKSA/IHB0clNpemVvZiA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNvbnN0IGhlYXBXcmFwcGVycyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIWNhY2hlLm1lbW9yeSl7XG4gICAgICBjYWNoZS5tZW1vcnkgPSAodGFyZ2V0Lm1lbW9yeSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSlcbiAgICAgICAgPyB0YXJnZXQubWVtb3J5IDogdGFyZ2V0LmV4cG9ydHMubWVtb3J5O1xuICAgIH1lbHNlIGlmKGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgpe1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBiID0gY2FjaGUubWVtb3J5LmJ1ZmZlcjtcbiAgICBjYWNoZS5IRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYik7IGNhY2hlLkhFQVA4VSA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgIGNhY2hlLkhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGIpOyBjYWNoZS5IRUFQMTZVID0gbmV3IFVpbnQxNkFycmF5KGIpO1xuICAgIGNhY2hlLkhFQVAzMiA9IG5ldyBJbnQzMkFycmF5KGIpOyBjYWNoZS5IRUFQMzJVID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgIGlmKHRhcmdldC5iaWdJbnRFbmFibGVkKXtcbiAgICAgIGNhY2hlLkhFQVA2NCA9IG5ldyBCaWdJbnQ2NEFycmF5KGIpOyBjYWNoZS5IRUFQNjRVID0gbmV3IEJpZ1VpbnQ2NEFycmF5KGIpO1xuICAgIH1cbiAgICBjYWNoZS5IRUFQMzJGID0gbmV3IEZsb2F0MzJBcnJheShiKTsgY2FjaGUuSEVBUDY0RiA9IG5ldyBGbG9hdDY0QXJyYXkoYik7XG4gICAgY2FjaGUuaGVhcFNpemUgPSBiLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuaGVhcDggPSAoKT0+aGVhcFdyYXBwZXJzKCkuSEVBUDg7XG5cbiAgXG4gIHRhcmdldC5oZWFwOHUgPSAoKT0+aGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuXG4gIFxuICB0YXJnZXQuaGVhcDE2ID0gKCk9PmhlYXBXcmFwcGVycygpLkhFQVAxNjtcblxuICBcbiAgdGFyZ2V0LmhlYXAxNnUgPSAoKT0+aGVhcFdyYXBwZXJzKCkuSEVBUDE2VTtcblxuICBcbiAgdGFyZ2V0LmhlYXAzMiA9ICgpPT5oZWFwV3JhcHBlcnMoKS5IRUFQMzI7XG5cbiAgXG4gIHRhcmdldC5oZWFwMzJ1ID0gKCk9PmhlYXBXcmFwcGVycygpLkhFQVAzMlU7XG5cbiAgXG4gIHRhcmdldC5oZWFwRm9yU2l6ZSA9IGZ1bmN0aW9uKG4sdW5zaWduZWQgPSB0cnVlKXtcbiAgICBsZXQgY3RvcjtcbiAgICBjb25zdCBjID0gKGNhY2hlLm1lbW9yeSAmJiBjYWNoZS5oZWFwU2l6ZSA9PT0gY2FjaGUubWVtb3J5LmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgID8gY2FjaGUgOiBoZWFwV3JhcHBlcnMoKTtcbiAgICBzd2l0Y2gobil7XG4gICAgICAgIGNhc2UgSW50OEFycmF5OiByZXR1cm4gYy5IRUFQODsgY2FzZSBVaW50OEFycmF5OiByZXR1cm4gYy5IRUFQOFU7XG4gICAgICAgIGNhc2UgSW50MTZBcnJheTogcmV0dXJuIGMuSEVBUDE2OyBjYXNlIFVpbnQxNkFycmF5OiByZXR1cm4gYy5IRUFQMTZVO1xuICAgICAgICBjYXNlIEludDMyQXJyYXk6IHJldHVybiBjLkhFQVAzMjsgY2FzZSBVaW50MzJBcnJheTogcmV0dXJuIGMuSEVBUDMyVTtcbiAgICAgICAgY2FzZSA4OiAgcmV0dXJuIHVuc2lnbmVkID8gYy5IRUFQOFUgOiBjLkhFQVA4O1xuICAgICAgICBjYXNlIDE2OiByZXR1cm4gdW5zaWduZWQgPyBjLkhFQVAxNlUgOiBjLkhFQVAxNjtcbiAgICAgICAgY2FzZSAzMjogcmV0dXJuIHVuc2lnbmVkID8gYy5IRUFQMzJVIDogYy5IRUFQMzI7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgaWYoYy5IRUFQNjQpIHJldHVybiB1bnNpZ25lZCA/IGMuSEVBUDY0VSA6IGMuSEVBUDY0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmKHRhcmdldC5iaWdJbnRFbmFibGVkKXtcbiAgICAgICAgICAgIGlmKG49PT1nbG9iYWxUaGlzWydCaWdVaW50NjRBcnJheSddKSByZXR1cm4gYy5IRUFQNjRVO1xuICAgICAgICAgICAgZWxzZSBpZihuPT09Z2xvYmFsVGhpc1snQmlnSW50NjRBcnJheSddKSByZXR1cm4gYy5IRUFQNjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgfVxuICAgIHRvc3MoXCJJbnZhbGlkIGhlYXBGb3JTaXplKCkgc2l6ZTogZXhwZWN0aW5nIDgsIDE2LCAzMixcIixcbiAgICAgICAgIFwib3IgKGlmIEJpZ0ludCBpcyBlbmFibGVkKSA2NC5cIik7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5mdW5jdGlvblRhYmxlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGFyZ2V0LmV4cG9ydHMuX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZTtcbiAgICBcbiAgfTtcblxuICBcbiAgdGFyZ2V0LmZ1bmN0aW9uRW50cnkgPSBmdW5jdGlvbihmcHRyKXtcbiAgICBjb25zdCBmdCA9IHRhcmdldC5mdW5jdGlvblRhYmxlKCk7XG4gICAgcmV0dXJuIGZwdHIgPCBmdC5sZW5ndGggPyBmdC5nZXQoZnB0cikgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5qc0Z1bmNUb1dhc20gPSBmdW5jdGlvbiBmKGZ1bmMsIHNpZyl7XG4gICAgXG4gICAgaWYoIWYuXyl7XG4gICAgICBmLl8gPSB7XG4gICAgICAgIFxuICAgICAgICBzaWdUeXBlczogT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICAgICAgICBpOiAnaTMyJywgcDogJ2kzMicsIFA6ICdpMzInLCBzOiAnaTMyJyxcbiAgICAgICAgICBqOiAnaTY0JywgZjogJ2YzMicsIGQ6ICdmNjQnXG4gICAgICAgIH0pLFxuICAgICAgICBcbiAgICAgICAgdHlwZUNvZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgICAgICAgIGY2NDogMHg3YywgZjMyOiAweDdkLCBpNjQ6IDB4N2UsIGkzMjogMHg3ZlxuICAgICAgICB9KSxcbiAgICAgICAgXG4gICAgICAgIHVsZWIxMjhFbmNvZGU6IGZ1bmN0aW9uKHRndCwgbWV0aG9kLCBuKXtcbiAgICAgICAgICBpZihuPDEyOCkgdGd0W21ldGhvZF0obik7XG4gICAgICAgICAgZWxzZSB0Z3RbbWV0aG9kXSggKG4gJSAxMjgpIHwgMTI4LCBuPj43KTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHJ4SlNpZzogL14oXFx3KVxcKChcXHcqKVxcKSQvLFxuICAgICAgICBcbiAgICAgICAgc2lnUGFyYW1zOiBmdW5jdGlvbihzaWcpe1xuICAgICAgICAgIGNvbnN0IG0gPSBmLl8ucnhKU2lnLmV4ZWMoc2lnKTtcbiAgICAgICAgICByZXR1cm4gbSA/IG1bMl0gOiBzaWcuc3Vic3RyKDEpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgbGV0dGVyVHlwZTogKHgpPT5mLl8uc2lnVHlwZXNbeF0gfHwgdG9zcyhcIkludmFsaWQgc2lnbmF0dXJlIGxldHRlcjpcIix4KSxcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcHVzaFNpZ1R5cGU6IChkZXN0LCBsZXR0ZXIpPT5kZXN0LnB1c2goZi5fLnR5cGVDb2Rlc1tmLl8ubGV0dGVyVHlwZShsZXR0ZXIpXSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIGZ1bmMpe1xuICAgICAgY29uc3QgeCA9IHNpZztcbiAgICAgIHNpZyA9IGZ1bmM7XG4gICAgICBmdW5jID0geDtcbiAgICB9XG4gICAgY29uc3Qgc2lnUGFyYW1zID0gZi5fLnNpZ1BhcmFtcyhzaWcpO1xuICAgIGNvbnN0IHdhc21Db2RlID0gWzB4MDEsIDB4NjBdO1xuICAgIGYuXy51bGViMTI4RW5jb2RlKHdhc21Db2RlLCAncHVzaCcsIHNpZ1BhcmFtcy5sZW5ndGgpO1xuICAgIGZvcihjb25zdCB4IG9mIHNpZ1BhcmFtcykgZi5fLnB1c2hTaWdUeXBlKHdhc21Db2RlLCB4KTtcbiAgICBpZigndic9PT1zaWdbMF0pIHdhc21Db2RlLnB1c2goMCk7XG4gICAgZWxzZXtcbiAgICAgIHdhc21Db2RlLnB1c2goMSk7XG4gICAgICBmLl8ucHVzaFNpZ1R5cGUod2FzbUNvZGUsIHNpZ1swXSk7XG4gICAgfVxuICAgIGYuXy51bGViMTI4RW5jb2RlKHdhc21Db2RlLCAndW5zaGlmdCcsIHdhc21Db2RlLmxlbmd0aCk7XG4gICAgd2FzbUNvZGUudW5zaGlmdChcbiAgICAgIDB4MDAsIDB4NjEsIDB4NzMsIDB4NmQsIFxuICAgICAgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgXG4gICAgICAweDAxIFxuICAgICk7XG4gICAgd2FzbUNvZGUucHVzaChcbiAgICAgICAweDAyLCAweDA3LFxuICAgICAgXG4gICAgICAweDAxLCAweDAxLCAweDY1LCAweDAxLCAweDY2LCAweDAwLCAweDAwLFxuICAgICAgIDB4MDcsIDB4MDUsXG4gICAgICBcbiAgICAgIDB4MDEsIDB4MDEsIDB4NjYsIDB4MDAsIDB4MDBcbiAgICApO1xuICAgIHJldHVybiAobmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheSh3YXNtQ29kZSkpLCB7XG4gICAgICAgIGU6IHsgZjogZnVuYyB9XG4gICAgICB9KSkuZXhwb3J0c1snZiddO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2luc3RhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uIGYoZnVuYywgc2lnLCBzY29wZWQpe1xuICAgIGlmKHNjb3BlZCAmJiAhY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoKXtcbiAgICAgIHRvc3MoXCJObyBzY29wZWRBbGxvY1B1c2goKSBzY29wZSBpcyBhY3RpdmUuXCIpO1xuICAgIH1cbiAgICBpZignc3RyaW5nJz09PXR5cGVvZiBmdW5jKXtcbiAgICAgIGNvbnN0IHggPSBzaWc7XG4gICAgICBzaWcgPSBmdW5jO1xuICAgICAgZnVuYyA9IHg7XG4gICAgfVxuICAgIGlmKCdzdHJpbmcnIT09dHlwZW9mIHNpZyB8fCAhKGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgICAgdG9zcyhcIkludmFsaWQgYXJndW1lbnRzOiBleHBlY3RpbmcgKGZ1bmN0aW9uLHNpZ25hdHVyZSkgXCIrXG4gICAgICAgICAgIFwib3IgKHNpZ25hdHVyZSxmdW5jdGlvbikuXCIpO1xuICAgIH1cbiAgICBjb25zdCBmdCA9IHRhcmdldC5mdW5jdGlvblRhYmxlKCk7XG4gICAgY29uc3Qgb2xkTGVuID0gZnQubGVuZ3RoO1xuICAgIGxldCBwdHI7XG4gICAgd2hpbGUoY2FjaGUuZnJlZUZ1bmNJbmRleGVzLmxlbmd0aCl7XG4gICAgICBwdHIgPSBjYWNoZS5mcmVlRnVuY0luZGV4ZXMucG9wKCk7XG4gICAgICBpZihmdC5nZXQocHRyKSl7IFxuICAgICAgICBwdHIgPSBudWxsO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1lbHNle1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoIXB0cil7XG4gICAgICBwdHIgPSBvbGRMZW47XG4gICAgICBmdC5ncm93KDEpO1xuICAgIH1cbiAgICB0cnl7XG4gICAgICBcbiAgICAgIGZ0LnNldChwdHIsIGZ1bmMpO1xuICAgICAgaWYoc2NvcGVkKXtcbiAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoLTFdLnB1c2gocHRyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdHI7XG4gICAgfWNhdGNoKGUpe1xuICAgICAgaWYoIShlIGluc3RhbmNlb2YgVHlwZUVycm9yKSl7XG4gICAgICAgIGlmKHB0cj09PW9sZExlbikgY2FjaGUuZnJlZUZ1bmNJbmRleGVzLnB1c2gob2xkTGVuKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZwdHIgPSB0YXJnZXQuanNGdW5jVG9XYXNtKGZ1bmMsIHNpZyk7XG4gICAgICBmdC5zZXQocHRyLCBmcHRyKTtcbiAgICAgIGlmKHNjb3BlZCl7XG4gICAgICAgIGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aC0xXS5wdXNoKHB0cik7XG4gICAgICB9XG4gICAgfWNhdGNoKGUpe1xuICAgICAgaWYocHRyPT09b2xkTGVuKSBjYWNoZS5mcmVlRnVuY0luZGV4ZXMucHVzaChvbGRMZW4pO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHB0cjtcbiAgfTtcblxuICBcbiAgdGFyZ2V0Lmluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpPT5fX2luc3RhbGxGdW5jdGlvbihmdW5jLCBzaWcsIGZhbHNlKTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEluc3RhbGxGdW5jdGlvbiA9IChmdW5jLCBzaWcpPT5fX2luc3RhbGxGdW5jdGlvbihmdW5jLCBzaWcsIHRydWUpO1xuXG4gIFxuICB0YXJnZXQudW5pbnN0YWxsRnVuY3Rpb24gPSBmdW5jdGlvbihwdHIpe1xuICAgIGlmKCFwdHIgJiYgMCE9PXB0cikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBmaSA9IGNhY2hlLmZyZWVGdW5jSW5kZXhlcztcbiAgICBjb25zdCBmdCA9IHRhcmdldC5mdW5jdGlvblRhYmxlKCk7XG4gICAgZmkucHVzaChwdHIpO1xuICAgIGNvbnN0IHJjID0gZnQuZ2V0KHB0cik7XG4gICAgZnQuc2V0KHB0ciwgbnVsbCk7XG4gICAgcmV0dXJuIHJjO1xuICB9O1xuXG4gIFxuICB0YXJnZXQucGVlayA9IGZ1bmN0aW9uIGYocHRyLCB0eXBlPSdpOCcpe1xuICAgIGlmKHR5cGUuZW5kc1dpdGgoJyonKSkgdHlwZSA9IHB0cklSO1xuICAgIGNvbnN0IGMgPSAoY2FjaGUubWVtb3J5ICYmIGNhY2hlLmhlYXBTaXplID09PSBjYWNoZS5tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgPyBjYWNoZSA6IGhlYXBXcmFwcGVycygpO1xuICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KHB0cikgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcmM7XG4gICAgZG97XG4gICAgICBpZihsaXN0KSBwdHIgPSBhcmd1bWVudHNbMF0uc2hpZnQoKTtcbiAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICBjYXNlICdpMSc6XG4gICAgICAgICAgY2FzZSAnaTgnOiByYyA9IGMuSEVBUDhbcHRyPj4wXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaTE2JzogcmMgPSBjLkhFQVAxNltwdHI+PjFdOyBicmVhaztcbiAgICAgICAgICBjYXNlICdpMzInOiByYyA9IGMuSEVBUDMyW3B0cj4+Ml07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Zsb2F0JzogY2FzZSAnZjMyJzogcmMgPSBjLkhFQVAzMkZbcHRyPj4yXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZG91YmxlJzogY2FzZSAnZjY0JzogcmMgPSBOdW1iZXIoYy5IRUFQNjRGW3B0cj4+M10pOyBicmVhaztcbiAgICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgICAgaWYodGFyZ2V0LmJpZ0ludEVuYWJsZWQpe1xuICAgICAgICAgICAgICByYyA9IEJpZ0ludChjLkhFQVA2NFtwdHI+PjNdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdG9zcygnSW52YWxpZCB0eXBlIGZvciBwZWVrKCk6Jyx0eXBlKTtcbiAgICAgIH1cbiAgICAgIGlmKGxpc3QpIGxpc3QucHVzaChyYyk7XG4gICAgfXdoaWxlKGxpc3QgJiYgYXJndW1lbnRzWzBdLmxlbmd0aCk7XG4gICAgcmV0dXJuIGxpc3QgfHwgcmM7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5wb2tlID0gZnVuY3Rpb24ocHRyLCB2YWx1ZSwgdHlwZT0naTgnKXtcbiAgICBpZiAodHlwZS5lbmRzV2l0aCgnKicpKSB0eXBlID0gcHRySVI7XG4gICAgY29uc3QgYyA9IChjYWNoZS5tZW1vcnkgJiYgY2FjaGUuaGVhcFNpemUgPT09IGNhY2hlLm1lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICA/IGNhY2hlIDogaGVhcFdyYXBwZXJzKCk7XG4gICAgZm9yKGNvbnN0IHAgb2YgKEFycmF5LmlzQXJyYXkocHRyKSA/IHB0ciA6IFtwdHJdKSl7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdpMSc6XG4gICAgICAgICAgY2FzZSAnaTgnOiBjLkhFQVA4W3A+PjBdID0gdmFsdWU7IGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ2kxNic6IGMuSEVBUDE2W3A+PjFdID0gdmFsdWU7IGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ2kzMic6IGMuSEVBUDMyW3A+PjJdID0gdmFsdWU7IGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ2Zsb2F0JzogY2FzZSAnZjMyJzogYy5IRUFQMzJGW3A+PjJdID0gdmFsdWU7IGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6IGNhc2UgJ2Y2NCc6IGMuSEVBUDY0RltwPj4zXSA9IHZhbHVlOyBjb250aW51ZTtcbiAgICAgICAgICBjYXNlICdpNjQnOlxuICAgICAgICAgICAgaWYoYy5IRUFQNjQpe1xuICAgICAgICAgICAgICBjLkhFQVA2NFtwPj4zXSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRvc3MoJ0ludmFsaWQgdHlwZSBmb3IgcG9rZSgpOiAnICsgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFxuICB0YXJnZXQucGVla1B0ciA9ICguLi5wdHIpPT50YXJnZXQucGVlayggKDE9PT1wdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyKSwgcHRySVIgKTtcblxuICBcbiAgdGFyZ2V0LnBva2VQdHIgPSAocHRyLCB2YWx1ZT0wKT0+dGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgcHRySVIpO1xuXG4gIFxuICB0YXJnZXQucGVlazggPSAoLi4ucHRyKT0+dGFyZ2V0LnBlZWsoICgxPT09cHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciksICdpOCcgKTtcbiAgXG4gIHRhcmdldC5wb2tlOCA9IChwdHIsIHZhbHVlKT0+dGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2k4Jyk7XG4gIFxuICB0YXJnZXQucGVlazE2ID0gKC4uLnB0cik9PnRhcmdldC5wZWVrKCAoMT09PXB0ci5sZW5ndGggPyBwdHJbMF0gOiBwdHIpLCAnaTE2JyApO1xuICBcbiAgdGFyZ2V0LnBva2UxNiA9IChwdHIsIHZhbHVlKT0+dGFyZ2V0LnBva2UocHRyLCB2YWx1ZSwgJ2kxNicpO1xuICBcbiAgdGFyZ2V0LnBlZWszMiA9ICguLi5wdHIpPT50YXJnZXQucGVlayggKDE9PT1wdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyKSwgJ2kzMicgKTtcbiAgXG4gIHRhcmdldC5wb2tlMzIgPSAocHRyLCB2YWx1ZSk9PnRhcmdldC5wb2tlKHB0ciwgdmFsdWUsICdpMzInKTtcbiAgXG4gIHRhcmdldC5wZWVrNjQgPSAoLi4ucHRyKT0+dGFyZ2V0LnBlZWsoICgxPT09cHRyLmxlbmd0aCA/IHB0clswXSA6IHB0ciksICdpNjQnICk7XG4gIFxuICB0YXJnZXQucG9rZTY0ID0gKHB0ciwgdmFsdWUpPT50YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnaTY0Jyk7XG4gIFxuICB0YXJnZXQucGVlazMyZiA9ICguLi5wdHIpPT50YXJnZXQucGVlayggKDE9PT1wdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyKSwgJ2YzMicgKTtcbiAgXG4gIHRhcmdldC5wb2tlMzJmID0gKHB0ciwgdmFsdWUpPT50YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnZjMyJyk7XG4gIFxuICB0YXJnZXQucGVlazY0ZiA9ICguLi5wdHIpPT50YXJnZXQucGVlayggKDE9PT1wdHIubGVuZ3RoID8gcHRyWzBdIDogcHRyKSwgJ2Y2NCcgKTtcbiAgXG4gIHRhcmdldC5wb2tlNjRmID0gKHB0ciwgdmFsdWUpPT50YXJnZXQucG9rZShwdHIsIHZhbHVlLCAnZjY0Jyk7XG5cbiAgXG4gIHRhcmdldC5nZXRNZW1WYWx1ZSA9IHRhcmdldC5wZWVrO1xuICBcbiAgdGFyZ2V0LmdldFB0clZhbHVlID0gdGFyZ2V0LnBlZWtQdHI7XG4gIFxuICB0YXJnZXQuc2V0TWVtVmFsdWUgPSB0YXJnZXQucG9rZTtcbiAgXG4gIHRhcmdldC5zZXRQdHJWYWx1ZSA9IHRhcmdldC5wb2tlUHRyO1xuXG4gIFxuICB0YXJnZXQuaXNQdHIzMiA9IChwdHIpPT4oJ251bWJlcic9PT10eXBlb2YgcHRyICYmIChwdHI9PT0ocHRyfDApKSAmJiBwdHI+PTApO1xuXG4gIFxuICB0YXJnZXQuaXNQdHIgPSB0YXJnZXQuaXNQdHIzMjtcblxuICBcbiAgdGFyZ2V0LmNzdHJsZW4gPSBmdW5jdGlvbihwdHIpe1xuICAgIGlmKCFwdHIgfHwgIXRhcmdldC5pc1B0cihwdHIpKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBoID0gaGVhcFdyYXBwZXJzKCkuSEVBUDhVO1xuICAgIGxldCBwb3MgPSBwdHI7XG4gICAgZm9yKCA7IGhbcG9zXSAhPT0gMDsgKytwb3MgKXt9XG4gICAgcmV0dXJuIHBvcyAtIHB0cjtcbiAgfTtcblxuICBcbiAgY29uc3QgX19TQUIgPSAoJ3VuZGVmaW5lZCc9PT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZnVuY3Rpb24oKXt9IDogU2hhcmVkQXJyYXlCdWZmZXI7XG4gIGNvbnN0IF9fdXRmOERlY29kZSA9IGZ1bmN0aW9uKGFycmF5QnVmZmVyLCBiZWdpbiwgZW5kKXtcbiAgICByZXR1cm4gY2FjaGUudXRmOERlY29kZXIuZGVjb2RlKFxuICAgICAgKGFycmF5QnVmZmVyLmJ1ZmZlciBpbnN0YW5jZW9mIF9fU0FCKVxuICAgICAgICA/IGFycmF5QnVmZmVyLnNsaWNlKGJlZ2luLCBlbmQpXG4gICAgICAgIDogYXJyYXlCdWZmZXIuc3ViYXJyYXkoYmVnaW4sIGVuZClcbiAgICApO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuY3N0clRvSnMgPSBmdW5jdGlvbihwdHIpe1xuICAgIGNvbnN0IG4gPSB0YXJnZXQuY3N0cmxlbihwdHIpO1xuICAgIHJldHVybiBuID8gX191dGY4RGVjb2RlKGhlYXBXcmFwcGVycygpLkhFQVA4VSwgcHRyLCBwdHIrbikgOiAobnVsbD09PW4gPyBuIDogXCJcIik7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5qc3RybGVuID0gZnVuY3Rpb24oc3RyKXtcbiAgICBcbiAgICBpZignc3RyaW5nJyE9PXR5cGVvZiBzdHIpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBuOyArK2kpe1xuICAgICAgbGV0IHUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmKHU+PTB4ZDgwMCAmJiB1PD0weGRmZmYpe1xuICAgICAgICB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M0ZGKTtcbiAgICAgIH1cbiAgICAgIGlmKHU8PTB4N2YpICsrbGVuO1xuICAgICAgZWxzZSBpZih1PD0weDdmZikgbGVuICs9IDI7XG4gICAgICBlbHNlIGlmKHU8PTB4ZmZmZikgbGVuICs9IDM7XG4gICAgICBlbHNlIGxlbiArPSA0O1xuICAgIH1cbiAgICByZXR1cm4gbGVuO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuanN0cmNweSA9IGZ1bmN0aW9uKGpzdHIsIHRndCwgb2Zmc2V0ID0gMCwgbWF4Qnl0ZXMgPSAtMSwgYWRkTnVsID0gdHJ1ZSl7XG4gICAgXG4gICAgaWYoIXRndCB8fCAoISh0Z3QgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpICYmICEodGd0IGluc3RhbmNlb2YgVWludDhBcnJheSkpKXtcbiAgICAgIHRvc3MoXCJqc3RyY3B5KCkgdGFyZ2V0IG11c3QgYmUgYW4gSW50OEFycmF5IG9yIFVpbnQ4QXJyYXkuXCIpO1xuICAgIH1cbiAgICBpZihtYXhCeXRlczwwKSBtYXhCeXRlcyA9IHRndC5sZW5ndGggLSBvZmZzZXQ7XG4gICAgaWYoIShtYXhCeXRlcz4wKSB8fCAhKG9mZnNldD49MCkpIHJldHVybiAwO1xuICAgIGxldCBpID0gMCwgbWF4ID0ganN0ci5sZW5ndGg7XG4gICAgY29uc3QgYmVnaW4gPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIG1heEJ5dGVzIC0gKGFkZE51bCA/IDEgOiAwKTtcbiAgICBmb3IoOyBpIDwgbWF4ICYmIG9mZnNldCA8IGVuZDsgKytpKXtcbiAgICAgIGxldCB1ID0ganN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYodT49MHhkODAwICYmIHU8PTB4ZGZmZil7XG4gICAgICAgIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8IChqc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M0ZGKTtcbiAgICAgIH1cbiAgICAgIGlmKHU8PTB4N2Ype1xuICAgICAgICBpZihvZmZzZXQgPj0gZW5kKSBicmVhaztcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IHU7XG4gICAgICB9ZWxzZSBpZih1PD0weDdmZil7XG4gICAgICAgIGlmKG9mZnNldCArIDEgPj0gZW5kKSBicmVhaztcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4QzAgfCAodSA+PiA2KTtcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAodSAmIDB4M2YpO1xuICAgICAgfWVsc2UgaWYodTw9MHhmZmZmKXtcbiAgICAgICAgaWYob2Zmc2V0ICsgMiA+PSBlbmQpIGJyZWFrO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHhlMCB8ICh1ID4+IDEyKTtcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiAweDNmKTtcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ODAgfCAodSAmIDB4M2YpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKG9mZnNldCArIDMgPj0gZW5kKSBicmVhaztcbiAgICAgICAgdGd0W29mZnNldCsrXSA9IDB4ZjAgfCAodSA+PiAxOCk7XG4gICAgICAgIHRndFtvZmZzZXQrK10gPSAweDgwIHwgKCh1ID4+IDEyKSAmIDB4M2YpO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICgodSA+PiA2KSAmIDB4M2YpO1xuICAgICAgICB0Z3Rbb2Zmc2V0KytdID0gMHg4MCB8ICh1ICYgMHgzZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGFkZE51bCkgdGd0W29mZnNldCsrXSA9IDA7XG4gICAgcmV0dXJuIG9mZnNldCAtIGJlZ2luO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuY3N0cm5jcHkgPSBmdW5jdGlvbih0Z3RQdHIsIHNyY1B0ciwgbil7XG4gICAgaWYoIXRndFB0ciB8fCAhc3JjUHRyKSB0b3NzKFwiY3N0cm5jcHkoKSBkb2VzIG5vdCBhY2NlcHQgTlVMTCBzdHJpbmdzLlwiKTtcbiAgICBpZihuPDApIG4gPSB0YXJnZXQuY3N0cmxlbihzdHJQdHIpKzE7XG4gICAgZWxzZSBpZighKG4+MCkpIHJldHVybiAwO1xuICAgIGNvbnN0IGhlYXAgPSB0YXJnZXQuaGVhcDh1KCk7XG4gICAgbGV0IGkgPSAwLCBjaDtcbiAgICBmb3IoOyBpIDwgbiAmJiAoY2ggPSBoZWFwW3NyY1B0citpXSk7ICsraSl7XG4gICAgICBoZWFwW3RndFB0citpXSA9IGNoO1xuICAgIH1cbiAgICBpZihpPG4pIGhlYXBbdGd0UHRyICsgaSsrXSA9IDA7XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5qc3RyVG9VaW50QXJyYXkgPSAoc3RyLCBhZGROdWw9ZmFsc2UpPT57XG4gICAgcmV0dXJuIGNhY2hlLnV0ZjhFbmNvZGVyLmVuY29kZShhZGROdWwgPyAoc3RyK1wiXFwwXCIpIDogc3RyKTtcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgfTtcblxuICBjb25zdCBfX2FmZmlybUFsbG9jID0gKG9iaixmdW5jTmFtZSk9PntcbiAgICBpZighKG9iai5hbGxvYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fFxuICAgICAgICEob2JqLmRlYWxsb2MgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgICAgdG9zcyhcIk9iamVjdCBpcyBtaXNzaW5nIGFsbG9jKCkgYW5kL29yIGRlYWxsb2MoKSBmdW5jdGlvbihzKVwiLFxuICAgICAgICAgICBcInJlcXVpcmVkIGJ5XCIsZnVuY05hbWUrXCIoKS5cIik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IF9fYWxsb2NDU3RyID0gZnVuY3Rpb24oanN0ciwgcmV0dXJuV2l0aExlbmd0aCwgYWxsb2NhdG9yLCBmdW5jTmFtZSl7XG4gICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsIGZ1bmNOYW1lKTtcbiAgICBpZignc3RyaW5nJyE9PXR5cGVvZiBqc3RyKSByZXR1cm4gbnVsbDtcbiAgICBpZigwKXtcbiAgICAgIGNvbnN0IG4gPSB0YXJnZXQuanN0cmxlbihqc3RyKSxcbiAgICAgICAgICAgIHB0ciA9IGFsbG9jYXRvcihuKzEpO1xuICAgICAgdGFyZ2V0LmpzdHJjcHkoanN0ciwgdGFyZ2V0LmhlYXA4dSgpLCBwdHIsIG4rMSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmV0dXJuV2l0aExlbmd0aCA/IFtwdHIsIG5dIDogcHRyO1xuICAgIH1lbHNle1xuICAgICAgY29uc3QgdSA9IGNhY2hlLnV0ZjhFbmNvZGVyLmVuY29kZShqc3RyKSxcbiAgICAgICAgICAgIHB0ciA9IGFsbG9jYXRvcih1Lmxlbmd0aCsxKSxcbiAgICAgICAgICAgIGhlYXAgPSBoZWFwV3JhcHBlcnMoKS5IRUFQOFU7XG4gICAgICBoZWFwLnNldCh1LCBwdHIpO1xuICAgICAgaGVhcFtwdHIgKyB1Lmxlbmd0aF0gPSAwO1xuICAgICAgcmV0dXJuIHJldHVybldpdGhMZW5ndGggPyBbcHRyLCB1Lmxlbmd0aF0gOiBwdHI7XG4gICAgfVxuICB9O1xuXG4gIFxuICB0YXJnZXQuYWxsb2NDU3RyaW5nID1cbiAgICAoanN0ciwgcmV0dXJuV2l0aExlbmd0aD1mYWxzZSk9Pl9fYWxsb2NDU3RyKGpzdHIsIHJldHVybldpdGhMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuYWxsb2MsICdhbGxvY0NTdHJpbmcoKScpO1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoID0gZnVuY3Rpb24oKXtcbiAgICBfX2FmZmlybUFsbG9jKHRhcmdldCwgJ3Njb3BlZEFsbG9jUHVzaCcpO1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBjYWNoZS5zY29wZWRBbGxvYy5wdXNoKGEpO1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkQWxsb2NQb3AgPSBmdW5jdGlvbihzdGF0ZSl7XG4gICAgX19hZmZpcm1BbGxvYyh0YXJnZXQsICdzY29wZWRBbGxvY1BvcCcpO1xuICAgIGNvbnN0IG4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgPyBjYWNoZS5zY29wZWRBbGxvYy5pbmRleE9mKHN0YXRlKVxuICAgICAgICAgIDogY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoLTE7XG4gICAgaWYobjwwKSB0b3NzKFwiSW52YWxpZCBzdGF0ZSBvYmplY3QgZm9yIHNjb3BlZEFsbG9jUG9wKCkuXCIpO1xuICAgIGlmKDA9PT1hcmd1bWVudHMubGVuZ3RoKSBzdGF0ZSA9IGNhY2hlLnNjb3BlZEFsbG9jW25dO1xuICAgIGNhY2hlLnNjb3BlZEFsbG9jLnNwbGljZShuLDEpO1xuICAgIGZvcihsZXQgcDsgKHAgPSBzdGF0ZS5wb3AoKSk7ICl7XG4gICAgICBpZih0YXJnZXQuZnVuY3Rpb25FbnRyeShwKSl7XG4gICAgICAgIFxuICAgICAgICB0YXJnZXQudW5pbnN0YWxsRnVuY3Rpb24ocCk7XG4gICAgICB9XG4gICAgICBlbHNlIHRhcmdldC5kZWFsbG9jKHApO1xuICAgIH1cbiAgfTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEFsbG9jID0gZnVuY3Rpb24obil7XG4gICAgaWYoIWNhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aCl7XG4gICAgICB0b3NzKFwiTm8gc2NvcGVkQWxsb2NQdXNoKCkgc2NvcGUgaXMgYWN0aXZlLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcCA9IHRhcmdldC5hbGxvYyhuKTtcbiAgICBjYWNoZS5zY29wZWRBbGxvY1tjYWNoZS5zY29wZWRBbGxvYy5sZW5ndGgtMV0ucHVzaChwKTtcbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LnNjb3BlZEFsbG9jLCAnbGV2ZWwnLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiAoKT0+Y2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoLFxuICAgIHNldDogKCk9PnRvc3MoXCJUaGUgJ2FjdGl2ZScgcHJvcGVydHkgaXMgcmVhZC1vbmx5LlwiKVxuICB9KTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEFsbG9jQ1N0cmluZyA9XG4gICAgKGpzdHIsIHJldHVybldpdGhMZW5ndGg9ZmFsc2UpPT5fX2FsbG9jQ1N0cihqc3RyLCByZXR1cm5XaXRoTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jLCAnc2NvcGVkQWxsb2NDU3RyaW5nKCknKTtcblxuICBcbiAgY29uc3QgX19hbGxvY01haW5Bcmd2ID0gZnVuY3Rpb24oaXNTY29wZWQsIGxpc3Qpe1xuICAgIGNvbnN0IHBMaXN0ID0gdGFyZ2V0W1xuICAgICAgaXNTY29wZWQgPyAnc2NvcGVkQWxsb2MnIDogJ2FsbG9jJ1xuICAgIF0oKGxpc3QubGVuZ3RoICsgMSkgKiB0YXJnZXQucHRyU2l6ZW9mKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGlzdC5mb3JFYWNoKChlKT0+e1xuICAgICAgdGFyZ2V0LnBva2VQdHIocExpc3QgKyAodGFyZ2V0LnB0clNpemVvZiAqIGkrKyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTY29wZWQgPyAnc2NvcGVkQWxsb2NDU3RyaW5nJyA6ICdhbGxvY0NTdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgXShcIlwiK2UpKTtcbiAgICB9KTtcbiAgICB0YXJnZXQucG9rZVB0cihwTGlzdCArICh0YXJnZXQucHRyU2l6ZW9mICogaSksIDApO1xuICAgIHJldHVybiBwTGlzdDtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnNjb3BlZEFsbG9jTWFpbkFyZ3YgPSAobGlzdCk9Pl9fYWxsb2NNYWluQXJndih0cnVlLCBsaXN0KTtcblxuICBcbiAgdGFyZ2V0LmFsbG9jTWFpbkFyZ3YgPSAobGlzdCk9Pl9fYWxsb2NNYWluQXJndihmYWxzZSwgbGlzdCk7XG5cbiAgXG4gIHRhcmdldC5jQXJndlRvSnMgPSAoYXJnYywgcEFyZ3YpPT57XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhcmdjOyArK2kpe1xuICAgICAgY29uc3QgYXJnID0gdGFyZ2V0LnBlZWtQdHIocEFyZ3YgKyAodGFyZ2V0LnB0clNpemVvZiAqIGkpKTtcbiAgICAgIGxpc3QucHVzaCggYXJnID8gdGFyZ2V0LmNzdHJUb0pzKGFyZykgOiBudWxsICk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9O1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkQWxsb2NDYWxsID0gZnVuY3Rpb24oZnVuYyl7XG4gICAgdGFyZ2V0LnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgIHRyeXsgcmV0dXJuIGZ1bmMoKSB9IGZpbmFsbHl7IHRhcmdldC5zY29wZWRBbGxvY1BvcCgpIH1cbiAgfTtcblxuICBcbiAgY29uc3QgX19hbGxvY1B0ciA9IGZ1bmN0aW9uKGhvd01hbnksIHNhZmVQdHJTaXplLCBtZXRob2Qpe1xuICAgIF9fYWZmaXJtQWxsb2ModGFyZ2V0LCBtZXRob2QpO1xuICAgIGNvbnN0IHBJciA9IHNhZmVQdHJTaXplID8gJ2k2NCcgOiBwdHJJUjtcbiAgICBsZXQgbSA9IHRhcmdldFttZXRob2RdKGhvd01hbnkgKiAoc2FmZVB0clNpemUgPyA4IDogcHRyU2l6ZW9mKSk7XG4gICAgdGFyZ2V0LnBva2UobSwgMCwgcElyKVxuICAgIGlmKDE9PT1ob3dNYW55KXtcbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBjb25zdCBhID0gW21dO1xuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBob3dNYW55OyArK2kpe1xuICAgICAgbSArPSAoc2FmZVB0clNpemUgPyA4IDogcHRyU2l6ZW9mKTtcbiAgICAgIGFbaV0gPSBtO1xuICAgICAgdGFyZ2V0LnBva2UobSwgMCwgcElyKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgXG4gIHRhcmdldC5hbGxvY1B0ciA9XG4gICAgKGhvd01hbnk9MSwgc2FmZVB0clNpemU9dHJ1ZSk9Pl9fYWxsb2NQdHIoaG93TWFueSwgc2FmZVB0clNpemUsICdhbGxvYycpO1xuXG4gIFxuICB0YXJnZXQuc2NvcGVkQWxsb2NQdHIgPVxuICAgIChob3dNYW55PTEsIHNhZmVQdHJTaXplPXRydWUpPT5fX2FsbG9jUHRyKGhvd01hbnksIHNhZmVQdHJTaXplLCAnc2NvcGVkQWxsb2MnKTtcblxuICBcbiAgdGFyZ2V0LnhHZXQgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGFyZ2V0LmV4cG9ydHNbbmFtZV0gfHwgdG9zcyhcIkNhbm5vdCBmaW5kIGV4cG9ydGVkIHN5bWJvbDpcIixuYW1lKTtcbiAgfTtcblxuICBjb25zdCBfX2FyZ2NNaXNtYXRjaCA9XG4gICAgICAgIChmLG4pPT50b3NzKGYrXCIoKSByZXF1aXJlc1wiLG4sXCJhcmd1bWVudChzKS5cIik7XG5cbiAgXG4gIHRhcmdldC54Q2FsbCA9IGZ1bmN0aW9uKGZuYW1lLCAuLi5hcmdzKXtcbiAgICBjb25zdCBmID0gdGFyZ2V0LnhHZXQoZm5hbWUpO1xuICAgIGlmKCEoZiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgdG9zcyhcIkV4cG9ydGVkIHN5bWJvbFwiLGZuYW1lLFwiaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgIGlmKGYubGVuZ3RoIT09YXJncy5sZW5ndGgpIF9fYXJnY01pc21hdGNoKGZuYW1lLGYubGVuZ3RoKVxuICAgIDtcbiAgICByZXR1cm4gKDI9PT1hcmd1bWVudHMubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSlcbiAgICAgID8gZi5hcHBseShudWxsLCBhcmd1bWVudHNbMV0pXG4gICAgICA6IGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIH07XG5cbiAgXG4gIGNhY2hlLnhXcmFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY2FjaGUueFdyYXAuY29udmVydCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIFxuICBjYWNoZS54V3JhcC5jb252ZXJ0LmFyZyA9IG5ldyBNYXA7XG4gIFxuICBjYWNoZS54V3JhcC5jb252ZXJ0LnJlc3VsdCA9IG5ldyBNYXA7XG4gIGNvbnN0IHhBcmcgPSBjYWNoZS54V3JhcC5jb252ZXJ0LmFyZywgeFJlc3VsdCA9IGNhY2hlLnhXcmFwLmNvbnZlcnQucmVzdWx0O1xuXG4gIGlmKHRhcmdldC5iaWdJbnRFbmFibGVkKXtcbiAgICB4QXJnLnNldCgnaTY0JywgKGkpPT5CaWdJbnQoaSkpO1xuICB9XG4gIGNvbnN0IF9feEFyZ1B0ciA9ICdpMzInID09PSBwdHJJUlxuICAgICAgICA/ICgoaSk9PihpIHwgMCkpIDogKChpKT0+KEJpZ0ludChpKSB8IEJpZ0ludCgwKSkpO1xuICB4QXJnLnNldCgnaTMyJywgX194QXJnUHRyIClcbiAgICAuc2V0KCdpMTYnLCAoaSk9PigoaSB8IDApICYgMHhGRkZGKSlcbiAgICAuc2V0KCdpOCcsIChpKT0+KChpIHwgMCkgJiAweEZGKSlcbiAgICAuc2V0KCdmMzInLCAoaSk9Pk51bWJlcihpKS52YWx1ZU9mKCkpXG4gICAgLnNldCgnZmxvYXQnLCB4QXJnLmdldCgnZjMyJykpXG4gICAgLnNldCgnZjY0JywgeEFyZy5nZXQoJ2YzMicpKVxuICAgIC5zZXQoJ2RvdWJsZScsIHhBcmcuZ2V0KCdmNjQnKSlcbiAgICAuc2V0KCdpbnQnLCB4QXJnLmdldCgnaTMyJykpXG4gICAgLnNldCgnbnVsbCcsIChpKT0+aSlcbiAgICAuc2V0KG51bGwsIHhBcmcuZ2V0KCdudWxsJykpXG4gICAgLnNldCgnKionLCBfX3hBcmdQdHIpXG4gICAgLnNldCgnKicsIF9feEFyZ1B0cik7XG4gIHhSZXN1bHQuc2V0KCcqJywgX194QXJnUHRyKVxuICAgIC5zZXQoJ3BvaW50ZXInLCBfX3hBcmdQdHIpXG4gICAgLnNldCgnbnVtYmVyJywgKHYpPT5OdW1iZXIodikpXG4gICAgLnNldCgndm9pZCcsICh2KT0+dW5kZWZpbmVkKVxuICAgIC5zZXQoJ251bGwnLCAodik9PnYpXG4gICAgLnNldChudWxsLCB4UmVzdWx0LmdldCgnbnVsbCcpKTtcblxuICB7IFxuICAgIGNvbnN0IGNvcHlUb1Jlc3VsdCA9IFsnaTgnLCAnaTE2JywgJ2kzMicsICdpbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZjMyJywgJ2Zsb2F0JywgJ2Y2NCcsICdkb3VibGUnXTtcbiAgICBpZih0YXJnZXQuYmlnSW50RW5hYmxlZCkgY29weVRvUmVzdWx0LnB1c2goJ2k2NCcpO1xuICAgIGNvbnN0IGFkYXB0UHRyID0geEFyZy5nZXQocHRySVIpO1xuICAgIGZvcihjb25zdCB0IG9mIGNvcHlUb1Jlc3VsdCl7XG4gICAgICB4QXJnLnNldCh0KycqJywgYWRhcHRQdHIpO1xuICAgICAgeFJlc3VsdC5zZXQodCsnKicsIGFkYXB0UHRyKTtcbiAgICAgIHhSZXN1bHQuc2V0KHQsICh4QXJnLmdldCh0KSB8fCB0b3NzKFwiTWlzc2luZyBhcmcgY29udmVydGVyOlwiLHQpKSk7XG4gICAgfVxuICB9XG5cbiAgXG4gIGNvbnN0IF9feEFyZ1N0cmluZyA9IGZ1bmN0aW9uKHYpe1xuICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIHYpIHJldHVybiB0YXJnZXQuc2NvcGVkQWxsb2NDU3RyaW5nKHYpO1xuICAgIHJldHVybiB2ID8gX194QXJnUHRyKHYpIDogbnVsbDtcbiAgfTtcbiAgeEFyZy5zZXQoJ3N0cmluZycsIF9feEFyZ1N0cmluZylcbiAgICAuc2V0KCd1dGY4JywgX194QXJnU3RyaW5nKVxuICAgIC5zZXQoJ3BvaW50ZXInLCBfX3hBcmdTdHJpbmcpO1xuICBcblxuICB4UmVzdWx0LnNldCgnc3RyaW5nJywgKGkpPT50YXJnZXQuY3N0clRvSnMoaSkpXG4gICAgLnNldCgndXRmOCcsIHhSZXN1bHQuZ2V0KCdzdHJpbmcnKSlcbiAgICAuc2V0KCdzdHJpbmc6ZGVhbGxvYycsIChpKT0+e1xuICAgICAgdHJ5IHsgcmV0dXJuIGkgPyB0YXJnZXQuY3N0clRvSnMoaSkgOiBudWxsIH1cbiAgICAgIGZpbmFsbHl7IHRhcmdldC5kZWFsbG9jKGkpIH1cbiAgICB9KVxuICAgIC5zZXQoJ3V0Zjg6ZGVhbGxvYycsIHhSZXN1bHQuZ2V0KCdzdHJpbmc6ZGVhbGxvYycpKVxuICAgIC5zZXQoJ2pzb24nLCAoaSk9PkpTT04ucGFyc2UodGFyZ2V0LmNzdHJUb0pzKGkpKSlcbiAgICAuc2V0KCdqc29uOmRlYWxsb2MnLCAoaSk9PntcbiAgICAgIHRyeXsgcmV0dXJuIGkgPyBKU09OLnBhcnNlKHRhcmdldC5jc3RyVG9KcyhpKSkgOiBudWxsIH1cbiAgICAgIGZpbmFsbHl7IHRhcmdldC5kZWFsbG9jKGkpIH1cbiAgICB9KTtcblxuICBcbiAgY29uc3QgQWJzdHJhY3RBcmdBZGFwdGVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG9wdCl7XG4gICAgICB0aGlzLm5hbWUgPSBvcHQubmFtZSB8fCAndW5uYW1lZCBhZGFwdGVyJztcbiAgICB9XG4gICAgXG4gICAgY29udmVydEFyZyh2LGFyZ3YsYXJnSW5kZXgpe1xuICAgICAgdG9zcyhcIkFic3RyYWN0QXJnQWRhcHRlciBtdXN0IGJlIHN1YmNsYXNzZWQuXCIpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgeEFyZy5GdW5jUHRyQWRhcHRlciA9IGNsYXNzIEZ1bmNQdHJBZGFwdGVyIGV4dGVuZHMgQWJzdHJhY3RBcmdBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHQpIHtcbiAgICAgIHN1cGVyKG9wdCk7XG4gICAgICBpZih4QXJnLkZ1bmNQdHJBZGFwdGVyLndhcm5PblVzZSl7XG4gICAgICAgIGNvbnNvbGUud2FybigneEFyZy5GdW5jUHRyQWRhcHRlciBpcyBhbiBpbnRlcm5hbC1vbmx5IEFQSScsXG4gICAgICAgICAgICAgICAgICAgICAnYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBpbnZva2VkIGZyb20nLFxuICAgICAgICAgICAgICAgICAgICAgJ2NsaWVudC1sZXZlbCBjb2RlLiBJbnZva2VkIHdpdGg6JyxvcHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gb3B0Lm5hbWUgfHwgXCJ1bm5hbWVkXCI7XG4gICAgICB0aGlzLnNpZ25hdHVyZSA9IG9wdC5zaWduYXR1cmU7XG4gICAgICBpZihvcHQuY29udGV4dEtleSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5jb250ZXh0S2V5ID0gb3B0LmNvbnRleHRLZXk7XG4gICAgICAgIGlmKCFvcHQuYmluZFNjb3BlKSBvcHQuYmluZFNjb3BlID0gJ2NvbnRleHQnO1xuICAgICAgfVxuICAgICAgdGhpcy5iaW5kU2NvcGUgPSBvcHQuYmluZFNjb3BlXG4gICAgICAgIHx8IHRvc3MoXCJGdW5jUHRyQWRhcHRlciBvcHRpb25zIHJlcXVpcmVzIGEgYmluZFNjb3BlIChleHBsaWNpdCBvciBpbXBsaWVkKS5cIik7XG4gICAgICBpZihGdW5jUHRyQWRhcHRlci5iaW5kU2NvcGVzLmluZGV4T2Yob3B0LmJpbmRTY29wZSk8MCl7XG4gICAgICAgIHRvc3MoXCJJbnZhbGlkIG9wdGlvbnMuYmluZFNjb3BlIChcIitvcHQuYmluZE1vZCtcIikgZm9yIEZ1bmNQdHJBZGFwdGVyLiBcIitcbiAgICAgICAgICAgICBcIkV4cGVjdGluZyBvbmUgb2Y6IChcIitGdW5jUHRyQWRhcHRlci5iaW5kU2NvcGVzLmpvaW4oJywgJykrJyknKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNUcmFuc2llbnQgPSAndHJhbnNpZW50Jz09PXRoaXMuYmluZFNjb3BlO1xuICAgICAgdGhpcy5pc0NvbnRleHQgPSAnY29udGV4dCc9PT10aGlzLmJpbmRTY29wZTtcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgPSAncGVybWFuZW50Jz09PXRoaXMuYmluZFNjb3BlO1xuICAgICAgdGhpcy5zaW5nbGV0b24gPSAoJ3NpbmdsZXRvbic9PT10aGlzLmJpbmRTY29wZSkgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAgIFxuICAgICAgdGhpcy5jYWxsUHJveHkgPSAob3B0LmNhbGxQcm94eSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICA/IG9wdC5jYWxsUHJveHkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgXG5cbiAgICBcbiAgICBjb250ZXh0S2V5KGFyZ3YsYXJnSW5kZXgpe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgXG4gICAgY29udGV4dE1hcChrZXkpe1xuICAgICAgY29uc3QgY20gPSAodGhpcy5fX2NtYXAgfHwgKHRoaXMuX19jbWFwID0gbmV3IE1hcCkpO1xuICAgICAgbGV0IHJjID0gY20uZ2V0KGtleSk7XG4gICAgICBpZih1bmRlZmluZWQ9PT1yYykgY20uc2V0KGtleSwgKHJjID0gW10pKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9XG5cbiAgICBcbiAgICBjb252ZXJ0QXJnKHYsYXJndixhcmdJbmRleCl7XG4gICAgICBcbiAgICAgIGxldCBwYWlyID0gdGhpcy5zaW5nbGV0b247XG4gICAgICBpZighcGFpciAmJiB0aGlzLmlzQ29udGV4dCl7XG4gICAgICAgIHBhaXIgPSB0aGlzLmNvbnRleHRNYXAodGhpcy5jb250ZXh0S2V5KGFyZ3YsYXJnSW5kZXgpKTtcbiAgICAgICAgXG4gICAgICB9XG4gICAgICBpZihwYWlyICYmIHBhaXJbMF09PT12KSByZXR1cm4gcGFpclsxXTtcbiAgICAgIGlmKHYgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5jYWxsUHJveHkpIHYgPSB0aGlzLmNhbGxQcm94eSh2KTtcbiAgICAgICAgY29uc3QgZnAgPSBfX2luc3RhbGxGdW5jdGlvbih2LCB0aGlzLnNpZ25hdHVyZSwgdGhpcy5pc1RyYW5zaWVudCk7XG4gICAgICAgIGlmKEZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwpe1xuICAgICAgICAgIEZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0KFwiRnVuY1B0ckFkYXB0ZXIgaW5zdGFsbGVkXCIsIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0S2V5KGFyZ3YsYXJnSW5kZXgpLCAnQCcrZnAsIHYpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhaXIpe1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKHBhaXJbMV0pe1xuICAgICAgICAgICAgaWYoRnVuY1B0ckFkYXB0ZXIuZGVidWdGdW5jSW5zdGFsbCl7XG4gICAgICAgICAgICAgIEZ1bmNQdHJBZGFwdGVyLmRlYnVnT3V0KFwiRnVuY1B0ckFkYXB0ZXIgdW5pbnN0YWxsaW5nXCIsIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dEtleShhcmd2LGFyZ0luZGV4KSwgJ0AnK3BhaXJbMV0sIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY2FjaGUuc2NvcGVkQWxsb2NbY2FjaGUuc2NvcGVkQWxsb2MubGVuZ3RoLTFdLnB1c2gocGFpclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKXt9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhaXJbMF0gPSB2O1xuICAgICAgICAgIHBhaXJbMV0gPSBmcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnA7XG4gICAgICB9ZWxzZSBpZih0YXJnZXQuaXNQdHIodikgfHwgbnVsbD09PXYgfHwgdW5kZWZpbmVkPT09dil7XG4gICAgICAgIFxuICAgICAgICBpZihwYWlyICYmIHBhaXJbMV0gJiYgcGFpclsxXSE9PXYpe1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKEZ1bmNQdHJBZGFwdGVyLmRlYnVnRnVuY0luc3RhbGwpe1xuICAgICAgICAgICAgRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQoXCJGdW5jUHRyQWRhcHRlciB1bmluc3RhbGxpbmdcIiwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dEtleShhcmd2LGFyZ0luZGV4KSwgJ0AnK3BhaXJbMV0sIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnl7IGNhY2hlLnNjb3BlZEFsbG9jW2NhY2hlLnNjb3BlZEFsbG9jLmxlbmd0aC0xXS5wdXNoKHBhaXJbMV0pIH1cbiAgICAgICAgICBjYXRjaChlKXt9XG4gICAgICAgICAgcGFpclswXSA9IHBhaXJbMV0gPSAodiB8IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2IHx8IDA7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgRnVuY1B0ckFkYXB0ZXIgYXJndW1lbnQgdHlwZS4gXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RpbmcgYSBmdW5jdGlvbiBwb2ludGVyIG9yIGEgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubmFtZSA/IHRoaXMubmFtZSsnICcgOiAnJykrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvbiBtYXRjaGluZyBzaWduYXR1cmUgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmUrXCIuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBcbiAgeEFyZy5GdW5jUHRyQWRhcHRlci53YXJuT25Vc2UgPSBmYWxzZTtcblxuICBcbiAgeEFyZy5GdW5jUHRyQWRhcHRlci5kZWJ1Z0Z1bmNJbnN0YWxsID0gZmFsc2U7XG5cbiAgXG4gIHhBcmcuRnVuY1B0ckFkYXB0ZXIuZGVidWdPdXQgPSBjb25zb2xlLmRlYnVnLmJpbmQoY29uc29sZSk7XG5cbiAgeEFyZy5GdW5jUHRyQWRhcHRlci5iaW5kU2NvcGVzID0gW1xuICAgICd0cmFuc2llbnQnLCAnY29udGV4dCcsICdzaW5nbGV0b24nLCAncGVybWFuZW50J1xuICBdO1xuXG4gIGNvbnN0IF9feEFyZ0FkYXB0ZXJDaGVjayA9XG4gICAgICAgICh0KT0+eEFyZy5nZXQodCkgfHwgdG9zcyhcIkFyZ3VtZW50IGFkYXB0ZXIgbm90IGZvdW5kOlwiLHQpO1xuXG4gIGNvbnN0IF9feFJlc3VsdEFkYXB0ZXJDaGVjayA9XG4gICAgICAgICh0KT0+eFJlc3VsdC5nZXQodCkgfHwgdG9zcyhcIlJlc3VsdCBhZGFwdGVyIG5vdCBmb3VuZDpcIix0KTtcblxuICBjYWNoZS54V3JhcC5jb252ZXJ0QXJnID0gKHQsLi4uYXJncyk9Pl9feEFyZ0FkYXB0ZXJDaGVjayh0KSguLi5hcmdzKTtcbiAgY2FjaGUueFdyYXAuY29udmVydEFyZ05vQ2hlY2sgPSAodCwuLi5hcmdzKT0+eEFyZy5nZXQodCkoLi4uYXJncyk7XG5cbiAgY2FjaGUueFdyYXAuY29udmVydFJlc3VsdCA9XG4gICAgKHQsdik9PihudWxsPT09dCA/IHYgOiAodCA/IF9feFJlc3VsdEFkYXB0ZXJDaGVjayh0KSh2KSA6IHVuZGVmaW5lZCkpO1xuICBjYWNoZS54V3JhcC5jb252ZXJ0UmVzdWx0Tm9DaGVjayA9XG4gICAgKHQsdik9PihudWxsPT09dCA/IHYgOiAodCA/IHhSZXN1bHQuZ2V0KHQpKHYpIDogdW5kZWZpbmVkKSk7XG5cbiAgXG4gIHRhcmdldC54V3JhcCA9IGZ1bmN0aW9uKGZBcmcsIHJlc3VsdFR5cGUsIC4uLmFyZ1R5cGVzKXtcbiAgICBpZigzPT09YXJndW1lbnRzLmxlbmd0aCAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkpe1xuICAgICAgYXJnVHlwZXMgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuICAgIGlmKHRhcmdldC5pc1B0cihmQXJnKSl7XG4gICAgICBmQXJnID0gdGFyZ2V0LmZ1bmN0aW9uRW50cnkoZkFyZylcbiAgICAgICAgfHwgdG9zcyhcIkZ1bmN0aW9uIHBvaW50ZXIgbm90IGZvdW5kIGluIFdBU00gZnVuY3Rpb24gdGFibGUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBmSXNGdW5jID0gKGZBcmcgaW5zdGFuY2VvZiBGdW5jdGlvbik7XG4gICAgY29uc3QgeGYgPSBmSXNGdW5jID8gZkFyZyA6IHRhcmdldC54R2V0KGZBcmcpO1xuICAgIGlmKGZJc0Z1bmMpIGZBcmcgPSB4Zi5uYW1lIHx8ICd1bm5hbWVkIGZ1bmN0aW9uJztcbiAgICBpZihhcmdUeXBlcy5sZW5ndGghPT14Zi5sZW5ndGgpIF9fYXJnY01pc21hdGNoKGZBcmcsIHhmLmxlbmd0aCk7XG4gICAgaWYoKG51bGw9PT1yZXN1bHRUeXBlKSAmJiAwPT09eGYubGVuZ3RoKXtcbiAgICAgIFxuICAgICAgcmV0dXJuIHhmO1xuICAgIH1cbiAgICA7XG4gICAgaWYodW5kZWZpbmVkIT09cmVzdWx0VHlwZSAmJiBudWxsIT09cmVzdWx0VHlwZSkgX194UmVzdWx0QWRhcHRlckNoZWNrKHJlc3VsdFR5cGUpO1xuICAgIGZvcihjb25zdCB0IG9mIGFyZ1R5cGVzKXtcbiAgICAgIGlmKHQgaW5zdGFuY2VvZiBBYnN0cmFjdEFyZ0FkYXB0ZXIpIHhBcmcuc2V0KHQsICguLi5hcmdzKT0+dC5jb252ZXJ0QXJnKC4uLmFyZ3MpKTtcbiAgICAgIGVsc2UgX194QXJnQWRhcHRlckNoZWNrKHQpO1xuICAgIH1cbiAgICBjb25zdCBjeHcgPSBjYWNoZS54V3JhcDtcbiAgICBpZigwPT09eGYubGVuZ3RoKXtcbiAgICAgIFxuICAgICAgcmV0dXJuICguLi5hcmdzKT0+KGFyZ3MubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyBfX2FyZ2NNaXNtYXRjaChmQXJnLCB4Zi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiBjeHcuY29udmVydFJlc3VsdChyZXN1bHRUeXBlLCB4Zi5jYWxsKG51bGwpKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgIGlmKGFyZ3MubGVuZ3RoIT09eGYubGVuZ3RoKSBfX2FyZ2NNaXNtYXRjaChmQXJnLCB4Zi5sZW5ndGgpO1xuICAgICAgY29uc3Qgc2NvcGUgPSB0YXJnZXQuc2NvcGVkQWxsb2NQdXNoKCk7XG4gICAgICB0cnl7XG4gICAgICAgIFxuICAgICAgICBmb3IoY29uc3QgaSBpbiBhcmdzKSBhcmdzW2ldID0gY3h3LmNvbnZlcnRBcmdOb0NoZWNrKFxuICAgICAgICAgIGFyZ1R5cGVzW2ldLCBhcmdzW2ldLCBhcmdzLCBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjeHcuY29udmVydFJlc3VsdE5vQ2hlY2socmVzdWx0VHlwZSwgeGYuYXBwbHkobnVsbCxhcmdzKSk7XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgdGFyZ2V0LnNjb3BlZEFsbG9jUG9wKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIFxuICBjb25zdCBfX3hBZGFwdGVyID0gZnVuY3Rpb24oZnVuYywgYXJnYywgdHlwZU5hbWUsIGFkYXB0ZXIsIG1vZGVOYW1lLCB4Y3ZQYXJ0KXtcbiAgICBpZignc3RyaW5nJz09PXR5cGVvZiB0eXBlTmFtZSl7XG4gICAgICBpZigxPT09YXJnYykgcmV0dXJuIHhjdlBhcnQuZ2V0KHR5cGVOYW1lKTtcbiAgICAgIGVsc2UgaWYoMj09PWFyZ2Mpe1xuICAgICAgICBpZighYWRhcHRlcil7XG4gICAgICAgICAgZGVsZXRlIHhjdlBhcnQuZ2V0KHR5cGVOYW1lKTtcbiAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgfWVsc2UgaWYoIShhZGFwdGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICAgICAgICB0b3NzKG1vZGVOYW1lLFwicmVxdWlyZXMgYSBmdW5jdGlvbiBhcmd1bWVudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgeGN2UGFydC5zZXQodHlwZU5hbWUsIGFkYXB0ZXIpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICB9XG4gICAgdG9zcyhcIkludmFsaWQgYXJndW1lbnRzIHRvXCIsbW9kZU5hbWUpO1xuICB9O1xuXG4gIFxuICB0YXJnZXQueFdyYXAucmVzdWx0QWRhcHRlciA9IGZ1bmN0aW9uIGYodHlwZU5hbWUsIGFkYXB0ZXIpe1xuICAgIHJldHVybiBfX3hBZGFwdGVyKGYsIGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVOYW1lLCBhZGFwdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICdyZXN1bHRBZGFwdGVyKCknLCB4UmVzdWx0KTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnhXcmFwLmFyZ0FkYXB0ZXIgPSBmdW5jdGlvbiBmKHR5cGVOYW1lLCBhZGFwdGVyKXtcbiAgICByZXR1cm4gX194QWRhcHRlcihmLCBhcmd1bWVudHMubGVuZ3RoLCB0eXBlTmFtZSwgYWRhcHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAnYXJnQWRhcHRlcigpJywgeEFyZyk7XG4gIH07XG5cbiAgdGFyZ2V0LnhXcmFwLkZ1bmNQdHJBZGFwdGVyID0geEFyZy5GdW5jUHRyQWRhcHRlcjtcblxuICBcbiAgdGFyZ2V0LnhDYWxsV3JhcHBlZCA9IGZ1bmN0aW9uKGZBcmcsIHJlc3VsdFR5cGUsIGFyZ1R5cGVzLCAuLi5hcmdzKXtcbiAgICBpZihBcnJheS5pc0FycmF5KGFyZ3VtZW50c1szXSkpIGFyZ3MgPSBhcmd1bWVudHNbM107XG4gICAgcmV0dXJuIHRhcmdldC54V3JhcChmQXJnLCByZXN1bHRUeXBlLCBhcmdUeXBlc3x8W10pLmFwcGx5KG51bGwsIGFyZ3N8fFtdKTtcbiAgfTtcblxuICBcbiAgdGFyZ2V0LnhXcmFwLnRlc3RDb252ZXJ0QXJnID0gY2FjaGUueFdyYXAuY29udmVydEFyZztcblxuICBcbiAgdGFyZ2V0LnhXcmFwLnRlc3RDb252ZXJ0UmVzdWx0ID0gY2FjaGUueFdyYXAuY29udmVydFJlc3VsdDtcblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5nbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIueWF3bCA9IGZ1bmN0aW9uKGNvbmZpZyl7XG4gIGNvbnN0IHdmZXRjaCA9ICgpPT5mZXRjaChjb25maWcudXJpLCB7Y3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbid9KTtcbiAgY29uc3Qgd3VpID0gdGhpcztcbiAgY29uc3QgZmluYWxUaGVuID0gZnVuY3Rpb24oYXJnKXtcbiAgICBcbiAgICBpZihjb25maWcud2FzbVV0aWxUYXJnZXQpe1xuICAgICAgY29uc3QgdG9zcyA9ICguLi5hcmdzKT0+e3Rocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSl9O1xuICAgICAgY29uc3QgdGd0ID0gY29uZmlnLndhc21VdGlsVGFyZ2V0O1xuICAgICAgdGd0Lm1vZHVsZSA9IGFyZy5tb2R1bGU7XG4gICAgICB0Z3QuaW5zdGFuY2UgPSBhcmcuaW5zdGFuY2U7XG4gICAgICBcbiAgICAgIGlmKCF0Z3QuaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkpe1xuICAgICAgICBcbiAgICAgICAgdGd0Lm1lbW9yeSA9IChjb25maWcuaW1wb3J0cyAmJiBjb25maWcuaW1wb3J0cy5lbnZcbiAgICAgICAgICAgICAgICAgICAgICAmJiBjb25maWcuaW1wb3J0cy5lbnYubWVtb3J5KVxuICAgICAgICAgIHx8IHRvc3MoXCJNaXNzaW5nICdtZW1vcnknIG9iamVjdCFcIik7XG4gICAgICB9XG4gICAgICBpZighdGd0LmFsbG9jICYmIGFyZy5pbnN0YW5jZS5leHBvcnRzLm1hbGxvYyl7XG4gICAgICAgIGNvbnN0IGV4cG9ydHMgPSBhcmcuaW5zdGFuY2UuZXhwb3J0cztcbiAgICAgICAgdGd0LmFsbG9jID0gZnVuY3Rpb24obil7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHMubWFsbG9jKG4pIHx8IHRvc3MoXCJBbGxvY2F0aW9uIG9mXCIsbixcImJ5dGVzIGZhaWxlZC5cIik7XG4gICAgICAgIH07XG4gICAgICAgIHRndC5kZWFsbG9jID0gZnVuY3Rpb24obSl7ZXhwb3J0cy5mcmVlKG0pfTtcbiAgICAgIH1cbiAgICAgIHd1aSh0Z3QpO1xuICAgIH1cbiAgICBpZihjb25maWcub25sb2FkKSBjb25maWcub25sb2FkKGFyZyxjb25maWcpO1xuICAgIHJldHVybiBhcmcgO1xuICB9O1xuICBjb25zdCBsb2FkV2FzbSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nXG4gICAgICAgID8gZnVuY3Rpb24gbG9hZFdhc21TdHJlYW1pbmcoKXtcbiAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcod2ZldGNoKCksIGNvbmZpZy5pbXBvcnRzfHx7fSlcbiAgICAgICAgICAgIC50aGVuKGZpbmFsVGhlbik7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiBsb2FkV2FzbU9sZFNjaG9vbCgpeyBcbiAgICAgICAgICByZXR1cm4gd2ZldGNoKClcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpXG4gICAgICAgICAgICAudGhlbihieXRlcyA9PiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgY29uZmlnLmltcG9ydHN8fHt9KSlcbiAgICAgICAgICAgIC50aGVuKGZpbmFsVGhlbik7XG4gICAgICAgIH07XG4gIHJldHVybiBsb2FkV2FzbTtcbn0uYmluZChnbG9iYWxUaGlzLldoV2FzbVV0aWxJbnN0YWxsZXIpO1xuXG5cblxuJ3VzZSBzdHJpY3QnO1xuZ2xvYmFsVGhpcy5KYWNjd2FieXQgPSBmdW5jdGlvbiBTdHJ1Y3RCaW5kZXJGYWN0b3J5KGNvbmZpZyl7XG5cblxuICBcbiAgY29uc3QgdG9zcyA9ICguLi5hcmdzKT0+e3Rocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSl9O1xuXG4gIFxuICBpZighKGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTWVtb3J5KVxuICAgICAmJiAhKGNvbmZpZy5oZWFwIGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICB0b3NzKFwiY29uZmlnLmhlYXAgbXVzdCBiZSBXZWJBc3NlbWJseS5NZW1vcnkgaW5zdGFuY2Ugb3IgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiAgWydhbGxvYycsJ2RlYWxsb2MnXS5mb3JFYWNoKGZ1bmN0aW9uKGspe1xuICAgIChjb25maWdba10gaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgIHRvc3MoXCJDb25maWcgb3B0aW9uICdcIitrK1wiJyBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICB9KTtcbiAgY29uc3QgU0JGID0gU3RydWN0QmluZGVyRmFjdG9yeTtcbiAgY29uc3QgaGVhcCA9IChjb25maWcuaGVhcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICA/IGNvbmZpZy5oZWFwIDogKCgpPT5uZXcgVWludDhBcnJheShjb25maWcuaGVhcC5idWZmZXIpKSxcbiAgICAgICAgYWxsb2MgPSBjb25maWcuYWxsb2MsXG4gICAgICAgIGRlYWxsb2MgPSBjb25maWcuZGVhbGxvYyxcbiAgICAgICAgbG9nID0gY29uZmlnLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgICAgICBtZW1iZXJQcmVmaXggPSAoY29uZmlnLm1lbWJlclByZWZpeCB8fCBcIlwiKSxcbiAgICAgICAgbWVtYmVyU3VmZml4ID0gKGNvbmZpZy5tZW1iZXJTdWZmaXggfHwgXCJcIiksXG4gICAgICAgIGJpZ0ludEVuYWJsZWQgPSAodW5kZWZpbmVkPT09Y29uZmlnLmJpZ0ludEVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICA/ICEhZ2xvYmFsVGhpc1snQmlnSW50NjRBcnJheSddIDogISFjb25maWcuYmlnSW50RW5hYmxlZCksXG4gICAgICAgIEJpZ0ludCA9IGdsb2JhbFRoaXNbJ0JpZ0ludCddLFxuICAgICAgICBCaWdJbnQ2NEFycmF5ID0gZ2xvYmFsVGhpc1snQmlnSW50NjRBcnJheSddLFxuICAgICAgICBcbiAgICAgICAgcHRyU2l6ZW9mID0gY29uZmlnLnB0clNpemVvZiB8fCA0LFxuICAgICAgICBwdHJJUiA9IGNvbmZpZy5wdHJJUiB8fCAnaTMyJ1xuICA7XG5cbiAgaWYoIVNCRi5kZWJ1Z0ZsYWdzKXtcbiAgICBTQkYuX19tYWtlRGVidWdGbGFncyA9IGZ1bmN0aW9uKGRlcml2ZUZyb209bnVsbCl7XG4gICAgICBcbiAgICAgIGlmKGRlcml2ZUZyb20gJiYgZGVyaXZlRnJvbS5fX2ZsYWdzKSBkZXJpdmVGcm9tID0gZGVyaXZlRnJvbS5fX2ZsYWdzO1xuICAgICAgY29uc3QgZiA9IGZ1bmN0aW9uIGYoZmxhZ3Mpe1xuICAgICAgICBpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgcmV0dXJuIGYuX19mbGFncztcbiAgICAgICAgfVxuICAgICAgICBpZihmbGFnczwwKXtcbiAgICAgICAgICBkZWxldGUgZi5fX2ZsYWdzLmdldHRlcjsgZGVsZXRlIGYuX19mbGFncy5zZXR0ZXI7XG4gICAgICAgICAgZGVsZXRlIGYuX19mbGFncy5hbGxvYzsgZGVsZXRlIGYuX19mbGFncy5kZWFsbG9jO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBmLl9fZmxhZ3MuZ2V0dGVyICA9IDAhPT0oMHgwMSAmIGZsYWdzKTtcbiAgICAgICAgICBmLl9fZmxhZ3Muc2V0dGVyICA9IDAhPT0oMHgwMiAmIGZsYWdzKTtcbiAgICAgICAgICBmLl9fZmxhZ3MuYWxsb2MgICA9IDAhPT0oMHgwNCAmIGZsYWdzKTtcbiAgICAgICAgICBmLl9fZmxhZ3MuZGVhbGxvYyA9IDAhPT0oMHgwOCAmIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZi5fZmxhZ3M7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsJ19fZmxhZ3MnLCB7XG4gICAgICAgIGl0ZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogT2JqZWN0LmNyZWF0ZShkZXJpdmVGcm9tKVxuICAgICAgfSk7XG4gICAgICBpZighZGVyaXZlRnJvbSkgZigwKTtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG4gICAgU0JGLmRlYnVnRmxhZ3MgPSBTQkYuX19tYWtlRGVidWdGbGFncygpO1xuICB9XG5cbiAgY29uc3QgaXNMaXR0bGVFbmRpYW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDIpO1xuICAgIG5ldyBEYXRhVmlldyhidWZmZXIpLnNldEludDE2KDAsIDI1NiwgdHJ1ZSApO1xuICAgIFxuICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpWzBdID09PSAyNTY7XG4gIH0pKCk7XG4gIFxuXG4gIFxuICBjb25zdCBpc0Z1bmNTaWcgPSAocyk9PicoJz09PXNbMV07XG4gIFxuICBjb25zdCBpc1B0clNpZyA9IChzKT0+J3AnPT09cyB8fCAnUCc9PT1zO1xuICBjb25zdCBpc0F1dG9QdHJTaWcgPSAocyk9PidQJz09PXMgO1xuICBjb25zdCBzaWdMZXR0ZXIgPSAocyk9PmlzRnVuY1NpZyhzKSA/ICdwJyA6IHNbMF07XG4gIFxuICBjb25zdCBzaWdJUiA9IGZ1bmN0aW9uKHMpe1xuICAgIHN3aXRjaChzaWdMZXR0ZXIocykpe1xuICAgICAgICBjYXNlICdjJzogY2FzZSAnQyc6IHJldHVybiAnaTgnO1xuICAgICAgICBjYXNlICdpJzogcmV0dXJuICdpMzInO1xuICAgICAgICBjYXNlICdwJzogY2FzZSAnUCc6IGNhc2UgJ3MnOiByZXR1cm4gcHRySVI7XG4gICAgICAgIGNhc2UgJ2onOiByZXR1cm4gJ2k2NCc7XG4gICAgICAgIGNhc2UgJ2YnOiByZXR1cm4gJ2Zsb2F0JztcbiAgICAgICAgY2FzZSAnZCc6IHJldHVybiAnZG91YmxlJztcbiAgICB9XG4gICAgdG9zcyhcIlVuaGFuZGxlZCBzaWduYXR1cmUgSVI6XCIscyk7XG4gIH07XG5cbiAgY29uc3QgYWZmaXJtQmlnSW50QXJyYXkgPSBCaWdJbnQ2NEFycmF5XG4gICAgICAgID8gKCk9PnRydWUgOiAoKT0+dG9zcygnQmlnSW50NjRBcnJheSBpcyBub3QgYXZhaWxhYmxlLicpO1xuICBcbiAgY29uc3Qgc2lnRFZHZXR0ZXIgPSBmdW5jdGlvbihzKXtcbiAgICBzd2l0Y2goc2lnTGV0dGVyKHMpKSB7XG4gICAgICAgIGNhc2UgJ3AnOiBjYXNlICdQJzogY2FzZSAncyc6IHtcbiAgICAgICAgICBzd2l0Y2gocHRyU2l6ZW9mKXtcbiAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gJ2dldEludDMyJztcbiAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnZ2V0QmlnSW50NjQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpJzogcmV0dXJuICdnZXRJbnQzMic7XG4gICAgICAgIGNhc2UgJ2MnOiByZXR1cm4gJ2dldEludDgnO1xuICAgICAgICBjYXNlICdDJzogcmV0dXJuICdnZXRVaW50OCc7XG4gICAgICAgIGNhc2UgJ2onOiByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiAnZ2V0QmlnSW50NjQnO1xuICAgICAgICBjYXNlICdmJzogcmV0dXJuICdnZXRGbG9hdDMyJztcbiAgICAgICAgY2FzZSAnZCc6IHJldHVybiAnZ2V0RmxvYXQ2NCc7XG4gICAgfVxuICAgIHRvc3MoXCJVbmhhbmRsZWQgRGF0YVZpZXcgZ2V0dGVyIGZvciBzaWduYXR1cmU6XCIscyk7XG4gIH07XG4gIFxuICBjb25zdCBzaWdEVlNldHRlciA9IGZ1bmN0aW9uKHMpe1xuICAgIHN3aXRjaChzaWdMZXR0ZXIocykpe1xuICAgICAgICBjYXNlICdwJzogY2FzZSAnUCc6IGNhc2UgJ3MnOiB7XG4gICAgICAgICAgc3dpdGNoKHB0clNpemVvZil7XG4gICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuICdzZXRJbnQzMic7XG4gICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ3NldEJpZ0ludDY0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaSc6IHJldHVybiAnc2V0SW50MzInO1xuICAgICAgICBjYXNlICdjJzogcmV0dXJuICdzZXRJbnQ4JztcbiAgICAgICAgY2FzZSAnQyc6IHJldHVybiAnc2V0VWludDgnO1xuICAgICAgICBjYXNlICdqJzogcmV0dXJuIGFmZmlybUJpZ0ludEFycmF5KCkgJiYgJ3NldEJpZ0ludDY0JztcbiAgICAgICAgY2FzZSAnZic6IHJldHVybiAnc2V0RmxvYXQzMic7XG4gICAgICAgIGNhc2UgJ2QnOiByZXR1cm4gJ3NldEZsb2F0NjQnO1xuICAgIH1cbiAgICB0b3NzKFwiVW5oYW5kbGVkIERhdGFWaWV3IHNldHRlciBmb3Igc2lnbmF0dXJlOlwiLHMpO1xuICB9O1xuICBcbiAgY29uc3Qgc2lnRFZTZXRXcmFwcGVyID0gZnVuY3Rpb24ocyl7XG4gICAgc3dpdGNoKHNpZ0xldHRlcihzKSkge1xuICAgICAgICBjYXNlICdpJzogY2FzZSAnZic6IGNhc2UgJ2MnOiBjYXNlICdDJzogY2FzZSAnZCc6IHJldHVybiBOdW1iZXI7XG4gICAgICAgIGNhc2UgJ2onOiByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgIGNhc2UgJ3AnOiBjYXNlICdQJzogY2FzZSAncyc6XG4gICAgICAgICAgc3dpdGNoKHB0clNpemVvZil7XG4gICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIE51bWJlcjtcbiAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gYWZmaXJtQmlnSW50QXJyYXkoKSAmJiBCaWdJbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0b3NzKFwiVW5oYW5kbGVkIERhdGFWaWV3IHNldCB3cmFwcGVyIGZvciBzaWduYXR1cmU6XCIscyk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IHNQcm9wTmFtZSA9IChzLGspPT5zKyc6OicraztcblxuICBjb25zdCBfX3Byb3BUaHJvd09uU2V0ID0gZnVuY3Rpb24oc3RydWN0TmFtZSxwcm9wTmFtZSl7XG4gICAgcmV0dXJuICgpPT50b3NzKHNQcm9wTmFtZShzdHJ1Y3ROYW1lLHByb3BOYW1lKSxcImlzIHJlYWQtb25seS5cIik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9faW5zdGFuY2VQb2ludGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICBcbiAgY29uc3QgeFB0clByb3BOYW1lID0gJyhwb2ludGVyLWlzLWV4dGVybmFsKSc7XG5cbiAgXG4gIGNvbnN0IF9fZnJlZVN0cnVjdCA9IGZ1bmN0aW9uKGN0b3IsIG9iaiwgbSl7XG4gICAgaWYoIW0pIG0gPSBfX2luc3RhbmNlUG9pbnRlck1hcC5nZXQob2JqKTtcbiAgICBpZihtKSB7XG4gICAgICBfX2luc3RhbmNlUG9pbnRlck1hcC5kZWxldGUob2JqKTtcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkob2JqLm9uZGlzcG9zZSkpe1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgd2hpbGUoKHggPSBvYmoub25kaXNwb3NlLnNoaWZ0KCkpKXtcbiAgICAgICAgICB0cnl7XG4gICAgICAgICAgICBpZih4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHguY2FsbChvYmopO1xuICAgICAgICAgICAgZWxzZSBpZih4IGluc3RhbmNlb2YgU3RydWN0VHlwZSkgeC5kaXNwb3NlKCk7XG4gICAgICAgICAgICBlbHNlIGlmKCdudW1iZXInID09PSB0eXBlb2YgeCkgZGVhbGxvYyh4KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwib25kaXNwb3NlKCkgZm9yXCIsY3Rvci5zdHJ1Y3ROYW1lLCdAJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBtLCd0aHJldy4gTk9UIHByb3BhZ2F0aW5nIGl0LicsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZSBpZihvYmoub25kaXNwb3NlIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICB0cnl7b2JqLm9uZGlzcG9zZSgpfVxuICAgICAgICBjYXRjaChlKXtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJvbmRpc3Bvc2UoKSBmb3JcIixjdG9yLnN0cnVjdE5hbWUsJ0AnLFxuICAgICAgICAgICAgICAgICAgICAgICBtLCd0aHJldy4gTk9UIHByb3BhZ2F0aW5nIGl0LicsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvYmoub25kaXNwb3NlO1xuICAgICAgaWYoY3Rvci5kZWJ1Z0ZsYWdzLl9fZmxhZ3MuZGVhbGxvYyl7XG4gICAgICAgIGxvZyhcImRlYnVnLmRlYWxsb2M6XCIsKG9ialt4UHRyUHJvcE5hbWVdP1wiRVhURVJOQUxcIjpcIlwiKSxcbiAgICAgICAgICAgIGN0b3Iuc3RydWN0TmFtZSxcImluc3RhbmNlOlwiLFxuICAgICAgICAgICAgY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZixcImJ5dGVzIEBcIittKTtcbiAgICAgIH1cbiAgICAgIGlmKCFvYmpbeFB0clByb3BOYW1lXSkgZGVhbGxvYyhtKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNvbnN0IHJvcCA9ICh2KT0+e3JldHVybiB7Y29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhYmxlOiBmYWxzZSwgdmFsdWU6IHZ9fTtcblxuICBcbiAgY29uc3QgX19hbGxvY1N0cnVjdCA9IGZ1bmN0aW9uKGN0b3IsIG9iaiwgbSl7XG4gICAgbGV0IGZpbGwgPSAhbTtcbiAgICBpZihtKSBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCB4UHRyUHJvcE5hbWUsIHJvcChtKSk7XG4gICAgZWxzZXtcbiAgICAgIG0gPSBhbGxvYyhjdG9yLnN0cnVjdEluZm8uc2l6ZW9mKTtcbiAgICAgIGlmKCFtKSB0b3NzKFwiQWxsb2NhdGlvbiBvZlwiLGN0b3Iuc3RydWN0TmFtZSxcInN0cnVjdHVyZSBmYWlsZWQuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYoY3Rvci5kZWJ1Z0ZsYWdzLl9fZmxhZ3MuYWxsb2Mpe1xuICAgICAgICBsb2coXCJkZWJ1Zy5hbGxvYzpcIiwoZmlsbD9cIlwiOlwiRVhURVJOQUxcIiksXG4gICAgICAgICAgICBjdG9yLnN0cnVjdE5hbWUsXCJpbnN0YW5jZTpcIixcbiAgICAgICAgICAgIGN0b3Iuc3RydWN0SW5mby5zaXplb2YsXCJieXRlcyBAXCIrbSk7XG4gICAgICB9XG4gICAgICBpZihmaWxsKSBoZWFwKCkuZmlsbCgwLCBtLCBtICsgY3Rvci5zdHJ1Y3RJbmZvLnNpemVvZik7XG4gICAgICBfX2luc3RhbmNlUG9pbnRlck1hcC5zZXQob2JqLCBtKTtcbiAgICB9Y2F0Y2goZSl7XG4gICAgICBfX2ZyZWVTdHJ1Y3QoY3Rvciwgb2JqLCBtKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgX19tZW1vcnlEdW1wID0gZnVuY3Rpb24oKXtcbiAgICBjb25zdCBwID0gdGhpcy5wb2ludGVyO1xuICAgIHJldHVybiBwXG4gICAgICA/IG5ldyBVaW50OEFycmF5KGhlYXAoKS5zbGljZShwLCBwK3RoaXMuc3RydWN0SW5mby5zaXplb2YpKVxuICAgICAgOiBudWxsO1xuICB9O1xuXG4gIGNvbnN0IF9fbWVtYmVyS2V5ID0gKGspPT5tZW1iZXJQcmVmaXggKyBrICsgbWVtYmVyU3VmZml4O1xuICBjb25zdCBfX21lbWJlcktleVByb3AgPSByb3AoX19tZW1iZXJLZXkpO1xuXG4gIFxuICBjb25zdCBfX2xvb2t1cE1lbWJlciA9IGZ1bmN0aW9uKHN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kPXRydWUpe1xuICAgIGxldCBtID0gc3RydWN0SW5mby5tZW1iZXJzW21lbWJlck5hbWVdO1xuICAgIGlmKCFtICYmIChtZW1iZXJQcmVmaXggfHwgbWVtYmVyU3VmZml4KSl7XG4gICAgICBcbiAgICAgIGZvcihjb25zdCB2IG9mIE9iamVjdC52YWx1ZXMoc3RydWN0SW5mby5tZW1iZXJzKSl7XG4gICAgICAgIGlmKHYua2V5PT09bWVtYmVyTmFtZSl7IG0gPSB2OyBicmVhazsgfVxuICAgICAgfVxuICAgICAgaWYoIW0gJiYgdG9zc0lmTm90Rm91bmQpe1xuICAgICAgICB0b3NzKHNQcm9wTmFtZShzdHJ1Y3RJbmZvLm5hbWUsbWVtYmVyTmFtZSksJ2lzIG5vdCBhIG1hcHBlZCBzdHJ1Y3QgbWVtYmVyLicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19tZW1iZXJTaWduYXR1cmUgPSBmdW5jdGlvbiBmKG9iaixtZW1iZXJOYW1lLGVtc2NyaXB0ZW5Gb3JtYXQ9ZmFsc2Upe1xuICAgIGlmKCFmLl8pIGYuXyA9ICh4KT0+eC5yZXBsYWNlKC9bXnZpcFBzanJkY0NdL2csXCJcIikucmVwbGFjZSgvW3BQc2NDXS9nLCdpJyk7XG4gICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0cnVlKTtcbiAgICByZXR1cm4gZW1zY3JpcHRlbkZvcm1hdCA/IGYuXyhtLnNpZ25hdHVyZSkgOiBtLnNpZ25hdHVyZTtcbiAgfTtcblxuICBjb25zdCBfX3B0clByb3BEZXNjcmlwdG9yID0ge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24oKXtyZXR1cm4gX19pbnN0YW5jZVBvaW50ZXJNYXAuZ2V0KHRoaXMpfSxcbiAgICBzZXQ6ICgpPT50b3NzKFwiQ2Fubm90IGFzc2lnbiB0aGUgJ3BvaW50ZXInIHByb3BlcnR5IG9mIGEgc3RydWN0LlwiKVxuICAgIFxuICAgIFxuICAgIFxuICB9O1xuXG4gIFxuICBjb25zdCBfX3N0cnVjdE1lbWJlcktleXMgPSByb3AoZnVuY3Rpb24oKXtcbiAgICBjb25zdCBhID0gW107XG4gICAgZm9yKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy5zdHJ1Y3RJbmZvLm1lbWJlcnMpKXtcbiAgICAgIGEucHVzaCh0aGlzLm1lbWJlcktleShrKSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9KTtcblxuICBjb25zdCBfX3V0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICBjb25zdCBfX3V0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIFxuICBjb25zdCBfX1NBQiA9ICgndW5kZWZpbmVkJz09PXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBmdW5jdGlvbigpe30gOiBTaGFyZWRBcnJheUJ1ZmZlcjtcbiAgY29uc3QgX191dGY4RGVjb2RlID0gZnVuY3Rpb24oYXJyYXlCdWZmZXIsIGJlZ2luLCBlbmQpe1xuICAgIHJldHVybiBfX3V0ZjhEZWNvZGVyLmRlY29kZShcbiAgICAgIChhcnJheUJ1ZmZlci5idWZmZXIgaW5zdGFuY2VvZiBfX1NBQilcbiAgICAgICAgPyBhcnJheUJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKVxuICAgICAgICA6IGFycmF5QnVmZmVyLnN1YmFycmF5KGJlZ2luLCBlbmQpXG4gICAgKTtcbiAgfTtcbiAgXG4gIGNvbnN0IF9fbWVtYmVySXNTdHJpbmcgPSBmdW5jdGlvbihvYmosbWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQ9ZmFsc2Upe1xuICAgIGNvbnN0IG0gPSBfX2xvb2t1cE1lbWJlcihvYmouc3RydWN0SW5mbywgbWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQpO1xuICAgIHJldHVybiAobSAmJiAxPT09bS5zaWduYXR1cmUubGVuZ3RoICYmICdzJz09PW0uc2lnbmF0dXJlWzBdKSA/IG0gOiBmYWxzZTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19hZmZpcm1DU3RyaW5nU2lnbmF0dXJlID0gZnVuY3Rpb24obWVtYmVyKXtcbiAgICBpZigncyc9PT1tZW1iZXIuc2lnbmF0dXJlKSByZXR1cm47XG4gICAgdG9zcyhcIkludmFsaWQgbWVtYmVyIHR5cGUgc2lnbmF0dXJlIGZvciBDLXN0cmluZyB2YWx1ZTpcIixcbiAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1lbWJlcikpO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX21lbWJlclRvSnNTdHJpbmcgPSBmdW5jdGlvbiBmKG9iaixtZW1iZXJOYW1lKXtcbiAgICBjb25zdCBtID0gX19sb29rdXBNZW1iZXIob2JqLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRydWUpO1xuICAgIF9fYWZmaXJtQ1N0cmluZ1NpZ25hdHVyZShtKTtcbiAgICBjb25zdCBhZGRyID0gb2JqW20ua2V5XTtcbiAgICBcbiAgICBpZighYWRkcikgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBvcyA9IGFkZHI7XG4gICAgY29uc3QgbWVtID0gaGVhcCgpO1xuICAgIGZvciggOyBtZW1bcG9zXSE9PTA7ICsrcG9zICkge1xuICAgICAgXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gKGFkZHI9PT1wb3MpID8gXCJcIiA6IF9fdXRmOERlY29kZShtZW0sIGFkZHIsIHBvcyk7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fYWRkT25EaXNwb3NlID0gZnVuY3Rpb24ob2JqLCAuLi52KXtcbiAgICBpZihvYmoub25kaXNwb3NlKXtcbiAgICAgIGlmKCFBcnJheS5pc0FycmF5KG9iai5vbmRpc3Bvc2UpKXtcbiAgICAgICAgb2JqLm9uZGlzcG9zZSA9IFtvYmoub25kaXNwb3NlXTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIG9iai5vbmRpc3Bvc2UgPSBbXTtcbiAgICB9XG4gICAgb2JqLm9uZGlzcG9zZS5wdXNoKC4uLnYpO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX2FsbG9jQ1N0cmluZyA9IGZ1bmN0aW9uKHN0cil7XG4gICAgY29uc3QgdSA9IF9fdXRmOEVuY29kZXIuZW5jb2RlKHN0cik7XG4gICAgY29uc3QgbWVtID0gYWxsb2ModS5sZW5ndGgrMSk7XG4gICAgaWYoIW1lbSkgdG9zcyhcIkFsbG9jYXRpb24gZXJyb3Igd2hpbGUgZHVwbGljYXRpbmcgc3RyaW5nOlwiLHN0cik7XG4gICAgY29uc3QgaCA9IGhlYXAoKTtcbiAgICBcbiAgICBcbiAgICBoLnNldCh1LCBtZW0pO1xuICAgIGhbbWVtICsgdS5sZW5ndGhdID0gMDtcbiAgICBcbiAgICByZXR1cm4gbWVtO1xuICB9O1xuXG4gIFxuICBjb25zdCBfX3NldE1lbWJlckNTdHJpbmcgPSBmdW5jdGlvbihvYmosIG1lbWJlck5hbWUsIHN0cil7XG4gICAgY29uc3QgbSA9IF9fbG9va3VwTWVtYmVyKG9iai5zdHJ1Y3RJbmZvLCBtZW1iZXJOYW1lLCB0cnVlKTtcbiAgICBfX2FmZmlybUNTdHJpbmdTaWduYXR1cmUobSk7XG4gICAgXG4gICAgY29uc3QgbWVtID0gX19hbGxvY0NTdHJpbmcoc3RyKTtcbiAgICBvYmpbbS5rZXldID0gbWVtO1xuICAgIF9fYWRkT25EaXNwb3NlKG9iaiwgbWVtKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIFxuICBjb25zdCBTdHJ1Y3RUeXBlID0gZnVuY3Rpb24gY3RvcihzdHJ1Y3ROYW1lLCBzdHJ1Y3RJbmZvKXtcbiAgICBpZihhcmd1bWVudHNbMl0hPT1yb3Ape1xuICAgICAgdG9zcyhcIkRvIG5vdCBjYWxsIHRoZSBTdHJ1Y3RUeXBlIGNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgIFwiZnJvbSBjbGllbnQtbGV2ZWwgY29kZS5cIik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMse1xuICAgICAgXG4gICAgICBzdHJ1Y3ROYW1lOiByb3Aoc3RydWN0TmFtZSksXG4gICAgICBzdHJ1Y3RJbmZvOiByb3Aoc3RydWN0SW5mbylcbiAgICB9KTtcbiAgfTtcblxuICBcbiAgU3RydWN0VHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICBkaXNwb3NlOiByb3AoZnVuY3Rpb24oKXtfX2ZyZWVTdHJ1Y3QodGhpcy5jb25zdHJ1Y3RvciwgdGhpcyl9KSxcbiAgICBsb29rdXBNZW1iZXI6IHJvcChmdW5jdGlvbihtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZD10cnVlKXtcbiAgICAgIHJldHVybiBfX2xvb2t1cE1lbWJlcih0aGlzLnN0cnVjdEluZm8sIG1lbWJlck5hbWUsIHRvc3NJZk5vdEZvdW5kKTtcbiAgICB9KSxcbiAgICBtZW1iZXJUb0pzU3RyaW5nOiByb3AoZnVuY3Rpb24obWVtYmVyTmFtZSl7XG4gICAgICByZXR1cm4gX19tZW1iZXJUb0pzU3RyaW5nKHRoaXMsIG1lbWJlck5hbWUpO1xuICAgIH0pLFxuICAgIG1lbWJlcklzU3RyaW5nOiByb3AoZnVuY3Rpb24obWVtYmVyTmFtZSwgdG9zc0lmTm90Rm91bmQ9dHJ1ZSl7XG4gICAgICByZXR1cm4gX19tZW1iZXJJc1N0cmluZyh0aGlzLCBtZW1iZXJOYW1lLCB0b3NzSWZOb3RGb3VuZCk7XG4gICAgfSksXG4gICAgbWVtYmVyS2V5OiBfX21lbWJlcktleVByb3AsXG4gICAgbWVtYmVyS2V5czogX19zdHJ1Y3RNZW1iZXJLZXlzLFxuICAgIG1lbWJlclNpZ25hdHVyZTogcm9wKGZ1bmN0aW9uKG1lbWJlck5hbWUsIGVtc2NyaXB0ZW5Gb3JtYXQ9ZmFsc2Upe1xuICAgICAgcmV0dXJuIF9fbWVtYmVyU2lnbmF0dXJlKHRoaXMsIG1lbWJlck5hbWUsIGVtc2NyaXB0ZW5Gb3JtYXQpO1xuICAgIH0pLFxuICAgIG1lbW9yeUR1bXA6IHJvcChfX21lbW9yeUR1bXApLFxuICAgIHBvaW50ZXI6IF9fcHRyUHJvcERlc2NyaXB0b3IsXG4gICAgc2V0TWVtYmVyQ1N0cmluZzogcm9wKGZ1bmN0aW9uKG1lbWJlck5hbWUsIHN0cil7XG4gICAgICByZXR1cm4gX19zZXRNZW1iZXJDU3RyaW5nKHRoaXMsIG1lbWJlck5hbWUsIHN0cik7XG4gICAgfSlcbiAgfSk7XG4gIFxuICBPYmplY3QuYXNzaWduKFN0cnVjdFR5cGUucHJvdG90eXBlLHtcbiAgICBhZGRPbkRpc3Bvc2U6IGZ1bmN0aW9uKC4uLnYpe1xuICAgICAgX19hZGRPbkRpc3Bvc2UodGhpcywuLi52KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdFR5cGUsIHtcbiAgICBhbGxvY0NTdHJpbmc6IHJvcChfX2FsbG9jQ1N0cmluZyksXG4gICAgaXNBOiByb3AoKHYpPT52IGluc3RhbmNlb2YgU3RydWN0VHlwZSksXG4gICAgaGFzRXh0ZXJuYWxQb2ludGVyOiByb3AoKHYpPT4odiBpbnN0YW5jZW9mIFN0cnVjdFR5cGUpICYmICEhdlt4UHRyUHJvcE5hbWVdKSxcbiAgICBtZW1iZXJLZXk6IF9fbWVtYmVyS2V5UHJvcFxuICB9KTtcblxuICBjb25zdCBpc051bWVyaWNWYWx1ZSA9ICh2KT0+TnVtYmVyLmlzRmluaXRlKHYpIHx8ICh2IGluc3RhbmNlb2YgKEJpZ0ludCB8fCBOdW1iZXIpKTtcblxuICBcbiAgY29uc3QgbWFrZU1lbWJlcldyYXBwZXIgPSBmdW5jdGlvbiBmKGN0b3IsbmFtZSwgZGVzY3Ipe1xuICAgIGlmKCFmLl8pe1xuICAgICAgXG4gICAgICBmLl8gPSB7Z2V0dGVyczoge30sIHNldHRlcnM6IHt9LCBzdzp7fX07XG4gICAgICBjb25zdCBhID0gWydpJywnYycsJ0MnLCdwJywnUCcsJ3MnLCdmJywnZCcsJ3YoKSddO1xuICAgICAgaWYoYmlnSW50RW5hYmxlZCkgYS5wdXNoKCdqJyk7XG4gICAgICBhLmZvckVhY2goZnVuY3Rpb24odil7XG4gICAgICAgIFxuICAgICAgICBmLl8uZ2V0dGVyc1t2XSA9IHNpZ0RWR2V0dGVyKHYpIDtcbiAgICAgICAgZi5fLnNldHRlcnNbdl0gPSBzaWdEVlNldHRlcih2KSA7XG4gICAgICAgIGYuXy5zd1t2XSA9IHNpZ0RWU2V0V3JhcHBlcih2KSAgO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByeFNpZzEgPSAvXltpcFBzamZkY0NdJC8sXG4gICAgICAgICAgICByeFNpZzIgPSAvXlt2aXBQc2pmZGNDXVxcKFtpcFBzamZkY0NdKlxcKSQvO1xuICAgICAgZi5zaWdDaGVjayA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwga2V5LHNpZyl7XG4gICAgICAgIGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpe1xuICAgICAgICAgIHRvc3Mob2JqLnN0cnVjdE5hbWUsJ2FscmVhZHkgaGFzIGEgcHJvcGVydHkgbmFtZWQnLGtleSsnLicpO1xuICAgICAgICB9XG4gICAgICAgIHJ4U2lnMS50ZXN0KHNpZykgfHwgcnhTaWcyLnRlc3Qoc2lnKVxuICAgICAgICAgIHx8IHRvc3MoXCJNYWxmb3JtZWQgc2lnbmF0dXJlIGZvclwiLFxuICAgICAgICAgICAgICAgICAgc1Byb3BOYW1lKG9iai5zdHJ1Y3ROYW1lLG5hbWUpK1wiOlwiLHNpZyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBjdG9yLm1lbWJlcktleShuYW1lKTtcbiAgICBmLnNpZ0NoZWNrKGN0b3IucHJvdG90eXBlLCBuYW1lLCBrZXksIGRlc2NyLnNpZ25hdHVyZSk7XG4gICAgZGVzY3Iua2V5ID0ga2V5O1xuICAgIGRlc2NyLm5hbWUgPSBuYW1lO1xuICAgIGNvbnN0IHNpZ0dseXBoID0gc2lnTGV0dGVyKGRlc2NyLnNpZ25hdHVyZSk7XG4gICAgY29uc3QgeFByb3BOYW1lID0gc1Byb3BOYW1lKGN0b3IucHJvdG90eXBlLnN0cnVjdE5hbWUsa2V5KTtcbiAgICBjb25zdCBkYmcgPSBjdG9yLnByb3RvdHlwZS5kZWJ1Z0ZsYWdzLl9fZmxhZ3M7XG4gICAgXG4gICAgY29uc3QgcHJvcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcHJvcC5jb25maWd1cmFibGUgPSBmYWxzZTtcbiAgICBwcm9wLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICBwcm9wLmdldCA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZihkYmcuZ2V0dGVyKXtcbiAgICAgICAgbG9nKFwiZGVidWcuZ2V0dGVyOlwiLGYuXy5nZXR0ZXJzW3NpZ0dseXBoXSxcImZvclwiLCBzaWdJUihzaWdHbHlwaCksXG4gICAgICAgICAgICB4UHJvcE5hbWUsJ0AnLCB0aGlzLnBvaW50ZXIsJysnLGRlc2NyLm9mZnNldCwnc3onLGRlc2NyLnNpemVvZik7XG4gICAgICB9XG4gICAgICBsZXQgcmMgPSAoXG4gICAgICAgIG5ldyBEYXRhVmlldyhoZWFwKCkuYnVmZmVyLCB0aGlzLnBvaW50ZXIgKyBkZXNjci5vZmZzZXQsIGRlc2NyLnNpemVvZilcbiAgICAgIClbZi5fLmdldHRlcnNbc2lnR2x5cGhdXSgwLCBpc0xpdHRsZUVuZGlhbik7XG4gICAgICBpZihkYmcuZ2V0dGVyKSBsb2coXCJkZWJ1Zy5nZXR0ZXI6XCIseFByb3BOYW1lLFwicmVzdWx0ID1cIixyYyk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfTtcbiAgICBpZihkZXNjci5yZWFkT25seSl7XG4gICAgICBwcm9wLnNldCA9IF9fcHJvcFRocm93T25TZXQoY3Rvci5wcm90b3R5cGUuc3RydWN0TmFtZSxrZXkpO1xuICAgIH1lbHNle1xuICAgICAgcHJvcC5zZXQgPSBmdW5jdGlvbih2KXtcbiAgICAgICAgaWYoZGJnLnNldHRlcil7XG4gICAgICAgICAgbG9nKFwiZGVidWcuc2V0dGVyOlwiLGYuXy5zZXR0ZXJzW3NpZ0dseXBoXSxcImZvclwiLCBzaWdJUihzaWdHbHlwaCksXG4gICAgICAgICAgICAgIHhQcm9wTmFtZSwnQCcsIHRoaXMucG9pbnRlciwnKycsZGVzY3Iub2Zmc2V0LCdzeicsZGVzY3Iuc2l6ZW9mLCB2KTtcbiAgICAgICAgfVxuICAgICAgICBpZighdGhpcy5wb2ludGVyKXtcbiAgICAgICAgICB0b3NzKFwiQ2Fubm90IHNldCBzdHJ1Y3QgcHJvcGVydHkgb24gZGlzcG9zZWQgaW5zdGFuY2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmKG51bGw9PT12KSB2ID0gMDtcbiAgICAgICAgZWxzZSB3aGlsZSghaXNOdW1lcmljVmFsdWUodikpe1xuICAgICAgICAgIGlmKGlzQXV0b1B0clNpZyhkZXNjci5zaWduYXR1cmUpICYmICh2IGluc3RhbmNlb2YgU3RydWN0VHlwZSkpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2ID0gdi5wb2ludGVyIHx8IDA7XG4gICAgICAgICAgICBpZihkYmcuc2V0dGVyKSBsb2coXCJkZWJ1Zy5zZXR0ZXI6XCIseFByb3BOYW1lLFwicmVzb2x2ZWQgdG9cIix2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3NzKFwiSW52YWxpZCB2YWx1ZSBmb3IgcG9pbnRlci10eXBlXCIseFByb3BOYW1lKycuJyk7XG4gICAgICAgIH1cbiAgICAgICAgKFxuICAgICAgICAgIG5ldyBEYXRhVmlldyhoZWFwKCkuYnVmZmVyLCB0aGlzLnBvaW50ZXIgKyBkZXNjci5vZmZzZXQsIGRlc2NyLnNpemVvZilcbiAgICAgICAgKVtmLl8uc2V0dGVyc1tzaWdHbHlwaF1dKDAsIGYuXy5zd1tzaWdHbHlwaF0odiksIGlzTGl0dGxlRW5kaWFuKTtcbiAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwga2V5LCBwcm9wKTtcbiAgfTtcbiAgXG4gIFxuICBjb25zdCBTdHJ1Y3RCaW5kZXIgPSBmdW5jdGlvbiBTdHJ1Y3RCaW5kZXIoc3RydWN0TmFtZSwgc3RydWN0SW5mbyl7XG4gICAgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgc3RydWN0SW5mbyA9IHN0cnVjdE5hbWU7XG4gICAgICBzdHJ1Y3ROYW1lID0gc3RydWN0SW5mby5uYW1lO1xuICAgIH1lbHNlIGlmKCFzdHJ1Y3RJbmZvLm5hbWUpe1xuICAgICAgc3RydWN0SW5mby5uYW1lID0gc3RydWN0TmFtZTtcbiAgICB9XG4gICAgaWYoIXN0cnVjdE5hbWUpIHRvc3MoXCJTdHJ1Y3QgbmFtZSBpcyByZXF1aXJlZC5cIik7XG4gICAgbGV0IGxhc3RNZW1iZXIgPSBmYWxzZTtcbiAgICBPYmplY3Qua2V5cyhzdHJ1Y3RJbmZvLm1lbWJlcnMpLmZvckVhY2goKGspPT57XG4gICAgICBcbiAgICAgIGNvbnN0IG0gPSBzdHJ1Y3RJbmZvLm1lbWJlcnNba107XG4gICAgICBpZighbS5zaXplb2YpIHRvc3Moc3RydWN0TmFtZSxcIm1lbWJlclwiLGssXCJpcyBtaXNzaW5nIHNpemVvZi5cIik7XG4gICAgICBlbHNlIGlmKG0uc2l6ZW9mPT09MSl7XG4gICAgICAgIChtLnNpZ25hdHVyZSA9PT0gJ2MnIHx8IG0uc2lnbmF0dXJlID09PSAnQycpIHx8XG4gICAgICAgICAgdG9zcyhcIlVuZXhwZWN0ZWQgc2l6ZW9mPT0xIG1lbWJlclwiLFxuICAgICAgICAgICAgICAgc1Byb3BOYW1lKHN0cnVjdEluZm8ubmFtZSxrKSxcbiAgICAgICAgICAgICAgIFwid2l0aCBzaWduYXR1cmVcIixtLnNpZ25hdHVyZSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZigwIT09KG0uc2l6ZW9mJTQpKXtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHN0cnVjdCBtZW1iZXIgZGVzY3JpcHRpb24gPVwiLG0sXCJmcm9tXCIsc3RydWN0SW5mbyk7XG4gICAgICAgICAgdG9zcyhzdHJ1Y3ROYW1lLFwibWVtYmVyXCIsayxcInNpemVvZiBpcyBub3QgYWxpZ25lZC4gc2l6ZW9mPVwiK20uc2l6ZW9mKTtcbiAgICAgICAgfVxuICAgICAgICBpZigwIT09KG0ub2Zmc2V0JTQpKXtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHN0cnVjdCBtZW1iZXIgZGVzY3JpcHRpb24gPVwiLG0sXCJmcm9tXCIsc3RydWN0SW5mbyk7XG4gICAgICAgICAgdG9zcyhzdHJ1Y3ROYW1lLFwibWVtYmVyXCIsayxcIm9mZnNldCBpcyBub3QgYWxpZ25lZC4gb2Zmc2V0PVwiK20ub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoIWxhc3RNZW1iZXIgfHwgbGFzdE1lbWJlci5vZmZzZXQgPCBtLm9mZnNldCkgbGFzdE1lbWJlciA9IG07XG4gICAgfSk7XG4gICAgaWYoIWxhc3RNZW1iZXIpIHRvc3MoXCJObyBtZW1iZXIgcHJvcGVydHkgZGVzY3JpcHRpb25zIGZvdW5kLlwiKTtcbiAgICBlbHNlIGlmKHN0cnVjdEluZm8uc2l6ZW9mIDwgbGFzdE1lbWJlci5vZmZzZXQrbGFzdE1lbWJlci5zaXplb2Ype1xuICAgICAgdG9zcyhcIkludmFsaWQgc3RydWN0IGNvbmZpZzpcIixzdHJ1Y3ROYW1lLFxuICAgICAgICAgICBcIm1heCBtZW1iZXIgb2Zmc2V0IChcIitsYXN0TWVtYmVyLm9mZnNldCtcIikgXCIsXG4gICAgICAgICAgIFwiZXh0ZW5kcyBwYXN0IGVuZCBvZiBzdHJ1Y3QgKHNpemVvZj1cIitzdHJ1Y3RJbmZvLnNpemVvZitcIikuXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWJ1Z0ZsYWdzID0gcm9wKFNCRi5fX21ha2VEZWJ1Z0ZsYWdzKFN0cnVjdEJpbmRlci5kZWJ1Z0ZsYWdzKSk7XG4gICAgXG4gICAgY29uc3QgU3RydWN0Q3RvciA9IGZ1bmN0aW9uIFN0cnVjdEN0b3IoZXh0ZXJuYWxNZW1vcnkpe1xuICAgICAgaWYoISh0aGlzIGluc3RhbmNlb2YgU3RydWN0Q3Rvcikpe1xuICAgICAgICB0b3NzKFwiVGhlXCIsc3RydWN0TmFtZSxcImNvbnN0cnVjdG9yIG1heSBvbmx5IGJlIGNhbGxlZCB2aWEgJ25ldycuXCIpO1xuICAgICAgfWVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgIGlmKGV4dGVybmFsTWVtb3J5IT09KGV4dGVybmFsTWVtb3J5fDApIHx8IGV4dGVybmFsTWVtb3J5PD0wKXtcbiAgICAgICAgICB0b3NzKFwiSW52YWxpZCBwb2ludGVyIHZhbHVlIGZvclwiLHN0cnVjdE5hbWUsXCJjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX19hbGxvY1N0cnVjdChTdHJ1Y3RDdG9yLCB0aGlzLCBleHRlcm5hbE1lbW9yeSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgX19hbGxvY1N0cnVjdChTdHJ1Y3RDdG9yLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN0cnVjdEN0b3Ise1xuICAgICAgZGVidWdGbGFnczogZGVidWdGbGFncyxcbiAgICAgIGlzQTogcm9wKCh2KT0+diBpbnN0YW5jZW9mIFN0cnVjdEN0b3IpLFxuICAgICAgbWVtYmVyS2V5OiBfX21lbWJlcktleVByb3AsXG4gICAgICBtZW1iZXJLZXlzOiBfX3N0cnVjdE1lbWJlcktleXMsXG4gICAgICBtZXRob2RJbmZvRm9yS2V5OiByb3AoZnVuY3Rpb24obUtleSl7XG4gICAgICB9KSxcbiAgICAgIHN0cnVjdEluZm86IHJvcChzdHJ1Y3RJbmZvKSxcbiAgICAgIHN0cnVjdE5hbWU6IHJvcChzdHJ1Y3ROYW1lKVxuICAgIH0pO1xuICAgIFN0cnVjdEN0b3IucHJvdG90eXBlID0gbmV3IFN0cnVjdFR5cGUoc3RydWN0TmFtZSwgc3RydWN0SW5mbywgcm9wKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTdHJ1Y3RDdG9yLnByb3RvdHlwZSx7XG4gICAgICBkZWJ1Z0ZsYWdzOiBkZWJ1Z0ZsYWdzLFxuICAgICAgY29uc3RydWN0b3I6IHJvcChTdHJ1Y3RDdG9yKVxuICAgICAgXG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMoc3RydWN0SW5mby5tZW1iZXJzKS5mb3JFYWNoKFxuICAgICAgKG5hbWUpPT5tYWtlTWVtYmVyV3JhcHBlcihTdHJ1Y3RDdG9yLCBuYW1lLCBzdHJ1Y3RJbmZvLm1lbWJlcnNbbmFtZV0pXG4gICAgKTtcbiAgICByZXR1cm4gU3RydWN0Q3RvcjtcbiAgfTtcbiAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUgPSBTdHJ1Y3RUeXBlO1xuICBTdHJ1Y3RCaW5kZXIuY29uZmlnID0gY29uZmlnO1xuICBTdHJ1Y3RCaW5kZXIuYWxsb2NDU3RyaW5nID0gX19hbGxvY0NTdHJpbmc7XG4gIGlmKCFTdHJ1Y3RCaW5kZXIuZGVidWdGbGFncyl7XG4gICAgU3RydWN0QmluZGVyLmRlYnVnRmxhZ3MgPSBTQkYuX19tYWtlRGVidWdGbGFncyhTQkYuZGVidWdGbGFncyk7XG4gIH1cbiAgcmV0dXJuIFN0cnVjdEJpbmRlcjtcbn07XG5cblxuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oc3FsaXRlMyl7XG4gICd1c2Ugc3RyaWN0JztcbiAgY29uc3QgdG9zcyA9ICguLi5hcmdzKT0+e3Rocm93IG5ldyBFcnJvcihhcmdzLmpvaW4oJyAnKSl9O1xuICBjb25zdCB0b3NzMyA9IHNxbGl0ZTMuU1FMaXRlM0Vycm9yLnRvc3M7XG4gIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGksIHdhc20gPSBzcWxpdGUzLndhc20sIHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcih3YXNtKTtcbiAgZGVsZXRlIGdsb2JhbFRoaXMuV2hXYXNtVXRpbEluc3RhbGxlcjtcblxuICBpZigwKXtcbiAgICBcbiAgICBcbiAgICBjb25zdCBkZWFsbG9jID0gd2FzbS5leHBvcnRzW3NxbGl0ZTMuY29uZmlnLmRlYWxsb2NFeHBvcnROYW1lXTtcbiAgICBjb25zdCBuRnVuYyA9IHdhc20uZnVuY3Rpb25UYWJsZSgpLmxlbmd0aDtcbiAgICBsZXQgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBuRnVuYzsgKytpKXtcbiAgICAgIGNvbnN0IGUgPSB3YXNtLmZ1bmN0aW9uRW50cnkoaSk7XG4gICAgICBpZihkZWFsbG9jID09PSBlKXtcbiAgICAgICAgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGRlYWxsb2MgIT09IHdhc20uZnVuY3Rpb25FbnRyeShjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpKXtcbiAgICAgIHRvc3MoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IGZpbmQgZnVuY3Rpb24gcG9pbnRlciBmb3IgU1FMSVRFX1dBU01fREVBTExPQy5cIik7XG4gICAgfVxuICB9XG5cbiAgXG4gIHdhc20uYmluZGluZ1NpZ25hdHVyZXMgPSBbXG4gICAgXG4gICAgW1wic3FsaXRlM19hZ2dyZWdhdGVfY29udGV4dFwiLFwidm9pZCpcIiwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiaW50XCJdLFxuICAgIFxuICAgIFxuICAgIFtcInNxbGl0ZTNfYmluZF9kb3VibGVcIixcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIiwgXCJmNjRcIl0sXG4gICAgW1wic3FsaXRlM19iaW5kX2ludFwiLFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2JpbmRfbnVsbFwiLHVuZGVmaW5lZCwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfY291bnRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfYmluZF9wYXJhbWV0ZXJfaW5kZXhcIixcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM19iaW5kX3BvaW50ZXJcIiwgXCJpbnRcIixcbiAgICAgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCIsIFwiKlwiLCBcInN0cmluZzpzdGF0aWNcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfYnVzeV9oYW5kbGVyXCIsXCJpbnRcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBzaWduYXR1cmU6ICdpKHBpKScsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2LGFyZ0luZGV4KT0+YXJndlswXVxuICAgICAgfSksXG4gICAgICBcIipcIlxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfYnVzeV90aW1lb3V0XCIsXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcImludFwiXSxcbiAgICBcbiAgICBcbiAgICBbXCJzcWxpdGUzX2NoYW5nZXNcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX2NsZWFyX2JpbmRpbmdzXCIsXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfY29sbGF0aW9uX25lZWRlZFwiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwiKlwiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fYmxvYlwiLFwiKlwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fYnl0ZXNcIixcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fY291bnRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX2RvdWJsZVwiLFwiZjY0XCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl9pbnRcIixcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fbmFtZVwiLFwic3RyaW5nXCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl90ZXh0XCIsXCJzdHJpbmdcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfY29sdW1uX3R5cGVcIixcImludFwiLCBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19jb2x1bW5fdmFsdWVcIixcInNxbGl0ZTNfdmFsdWUqXCIsIFwic3FsaXRlM19zdG10KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbW1pdF9ob29rXCIsIFwidm9pZCpcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiAnc3FsaXRlM19jb21taXRfaG9vaycsXG4gICAgICAgIHNpZ25hdHVyZTogJ2kocCknLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndik9PmFyZ3ZbMF1cbiAgICAgIH0pLFxuICAgICAgJyonXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19jb21waWxlb3B0aW9uX2dldFwiLCBcInN0cmluZ1wiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2NvbXBpbGVvcHRpb25fdXNlZFwiLCBcImludFwiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX2NvbXBsZXRlXCIsIFwiaW50XCIsIFwic3RyaW5nOmZsZXhpYmxlXCJdLFxuICAgIFtcInNxbGl0ZTNfY29udGV4dF9kYl9oYW5kbGVcIiwgXCJzcWxpdGUzKlwiLCBcInNxbGl0ZTNfY29udGV4dCpcIl0sXG5cbiAgICBcbiAgICBcbiAgICBbXCJzcWxpdGUzX2RhdGFfY291bnRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfZGJfZmlsZW5hbWVcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX2RiX2hhbmRsZVwiLCBcInNxbGl0ZTMqXCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX2RiX25hbWVcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2RiX3N0YXR1c1wiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwiaW50XCIsIFwiKlwiLCBcIipcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19lcnJjb2RlXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19lcnJtc2dcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX2Vycm9yX29mZnNldFwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfZXJyc3RyXCIsIFwic3RyaW5nXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfZXhlY1wiLCBcImludFwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsIFwic3RyaW5nOmZsZXhpYmxlXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIHNpZ25hdHVyZTogJ2kocGlwcCknLFxuICAgICAgICBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICBsZXQgYU5hbWVzO1xuICAgICAgICAgIHJldHVybiAocFZvaWQsIG5Db2xzLCBwQ29sVmFscywgcENvbE5hbWVzKT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgYVZhbHMgPSB3YXNtLmNBcmd2VG9KcyhuQ29scywgcENvbFZhbHMpO1xuICAgICAgICAgICAgICBpZighYU5hbWVzKSBhTmFtZXMgPSB3YXNtLmNBcmd2VG9KcyhuQ29scywgcENvbE5hbWVzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFWYWxzLCBhTmFtZXMpIHwgMDtcbiAgICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiBlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFwiKlwiLCBcIioqXCJcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX2V4cGFuZGVkX3NxbFwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19leHRlbmRlZF9lcnJjb2RlXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19leHRlbmRlZF9yZXN1bHRfY29kZXNcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2ZpbGVfY29udHJvbFwiLCBcImludFwiLCBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiaW50XCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX2ZpbmFsaXplXCIsIFwiaW50XCIsIFwic3FsaXRlM19zdG10KlwiXSxcbiAgICBbXCJzcWxpdGUzX2ZyZWVcIiwgdW5kZWZpbmVkLFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX2dldF9hdXRvY29tbWl0XCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19nZXRfYXV4ZGF0YVwiLCBcIipcIiwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfaW5pdGlhbGl6ZVwiLCB1bmRlZmluZWRdLFxuICAgIFxuICAgIFtcInNxbGl0ZTNfa2V5d29yZF9jb3VudFwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX2tleXdvcmRfbmFtZVwiLCBcImludFwiLCBbXCJpbnRcIiwgXCIqKlwiLCBcIipcIl1dLFxuICAgIFtcInNxbGl0ZTNfa2V5d29yZF9jaGVja1wiLCBcImludFwiLCBbXCJzdHJpbmdcIiwgXCJpbnRcIl1dLFxuICAgIFtcInNxbGl0ZTNfbGlidmVyc2lvblwiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX2xpYnZlcnNpb25fbnVtYmVyXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfbGltaXRcIiwgXCJpbnRcIiwgW1wic3FsaXRlMypcIiwgXCJpbnRcIiwgXCJpbnRcIl1dLFxuICAgIFtcInNxbGl0ZTNfbWFsbG9jXCIsIFwiKlwiLFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfb3BlblwiLCBcImludFwiLCBcInN0cmluZ1wiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19vcGVuX3YyXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsIFwiKlwiLCBcImludFwiLCBcInN0cmluZ1wiXSxcbiAgICBcbiAgICBcbiAgICBbXCJzcWxpdGUzX3Byb2dyZXNzX2hhbmRsZXJcIiwgdW5kZWZpbmVkLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsIFwiaW50XCIsIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgbmFtZTogJ3hQcm9ncmVzc0hhbmRsZXInLFxuICAgICAgICBzaWduYXR1cmU6ICdpKHApJyxcbiAgICAgICAgYmluZFNjb3BlOiAnY29udGV4dCcsXG4gICAgICAgIGNvbnRleHRLZXk6IChhcmd2LGFyZ0luZGV4KT0+YXJndlswXVxuICAgICAgfSksIFwiKlwiXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM19yZWFsbG9jXCIsIFwiKlwiLFwiKlwiLFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzZXRcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2Jsb2JcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCIqXCIsIFwiaW50XCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9kb3VibGVcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJmNjRcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfZXJyb3JcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfZXJyb3JfY29kZVwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9lcnJvcl9ub21lbVwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9lcnJvcl90b29iaWdcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfaW50XCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X251bGxcIiwgdW5kZWZpbmVkLCBcInNxbGl0ZTNfY29udGV4dCpcIl0sXG4gICAgW1wic3FsaXRlM19yZXN1bHRfcG9pbnRlclwiLCB1bmRlZmluZWQsXG4gICAgIFwic3FsaXRlM19jb250ZXh0KlwiLCBcIipcIiwgXCJzdHJpbmc6c3RhdGljXCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF9zdWJ0eXBlXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX3ZhbHVlKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF90ZXh0XCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX2NvbnRleHQqXCIsIFwic3RyaW5nXCIsIFwiaW50XCIsIFwiKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Jlc3VsdF96ZXJvYmxvYlwiLCB1bmRlZmluZWQsIFwic3FsaXRlM19jb250ZXh0KlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3JvbGxiYWNrX2hvb2tcIiwgXCJ2b2lkKlwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6ICdzcWxpdGUzX3JvbGxiYWNrX2hvb2snLFxuICAgICAgICBzaWduYXR1cmU6ICd2KHApJyxcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YpPT5hcmd2WzBdXG4gICAgICB9KSxcbiAgICAgICcqJ1xuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfc2V0X2F1dGhvcml6ZXJcIiwgXCJpbnRcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiBcInNxbGl0ZTNfc2V0X2F1dGhvcml6ZXI6OnhBdXRoXCIsXG4gICAgICAgIHNpZ25hdHVyZTogXCJpKHBpXCIrXCJzc3NzKVwiLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndiwgYXJnSW5kZXgpPT5hcmd2WzBdLFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICByZXR1cm4gKHBWLCBpQ29kZSwgczAsIHMxLCBzMiwgczMpPT57XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIHMwID0gczAgJiYgd2FzbS5jc3RyVG9KcyhzMCk7IHMxID0gczEgJiYgd2FzbS5jc3RyVG9KcyhzMSk7XG4gICAgICAgICAgICAgIHMyID0gczIgJiYgd2FzbS5jc3RyVG9KcyhzMik7IHMzID0gczMgJiYgd2FzbS5jc3RyVG9KcyhzMyk7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhwViwgaUNvZGUsIHMwLCBzMSwgczIsIHMzKSB8fCAwO1xuICAgICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgICByZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBcIipcIlxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfc2V0X2F1eGRhdGFcIiwgdW5kZWZpbmVkLCBbXG4gICAgICBcInNxbGl0ZTNfY29udGV4dCpcIiwgXCJpbnRcIiwgXCIqXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6ICd4RGVzdHJveUF1eERhdGEnLFxuICAgICAgICBzaWduYXR1cmU6ICd2KCopJyxcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YsIGFyZ0luZGV4KT0+YXJndlswXVxuICAgICAgfSlcbiAgICBdXSxcbiAgICBbXCJzcWxpdGUzX3NodXRkb3duXCIsIHVuZGVmaW5lZF0sXG4gICAgW1wic3FsaXRlM19zb3VyY2VpZFwiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX3NxbFwiLCBcInN0cmluZ1wiLCBcInNxbGl0ZTNfc3RtdCpcIl0sXG4gICAgW1wic3FsaXRlM19zdGF0dXNcIiwgXCJpbnRcIiwgXCJpbnRcIiwgXCIqXCIsIFwiKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3N0ZXBcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCJdLFxuICAgIFtcInNxbGl0ZTNfc3RtdF9pc2V4cGxhaW5cIiwgXCJpbnRcIiwgW1wic3FsaXRlM19zdG10KlwiXV0sXG4gICAgW1wic3FsaXRlM19zdG10X3JlYWRvbmx5XCIsIFwiaW50XCIsIFtcInNxbGl0ZTNfc3RtdCpcIl1dLFxuICAgIFtcInNxbGl0ZTNfc3RtdF9zdGF0dXNcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfc3RyZ2xvYlwiLCBcImludFwiLCBcInN0cmluZ1wiLFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfc3RyaWNtcFwiLCBcImludFwiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcbiAgICBbXCJzcWxpdGUzX3N0cmxpa2VcIiwgXCJpbnRcIiwgXCJzdHJpbmdcIiwgXCJzdHJpbmdcIixcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3N0cm5pY21wXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsIFwic3RyaW5nXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfdGFibGVfY29sdW1uX21ldGFkYXRhXCIsIFwiaW50XCIsXG4gICAgIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCJzdHJpbmdcIiwgXCJzdHJpbmdcIixcbiAgICAgXCIqKlwiLCBcIioqXCIsIFwiKlwiLCBcIipcIiwgXCIqXCJdLFxuICAgIFtcInNxbGl0ZTNfdG90YWxfY2hhbmdlc1wiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfdHJhY2VfdjJcIiwgXCJpbnRcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLCBcImludFwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiAnc3FsaXRlM190cmFjZV92Mjo6Y2FsbGJhY2snLFxuICAgICAgICBzaWduYXR1cmU6ICdpKGlwcHApJyxcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YsYXJnSW5kZXgpPT5hcmd2WzBdXG4gICAgICB9KSxcbiAgICAgIFwiKlwiXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM190eG5fc3RhdGVcIiwgXCJpbnRcIiwgW1wic3FsaXRlMypcIixcInN0cmluZ1wiXV0sXG4gICAgXG4gICAgW1wic3FsaXRlM191cmlfYm9vbGVhblwiLCBcImludFwiLCBcInNxbGl0ZTNfZmlsZW5hbWVcIiwgXCJzdHJpbmdcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM191cmlfa2V5XCIsIFwic3RyaW5nXCIsIFwic3FsaXRlM19maWxlbmFtZVwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3VyaV9wYXJhbWV0ZXJcIiwgXCJzdHJpbmdcIiwgXCJzcWxpdGUzX2ZpbGVuYW1lXCIsIFwic3RyaW5nXCJdLFxuICAgIFtcInNxbGl0ZTNfdXNlcl9kYXRhXCIsXCJ2b2lkKlwiLCBcInNxbGl0ZTNfY29udGV4dCpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9ibG9iXCIsIFwiKlwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfYnl0ZXNcIixcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfZG91YmxlXCIsXCJmNjRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2R1cFwiLCBcInNxbGl0ZTNfdmFsdWUqXCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9mcmVlXCIsIHVuZGVmaW5lZCwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX2Zyb21iaW5kXCIsIFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9pbnRcIixcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfbm9jaGFuZ2VcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ZhbHVlX251bWVyaWNfdHlwZVwiLCBcImludFwiLCBcInNxbGl0ZTNfdmFsdWUqXCJdLFxuICAgIFtcInNxbGl0ZTNfdmFsdWVfcG9pbnRlclwiLCBcIipcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiLCBcInN0cmluZzpzdGF0aWNcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9zdWJ0eXBlXCIsIFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV90ZXh0XCIsIFwic3RyaW5nXCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192YWx1ZV90eXBlXCIsIFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192ZnNfZmluZFwiLCBcIipcIiwgXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM192ZnNfcmVnaXN0ZXJcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZmcypcIiwgXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM192ZnNfdW5yZWdpc3RlclwiLCBcImludFwiLCBcInNxbGl0ZTNfdmZzKlwiXVxuICBdO1xuXG4gIGlmKGZhbHNlICYmIHdhc20uY29tcGlsZU9wdGlvblVzZWQoJ1NRTElURV9FTkFCTEVfTk9STUFMSVpFJykpe1xuICAgIFxuICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMucHVzaChbXCJzcWxpdGUzX25vcm1hbGl6ZWRfc3FsXCIsIFwic3RyaW5nXCIsIFwic3FsaXRlM19zdG10KlwiXSk7XG4gIH1cblxuICBpZih3YXNtLmV4cG9ydHMuc3FsaXRlM19hY3RpdmF0ZV9zZWUgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5wdXNoKFxuICAgICAgW1wic3FsaXRlM19rZXlcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcImludFwiXSxcbiAgICAgIFtcInNxbGl0ZTNfa2V5X3YyXCIsXCJpbnRcIixcInNxbGl0ZTMqXCIsXCJzdHJpbmdcIixcIipcIixcImludFwiXSxcbiAgICAgIFtcInNxbGl0ZTNfcmVrZXlcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcImludFwiXSxcbiAgICAgIFtcInNxbGl0ZTNfcmVrZXlfdjJcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcIipcIiwgXCJpbnRcIl0sXG4gICAgICBbXCJzcWxpdGUzX2FjdGl2YXRlX3NlZVwiLCB1bmRlZmluZWQsIFwic3RyaW5nXCJdXG4gICAgKTtcbiAgfVxuICBcbiAgd2FzbS5iaW5kaW5nU2lnbmF0dXJlcy5pbnQ2NCA9IFtcbiAgICBbXCJzcWxpdGUzX2JpbmRfaW50NjRcIixcImludFwiLCBbXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCIsIFwiaTY0XCJdXSxcbiAgICBbXCJzcWxpdGUzX2NoYW5nZXM2NFwiLFwiaTY0XCIsIFtcInNxbGl0ZTMqXCJdXSxcbiAgICBbXCJzcWxpdGUzX2NvbHVtbl9pbnQ2NFwiLFwiaTY0XCIsIFtcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIl1dLFxuICAgIFtcInNxbGl0ZTNfY3JlYXRlX21vZHVsZVwiLCBcImludFwiLFxuICAgICBbXCJzcWxpdGUzKlwiLFwic3RyaW5nXCIsXCJzcWxpdGUzX21vZHVsZSpcIixcIipcIl1dLFxuICAgIFtcInNxbGl0ZTNfY3JlYXRlX21vZHVsZV92MlwiLCBcImludFwiLFxuICAgICBbXCJzcWxpdGUzKlwiLFwic3RyaW5nXCIsXCJzcWxpdGUzX21vZHVsZSpcIixcIipcIixcIipcIl1dLFxuICAgIFtcInNxbGl0ZTNfZGVjbGFyZV92dGFiXCIsIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsIFwic3RyaW5nOmZsZXhpYmxlXCJdXSxcbiAgICBbXCJzcWxpdGUzX2Rlc2VyaWFsaXplXCIsIFwiaW50XCIsIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCIqXCIsIFwiaTY0XCIsIFwiaTY0XCIsIFwiaW50XCJdXG4gICAgLFxuICAgIFtcInNxbGl0ZTNfZHJvcF9tb2R1bGVzXCIsIFwiaW50XCIsIFtcInNxbGl0ZTMqXCIsIFwiKipcIl1dLFxuICAgIFtcInNxbGl0ZTNfbGFzdF9pbnNlcnRfcm93aWRcIiwgXCJpNjRcIiwgW1wic3FsaXRlMypcIl1dLFxuICAgIFtcInNxbGl0ZTNfbWFsbG9jNjRcIiwgXCIqXCIsXCJpNjRcIl0sXG4gICAgW1wic3FsaXRlM19tc2l6ZVwiLCBcImk2NFwiLCBcIipcIl0sXG4gICAgW1wic3FsaXRlM19vdmVybG9hZF9mdW5jdGlvblwiLCBcImludFwiLCBbXCJzcWxpdGUzKlwiLFwic3RyaW5nXCIsXCJpbnRcIl1dLFxuICAgIFtcInNxbGl0ZTNfcHJldXBkYXRlX2Jsb2J3cml0ZVwiLCBcImludFwiLCBcInNxbGl0ZTMqXCJdLFxuICAgIFtcInNxbGl0ZTNfcHJldXBkYXRlX2NvdW50XCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM19wcmV1cGRhdGVfZGVwdGhcIiwgXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX3ByZXVwZGF0ZV9ob29rXCIsIFwiKlwiLCBbXG4gICAgICBcInNxbGl0ZTMqXCIsXG4gICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgIG5hbWU6ICdzcWxpdGUzX3ByZXVwZGF0ZV9ob29rJyxcbiAgICAgICAgc2lnbmF0dXJlOiBcInYocHBpcHBqailcIixcbiAgICAgICAgY29udGV4dEtleTogKGFyZ3YpPT5hcmd2WzBdLFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICByZXR1cm4gKHAsZGIsb3AsekRiLHpUYmwsaUtleTEsaUtleTIpPT57XG4gICAgICAgICAgICBjYWxsYmFjayhwLCBkYiwgb3AsIHdhc20uY3N0clRvSnMoekRiKSwgd2FzbS5jc3RyVG9Kcyh6VGJsKSxcbiAgICAgICAgICAgICAgICAgICAgIGlLZXkxLCBpS2V5Mik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBcIipcIlxuICAgIF1dLFxuICAgIFtcInNxbGl0ZTNfcHJldXBkYXRlX25ld1wiLCBcImludFwiLCBbXCJzcWxpdGUzKlwiLCBcImludFwiLCBcIioqXCJdXSxcbiAgICBbXCJzcWxpdGUzX3ByZXVwZGF0ZV9vbGRcIiwgXCJpbnRcIiwgW1wic3FsaXRlMypcIiwgXCJpbnRcIiwgXCIqKlwiXV0sXG4gICAgW1wic3FsaXRlM19yZWFsbG9jNjRcIiwgXCIqXCIsXCIqXCIsIFwiaTY0XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X2ludDY0XCIsIHVuZGVmaW5lZCwgXCIqXCIsIFwiaTY0XCJdLFxuICAgIFtcInNxbGl0ZTNfcmVzdWx0X3plcm9ibG9iNjRcIiwgXCJpbnRcIiwgXCIqXCIsIFwiaTY0XCJdLFxuICAgIFtcInNxbGl0ZTNfc2VyaWFsaXplXCIsXCIqXCIsIFwic3FsaXRlMypcIiwgXCJzdHJpbmdcIiwgXCIqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfc2V0X2xhc3RfaW5zZXJ0X3Jvd2lkXCIsIHVuZGVmaW5lZCwgW1wic3FsaXRlMypcIiwgXCJpNjRcIl1dLFxuICAgIFtcInNxbGl0ZTNfc3RhdHVzNjRcIiwgXCJpbnRcIiwgXCJpbnRcIiwgXCIqXCIsIFwiKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3RvdGFsX2NoYW5nZXM2NFwiLCBcImk2NFwiLCBbXCJzcWxpdGUzKlwiXV0sXG4gICAgW1wic3FsaXRlM191cGRhdGVfaG9va1wiLCBcIipcIiwgW1xuICAgICAgXCJzcWxpdGUzKlwiLFxuICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICBuYW1lOiAnc3FsaXRlM191cGRhdGVfaG9vaycsXG4gICAgICAgIHNpZ25hdHVyZTogXCJ2KGlpcHBqKVwiLFxuICAgICAgICBjb250ZXh0S2V5OiAoYXJndik9PmFyZ3ZbMF0sXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIHJldHVybiAocCxvcCx6MCx6MSxyb3dpZCk9PntcbiAgICAgICAgICAgIGNhbGxiYWNrKHAsIG9wLCB3YXNtLmNzdHJUb0pzKHowKSwgd2FzbS5jc3RyVG9Kcyh6MSksIHJvd2lkKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFwiKlwiXG4gICAgXV0sXG4gICAgW1wic3FsaXRlM191cmlfaW50NjRcIiwgXCJpNjRcIiwgW1wic3FsaXRlM19maWxlbmFtZVwiLCBcInN0cmluZ1wiLCBcImk2NFwiXV0sXG4gICAgW1wic3FsaXRlM192YWx1ZV9pbnQ2NFwiLFwiaTY0XCIsIFwic3FsaXRlM192YWx1ZSpcIl0sXG4gICAgW1wic3FsaXRlM192dGFiX2NvbGxhdGlvblwiLFwic3RyaW5nXCIsXCJzcWxpdGUzX2luZGV4X2luZm8qXCIsXCJpbnRcIl0sXG4gICAgW1wic3FsaXRlM192dGFiX2Rpc3RpbmN0XCIsXCJpbnRcIiwgXCJzcWxpdGUzX2luZGV4X2luZm8qXCJdLFxuICAgIFtcInNxbGl0ZTNfdnRhYl9pblwiLFwiaW50XCIsIFwic3FsaXRlM19pbmRleF9pbmZvKlwiLCBcImludFwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3Z0YWJfaW5fZmlyc3RcIiwgXCJpbnRcIiwgXCJzcWxpdGUzX3ZhbHVlKlwiLCBcIioqXCJdLFxuICAgIFtcInNxbGl0ZTNfdnRhYl9pbl9uZXh0XCIsIFwiaW50XCIsIFwic3FsaXRlM192YWx1ZSpcIiwgXCIqKlwiXSxcbiAgICBcbiAgICBbXCJzcWxpdGUzX3Z0YWJfbm9jaGFuZ2VcIixcImludFwiLCBcInNxbGl0ZTNfY29udGV4dCpcIl0sXG4gICAgW1wic3FsaXRlM192dGFiX29uX2NvbmZsaWN0XCIsXCJpbnRcIiwgXCJzcWxpdGUzKlwiXSxcbiAgICBbXCJzcWxpdGUzX3Z0YWJfcmhzX3ZhbHVlXCIsXCJpbnRcIiwgXCJzcWxpdGUzX2luZGV4X2luZm8qXCIsIFwiaW50XCIsIFwiKipcIl1cbiAgXTtcblxuICBcbiAgaWYod2FzbS5iaWdJbnRFbmFibGVkICYmICEhd2FzbS5leHBvcnRzLnNxbGl0ZTNjaGFuZ2Vncm91cF9hZGQpe1xuICAgIFxuICAgIFxuICAgIGNvbnN0IF9faXBzUHJveHkgPSB7XG4gICAgICBzaWduYXR1cmU6ICdpKHBzKScsXG4gICAgICBjYWxsUHJveHk6KGNhbGxiYWNrKT0+e1xuICAgICAgICByZXR1cm4gKHAscyk9PntcbiAgICAgICAgICB0cnl7cmV0dXJuIGNhbGxiYWNrKHAsIHdhc20uY3N0clRvSnMocykpIHwgMH1cbiAgICAgICAgICBjYXRjaChlKXtyZXR1cm4gZS5yZXN1bHRDb2RlIHx8IGNhcGkuU1FMSVRFX0VSUk9SfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhc20uYmluZGluZ1NpZ25hdHVyZXMuaW50NjQucHVzaCguLi5bXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGQnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZWdyb3VwKicsICdpbnQnLCAndm9pZConXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9hZGRfc3RybScsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9kZWxldGUnLCB1bmRlZmluZWQsIFsnc3FsaXRlM19jaGFuZ2Vncm91cConXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9uZXcnLCAnaW50JywgWycqKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZWdyb3VwX291dHB1dCcsICdpbnQnLCBbJ3NxbGl0ZTNfY2hhbmdlZ3JvdXAqJywgJ2ludConLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2Vncm91cF9vdXRwdXRfc3RybScsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzX2NoYW5nZWdyb3VwKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneE91dHB1dCcsIHNpZ25hdHVyZTogJ2kocHBpKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2FwcGx5JywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTMqJywgJ2ludCcsICd2b2lkKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneEZpbHRlcicsIGJpbmRTY29wZTogJ3RyYW5zaWVudCcsIC4uLl9faXBzUHJveHlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneENvbmZsaWN0Jywgc2lnbmF0dXJlOiAnaShwaXApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfc3RybScsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJywgYmluZFNjb3BlOiAndHJhbnNpZW50JywgLi4uX19pcHNQcm94eVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4Q29uZmxpY3QnLCBzaWduYXR1cmU6ICdpKHBpcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9hcHBseV92MicsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzKicsICdpbnQnLCAndm9pZConLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hGaWx0ZXInLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnLCAuLi5fX2lwc1Byb3h5XG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hDb25mbGljdCcsIHNpZ25hdHVyZTogJ2kocGlwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsICcqKicsICdpbnQqJywgJ2ludCdcblxuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfYXBwbHlfdjJfc3RybScsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJywgYmluZFNjb3BlOiAndHJhbnNpZW50JywgLi4uX19pcHNQcm94eVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4Q29uZmxpY3QnLCBzaWduYXR1cmU6ICdpKHBpcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConLCAnKionLCAnaW50KicsICdpbnQnXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9jb25jYXQnLCAnaW50JywgWydpbnQnLCd2b2lkKicsICdpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9jb25jYXRfc3RybScsICdpbnQnLCBbXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0QScsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0QicsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneE91dHB1dCcsIHNpZ25hdHVyZTogJ2kocHBpKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2NvbmZsaWN0JywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnaW50JywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X2ZpbmFsaXplJywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfZmtfY29uZmxpY3RzJywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnaW50KiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9pbnZlcnQnLCAnaW50JywgWydpbnQnLCAndm9pZConLCAnaW50KicsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9pbnZlcnRfc3RybScsICdpbnQnLCBbXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBuYW1lOiAneElucHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4T3V0cHV0Jywgc2lnbmF0dXJlOiAnaShwcGkpJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfbmV3JywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnaW50JywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X25leHQnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9vbGQnLCAnaW50JywgWydzcWxpdGUzX2NoYW5nZXNldF9pdGVyKicsICdpbnQnLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNjaGFuZ2VzZXRfb3AnLCAnaW50JywgW1xuICAgICAgICAnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnKionLCAnaW50KicsICdpbnQqJywnaW50KidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3BrJywgJ2ludCcsIFsnc3FsaXRlM19jaGFuZ2VzZXRfaXRlcionLCAnKionLCAnaW50KiddXSxcbiAgICAgIFsnc3FsaXRlM2NoYW5nZXNldF9zdGFydCcsICdpbnQnLCBbJyoqJywgJ2ludCcsICcqJ11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnKionLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKidcbiAgICAgIF1dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyJywgJ2ludCcsIFsnKionLCAnaW50JywgJyonLCAnaW50J11dLFxuICAgICAgWydzcWxpdGUzY2hhbmdlc2V0X3N0YXJ0X3YyX3N0cm0nLCAnaW50JywgW1xuICAgICAgICAnKionLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hJbnB1dCcsIHNpZ25hdHVyZTogJ2kocHBwKScsIGJpbmRTY29wZTogJ3RyYW5zaWVudCdcbiAgICAgICAgfSksXG4gICAgICAgICd2b2lkKicsICdpbnQnXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fYXR0YWNoJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdzdHJpbmcnXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NoYW5nZXNldCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50KicsICcqKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY2hhbmdlc2V0X3NpemUnLCAnaTY0JywgWydzcWxpdGUzX3Nlc3Npb24qJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9jaGFuZ2VzZXRfc3RybScsICdpbnQnLCBbXG4gICAgICAgICdzcWxpdGUzX3Nlc3Npb24qJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4T3V0cHV0Jywgc2lnbmF0dXJlOiAnaShwcHApJywgYmluZFNjb3BlOiAndHJhbnNpZW50J1xuICAgICAgICB9KSxcbiAgICAgICAgJ3ZvaWQqJ1xuICAgICAgXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2NvbmZpZycsICdpbnQnLCBbJ2ludCcsICd2b2lkKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fY3JlYXRlJywgJ2ludCcsIFsnc3FsaXRlMyonLCAnc3RyaW5nJywgJyoqJ11dLFxuICAgICAgXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2RpZmYnLCAnaW50JywgWydzcWxpdGUzX3Nlc3Npb24qJywgJ3N0cmluZycsICdzdHJpbmcnLCAnKionXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX2VuYWJsZScsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50J11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9pbmRpcmVjdCcsICdpbnQnLCBbJ3NxbGl0ZTNfc2Vzc2lvbionLCAnaW50J11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9pc2VtcHR5JywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKiddXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fbWVtb3J5X3VzZWQnLCAnaTY0JywgWydzcWxpdGUzX3Nlc3Npb24qJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9vYmplY3RfY29uZmlnJywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICdpbnQnLCAndm9pZConXV0sXG4gICAgICBbJ3NxbGl0ZTNzZXNzaW9uX3BhdGNoc2V0JywgJ2ludCcsIFsnc3FsaXRlM19zZXNzaW9uKicsICcqJywgJyoqJ11dLFxuICAgICAgWydzcWxpdGUzc2Vzc2lvbl9wYXRjaHNldF9zdHJtJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTNfc2Vzc2lvbionLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7XG4gICAgICAgICAgbmFtZTogJ3hPdXRwdXQnLCBzaWduYXR1cmU6ICdpKHBwcCknLCBiaW5kU2NvcGU6ICd0cmFuc2llbnQnXG4gICAgICAgIH0pLFxuICAgICAgICAndm9pZConXG4gICAgICBdXSxcbiAgICAgIFsnc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyJywgdW5kZWZpbmVkLCBbXG4gICAgICAgICdzcWxpdGUzX3Nlc3Npb24qJyxcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe1xuICAgICAgICAgIG5hbWU6ICd4RmlsdGVyJywgLi4uX19pcHNQcm94eSxcbiAgICAgICAgICBjb250ZXh0S2V5OiAoYXJndixhcmdJbmRleCk9PmFyZ3ZbMF1cbiAgICAgICAgfSksXG4gICAgICAgICcqJ1xuICAgICAgXV1cbiAgICBdKTtcbiAgfVxuXG4gIFxuICB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLndhc20gPSBbXG4gICAgW1wic3FsaXRlM193YXNtX2RiX3Jlc2V0XCIsIFwiaW50XCIsIFwic3FsaXRlMypcIl0sXG4gICAgW1wic3FsaXRlM193YXNtX2RiX3Zmc1wiLCBcInNxbGl0ZTNfdmZzKlwiLCBcInNxbGl0ZTMqXCIsXCJzdHJpbmdcIl0sXG4gICAgW1wic3FsaXRlM193YXNtX3Zmc19jcmVhdGVfZmlsZVwiLCBcImludFwiLFxuICAgICBcInNxbGl0ZTNfdmZzKlwiLFwic3RyaW5nXCIsXCIqXCIsIFwiaW50XCJdLFxuICAgIFtcInNxbGl0ZTNfd2FzbV9wb3NpeF9jcmVhdGVfZmlsZVwiLCBcImludFwiLCBcInN0cmluZ1wiLFwiKlwiLCBcImludFwiXSxcbiAgICBbXCJzcWxpdGUzX3dhc21fdmZzX3VubGlua1wiLCBcImludFwiLCBcInNxbGl0ZTNfdmZzKlwiLFwic3RyaW5nXCJdXG4gIF07XG5cbiAgXG4gIHNxbGl0ZTMuU3RydWN0QmluZGVyID0gZ2xvYmFsVGhpcy5KYWNjd2FieXQoe1xuICAgIGhlYXA6IDAgPyB3YXNtLm1lbW9yeSA6IHdhc20uaGVhcDh1LFxuICAgIGFsbG9jOiB3YXNtLmFsbG9jLFxuICAgIGRlYWxsb2M6IHdhc20uZGVhbGxvYyxcbiAgICBiaWdJbnRFbmFibGVkOiB3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgbWVtYmVyUHJlZml4OiAgJyQnXG4gIH0pO1xuICBkZWxldGUgZ2xvYmFsVGhpcy5KYWNjd2FieXQ7XG5cbiAge1xuXG4gICAgXG4gICAgY29uc3QgX194U3RyaW5nID0gd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzdHJpbmcnKTtcbiAgICB3YXNtLnhXcmFwLmFyZ0FkYXB0ZXIoXG4gICAgICAnc3RyaW5nOmZsZXhpYmxlJywgKHYpPT5fX3hTdHJpbmcodXRpbC5mbGV4aWJsZVN0cmluZyh2KSlcbiAgICApO1xuXG4gICAgXG4gICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKFxuICAgICAgJ3N0cmluZzpzdGF0aWMnLFxuICAgICAgZnVuY3Rpb24odil7XG4gICAgICAgIGlmKHdhc20uaXNQdHIodikpIHJldHVybiB2O1xuICAgICAgICB2ID0gJycrdjtcbiAgICAgICAgbGV0IHJjID0gdGhpc1t2XTtcbiAgICAgICAgcmV0dXJuIHJjIHx8ICh0aGlzW3ZdID0gd2FzbS5hbGxvY0NTdHJpbmcodikpO1xuICAgICAgfS5iaW5kKE9iamVjdC5jcmVhdGUobnVsbCkpXG4gICAgKTtcblxuICAgIFxuICAgIGNvbnN0IF9feEFyZ1B0ciA9IHdhc20ueFdyYXAuYXJnQWRhcHRlcignKicpO1xuICAgIGNvbnN0IG5pbFR5cGUgPSBmdW5jdGlvbigpe307XG4gICAgd2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzX2ZpbGVuYW1lJywgX194QXJnUHRyKVxuICAgICgnc3FsaXRlM19jb250ZXh0KicsIF9feEFyZ1B0cilcbiAgICAoJ3NxbGl0ZTNfdmFsdWUqJywgX194QXJnUHRyKVxuICAgICgndm9pZConLCBfX3hBcmdQdHIpXG4gICAgKCdzcWxpdGUzX2NoYW5nZWdyb3VwKicsIF9feEFyZ1B0cilcbiAgICAoJ3NxbGl0ZTNfY2hhbmdlc2V0X2l0ZXIqJywgX194QXJnUHRyKVxuICAgIFxuICAgICgnc3FsaXRlM19zZXNzaW9uKicsIF9feEFyZ1B0cilcbiAgICAoJ3NxbGl0ZTNfc3RtdConLCAodik9PlxuICAgICAgX194QXJnUHRyKCh2IGluc3RhbmNlb2YgKHNxbGl0ZTM/Lm9vMT8uU3RtdCB8fCBuaWxUeXBlKSlcbiAgICAgICAgICAgPyB2LnBvaW50ZXIgOiB2KSlcbiAgICAoJ3NxbGl0ZTMqJywgKHYpPT5cbiAgICAgIF9feEFyZ1B0cigodiBpbnN0YW5jZW9mIChzcWxpdGUzPy5vbzE/LkRCIHx8IG5pbFR5cGUpKVxuICAgICAgICAgICA/IHYucG9pbnRlciA6IHYpKVxuICAgICgnc3FsaXRlM19pbmRleF9pbmZvKicsICh2KT0+XG4gICAgICBfX3hBcmdQdHIoKHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX2luZGV4X2luZm8gfHwgbmlsVHlwZSkpXG4gICAgICAgICAgID8gdi5wb2ludGVyIDogdikpXG4gICAgKCdzcWxpdGUzX21vZHVsZSonLCAodik9PlxuICAgICAgX194QXJnUHRyKCh2IGluc3RhbmNlb2YgKGNhcGkuc3FsaXRlM19tb2R1bGUgfHwgbmlsVHlwZSkpXG4gICAgICAgICAgID8gdi5wb2ludGVyIDogdikpXG4gICAgXG4gICAgKCdzcWxpdGUzX3ZmcyonLCAodik9PntcbiAgICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIHYpe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM192ZnNfZmluZCh2KVxuICAgICAgICAgIHx8IHNxbGl0ZTMuU1FMaXRlM0Vycm9yLnRvc3MoXG4gICAgICAgICAgICBjYXBpLlNRTElURV9OT1RGT1VORCxcbiAgICAgICAgICAgIFwiVW5rbm93biBzcWxpdGUzX3ZmcyBuYW1lOlwiLCB2XG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX3hBcmdQdHIoKHYgaW5zdGFuY2VvZiAoY2FwaS5zcWxpdGUzX3ZmcyB8fCBuaWxUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgPyB2LnBvaW50ZXIgOiB2KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IF9feFJjUHRyID0gd2FzbS54V3JhcC5yZXN1bHRBZGFwdGVyKCcqJyk7XG4gICAgd2FzbS54V3JhcC5yZXN1bHRBZGFwdGVyKCdzcWxpdGUzKicsIF9feFJjUHRyKVxuICAgICgnc3FsaXRlM19jb250ZXh0KicsIF9feFJjUHRyKVxuICAgICgnc3FsaXRlM19zdG10KicsIF9feFJjUHRyKVxuICAgICgnc3FsaXRlM192YWx1ZSonLCBfX3hSY1B0cilcbiAgICAoJ3NxbGl0ZTNfdmZzKicsIF9feFJjUHRyKVxuICAgICgndm9pZConLCBfX3hSY1B0cik7XG5cbiAgICBcbiAgICBpZigwID09PSB3YXNtLmV4cG9ydHMuc3FsaXRlM19zdGVwLmxlbmd0aCl7XG4gICAgICBcbiAgICAgIHdhc20ueFdyYXAuZG9BcmdjQ2hlY2sgPSBmYWxzZTtcbiAgICAgIHNxbGl0ZTMuY29uZmlnLndhcm4oXG4gICAgICAgIFwiRGlzYWJsaW5nIHNxbGl0ZTMud2FzbS54V3JhcC5kb0FyZ2NDaGVjayBkdWUgdG8gZW52aXJvbm1lbnRhbCBxdWlya3MuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZvcihjb25zdCBlIG9mIHdhc20uYmluZGluZ1NpZ25hdHVyZXMpe1xuICAgICAgY2FwaVtlWzBdXSA9IHdhc20ueFdyYXAuYXBwbHkobnVsbCwgZSk7XG4gICAgfVxuICAgIGZvcihjb25zdCBlIG9mIHdhc20uYmluZGluZ1NpZ25hdHVyZXMud2FzbSl7XG4gICAgICB3YXNtW2VbMF1dID0gd2FzbS54V3JhcC5hcHBseShudWxsLCBlKTtcbiAgICB9XG5cbiAgICBcbiAgICBjb25zdCBmSTY0RGlzYWJsZWQgPSBmdW5jdGlvbihmbmFtZSl7XG4gICAgICByZXR1cm4gKCk9PnRvc3MoZm5hbWUrXCIoKSBpcyB1bmF2YWlsYWJsZSBkdWUgdG8gbGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwib2YgQmlnSW50IHN1cHBvcnQgaW4gdGhpcyBidWlsZC5cIik7XG4gICAgfTtcbiAgICBmb3IoY29uc3QgZSBvZiB3YXNtLmJpbmRpbmdTaWduYXR1cmVzLmludDY0KXtcbiAgICAgIGNhcGlbZVswXV0gPSB3YXNtLmJpZ0ludEVuYWJsZWRcbiAgICAgICAgPyB3YXNtLnhXcmFwLmFwcGx5KG51bGwsIGUpXG4gICAgICAgIDogZkk2NERpc2FibGVkKGVbMF0pO1xuICAgIH1cblxuICAgIFxuICAgIGRlbGV0ZSB3YXNtLmJpbmRpbmdTaWduYXR1cmVzO1xuXG4gICAgaWYod2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcil7XG4gICAgICBjb25zdCBfX2RiX2VyciA9IHdhc20ueFdyYXAoXG4gICAgICAgICdzcWxpdGUzX3dhc21fZGJfZXJyb3InLCAnaW50JywgJ3NxbGl0ZTMqJywgJ2ludCcsICdzdHJpbmcnXG4gICAgICApO1xuICAgICAgXG4gICAgICB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvciA9IGZ1bmN0aW9uKHBEYiwgcmVzdWx0Q29kZSwgbWVzc2FnZSl7XG4gICAgICAgIGlmKHJlc3VsdENvZGUgaW5zdGFuY2VvZiBzcWxpdGUzLldhc21BbGxvY0Vycm9yKXtcbiAgICAgICAgICByZXN1bHRDb2RlID0gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgICAgbWVzc2FnZSA9IDAgO1xuICAgICAgICB9ZWxzZSBpZihyZXN1bHRDb2RlIGluc3RhbmNlb2YgRXJyb3Ipe1xuICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnK3Jlc3VsdENvZGU7XG4gICAgICAgICAgcmVzdWx0Q29kZSA9IChyZXN1bHRDb2RlLnJlc3VsdENvZGUgfHwgY2FwaS5TUUxJVEVfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwRGIgPyBfX2RiX2VycihwRGIsIHJlc3VsdENvZGUsIG1lc3NhZ2UpIDogcmVzdWx0Q29kZTtcbiAgICAgIH07XG4gICAgfWVsc2V7XG4gICAgICB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvciA9IGZ1bmN0aW9uKHBEYixlcnJDb2RlLG1zZyl7XG4gICAgICAgIGNvbnNvbGUud2FybihcInNxbGl0ZTNfd2FzbV9kYl9lcnJvcigpIGlzIG5vdCBleHBvcnRlZC5cIixhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZXJyQ29kZTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGNvbnN0IGNKc29uID0gd2FzbS54Q2FsbCgnc3FsaXRlM193YXNtX2VudW1fanNvbicpO1xuICAgIGlmKCFjSnNvbil7XG4gICAgICB0b3NzKFwiTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IGluY3JlYXNlIHNxbGl0ZTNfd2FzbV9lbnVtX2pzb24oKSdzXCIsXG4gICAgICAgICAgIFwic3RhdGljIGJ1ZmZlciBzaXplIVwiKTtcbiAgICB9XG4gICAgXG4gICAgd2FzbS5jdHlwZSA9IEpTT04ucGFyc2Uod2FzbS5jc3RyVG9KcyhjSnNvbikpO1xuICAgIFxuICAgIGNvbnN0IGRlZmluZUdyb3VwcyA9IFsnYWNjZXNzJywgJ2F1dGhvcml6ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnYmxvYkZpbmFsaXplcnMnLCAnY2hhbmdlc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZycsICdkYXRhVHlwZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGJDb25maWcnLCAnZGJTdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZW5jb2RpbmdzJywgJ2ZjbnRsJywgJ2Zsb2NrJywgJ2lvQ2FwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbWl0cycsICdvcGVuRmxhZ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAncHJlcGFyZUZsYWdzJywgJ3Jlc3VsdENvZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNTdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnc3RtdFN0YXR1cycsICdzeW5jRmxhZ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAndHJhY2UnLCAndHhuU3RhdGUnLCAndWRmRmxhZ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAndmVyc2lvbicgXTtcbiAgICBpZih3YXNtLmJpZ0ludEVuYWJsZWQpe1xuICAgICAgZGVmaW5lR3JvdXBzLnB1c2goJ3NlcmlhbGl6ZScsICdzZXNzaW9uJywgJ3Z0YWInKTtcbiAgICB9XG4gICAgZm9yKGNvbnN0IHQgb2YgZGVmaW5lR3JvdXBzKXtcbiAgICAgIGZvcihjb25zdCBlIG9mIE9iamVjdC5lbnRyaWVzKHdhc20uY3R5cGVbdF0pKXtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBjYXBpW2VbMF1dID0gZVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoIXdhc20uZnVuY3Rpb25FbnRyeShjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpKXtcbiAgICAgIHRvc3MoXCJJbnRlcm5hbCBlcnJvcjogY2Fubm90IHJlc29sdmUgZXhwb3J0ZWQgZnVuY3Rpb25cIixcbiAgICAgICAgICAgXCJlbnRyeSBTUUxJVEVfV0FTTV9ERUFMTE9DICg9PVwiK2NhcGkuU1FMSVRFX1dBU01fREVBTExPQytcIikuXCIpO1xuICAgIH1cbiAgICBjb25zdCBfX3JjTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IoY29uc3QgdCBvZiBbJ3Jlc3VsdENvZGVzJ10pe1xuICAgICAgZm9yKGNvbnN0IGUgb2YgT2JqZWN0LmVudHJpZXMod2FzbS5jdHlwZVt0XSkpe1xuICAgICAgICBfX3JjTWFwW2VbMV1dID0gZVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0ciA9IChyYyk9Pl9fcmNNYXBbcmNdO1xuICAgIFxuICAgIGNvbnN0IG5vdFRoZXNlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICAgIFxuICAgICAgV2FzbVRlc3RTdHJ1Y3Q6IHRydWUsXG4gICAgICBcbiAgICAgIHNxbGl0ZTNfa3Z2ZnNfbWV0aG9kczogIXV0aWwuaXNVSVRocmVhZCgpLFxuICAgICAgXG4gICAgICBzcWxpdGUzX2luZGV4X2luZm86ICF3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICBzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQ6ICF3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICBzcWxpdGUzX2luZGV4X29yZGVyYnk6ICF3YXNtLmJpZ0ludEVuYWJsZWQsXG4gICAgICBzcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2U6ICF3YXNtLmJpZ0ludEVuYWJsZWRcbiAgICB9KTtcbiAgICBmb3IoY29uc3QgcyBvZiB3YXNtLmN0eXBlLnN0cnVjdHMpe1xuICAgICAgaWYoIW5vdFRoZXNlW3MubmFtZV0pe1xuICAgICAgICBjYXBpW3MubmFtZV0gPSBzcWxpdGUzLlN0cnVjdEJpbmRlcihzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoY2FwaS5zcWxpdGUzX2luZGV4X2luZm8pe1xuICAgICAgXG4gICAgICBmb3IoY29uc3QgayBvZiBbJ3NxbGl0ZTNfaW5kZXhfY29uc3RyYWludCcsXG4gICAgICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfaW5kZXhfb3JkZXJieScsXG4gICAgICAgICAgICAgICAgICAgICAgJ3NxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZSddKXtcbiAgICAgICAgY2FwaS5zcWxpdGUzX2luZGV4X2luZm9ba10gPSBjYXBpW2tdO1xuICAgICAgICBkZWxldGUgY2FwaVtrXTtcbiAgICAgIH1cbiAgICAgIGNhcGkuc3FsaXRlM192dGFiX2NvbmZpZyA9IHdhc20ueFdyYXAoXG4gICAgICAgICdzcWxpdGUzX3dhc21fdnRhYl9jb25maWcnLCdpbnQnLFtcbiAgICAgICAgICAnc3FsaXRlMyonLCAnaW50JywgJ2ludCddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIFxuICBjb25zdCBfX2RiQXJnY01pc21hdGNoID0gKHBEYixmLG4pPT57XG4gICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKHBEYiwgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmK1wiKCkgcmVxdWlyZXMgXCIrbitcIiBhcmd1bWVudFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMT09PW4/XCJcIjoncycpK1wiLlwiKTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19lcnJFbmNvZGluZyA9IChwRGIpPT57XG4gICAgcmV0dXJuIHV0aWwuc3FsaXRlM193YXNtX2RiX2Vycm9yKFxuICAgICAgcERiLCBjYXBpLlNRTElURV9GT1JNQVQsIFwiU1FMSVRFX1VURjggaXMgdGhlIG9ubHkgc3VwcG9ydGVkIGVuY29kaW5nLlwiXG4gICAgKTtcbiAgfTtcblxuICBcbiAgY29uc3QgX19hcmdQRGIgPSAocERiKT0+d2FzbS54V3JhcC5hcmdBZGFwdGVyKCdzcWxpdGUzKicpKHBEYik7XG4gIGNvbnN0IF9fYXJnU3RyID0gKHN0cik9Pndhc20uaXNQdHIoc3RyKSA/IHdhc20uY3N0clRvSnMoc3RyKSA6IHN0cjtcbiAgY29uc3QgX19kYkNsZWFudXBNYXAgPSBmdW5jdGlvbihcbiAgICBwRGIsIG1vZGVcbiAgKXtcbiAgICBwRGIgPSBfX2FyZ1BEYihwRGIpO1xuICAgIGxldCBtID0gdGhpcy5kYk1hcC5nZXQocERiKTtcbiAgICBpZighbW9kZSl7XG4gICAgICB0aGlzLmRiTWFwLmRlbGV0ZShwRGIpO1xuICAgICAgcmV0dXJuIG07XG4gICAgfWVsc2UgaWYoIW0gJiYgbW9kZT4wKXtcbiAgICAgIHRoaXMuZGJNYXAuc2V0KHBEYiwgKG0gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9LmJpbmQoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHtcbiAgICBkYk1hcDogbmV3IE1hcFxuICB9KSk7XG5cbiAgX19kYkNsZWFudXBNYXAuYWRkQ29sbGF0aW9uID0gZnVuY3Rpb24ocERiLCBuYW1lKXtcbiAgICBjb25zdCBtID0gX19kYkNsZWFudXBNYXAocERiLCAxKTtcbiAgICBpZighbS5jb2xsYXRpb24pIG0uY29sbGF0aW9uID0gbmV3IFNldDtcbiAgICBtLmNvbGxhdGlvbi5hZGQoX19hcmdTdHIobmFtZSkudG9Mb3dlckNhc2UoKSk7XG4gIH07XG5cbiAgX19kYkNsZWFudXBNYXAuX2FkZFVERiA9IGZ1bmN0aW9uKHBEYiwgbmFtZSwgYXJpdHksIG1hcCl7XG4gICAgXG4gICAgbmFtZSA9IF9fYXJnU3RyKG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgIGlmKCF1KSBtYXAuc2V0KG5hbWUsICh1ID0gbmV3IFNldCkpO1xuICAgIHUuYWRkKChhcml0eTwwKSA/IC0xIDogYXJpdHkpO1xuICB9O1xuXG4gIF9fZGJDbGVhbnVwTWFwLmFkZEZ1bmN0aW9uID0gZnVuY3Rpb24ocERiLCBuYW1lLCBhcml0eSl7XG4gICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgaWYoIW0udWRmKSBtLnVkZiA9IG5ldyBNYXA7XG4gICAgdGhpcy5fYWRkVURGKHBEYiwgbmFtZSwgYXJpdHksIG0udWRmKTtcbiAgfTtcblxuICBfX2RiQ2xlYW51cE1hcC5hZGRXaW5kb3dGdW5jID0gZnVuY3Rpb24ocERiLCBuYW1lLCBhcml0eSl7XG4gICAgY29uc3QgbSA9IF9fZGJDbGVhbnVwTWFwKHBEYiwgMSk7XG4gICAgaWYoIW0ud3VkZikgbS53dWRmID0gbmV3IE1hcDtcbiAgICB0aGlzLl9hZGRVREYocERiLCBuYW1lLCBhcml0eSwgbS53dWRmKTtcbiAgfTtcblxuICBcbiAgX19kYkNsZWFudXBNYXAuY2xlYW51cCA9IGZ1bmN0aW9uKHBEYil7XG4gICAgcERiID0gX19hcmdQRGIocERiKTtcbiAgICBcbiAgICBcbiAgICBjb25zdCBjbG9zZUFyZ3MgPSBbcERiXTtcbiAgICBmb3IoY29uc3QgbmFtZSBvZiBbXG4gICAgICAnc3FsaXRlM19idXN5X2hhbmRsZXInLFxuICAgICAgJ3NxbGl0ZTNfY29tbWl0X2hvb2snLFxuICAgICAgJ3NxbGl0ZTNfcHJldXBkYXRlX2hvb2snLFxuICAgICAgJ3NxbGl0ZTNfcHJvZ3Jlc3NfaGFuZGxlcicsXG4gICAgICAnc3FsaXRlM19yb2xsYmFja19ob29rJyxcbiAgICAgICdzcWxpdGUzX3NldF9hdXRob3JpemVyJyxcbiAgICAgICdzcWxpdGUzX3RyYWNlX3YyJyxcbiAgICAgICdzcWxpdGUzX3VwZGF0ZV9ob29rJ1xuICAgIF0pIHtcbiAgICAgIGNvbnN0IHggPSB3YXNtLmV4cG9ydHNbbmFtZV07XG4gICAgICBjbG9zZUFyZ3MubGVuZ3RoID0geC5sZW5ndGhcbiAgICAgIDtcbiAgICAgIHRyeXsgY2FwaVtuYW1lXSguLi5jbG9zZUFyZ3MpIH1cbiAgICAgIGNhdGNoKGUpe1xuICAgICAgICBjb25zb2xlLndhcm4oXCJjbG9zZS10aW1lIGNhbGwgb2ZcIixuYW1lK1wiKFwiLGNsb3NlQXJncyxcIikgdGhyZXc6XCIsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG0gPSBfX2RiQ2xlYW51cE1hcChwRGIsIDApO1xuICAgIGlmKCFtKSByZXR1cm47XG4gICAgaWYobS5jb2xsYXRpb24pe1xuICAgICAgZm9yKGNvbnN0IG5hbWUgb2YgbS5jb2xsYXRpb24pe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjIoXG4gICAgICAgICAgICBwRGIsIG5hbWUsIGNhcGkuU1FMSVRFX1VURjgsIDAsIDAsIDBcbiAgICAgICAgICApO1xuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBtLmNvbGxhdGlvbjtcbiAgICB9XG4gICAgbGV0IGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgMjsgKytpKXsgXG4gICAgICBjb25zdCBmbWFwID0gaSA/IG0ud3VkZiA6IG0udWRmO1xuICAgICAgaWYoIWZtYXApIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZnVuYyA9IGlcbiAgICAgICAgICAgID8gY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb25cbiAgICAgICAgICAgIDogY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MjtcbiAgICAgIGZvcihjb25zdCBlIG9mIGZtYXApe1xuICAgICAgICBjb25zdCBuYW1lID0gZVswXSwgYXJpdGllcyA9IGVbMV07XG4gICAgICAgIGNvbnN0IGZhcmdzID0gW3BEYiwgbmFtZSwgMCwgY2FwaS5TUUxJVEVfVVRGOCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGlmKGkpIGZhcmdzLnB1c2goMCk7XG4gICAgICAgIGZvcihjb25zdCBhcml0eSBvZiBhcml0aWVzKXtcbiAgICAgICAgICB0cnl7IGZhcmdzWzJdID0gYXJpdHk7IGZ1bmMuYXBwbHkobnVsbCwgZmFyZ3MpOyB9XG4gICAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgICB9XG4gICAgICAgIGFyaXRpZXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIGZtYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgZGVsZXRlIG0udWRmO1xuICAgIGRlbGV0ZSBtLnd1ZGY7XG4gIH07XG5cbiAge1xuICAgIGNvbnN0IF9fc3FsaXRlM0Nsb3NlVjIgPSB3YXNtLnhXcmFwKFwic3FsaXRlM19jbG9zZV92MlwiLCBcImludFwiLCBcInNxbGl0ZTMqXCIpO1xuICAgIGNhcGkuc3FsaXRlM19jbG9zZV92MiA9IGZ1bmN0aW9uKHBEYil7XG4gICAgICBpZigxIT09YXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLCAnc3FsaXRlM19jbG9zZV92MicsIDEpO1xuICAgICAgaWYocERiKXtcbiAgICAgICAgdHJ5e19fZGJDbGVhbnVwTWFwLmNsZWFudXAocERiKX0gY2F0Y2goZSl7fVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9fc3FsaXRlM0Nsb3NlVjIocERiKTtcbiAgICB9O1xuICB9XG5cbiAgaWYoY2FwaS5zcWxpdGUzc2Vzc2lvbl90YWJsZV9maWx0ZXIpe1xuICAgIGNvbnN0IF9fc3FsaXRlM1Nlc3Npb25EZWxldGUgPSB3YXNtLnhXcmFwKFxuICAgICAgJ3NxbGl0ZTNzZXNzaW9uX2RlbGV0ZScsIHVuZGVmaW5lZCwgWydzcWxpdGUzX3Nlc3Npb24qJ11cbiAgICApO1xuICAgIGNhcGkuc3FsaXRlM3Nlc3Npb25fZGVsZXRlID0gZnVuY3Rpb24ocFNlc3Npb24pe1xuICAgICAgaWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzc2Vzc2lvbl9kZWxldGUnLCAxKTtcbiAgICAgICAgXG4gICAgICB9XG4gICAgICBlbHNlIGlmKHBTZXNzaW9uKXtcbiAgICAgICAgXG4gICAgICAgIGNhcGkuc3FsaXRlM3Nlc3Npb25fdGFibGVfZmlsdGVyKHBTZXNzaW9uLCAwLCAwKTtcbiAgICAgIH1cbiAgICAgIF9fc3FsaXRlM1Nlc3Npb25EZWxldGUocFNlc3Npb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgXG4gICAgY29uc3QgY29udGV4dEtleSA9IChhcmd2LGFyZ0luZGV4KT0+e1xuICAgICAgcmV0dXJuICdhcmd2WycrYXJnSW5kZXgrJ106Jythcmd2WzBdK1xuICAgICAgICAnOicrd2FzbS5jc3RyVG9Kcyhhcmd2WzFdKS50b0xvd2VyQ2FzZSgpXG4gICAgfTtcbiAgICBjb25zdCBfX3NxbGl0ZTNDcmVhdGVDb2xsYXRpb25WMiA9IHdhc20ueFdyYXAoXG4gICAgICAnc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyJywgJ2ludCcsIFtcbiAgICAgICAgJ3NxbGl0ZTMqJywgJ3N0cmluZycsICdpbnQnLCAnKicsXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBcbiAgICAgICAgICBuYW1lOiAneENvbXBhcmUnLCBzaWduYXR1cmU6ICdpKHBpcGlwKScsIGNvbnRleHRLZXlcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyKHtcbiAgICAgICAgICBcbiAgICAgICAgICBuYW1lOiAneERlc3Ryb3knLCBzaWduYXR1cmU6ICd2KHApJywgY29udGV4dEtleVxuICAgICAgICB9KVxuICAgICAgXVxuICAgICk7XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2NvbGxhdGlvbl92MiA9IGZ1bmN0aW9uKHBEYix6TmFtZSxlVGV4dFJlcCxwQXJnLHhDb21wYXJlLHhEZXN0cm95KXtcbiAgICAgIGlmKDYhPT1hcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb25fdjInLCA2KTtcbiAgICAgIGVsc2UgaWYoIDAgPT09IChlVGV4dFJlcCAmIDB4ZikgKXtcbiAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgIH1lbHNlIGlmKCBjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpICl7XG4gICAgICAgIHJldHVybiBfX2VyckVuY29kaW5nKHBEYik7XG4gICAgICB9XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IHJjID0gX19zcWxpdGUzQ3JlYXRlQ29sbGF0aW9uVjIocERiLCB6TmFtZSwgZVRleHRSZXAsIHBBcmcsIHhDb21wYXJlLCB4RGVzdHJveSk7XG4gICAgICAgIGlmKDA9PT1yYyAmJiB4Q29tcGFyZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgICBfX2RiQ2xlYW51cE1hcC5hZGRDb2xsYXRpb24ocERiLCB6TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IocERiLCBlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24gPSAocERiLHpOYW1lLGVUZXh0UmVwLHBBcmcseENvbXBhcmUpPT57XG4gICAgICByZXR1cm4gKDU9PT1hcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICA/IGNhcGkuc3FsaXRlM19jcmVhdGVfY29sbGF0aW9uX3YyKHBEYix6TmFtZSxlVGV4dFJlcCxwQXJnLHhDb21wYXJlLDApXG4gICAgICAgIDogX19kYkFyZ2NNaXNtYXRjaChwRGIsICdzcWxpdGUzX2NyZWF0ZV9jb2xsYXRpb24nLCA1KTtcbiAgICB9O1xuXG4gIH1cblxuICB7XG4gICAgXG4gICAgY29uc3QgY29udGV4dEtleSA9IGZ1bmN0aW9uKGFyZ3YsYXJnSW5kZXgpe1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgYXJndlswXVxuICAgICAgICAgICsnOicrKGFyZ3ZbMl0gPCAwID8gLTEgOiBhcmd2WzJdKVxuICAgICAgICAgICsnOicrYXJnSW5kZXhcbiAgICAgICAgICArJzonK3dhc20uY3N0clRvSnMoYXJndlsxXSkudG9Mb3dlckNhc2UoKVxuICAgICAgKVxuICAgIH07XG5cbiAgICBcbiAgICBjb25zdCBfX2NmUHJveHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgIHhJbnZlcnNlQW5kU3RlcDoge1xuICAgICAgICBzaWduYXR1cmU6J3YocGlwKScsIGNvbnRleHRLZXksXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIHJldHVybiAocEN0eCwgYXJnYywgcEFyZ3YpPT57XG4gICAgICAgICAgICB0cnl7IGNhbGxiYWNrKHBDdHgsIC4uLmNhcGkuc3FsaXRlM192YWx1ZXNfdG9fanMoYXJnYywgcEFyZ3YpKSB9XG4gICAgICAgICAgICBjYXRjaChlKXsgY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcyhwQ3R4LCBlKSB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHhGaW5hbEFuZFZhbHVlOiB7XG4gICAgICAgIHNpZ25hdHVyZTondihwKScsIGNvbnRleHRLZXksXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIHJldHVybiAocEN0eCk9PntcbiAgICAgICAgICAgIHRyeXsgY2FwaS5zcWxpdGUzX3Jlc3VsdF9qcyhwQ3R4LCBjYWxsYmFjayhwQ3R4KSkgfVxuICAgICAgICAgICAgY2F0Y2goZSl7IGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgZSkgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4RnVuYzoge1xuICAgICAgICBzaWduYXR1cmU6J3YocGlwKScsIGNvbnRleHRLZXksXG4gICAgICAgIGNhbGxQcm94eTogKGNhbGxiYWNrKT0+e1xuICAgICAgICAgIHJldHVybiAocEN0eCwgYXJnYywgcEFyZ3YpPT57XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfanMoXG4gICAgICAgICAgICAgICAgcEN0eCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwQ3R4LCAuLi5jYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzKGFyZ2MsIHBBcmd2KSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNhcGkuc3FsaXRlM19yZXN1bHRfZXJyb3JfanMocEN0eCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHhEZXN0cm95OiB7XG4gICAgICAgIHNpZ25hdHVyZTondihwKScsIGNvbnRleHRLZXksXG4gICAgICAgIFxuICAgICAgICBjYWxsUHJveHk6IChjYWxsYmFjayk9PntcbiAgICAgICAgICByZXR1cm4gKHBWb2lkKT0+e1xuICAgICAgICAgICAgdHJ5eyBjYWxsYmFjayhwVm9pZCkgfVxuICAgICAgICAgICAgY2F0Y2goZSl7IGNvbnNvbGUuZXJyb3IoXCJVREYgeERlc3Ryb3kgbWV0aG9kIHRocmV3OlwiLGUpIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBfX3NxbGl0ZTNDcmVhdGVGdW5jdGlvbiA9IHdhc20ueFdyYXAoXG4gICAgICBcInNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyXCIsIFwiaW50XCIsIFtcbiAgICAgICAgXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLCBcImludFwiLFxuICAgICAgICBcImludFwiLCBcIipcIixcbiAgICAgICAgbmV3IHdhc20ueFdyYXAuRnVuY1B0ckFkYXB0ZXIoe25hbWU6ICd4RnVuYycsIC4uLl9fY2ZQcm94eS54RnVuY30pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hTdGVwJywgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hGaW5hbCcsIC4uLl9fY2ZQcm94eS54RmluYWxBbmRWYWx1ZX0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hEZXN0cm95JywgLi4uX19jZlByb3h5LnhEZXN0cm95fSlcbiAgICAgIF1cbiAgICApO1xuXG4gICAgY29uc3QgX19zcWxpdGUzQ3JlYXRlV2luZG93RnVuY3Rpb24gPSB3YXNtLnhXcmFwKFxuICAgICAgXCJzcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb25cIiwgXCJpbnRcIiwgW1xuICAgICAgICBcInNxbGl0ZTMqXCIsIFwic3RyaW5nXCIsIFwiaW50XCIsXG4gICAgICAgIFwiaW50XCIsIFwiKlwiLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hTdGVwJywgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hGaW5hbCcsIC4uLl9fY2ZQcm94eS54RmluYWxBbmRWYWx1ZX0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hWYWx1ZScsIC4uLl9fY2ZQcm94eS54RmluYWxBbmRWYWx1ZX0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hJbnZlcnNlJywgLi4uX19jZlByb3h5LnhJbnZlcnNlQW5kU3RlcH0pLFxuICAgICAgICBuZXcgd2FzbS54V3JhcC5GdW5jUHRyQWRhcHRlcih7bmFtZTogJ3hEZXN0cm95JywgLi4uX19jZlByb3h5LnhEZXN0cm95fSlcbiAgICAgIF1cbiAgICApO1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MiA9IGZ1bmN0aW9uIGYoXG4gICAgICBwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCwgcEFwcCxcbiAgICAgIHhGdW5jLCAgIFxuICAgICAgeFN0ZXAsICAgXG4gICAgICB4RmluYWwsICBcbiAgICAgIHhEZXN0cm95IFxuICAgICl7XG4gICAgICBpZiggZi5sZW5ndGghPT1hcmd1bWVudHMubGVuZ3RoICl7XG4gICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYixcInNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyXCIsZi5sZW5ndGgpO1xuICAgICAgfWVsc2UgaWYoIDAgPT09IChlVGV4dFJlcCAmIDB4ZikgKXtcbiAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgIH1lbHNlIGlmKCBjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpICl7XG4gICAgICAgIHJldHVybiBfX2VyckVuY29kaW5nKHBEYik7XG4gICAgICB9XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IHJjID0gX19zcWxpdGUzQ3JlYXRlRnVuY3Rpb24ocERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcEFwcCwgeEZ1bmMsIHhTdGVwLCB4RmluYWwsIHhEZXN0cm95KTtcbiAgICAgICAgaWYoMD09PXJjICYmICh4RnVuYyBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfHwgeFN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHx8IHhGaW5hbCBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfHwgeERlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZEZ1bmN0aW9uKHBEYiwgZnVuY05hbWUsIG5BcmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgY29uc29sZS5lcnJvcihcInNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyKCkgc2V0dXAgdGhyZXc6XCIsZSk7XG4gICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihwRGIsIGUsIFwiQ3JlYXRpb24gb2YgVURGIHRocmV3OiBcIitlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbiA9IGZ1bmN0aW9uIGYoXG4gICAgICBwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCwgcEFwcCxcbiAgICAgIHhGdW5jLCB4U3RlcCwgeEZpbmFsXG4gICAgKXtcbiAgICAgIHJldHVybiAoZi5sZW5ndGg9PT1hcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICA/IGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIocERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwQXBwLCB4RnVuYywgeFN0ZXAsIHhGaW5hbCwgMClcbiAgICAgICAgOiBfX2RiQXJnY01pc21hdGNoKHBEYixcInNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uXCIsZi5sZW5ndGgpO1xuICAgIH07XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX3dpbmRvd19mdW5jdGlvbiA9IGZ1bmN0aW9uIGYoXG4gICAgICBwRGIsIGZ1bmNOYW1lLCBuQXJnLCBlVGV4dFJlcCwgcEFwcCxcbiAgICAgIHhTdGVwLCAgIFxuICAgICAgeEZpbmFsLCAgXG4gICAgICB4VmFsdWUsICBcbiAgICAgIHhJbnZlcnNlLFxuICAgICAgeERlc3Ryb3kgXG4gICAgKXtcbiAgICAgIGlmKCBmLmxlbmd0aCE9PWFyZ3VtZW50cy5sZW5ndGggKXtcbiAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2gocERiLFwic3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uXCIsZi5sZW5ndGgpO1xuICAgICAgfWVsc2UgaWYoIDAgPT09IChlVGV4dFJlcCAmIDB4ZikgKXtcbiAgICAgICAgZVRleHRSZXAgfD0gY2FwaS5TUUxJVEVfVVRGODtcbiAgICAgIH1lbHNlIGlmKCBjYXBpLlNRTElURV9VVEY4ICE9PSAoZVRleHRSZXAgJiAweGYpICl7XG4gICAgICAgIHJldHVybiBfX2VyckVuY29kaW5nKHBEYik7XG4gICAgICB9XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IHJjID0gX19zcWxpdGUzQ3JlYXRlV2luZG93RnVuY3Rpb24ocERiLCBmdW5jTmFtZSwgbkFyZywgZVRleHRSZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcEFwcCwgeFN0ZXAsIHhGaW5hbCwgeFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhJbnZlcnNlLCB4RGVzdHJveSk7XG4gICAgICAgIGlmKDA9PT1yYyAmJiAoeFN0ZXAgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgIHx8IHhGaW5hbCBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfHwgeFZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICB8fCB4SW52ZXJzZSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgfHwgeERlc3Ryb3kgaW5zdGFuY2VvZiBGdW5jdGlvbikpe1xuICAgICAgICAgIF9fZGJDbGVhbnVwTWFwLmFkZFdpbmRvd0Z1bmMocERiLCBmdW5jTmFtZSwgbkFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBjb25zb2xlLmVycm9yKFwic3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uKCkgc2V0dXAgdGhyZXc6XCIsZSk7XG4gICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihwRGIsIGUsIFwiQ3JlYXRpb24gb2YgVURGIHRocmV3OiBcIitlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb25fdjIudWRmU2V0UmVzdWx0ID1cbiAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmU2V0UmVzdWx0ID1cbiAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZlNldFJlc3VsdCA9IGNhcGkuc3FsaXRlM19yZXN1bHRfanM7XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uX3YyLnVkZkNvbnZlcnRBcmdzID1cbiAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPVxuICAgICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24udWRmQ29udmVydEFyZ3MgPSBjYXBpLnNxbGl0ZTNfdmFsdWVzX3RvX2pzO1xuXG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92Mi51ZGZTZXRFcnJvciA9XG4gICAgICBjYXBpLnNxbGl0ZTNfY3JlYXRlX2Z1bmN0aW9uLnVkZlNldEVycm9yID1cbiAgICAgIGNhcGkuc3FsaXRlM19jcmVhdGVfd2luZG93X2Z1bmN0aW9uLnVkZlNldEVycm9yID0gY2FwaS5zcWxpdGUzX3Jlc3VsdF9lcnJvcl9qcztcblxuICB9O1xuXG4gIHtcblxuICAgIFxuICAgIGNvbnN0IF9fZmxleGlTdHJpbmcgPSAodixuKT0+e1xuICAgICAgaWYoJ3N0cmluZyc9PT10eXBlb2Ygdil7XG4gICAgICAgIG4gPSAtMTtcbiAgICAgIH1lbHNlIGlmKHV0aWwuaXNTUUxhYmxlVHlwZWRBcnJheSh2KSl7XG4gICAgICAgIG4gPSB2LmJ5dGVMZW5ndGg7XG4gICAgICAgIHYgPSB1dGlsLnR5cGVkQXJyYXlUb1N0cmluZyhcbiAgICAgICAgICAodiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSA/IG5ldyBVaW50OEFycmF5KHYpIDogdlxuICAgICAgICApO1xuICAgICAgfWVsc2UgaWYoQXJyYXkuaXNBcnJheSh2KSl7XG4gICAgICAgIHYgPSB2LmpvaW4oXCJcIik7XG4gICAgICAgIG4gPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdiwgbl07XG4gICAgfTtcblxuICAgIFxuICAgIGNvbnN0IF9fcHJlcGFyZSA9IHtcbiAgICAgIFxuICAgICAgYmFzaWM6IHdhc20ueFdyYXAoJ3NxbGl0ZTNfcHJlcGFyZV92MycsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImludFwiLCBbXCJzcWxpdGUzKlwiLCBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImludFwiLCBcIioqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKipcIl0pLFxuICAgICAgXG4gICAgICBmdWxsOiB3YXNtLnhXcmFwKCdzcWxpdGUzX3ByZXBhcmVfdjMnLFxuICAgICAgICAgICAgICAgICAgICAgICBcImludFwiLCBbXCJzcWxpdGUzKlwiLCBcIipcIiwgXCJpbnRcIiwgXCJpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIioqXCIsIFwiKipcIl0pXG4gICAgfTtcblxuICAgIFxuICAgIGNhcGkuc3FsaXRlM19wcmVwYXJlX3YzID0gZnVuY3Rpb24gZihwRGIsIHNxbCwgc3FsTGVuLCBwcmVwRmxhZ3MsIHBwU3RtdCwgcHpUYWlsKXtcbiAgICAgIGlmKGYubGVuZ3RoIT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKHBEYixcInNxbGl0ZTNfcHJlcGFyZV92M1wiLGYubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt4U3FsLCB4U3FsTGVuXSA9IF9fZmxleGlTdHJpbmcoc3FsLCBzcWxMZW4pO1xuICAgICAgc3dpdGNoKHR5cGVvZiB4U3FsKXtcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gX19wcmVwYXJlLmJhc2ljKHBEYiwgeFNxbCwgeFNxbExlbiwgcHJlcEZsYWdzLCBwcFN0bXQsIG51bGwpO1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiBfX3ByZXBhcmUuZnVsbChwRGIsIHhTcWwsIHhTcWxMZW4sIHByZXBGbGFncywgcHBTdG10LCBwelRhaWwpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICAgIHBEYiwgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgICBcIkludmFsaWQgU1FMIGFyZ3VtZW50IHR5cGUgZm9yIHNxbGl0ZTNfcHJlcGFyZV92Mi92MygpLlwiXG4gICAgICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92MiA9IGZ1bmN0aW9uIGYocERiLCBzcWwsIHNxbExlbiwgcHBTdG10LCBwelRhaWwpe1xuICAgICAgcmV0dXJuIChmLmxlbmd0aD09PWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgID8gY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjMocERiLCBzcWwsIHNxbExlbiwgMCwgcHBTdG10LCBwelRhaWwpXG4gICAgICAgIDogX19kYkFyZ2NNaXNtYXRjaChwRGIsXCJzcWxpdGUzX3ByZXBhcmVfdjJcIixmLmxlbmd0aCk7XG4gICAgfTtcblxuICB9XG5cbiAge1xuICAgIGNvbnN0IF9fYmluZFRleHQgPSB3YXNtLnhXcmFwKFwic3FsaXRlM19iaW5kX3RleHRcIiwgXCJpbnRcIiwgW1xuICAgICAgXCJzcWxpdGUzX3N0bXQqXCIsIFwiaW50XCIsIFwic3RyaW5nXCIsIFwiaW50XCIsIFwiKlwiXG4gICAgXSk7XG4gICAgY29uc3QgX19iaW5kQmxvYiA9IHdhc20ueFdyYXAoXCJzcWxpdGUzX2JpbmRfYmxvYlwiLCBcImludFwiLCBbXG4gICAgICBcInNxbGl0ZTNfc3RtdCpcIiwgXCJpbnRcIiwgXCIqXCIsIFwiaW50XCIsIFwiKlwiXG4gICAgXSk7XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfYmluZF90ZXh0ID0gZnVuY3Rpb24gZihwU3RtdCwgaUNvbCwgdGV4dCwgblRleHQsIHhEZXN0cm95KXtcbiAgICAgIGlmKGYubGVuZ3RoIT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgIHJldHVybiBfX2RiQXJnY01pc21hdGNoKGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNxbGl0ZTNfYmluZF90ZXh0XCIsIGYubGVuZ3RoKTtcbiAgICAgIH1lbHNlIGlmKHdhc20uaXNQdHIodGV4dCkgfHwgbnVsbD09PXRleHQpe1xuICAgICAgICByZXR1cm4gX19iaW5kVGV4dChwU3RtdCwgaUNvbCwgdGV4dCwgblRleHQsIHhEZXN0cm95KTtcbiAgICAgIH1lbHNlIGlmKHRleHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7XG4gICAgICAgIHRleHQgPSBuZXcgVWludDhBcnJheSh0ZXh0KTtcbiAgICAgIH1lbHNlIGlmKEFycmF5LmlzQXJyYXkocE1lbSkpe1xuICAgICAgICB0ZXh0ID0gcE1lbS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGxldCBwLCBuO1xuICAgICAgdHJ5e1xuICAgICAgICBpZih1dGlsLmlzU1FMYWJsZVR5cGVkQXJyYXkodGV4dCkpe1xuICAgICAgICAgIHAgPSB3YXNtLmFsbG9jRnJvbVR5cGVkQXJyYXkodGV4dCk7XG4gICAgICAgICAgbiA9IHRleHQuYnl0ZUxlbmd0aDtcbiAgICAgICAgfWVsc2UgaWYoJ3N0cmluZyc9PT10eXBlb2YgdGV4dCl7XG4gICAgICAgICAgW3AsIG5dID0gd2FzbS5hbGxvY0NTdHJpbmcodGV4dCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICAgIGNhcGkuc3FsaXRlM19kYl9oYW5kbGUocFN0bXQpLCBjYXBpLlNRTElURV9NSVNVU0UsXG4gICAgICAgICAgICBcIkludmFsaWQgM3JkIGFyZ3VtZW50IHR5cGUgZm9yIHNxbGl0ZTNfYmluZF90ZXh0KCkuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2JpbmRUZXh0KHBTdG10LCBpQ29sLCBwLCBuLCBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICB3YXNtLmRlYWxsb2MocCk7XG4gICAgICAgIHJldHVybiB1dGlsLnNxbGl0ZTNfd2FzbV9kYl9lcnJvcihcbiAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSwgZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iID0gZnVuY3Rpb24gZihwU3RtdCwgaUNvbCwgcE1lbSwgbk1lbSwgeERlc3Ryb3kpe1xuICAgICAgaWYoZi5sZW5ndGghPT1hcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIF9fZGJBcmdjTWlzbWF0Y2goY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3FsaXRlM19iaW5kX2Jsb2JcIiwgZi5sZW5ndGgpO1xuICAgICAgfWVsc2UgaWYod2FzbS5pc1B0cihwTWVtKSB8fCBudWxsPT09cE1lbSl7XG4gICAgICAgIHJldHVybiBfX2JpbmRCbG9iKHBTdG10LCBpQ29sLCBwTWVtLCBuTWVtLCB4RGVzdHJveSk7XG4gICAgICB9ZWxzZSBpZihwTWVtIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgICBwTWVtID0gbmV3IFVpbnQ4QXJyYXkocE1lbSk7XG4gICAgICB9ZWxzZSBpZihBcnJheS5pc0FycmF5KHBNZW0pKXtcbiAgICAgICAgcE1lbSA9IHBNZW0uam9pbignJyk7XG4gICAgICB9XG4gICAgICBsZXQgcCwgbjtcbiAgICAgIHRyeXtcbiAgICAgICAgaWYodXRpbC5pc0JpbmRhYmxlVHlwZWRBcnJheShwTWVtKSl7XG4gICAgICAgICAgcCA9IHdhc20uYWxsb2NGcm9tVHlwZWRBcnJheShwTWVtKTtcbiAgICAgICAgICBuID0gbk1lbT49MCA/IG5NZW0gOiBwTWVtLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1lbHNlIGlmKCdzdHJpbmcnPT09dHlwZW9mIHBNZW0pe1xuICAgICAgICAgIFtwLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHBNZW0pO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgICBjYXBpLnNxbGl0ZTNfZGJfaGFuZGxlKHBTdG10KSwgY2FwaS5TUUxJVEVfTUlTVVNFLFxuICAgICAgICAgICAgXCJJbnZhbGlkIDNyZCBhcmd1bWVudCB0eXBlIGZvciBzcWxpdGUzX2JpbmRfYmxvYigpLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19iaW5kQmxvYihwU3RtdCwgaUNvbCwgcCwgbiwgY2FwaS5TUUxJVEVfV0FTTV9ERUFMTE9DKTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgd2FzbS5kZWFsbG9jKHApO1xuICAgICAgICByZXR1cm4gdXRpbC5zcWxpdGUzX3dhc21fZGJfZXJyb3IoXG4gICAgICAgICAgY2FwaS5zcWxpdGUzX2RiX2hhbmRsZShwU3RtdCksIGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1cblxuICB7XG4gICAgXG4gICAgY2FwaS5zcWxpdGUzX2NvbmZpZyA9IGZ1bmN0aW9uKG9wLCAuLi5hcmdzKXtcbiAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGg8MikgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgIHN3aXRjaChvcCl7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfQ09WRVJJTkdfSU5ERVhfU0NBTjogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUVNU1RBVFVTOlxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NNQUxMX01BTExPQzogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU09SVEVSUkVGX1NJWkU6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NUTVRKUk5MX1NQSUxMOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19VUkk6XG4gICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9jb25maWdfaShvcCwgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTE9PS0FTSURFOiBcbiAgICAgICAgICAgIHJldHVybiB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2NvbmZpZ19paShvcCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfTUVNREJfTUFYU0laRTogXG4gICAgICAgICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfd2FzbV9jb25maWdfaihvcCwgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUTUFMTE9DOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19HRVRNVVRFWDogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUUENBQ0hFMjogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfR0VUUENBQ0hFOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19IRUFQOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19MT0c6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01BTExPQzpcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NTUFQX1NJWkU6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX01VTFRJVEhSRUFEOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19NVVRFWDogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUEFHRUNBQ0hFOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQ0FDSEUyOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19QQ0FDSEU6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1BDQUNIRV9IRFJTWjogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfUE1BU1o6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NFUklBTElaRUQ6IFxuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfQ09ORklHX1NJTkdMRVRIUkVBRDogXG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9DT05GSUdfU1FMTE9HOiBcbiAgICAgICAgICBjYXNlIGNhcGkuU1FMSVRFX0NPTkZJR19XSU4zMl9IRUFQU0laRTogXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9OT1RGT1VORDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAge1xuICAgIGNvbnN0IF9fYXV0b0V4dEZwdHIgPSBuZXcgU2V0O1xuXG4gICAgY2FwaS5zcWxpdGUzX2F1dG9fZXh0ZW5zaW9uID0gZnVuY3Rpb24oZlB0cil7XG4gICAgICBpZiggZlB0ciBpbnN0YW5jZW9mIEZ1bmN0aW9uICl7XG4gICAgICAgIGZQdHIgPSB3YXNtLmluc3RhbGxGdW5jdGlvbignaShwcHApJywgZlB0cik7XG4gICAgICB9ZWxzZSBpZiggMSE9PWFyZ3VtZW50cy5sZW5ndGggfHwgIXdhc20uaXNQdHIoZlB0cikgKXtcbiAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX01JU1VTRTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJjID0gd2FzbS5leHBvcnRzLnNxbGl0ZTNfYXV0b19leHRlbnNpb24oZlB0cik7XG4gICAgICBpZiggZlB0ciE9PWFyZ3VtZW50c1swXSApe1xuICAgICAgICBpZigwPT09cmMpIF9fYXV0b0V4dEZwdHIuYWRkKGZQdHIpO1xuICAgICAgICBlbHNlIHdhc20udW5pbnN0YWxsRnVuY3Rpb24oZlB0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmM7XG4gICAgfTtcblxuICAgIGNhcGkuc3FsaXRlM19jYW5jZWxfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbihmUHRyKXtcbiAgICAgO1xuICAgICAgaWYoIWZQdHIgfHwgMSE9PWFyZ3VtZW50cy5sZW5ndGggfHwgIXdhc20uaXNQdHIoZlB0cikpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHdhc20uZXhwb3J0cy5zcWxpdGUzX2NhbmNlbF9hdXRvX2V4dGVuc2lvbihmUHRyKTtcbiAgICAgIFxuICAgIH07XG5cbiAgICBjYXBpLnNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24gPSBmdW5jdGlvbigpe1xuICAgICAgd2FzbS5leHBvcnRzLnNxbGl0ZTNfcmVzZXRfYXV0b19leHRlbnNpb24oKTtcbiAgICAgIGZvcihjb25zdCBmcCBvZiBfX2F1dG9FeHRGcHRyKSB3YXNtLnVuaW5zdGFsbEZ1bmN0aW9uKGZwKTtcbiAgICAgIF9fYXV0b0V4dEZwdHIuY2xlYXIoKTtcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcEt2dmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKFwia3Z2ZnNcIik7XG4gIGlmKCBwS3Z2ZnMgKXtcbiAgICBpZih1dGlsLmlzVUlUaHJlYWQoKSl7XG4gICAgICBjb25zdCBrdnZmc01ldGhvZHMgPSBuZXcgY2FwaS5zcWxpdGUzX2t2dmZzX21ldGhvZHMoXG4gICAgICAgIHdhc20uZXhwb3J0cy5zcWxpdGUzX3dhc21fa3Z2ZnNfbWV0aG9kcygpXG4gICAgICApO1xuICAgICAgZGVsZXRlIGNhcGkuc3FsaXRlM19rdnZmc19tZXRob2RzO1xuXG4gICAgICBjb25zdCBrdnZmc01ha2VLZXkgPSB3YXNtLmV4cG9ydHMuc3FsaXRlM193YXNtX2t2dmZzTWFrZUtleU9uUHN0YWNrLFxuICAgICAgICAgICAgcHN0YWNrID0gd2FzbS5wc3RhY2s7XG5cbiAgICAgIGNvbnN0IGt2dmZzU3RvcmFnZSA9ICh6Q2xhc3MpPT5cbiAgICAgICAgICAgICgoMTE1PT09d2FzbS5wZWVrKHpDbGFzcykpXG4gICAgICAgICAgICAgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSk7XG5cbiAgICAgIFxuICAgICAgY29uc3Qga3Z2ZnNJbXBscyA9IHtcbiAgICAgICAgeFJlYWQ6ICh6Q2xhc3MsIHpLZXksIHpCdWYsIG5CdWYpPT57XG4gICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcixcbiAgICAgICAgICAgICAgICBhc3RhY2sgPSB3YXNtLnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB6WEtleSA9IGt2dmZzTWFrZUtleSh6Q2xhc3MsektleSk7XG4gICAgICAgICAgICBpZighelhLZXkpIHJldHVybiAtMztcbiAgICAgICAgICAgIGNvbnN0IGpLZXkgPSB3YXNtLmNzdHJUb0pzKHpYS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGpWID0ga3Z2ZnNTdG9yYWdlKHpDbGFzcykuZ2V0SXRlbShqS2V5KTtcbiAgICAgICAgICAgIGlmKCFqVikgcmV0dXJuIC0xO1xuICAgICAgICAgICAgY29uc3QgblYgPSBqVi5sZW5ndGggO1xuICAgICAgICAgICAgaWYobkJ1Zjw9MCkgcmV0dXJuIG5WO1xuICAgICAgICAgICAgZWxzZSBpZigxPT09bkJ1Zil7XG4gICAgICAgICAgICAgIHdhc20ucG9rZSh6QnVmLCAwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5WO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgelYgPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhqVik7XG4gICAgICAgICAgICBpZihuQnVmID4gblYgKyAxKSBuQnVmID0gblYgKyAxO1xuICAgICAgICAgICAgd2FzbS5oZWFwOHUoKS5jb3B5V2l0aGluKHpCdWYsIHpWLCB6ViArIG5CdWYgLSAxKTtcbiAgICAgICAgICAgIHdhc20ucG9rZSh6QnVmICsgbkJ1ZiAtIDEsIDApO1xuICAgICAgICAgICAgcmV0dXJuIG5CdWYgLSAxO1xuICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJrdnN0b3JhZ2VSZWFkKClcIixlKTtcbiAgICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgICB9ZmluYWxseXtcbiAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3AoYXN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHhXcml0ZTogKHpDbGFzcywgektleSwgekRhdGEpPT57XG4gICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgelhLZXkgPSBrdnZmc01ha2VLZXkoekNsYXNzLHpLZXkpO1xuICAgICAgICAgICAgaWYoIXpYS2V5KSByZXR1cm4gMTtcbiAgICAgICAgICAgIGNvbnN0IGpLZXkgPSB3YXNtLmNzdHJUb0pzKHpYS2V5KTtcbiAgICAgICAgICAgIGt2dmZzU3RvcmFnZSh6Q2xhc3MpLnNldEl0ZW0oaktleSwgd2FzbS5jc3RyVG9Kcyh6RGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImt2c3RvcmFnZVdyaXRlKClcIixlKTtcbiAgICAgICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUjtcbiAgICAgICAgICB9ZmluYWxseXtcbiAgICAgICAgICAgIHBzdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHhEZWxldGU6ICh6Q2xhc3MsIHpLZXkpPT57XG4gICAgICAgICAgY29uc3Qgc3RhY2sgPSBwc3RhY2sucG9pbnRlcjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgelhLZXkgPSBrdnZmc01ha2VLZXkoekNsYXNzLHpLZXkpO1xuICAgICAgICAgICAgaWYoIXpYS2V5KSByZXR1cm4gMTtcbiAgICAgICAgICAgIGt2dmZzU3RvcmFnZSh6Q2xhc3MpLnJlbW92ZUl0ZW0od2FzbS5jc3RyVG9Kcyh6WEtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImt2c3RvcmFnZURlbGV0ZSgpXCIsZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgICAgfWZpbmFsbHl7XG4gICAgICAgICAgICBwc3RhY2sucmVzdG9yZShzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZm9yKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoa3Z2ZnNJbXBscykpe1xuICAgICAgICBrdnZmc01ldGhvZHNba3Z2ZnNNZXRob2RzLm1lbWJlcktleShrKV0gPVxuICAgICAgICAgIHdhc20uaW5zdGFsbEZ1bmN0aW9uKFxuICAgICAgICAgICAga3Z2ZnNNZXRob2RzLm1lbWJlclNpZ25hdHVyZShrKSxcbiAgICAgICAgICAgIGt2dmZzSW1wbHNba11cbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgXG4gICAgICBjYXBpLnNxbGl0ZTNfdmZzX3VucmVnaXN0ZXIocEt2dmZzKTtcbiAgICB9XG4gIH1cblxuICB3YXNtLnhXcmFwLkZ1bmNQdHJBZGFwdGVyLndhcm5PblVzZSA9IHRydWU7XG59KTtcblxuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oc3FsaXRlMyl7XG4gIHNxbGl0ZTMudmVyc2lvbiA9IHtcImxpYlZlcnNpb25cIjogXCIzLjQ1LjJcIiwgXCJsaWJWZXJzaW9uTnVtYmVyXCI6IDMwNDUwMDIsIFwic291cmNlSWRcIjogXCIyMDI0LTAzLTEyIDExOjA2OjIzIGQ4Y2Q2ZDQ5YjQ2YTM5NWIxMzk1NTM4N2QwNWU5ZTFhMmE0N2U1NGZiOTlmM2M5YjU5ODM1YmJlZmFkNmFmNzdcIixcImRvd25sb2FkVmVyc2lvblwiOiAzNDUwMjAwfTtcbn0pO1xuXG5cblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uKHNxbGl0ZTMpe1xuICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpPT57dGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKX07XG4gIGNvbnN0IHRvc3MzID0gKC4uLmFyZ3MpPT57dGhyb3cgbmV3IHNxbGl0ZTMuU1FMaXRlM0Vycm9yKC4uLmFyZ3MpfTtcblxuICBjb25zdCBjYXBpID0gc3FsaXRlMy5jYXBpLCB3YXNtID0gc3FsaXRlMy53YXNtLCB1dGlsID0gc3FsaXRlMy51dGlsO1xuICBcblxuICBcbiAgY29uc3QgX19wdHJNYXAgPSBuZXcgV2Vha01hcCgpO1xuICBcbiAgY29uc3QgX19zdG10TWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICBcbiAgY29uc3QgZ2V0T3duT3B0aW9uID0gKG9wdHMsIHAsIGRmbHQpPT57XG4gICAgY29uc3QgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3B0cyxwKTtcbiAgICByZXR1cm4gZCA/IGQudmFsdWUgOiBkZmx0O1xuICB9O1xuXG4gIFxuICBjb25zdCBjaGVja1NxbGl0ZTNSYyA9IGZ1bmN0aW9uKGRiUHRyLCBzcWxpdGVSZXN1bHRDb2RlKXtcbiAgICBpZihzcWxpdGVSZXN1bHRDb2RlKXtcbiAgICAgIGlmKGRiUHRyIGluc3RhbmNlb2YgREIpIGRiUHRyID0gZGJQdHIucG9pbnRlcjtcbiAgICAgIHRvc3MzKFxuICAgICAgICBzcWxpdGVSZXN1bHRDb2RlLFxuICAgICAgICBcInNxbGl0ZTMgcmVzdWx0IGNvZGVcIixzcWxpdGVSZXN1bHRDb2RlK1wiOlwiLFxuICAgICAgICAoZGJQdHJcbiAgICAgICAgID8gY2FwaS5zcWxpdGUzX2Vycm1zZyhkYlB0cilcbiAgICAgICAgIDogY2FwaS5zcWxpdGUzX2VycnN0cihzcWxpdGVSZXN1bHRDb2RlKSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fZGJUcmFjZVRvQ29uc29sZSA9XG4gICAgICAgIHdhc20uaW5zdGFsbEZ1bmN0aW9uKCdpKGlwcHApJywgZnVuY3Rpb24odCxjLHAseCl7XG4gICAgICAgICAgaWYoY2FwaS5TUUxJVEVfVFJBQ0VfU1RNVD09PXQpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNRTCBUUkFDRSAjXCIrKCsrdGhpcy5jb3VudGVyKSsnIHZpYSBzcWxpdGUzQCcrYysnOicsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXNtLmNzdHJUb0pzKHgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh7Y291bnRlcjogMH0pKTtcblxuICBcbiAgY29uc3QgX192ZnNQb3N0T3BlblNxbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgXG4gIGNvbnN0IGRiQ3RvckhlbHBlciA9IGZ1bmN0aW9uIGN0b3IoLi4uYXJncyl7XG4gICAgaWYoIWN0b3IuX25hbWUydmZzKXtcbiAgICAgIFxuICAgICAgY3Rvci5fbmFtZTJ2ZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgaXNXb3JrZXJUaHJlYWQgPSAoJ2Z1bmN0aW9uJz09PXR5cGVvZiBpbXBvcnRTY3JpcHRzKVxuICAgICAgICAgICAgPyAobik9PnRvc3MzKFwiVGhlIFZGUyBmb3JcIixuLFwiaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIG1haW4gd2luZG93IHRocmVhZC5cIilcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICBjdG9yLl9uYW1lMnZmc1snOmxvY2FsU3RvcmFnZTonXSA9IHtcbiAgICAgICAgdmZzOiAna3Z2ZnMnLCBmaWxlbmFtZTogaXNXb3JrZXJUaHJlYWQgfHwgKCgpPT4nbG9jYWwnKVxuICAgICAgfTtcbiAgICAgIGN0b3IuX25hbWUydmZzWyc6c2Vzc2lvblN0b3JhZ2U6J10gPSB7XG4gICAgICAgIHZmczogJ2t2dmZzJywgZmlsZW5hbWU6IGlzV29ya2VyVGhyZWFkIHx8ICgoKT0+J3Nlc3Npb24nKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3B0ID0gY3Rvci5ub3JtYWxpemVBcmdzKC4uLmFyZ3MpO1xuICAgIGxldCBmbiA9IG9wdC5maWxlbmFtZSwgdmZzTmFtZSA9IG9wdC52ZnMsIGZsYWdzU3RyID0gb3B0LmZsYWdzO1xuICAgIGlmKCgnc3RyaW5nJyE9PXR5cGVvZiBmbiAmJiAnbnVtYmVyJyE9PXR5cGVvZiBmbilcbiAgICAgICB8fCAnc3RyaW5nJyE9PXR5cGVvZiBmbGFnc1N0clxuICAgICAgIHx8ICh2ZnNOYW1lICYmICgnc3RyaW5nJyE9PXR5cGVvZiB2ZnNOYW1lICYmICdudW1iZXInIT09dHlwZW9mIHZmc05hbWUpKSl7XG4gICAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcihcIkludmFsaWQgREIgY3RvciBhcmdzXCIsb3B0LGFyZ3VtZW50cyk7XG4gICAgICB0b3NzMyhcIkludmFsaWQgYXJndW1lbnRzIGZvciBEQiBjb25zdHJ1Y3Rvci5cIik7XG4gICAgfVxuICAgIGxldCBmbkpzID0gKCdudW1iZXInPT09dHlwZW9mIGZuKSA/IHdhc20uY3N0clRvSnMoZm4pIDogZm47XG4gICAgY29uc3QgdmZzQ2hlY2sgPSBjdG9yLl9uYW1lMnZmc1tmbkpzXTtcbiAgICBpZih2ZnNDaGVjayl7XG4gICAgICB2ZnNOYW1lID0gdmZzQ2hlY2sudmZzO1xuICAgICAgZm4gPSBmbkpzID0gdmZzQ2hlY2suZmlsZW5hbWUoZm5Kcyk7XG4gICAgfVxuICAgIGxldCBwRGIsIG9mbGFncyA9IDA7XG4gICAgaWYoIGZsYWdzU3RyLmluZGV4T2YoJ2MnKT49MCApe1xuICAgICAgb2ZsYWdzIHw9IGNhcGkuU1FMSVRFX09QRU5fQ1JFQVRFIHwgY2FwaS5TUUxJVEVfT1BFTl9SRUFEV1JJVEU7XG4gICAgfVxuICAgIGlmKCBmbGFnc1N0ci5pbmRleE9mKCd3Jyk+PTAgKSBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9SRUFEV1JJVEU7XG4gICAgaWYoIDA9PT1vZmxhZ3MgKSBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9SRUFET05MWTtcbiAgICBvZmxhZ3MgfD0gY2FwaS5TUUxJVEVfT1BFTl9FWFJFU0NPREU7XG4gICAgY29uc3Qgc3RhY2sgPSB3YXNtLnBzdGFjay5wb2ludGVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwUHRyID0gd2FzbS5wc3RhY2suYWxsb2NQdHIoKSA7XG4gICAgICBsZXQgcmMgPSBjYXBpLnNxbGl0ZTNfb3Blbl92MihmbiwgcFB0ciwgb2ZsYWdzLCB2ZnNOYW1lIHx8IDApO1xuICAgICAgcERiID0gd2FzbS5wZWVrUHRyKHBQdHIpO1xuICAgICAgY2hlY2tTcWxpdGUzUmMocERiLCByYyk7XG4gICAgICBjYXBpLnNxbGl0ZTNfZXh0ZW5kZWRfcmVzdWx0X2NvZGVzKHBEYiwgMSk7XG4gICAgICBpZihmbGFnc1N0ci5pbmRleE9mKCd0Jyk+PTApe1xuICAgICAgICBjYXBpLnNxbGl0ZTNfdHJhY2VfdjIocERiLCBjYXBpLlNRTElURV9UUkFDRV9TVE1ULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kYlRyYWNlVG9Db25zb2xlLCBwRGIpO1xuICAgICAgfVxuICAgIH1jYXRjaCggZSApe1xuICAgICAgaWYoIHBEYiApIGNhcGkuc3FsaXRlM19jbG9zZV92MihwRGIpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9ZmluYWxseXtcbiAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgIH1cbiAgICB0aGlzLmZpbGVuYW1lID0gZm5KcztcbiAgICBfX3B0ck1hcC5zZXQodGhpcywgcERiKTtcbiAgICBfX3N0bXRNYXAuc2V0KHRoaXMsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIHRyeXtcbiAgICAgIFxuICAgICAgY29uc3QgcFZmcyA9IGNhcGkuc3FsaXRlM19qc19kYl92ZnMocERiKTtcbiAgICAgIGlmKCFwVmZzKSB0b3NzMyhcIkludGVybmFsIGVycm9yOiBjYW5ub3QgZ2V0IFZGUyBmb3IgbmV3IGRiIGhhbmRsZS5cIik7XG4gICAgICBjb25zdCBwb3N0SW5pdFNxbCA9IF9fdmZzUG9zdE9wZW5TcWxbcFZmc107XG4gICAgICBpZihwb3N0SW5pdFNxbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgcG9zdEluaXRTcWwodGhpcywgc3FsaXRlMyk7XG4gICAgICB9ZWxzZSBpZihwb3N0SW5pdFNxbCl7XG4gICAgICAgIGNoZWNrU3FsaXRlM1JjKFxuICAgICAgICAgIHBEYiwgY2FwaS5zcWxpdGUzX2V4ZWMocERiLCBwb3N0SW5pdFNxbCwgMCwgMCwgMClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9Y2F0Y2goZSl7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcblxuICBcbiAgZGJDdG9ySGVscGVyLnNldFZmc1Bvc3RPcGVuU3FsID0gZnVuY3Rpb24ocFZmcywgc3FsKXtcbiAgICBfX3Zmc1Bvc3RPcGVuU3FsW3BWZnNdID0gc3FsO1xuICB9O1xuXG4gIFxuICBkYkN0b3JIZWxwZXIubm9ybWFsaXplQXJncyA9IGZ1bmN0aW9uKGZpbGVuYW1lPSc6bWVtb3J5OicsZmxhZ3MgPSAnYycsdmZzID0gbnVsbCl7XG4gICAgY29uc3QgYXJnID0ge307XG4gICAgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGggJiYgYXJndW1lbnRzWzBdICYmICdvYmplY3QnPT09dHlwZW9mIGFyZ3VtZW50c1swXSl7XG4gICAgICBPYmplY3QuYXNzaWduKGFyZywgYXJndW1lbnRzWzBdKTtcbiAgICAgIGlmKHVuZGVmaW5lZD09PWFyZy5mbGFncykgYXJnLmZsYWdzID0gJ2MnO1xuICAgICAgaWYodW5kZWZpbmVkPT09YXJnLnZmcykgYXJnLnZmcyA9IG51bGw7XG4gICAgICBpZih1bmRlZmluZWQ9PT1hcmcuZmlsZW5hbWUpIGFyZy5maWxlbmFtZSA9ICc6bWVtb3J5Oic7XG4gICAgfWVsc2V7XG4gICAgICBhcmcuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgIGFyZy5mbGFncyA9IGZsYWdzO1xuICAgICAgYXJnLnZmcyA9IHZmcztcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbiAgXG4gIGNvbnN0IERCID0gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgZGJDdG9ySGVscGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xuICBEQi5kYkN0b3JIZWxwZXIgPSBkYkN0b3JIZWxwZXI7XG5cbiAgXG4gIGNvbnN0IEJpbmRUeXBlcyA9IHtcbiAgICBudWxsOiAxLFxuICAgIG51bWJlcjogMixcbiAgICBzdHJpbmc6IDMsXG4gICAgYm9vbGVhbjogNCxcbiAgICBibG9iOiA1XG4gIH07XG4gIEJpbmRUeXBlc1sndW5kZWZpbmVkJ10gPT0gQmluZFR5cGVzLm51bGw7XG4gIGlmKHdhc20uYmlnSW50RW5hYmxlZCl7XG4gICAgQmluZFR5cGVzLmJpZ2ludCA9IEJpbmRUeXBlcy5udW1iZXI7XG4gIH1cblxuICBcbiAgY29uc3QgU3RtdCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoQmluZFR5cGVzIT09YXJndW1lbnRzWzJdKXtcbiAgICAgIHRvc3MzKGNhcGkuU1FMSVRFX01JU1VTRSwgXCJEbyBub3QgY2FsbCB0aGUgU3RtdCBjb25zdHJ1Y3RvciBkaXJlY3RseS4gVXNlIERCLnByZXBhcmUoKS5cIik7XG4gICAgfVxuICAgIHRoaXMuZGIgPSBhcmd1bWVudHNbMF07XG4gICAgX19wdHJNYXAuc2V0KHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgdGhpcy5wYXJhbWV0ZXJDb3VudCA9IGNhcGkuc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9jb3VudCh0aGlzLnBvaW50ZXIpO1xuICB9O1xuXG4gIFxuICBjb25zdCBhZmZpcm1EYk9wZW4gPSBmdW5jdGlvbihkYil7XG4gICAgaWYoIWRiLnBvaW50ZXIpIHRvc3MzKFwiREIgaGFzIGJlZW4gY2xvc2VkLlwiKTtcbiAgICByZXR1cm4gZGI7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGFmZmlybUNvbEluZGV4ID0gZnVuY3Rpb24oc3RtdCxuZHgpe1xuICAgIGlmKChuZHggIT09IChuZHh8MCkpIHx8IG5keDwwIHx8IG5keD49c3RtdC5jb2x1bW5Db3VudCl7XG4gICAgICB0b3NzMyhcIkNvbHVtbiBpbmRleFwiLG5keCxcImlzIG91dCBvZiByYW5nZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBzdG10O1xuICB9O1xuXG4gIFxuICBjb25zdCBwYXJzZUV4ZWNBcmdzID0gZnVuY3Rpb24oZGIsIGFyZ3Mpe1xuICAgIGNvbnN0IG91dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgb3V0Lm9wdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmKCdzdHJpbmcnPT09dHlwZW9mIGFyZ3NbMF0gfHwgdXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KGFyZ3NbMF0pKXtcbiAgICAgICAgICAgIG91dC5zcWwgPSBhcmdzWzBdO1xuICAgICAgICAgIH1lbHNlIGlmKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpe1xuICAgICAgICAgICAgb3V0LnNxbCA9IGFyZ3NbMF07XG4gICAgICAgICAgfWVsc2UgaWYoYXJnc1swXSAmJiAnb2JqZWN0Jz09PXR5cGVvZiBhcmdzWzBdKXtcbiAgICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgb3V0LnNxbCA9IG91dC5vcHQuc3FsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG91dC5zcWwgPSBhcmdzWzBdO1xuICAgICAgICAgIG91dC5vcHQgPSBhcmdzWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0b3NzMyhcIkludmFsaWQgYXJndW1lbnQgY291bnQgZm9yIGV4ZWMoKS5cIik7XG4gICAgfTtcbiAgICBvdXQuc3FsID0gdXRpbC5mbGV4aWJsZVN0cmluZyhvdXQuc3FsKTtcbiAgICBpZignc3RyaW5nJyE9PXR5cGVvZiBvdXQuc3FsKXtcbiAgICAgIHRvc3MzKFwiTWlzc2luZyBTUUwgYXJndW1lbnQgb3IgdW5zdXBwb3J0ZWQgU1FMIHZhbHVlIHR5cGUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcHQgPSBvdXQub3B0O1xuICAgIHN3aXRjaChvcHQucmV0dXJuVmFsdWUpe1xuICAgICAgICBjYXNlICdyZXN1bHRSb3dzJzpcbiAgICAgICAgICBpZighb3B0LnJlc3VsdFJvd3MpIG9wdC5yZXN1bHRSb3dzID0gW107XG4gICAgICAgICAgb3V0LnJldHVyblZhbCA9ICgpPT5vcHQucmVzdWx0Um93cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2F2ZVNxbCc6XG4gICAgICAgICAgaWYoIW9wdC5zYXZlU3FsKSBvcHQuc2F2ZVNxbCA9IFtdO1xuICAgICAgICAgIG91dC5yZXR1cm5WYWwgPSAoKT0+b3B0LnNhdmVTcWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICd0aGlzJzpcbiAgICAgICAgICBvdXQucmV0dXJuVmFsID0gKCk9PmRiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRvc3MzKFwiSW52YWxpZCByZXR1cm5WYWx1ZSB2YWx1ZTpcIixvcHQucmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgICBpZighb3B0LmNhbGxiYWNrICYmICFvcHQucmV0dXJuVmFsdWUgJiYgdW5kZWZpbmVkIT09b3B0LnJvd01vZGUpe1xuICAgICAgaWYoIW9wdC5yZXN1bHRSb3dzKSBvcHQucmVzdWx0Um93cyA9IFtdO1xuICAgICAgb3V0LnJldHVyblZhbCA9ICgpPT5vcHQucmVzdWx0Um93cztcbiAgICB9XG4gICAgaWYob3B0LmNhbGxiYWNrIHx8IG9wdC5yZXN1bHRSb3dzKXtcbiAgICAgIHN3aXRjaCgodW5kZWZpbmVkPT09b3B0LnJvd01vZGUpXG4gICAgICAgICAgICAgPyAnYXJyYXknIDogb3B0LnJvd01vZGUpIHtcbiAgICAgICAgICBjYXNlICdvYmplY3QnOiBvdXQuY2JBcmcgPSAoc3RtdCk9PnN0bXQuZ2V0KE9iamVjdC5jcmVhdGUobnVsbCkpOyBicmVhaztcbiAgICAgICAgICBjYXNlICdhcnJheSc6IG91dC5jYkFyZyA9IChzdG10KT0+c3RtdC5nZXQoW10pOyBicmVhaztcbiAgICAgICAgICBjYXNlICdzdG10JzpcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkob3B0LnJlc3VsdFJvd3MpKXtcbiAgICAgICAgICAgICAgdG9zczMoXCJleGVjKCk6IGludmFsaWQgcm93TW9kZSBmb3IgYSByZXN1bHRSb3dzIGFycmF5OiBtdXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYmUgb25lIG9mICdhcnJheScsICdvYmplY3QnLFwiLFxuICAgICAgICAgICAgICAgICAgICBcImEgcmVzdWx0IGNvbHVtbiBudW1iZXIsIG9yIGNvbHVtbiBuYW1lIHJlZmVyZW5jZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQuY2JBcmcgPSAoc3RtdCk9PnN0bXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYodXRpbC5pc0ludDMyKG9wdC5yb3dNb2RlKSl7XG4gICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KT0+c3RtdC5nZXQob3B0LnJvd01vZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1lbHNlIGlmKCdzdHJpbmcnPT09dHlwZW9mIG9wdC5yb3dNb2RlXG4gICAgICAgICAgICAgICAgICAgICAmJiBvcHQucm93TW9kZS5sZW5ndGg+MVxuICAgICAgICAgICAgICAgICAgICAgJiYgJyQnPT09b3B0LnJvd01vZGVbMF0pe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgJGNvbE5hbWUgPSBvcHQucm93TW9kZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgIG91dC5jYkFyZyA9IChzdG10KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gc3RtdC5nZXQoT2JqZWN0LmNyZWF0ZShudWxsKSlbJGNvbE5hbWVdO1xuICAgICAgICAgICAgICAgIHJldHVybiAodW5kZWZpbmVkPT09cmMpXG4gICAgICAgICAgICAgICAgICA/IHRvc3MzKGNhcGkuU1FMSVRFX05PVEZPVU5ELFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4ZWMoKTogdW5rbm93biByZXN1bHQgY29sdW1uOlwiLCRjb2xOYW1lKVxuICAgICAgICAgICAgICAgICAgOiByYztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3NzMyhcIkludmFsaWQgcm93TW9kZTpcIixvcHQucm93TW9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fc2VsZWN0Rmlyc3RSb3cgPSAoZGIsIHNxbCwgYmluZCwgLi4uZ2V0QXJncyk9PntcbiAgICBjb25zdCBzdG10ID0gZGIucHJlcGFyZShzcWwpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByYyA9IHN0bXQuYmluZChiaW5kKS5zdGVwKCkgPyBzdG10LmdldCguLi5nZXRBcmdzKSA6IHVuZGVmaW5lZDtcbiAgICAgIHN0bXQucmVzZXQoKTtcbiAgICAgIHJldHVybiByYztcbiAgICB9ZmluYWxseXtcbiAgICAgIHN0bXQuZmluYWxpemUoKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9fc2VsZWN0QWxsID1cbiAgICAgICAgKGRiLCBzcWwsIGJpbmQsIHJvd01vZGUpPT5kYi5leGVjKHtcbiAgICAgICAgICBzcWwsIGJpbmQsIHJvd01vZGUsIHJldHVyblZhbHVlOiAncmVzdWx0Um93cydcbiAgICAgICAgfSk7XG5cbiAgXG4gIERCLmNoZWNrUmMgPSAoZGIscmVzdWx0Q29kZSk9PmNoZWNrU3FsaXRlM1JjKGRiLHJlc3VsdENvZGUpO1xuXG4gIERCLnByb3RvdHlwZSA9IHtcbiAgICBcbiAgICBpc09wZW46IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gISF0aGlzLnBvaW50ZXI7XG4gICAgfSxcbiAgICBcbiAgICBhZmZpcm1PcGVuOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGFmZmlybURiT3Blbih0aGlzKTtcbiAgICB9LFxuICAgIFxuICAgIGNsb3NlOiBmdW5jdGlvbigpe1xuICAgICAgaWYodGhpcy5wb2ludGVyKXtcbiAgICAgICAgaWYodGhpcy5vbmNsb3NlICYmICh0aGlzLm9uY2xvc2UuYmVmb3JlIGluc3RhbmNlb2YgRnVuY3Rpb24pKXtcbiAgICAgICAgICB0cnl7dGhpcy5vbmNsb3NlLmJlZm9yZSh0aGlzKX1cbiAgICAgICAgICBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcERiID0gdGhpcy5wb2ludGVyO1xuICAgICAgICBPYmplY3Qua2V5cyhfX3N0bXRNYXAuZ2V0KHRoaXMpKS5mb3JFYWNoKChrLHMpPT57XG4gICAgICAgICAgaWYocyAmJiBzLnBvaW50ZXIpe1xuICAgICAgICAgICAgdHJ5e3MuZmluYWxpemUoKX1cbiAgICAgICAgICAgIGNhdGNoKGUpe31cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfX3B0ck1hcC5kZWxldGUodGhpcyk7XG4gICAgICAgIF9fc3RtdE1hcC5kZWxldGUodGhpcyk7XG4gICAgICAgIGNhcGkuc3FsaXRlM19jbG9zZV92MihwRGIpO1xuICAgICAgICBpZih0aGlzLm9uY2xvc2UgJiYgKHRoaXMub25jbG9zZS5hZnRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgICAgICAgdHJ5e3RoaXMub25jbG9zZS5hZnRlcih0aGlzKX1cbiAgICAgICAgICBjYXRjaChlKXt9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuZmlsZW5hbWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBjaGFuZ2VzOiBmdW5jdGlvbih0b3RhbD1mYWxzZSxzaXh0eUZvdXI9ZmFsc2Upe1xuICAgICAgY29uc3QgcCA9IGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyO1xuICAgICAgaWYodG90YWwpe1xuICAgICAgICByZXR1cm4gc2l4dHlGb3VyXG4gICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfdG90YWxfY2hhbmdlczY0KHApXG4gICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfdG90YWxfY2hhbmdlcyhwKTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gc2l4dHlGb3VyXG4gICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY2hhbmdlczY0KHApXG4gICAgICAgICAgOiBjYXBpLnNxbGl0ZTNfY2hhbmdlcyhwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGRiRmlsZW5hbWU6IGZ1bmN0aW9uKGRiTmFtZT0nbWFpbicpe1xuICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19kYl9maWxlbmFtZShhZmZpcm1EYk9wZW4odGhpcykucG9pbnRlciwgZGJOYW1lKTtcbiAgICB9LFxuICAgIFxuICAgIGRiTmFtZTogZnVuY3Rpb24oZGJOdW1iZXI9MCl7XG4gICAgICByZXR1cm4gY2FwaS5zcWxpdGUzX2RiX25hbWUoYWZmaXJtRGJPcGVuKHRoaXMpLnBvaW50ZXIsIGRiTnVtYmVyKTtcbiAgICB9LFxuICAgIFxuICAgIGRiVmZzTmFtZTogZnVuY3Rpb24oZGJOYW1lPTApe1xuICAgICAgbGV0IHJjO1xuICAgICAgY29uc3QgcFZmcyA9IGNhcGkuc3FsaXRlM19qc19kYl92ZnMoXG4gICAgICAgIGFmZmlybURiT3Blbih0aGlzKS5wb2ludGVyLCBkYk5hbWVcbiAgICAgICk7XG4gICAgICBpZihwVmZzKXtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBjYXBpLnNxbGl0ZTNfdmZzKHBWZnMpO1xuICAgICAgICB0cnl7IHJjID0gd2FzbS5jc3RyVG9Kcyh2LiR6TmFtZSkgfVxuICAgICAgICBmaW5hbGx5IHsgdi5kaXNwb3NlKCkgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJjO1xuICAgIH0sXG4gICAgXG4gICAgcHJlcGFyZTogZnVuY3Rpb24oc3FsKXtcbiAgICAgIGFmZmlybURiT3Blbih0aGlzKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5wc3RhY2sucG9pbnRlcjtcbiAgICAgIGxldCBwcFN0bXQsIHBTdG10O1xuICAgICAgdHJ5e1xuICAgICAgICBwcFN0bXQgPSB3YXNtLnBzdGFjay5hbGxvYyg4KTtcbiAgICAgICAgREIuY2hlY2tSYyh0aGlzLCBjYXBpLnNxbGl0ZTNfcHJlcGFyZV92Mih0aGlzLnBvaW50ZXIsIHNxbCwgLTEsIHBwU3RtdCwgbnVsbCkpO1xuICAgICAgICBwU3RtdCA9IHdhc20ucGVla1B0cihwcFN0bXQpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7XG4gICAgICAgIHdhc20ucHN0YWNrLnJlc3RvcmUoc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYoIXBTdG10KSB0b3NzMyhcIkNhbm5vdCBwcmVwYXJlIGVtcHR5IFNRTC5cIik7XG4gICAgICBjb25zdCBzdG10ID0gbmV3IFN0bXQodGhpcywgcFN0bXQsIEJpbmRUeXBlcyk7XG4gICAgICBfX3N0bXRNYXAuZ2V0KHRoaXMpW3BTdG10XSA9IHN0bXQ7XG4gICAgICByZXR1cm4gc3RtdDtcbiAgICB9LFxuICAgIFxuICAgIGV4ZWM6IGZ1bmN0aW9uKCl7XG4gICAgICBhZmZpcm1EYk9wZW4odGhpcyk7XG4gICAgICBjb25zdCBhcmcgPSBwYXJzZUV4ZWNBcmdzKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZighYXJnLnNxbCl7XG4gICAgICAgIHJldHVybiB0b3NzMyhcImV4ZWMoKSByZXF1aXJlcyBhbiBTUUwgc3RyaW5nLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdCA9IGFyZy5vcHQ7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IG9wdC5jYWxsYmFjaztcbiAgICAgIGNvbnN0IHJlc3VsdFJvd3MgPVxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvcHQucmVzdWx0Um93cykgPyBvcHQucmVzdWx0Um93cyA6IHVuZGVmaW5lZDtcbiAgICAgIGxldCBzdG10O1xuICAgICAgbGV0IGJpbmQgPSBvcHQuYmluZDtcbiAgICAgIGxldCBldmFsRmlyc3RSZXN1bHQgPSAhIShcbiAgICAgICAgYXJnLmNiQXJnIHx8IG9wdC5jb2x1bW5OYW1lcyB8fCByZXN1bHRSb3dzXG4gICAgICApIDtcbiAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5zY29wZWRBbGxvY1B1c2goKTtcbiAgICAgIGNvbnN0IHNhdmVTcWwgPSBBcnJheS5pc0FycmF5KG9wdC5zYXZlU3FsKSA/IG9wdC5zYXZlU3FsIDogdW5kZWZpbmVkO1xuICAgICAgdHJ5e1xuICAgICAgICBjb25zdCBpc1RBID0gdXRpbC5pc1NRTGFibGVUeXBlZEFycmF5KGFyZy5zcWwpXG4gICAgICAgIDtcbiAgICAgICAgXG4gICAgICAgIGxldCBzcWxCeXRlTGVuID0gaXNUQSA/IGFyZy5zcWwuYnl0ZUxlbmd0aCA6IHdhc20uanN0cmxlbihhcmcuc3FsKTtcbiAgICAgICAgY29uc3QgcHBTdG10ICA9IHdhc20uc2NvcGVkQWxsb2MoXG4gICAgICAgICAgXG4gICAgICAgICAgKDIgKiB3YXNtLnB0clNpemVvZikgKyAoc3FsQnl0ZUxlbiArIDEpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHB6VGFpbCA9IHBwU3RtdCArIHdhc20ucHRyU2l6ZW9mIDtcbiAgICAgICAgbGV0IHBTcWwgPSBwelRhaWwgKyB3YXNtLnB0clNpemVvZjtcbiAgICAgICAgY29uc3QgcFNxbEVuZCA9IHBTcWwgKyBzcWxCeXRlTGVuO1xuICAgICAgICBpZihpc1RBKSB3YXNtLmhlYXA4KCkuc2V0KGFyZy5zcWwsIHBTcWwpO1xuICAgICAgICBlbHNlIHdhc20uanN0cmNweShhcmcuc3FsLCB3YXNtLmhlYXA4KCksIHBTcWwsIHNxbEJ5dGVMZW4sIGZhbHNlKTtcbiAgICAgICAgd2FzbS5wb2tlKHBTcWwgKyBzcWxCeXRlTGVuLCAwKTtcbiAgICAgICAgd2hpbGUocFNxbCAmJiB3YXNtLnBlZWsocFNxbCwgJ2k4JylcbiAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgd2FzbS5wb2tlUHRyKFtwcFN0bXQsIHB6VGFpbF0sIDApO1xuICAgICAgICAgIERCLmNoZWNrUmModGhpcywgY2FwaS5zcWxpdGUzX3ByZXBhcmVfdjMoXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIsIHBTcWwsIHNxbEJ5dGVMZW4sIDAsIHBwU3RtdCwgcHpUYWlsXG4gICAgICAgICAgKSk7XG4gICAgICAgICAgY29uc3QgcFN0bXQgPSB3YXNtLnBlZWtQdHIocHBTdG10KTtcbiAgICAgICAgICBwU3FsID0gd2FzbS5wZWVrUHRyKHB6VGFpbCk7XG4gICAgICAgICAgc3FsQnl0ZUxlbiA9IHBTcWxFbmQgLSBwU3FsO1xuICAgICAgICAgIGlmKCFwU3RtdCkgY29udGludWU7XG4gICAgICAgICAgaWYoc2F2ZVNxbCkgc2F2ZVNxbC5wdXNoKGNhcGkuc3FsaXRlM19zcWwocFN0bXQpLnRyaW0oKSk7XG4gICAgICAgICAgc3RtdCA9IG5ldyBTdG10KHRoaXMsIHBTdG10LCBCaW5kVHlwZXMpO1xuICAgICAgICAgIGlmKGJpbmQgJiYgc3RtdC5wYXJhbWV0ZXJDb3VudCl7XG4gICAgICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgICAgICBiaW5kID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZXZhbEZpcnN0UmVzdWx0ICYmIHN0bXQuY29sdW1uQ291bnQpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgZ290Q29sTmFtZXMgPSBBcnJheS5pc0FycmF5KFxuICAgICAgICAgICAgICBvcHQuY29sdW1uTmFtZXNcbiAgICAgICAgICAgICAgKSA/IDAgOiAxO1xuICAgICAgICAgICAgZXZhbEZpcnN0UmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZihhcmcuY2JBcmcgfHwgcmVzdWx0Um93cyl7XG4gICAgICAgICAgICAgIGZvcig7IHN0bXQuc3RlcCgpOyBzdG10Ll9sb2NrZWRCeUV4ZWMgPSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgaWYoMD09PWdvdENvbE5hbWVzKyspIHN0bXQuZ2V0Q29sdW1uTmFtZXMob3B0LmNvbHVtbk5hbWVzKTtcbiAgICAgICAgICAgICAgICBzdG10Ll9sb2NrZWRCeUV4ZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGFyZy5jYkFyZyhzdG10KTtcbiAgICAgICAgICAgICAgICBpZihyZXN1bHRSb3dzKSByZXN1bHRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICBpZihjYWxsYmFjayAmJiBmYWxzZSA9PT0gY2FsbGJhY2suY2FsbChvcHQsIHJvdywgc3RtdCkpe1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0bXQuX2xvY2tlZEJ5RXhlYyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoMD09PWdvdENvbE5hbWVzKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHN0bXQuZ2V0Q29sdW1uTmFtZXMob3B0LmNvbHVtbk5hbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHN0bXQuc3RlcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdG10LnJlc2V0KFxuICAgICAgICAgICAgKS5maW5hbGl6ZSgpO1xuICAgICAgICAgIHN0bXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChzdGFjayk7XG4gICAgICAgIGlmKHN0bXQpe1xuICAgICAgICAgIGRlbGV0ZSBzdG10Ll9sb2NrZWRCeUV4ZWM7XG4gICAgICAgICAgc3RtdC5maW5hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnLnJldHVyblZhbCgpO1xuICAgIH0sXG5cbiAgICBcbiAgICBjcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gZihuYW1lLCB4RnVuYywgb3B0KXtcbiAgICAgIGNvbnN0IGlzRnVuYyA9IChmKT0+KGYgaW5zdGFuY2VvZiBGdW5jdGlvbik7XG4gICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgY2FzZSAxOiBcbiAgICAgICAgICAgIG9wdCA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gb3B0Lm5hbWU7XG4gICAgICAgICAgICB4RnVuYyA9IG9wdC54RnVuYyB8fCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiBcbiAgICAgICAgICAgIGlmKCFpc0Z1bmMoeEZ1bmMpKXtcbiAgICAgICAgICAgICAgb3B0ID0geEZ1bmM7XG4gICAgICAgICAgICAgIHhGdW5jID0gb3B0LnhGdW5jIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgICB9XG4gICAgICBpZighb3B0KSBvcHQgPSB7fTtcbiAgICAgIGlmKCdzdHJpbmcnICE9PSB0eXBlb2YgbmFtZSl7XG4gICAgICAgIHRvc3MzKFwiSW52YWxpZCBhcmd1bWVudHM6IG1pc3NpbmcgZnVuY3Rpb24gbmFtZS5cIik7XG4gICAgICB9XG4gICAgICBsZXQgeFN0ZXAgPSBvcHQueFN0ZXAgfHwgMDtcbiAgICAgIGxldCB4RmluYWwgPSBvcHQueEZpbmFsIHx8IDA7XG4gICAgICBjb25zdCB4VmFsdWUgPSBvcHQueFZhbHVlIHx8IDA7XG4gICAgICBjb25zdCB4SW52ZXJzZSA9IG9wdC54SW52ZXJzZSB8fCAwO1xuICAgICAgbGV0IGlzV2luZG93ID0gdW5kZWZpbmVkO1xuICAgICAgaWYoaXNGdW5jKHhGdW5jKSl7XG4gICAgICAgIGlzV2luZG93ID0gZmFsc2U7XG4gICAgICAgIGlmKGlzRnVuYyh4U3RlcCkgfHwgaXNGdW5jKHhGaW5hbCkpe1xuICAgICAgICAgIHRvc3MzKFwiQW1iaWd1b3VzIGFyZ3VtZW50czogc2NhbGFyIG9yIGFnZ3JlZ2F0ZT9cIik7XG4gICAgICAgIH1cbiAgICAgICAgeFN0ZXAgPSB4RmluYWwgPSBudWxsO1xuICAgICAgfWVsc2UgaWYoaXNGdW5jKHhTdGVwKSl7XG4gICAgICAgIGlmKCFpc0Z1bmMoeEZpbmFsKSl7XG4gICAgICAgICAgdG9zczMoXCJNaXNzaW5nIHhGaW5hbCgpIGNhbGxiYWNrIGZvciBhZ2dyZWdhdGUgb3Igd2luZG93IFVERi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgeEZ1bmMgPSBudWxsO1xuICAgICAgfWVsc2UgaWYoaXNGdW5jKHhGaW5hbCkpe1xuICAgICAgICB0b3NzMyhcIk1pc3NpbmcgeFN0ZXAoKSBjYWxsYmFjayBmb3IgYWdncmVnYXRlIG9yIHdpbmRvdyBVREYuXCIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRvc3MzKFwiTWlzc2luZyBmdW5jdGlvbi10eXBlIHByb3BlcnRpZXMuXCIpO1xuICAgICAgfVxuICAgICAgaWYoZmFsc2UgPT09IGlzV2luZG93KXtcbiAgICAgICAgaWYoaXNGdW5jKHhWYWx1ZSkgfHwgaXNGdW5jKHhJbnZlcnNlKSl7XG4gICAgICAgICAgdG9zczMoXCJ4VmFsdWUgYW5kIHhJbnZlcnNlIGFyZSBub3QgcGVybWl0dGVkIGZvciBub24td2luZG93IFVERnMuXCIpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZSBpZihpc0Z1bmMoeFZhbHVlKSl7XG4gICAgICAgIGlmKCFpc0Z1bmMoeEludmVyc2UpKXtcbiAgICAgICAgICB0b3NzMyhcInhJbnZlcnNlIG11c3QgYmUgcHJvdmlkZWQgaWYgeFZhbHVlIGlzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpc1dpbmRvdyA9IHRydWU7XG4gICAgICB9ZWxzZSBpZihpc0Z1bmMoeEludmVyc2UpKXtcbiAgICAgICAgdG9zczMoXCJ4VmFsdWUgbXVzdCBiZSBwcm92aWRlZCBpZiB4SW52ZXJzZSBpcy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwQXBwID0gb3B0LnBBcHA7XG4gICAgICBpZih1bmRlZmluZWQhPT1wQXBwICYmXG4gICAgICAgICBudWxsIT09cEFwcCAmJlxuICAgICAgICAgKCgnbnVtYmVyJyE9PXR5cGVvZiBwQXBwKSB8fCAhdXRpbC5pc0ludDMyKHBBcHApKSl7XG4gICAgICAgIHRvc3MzKFwiSW52YWxpZCB2YWx1ZSBmb3IgcEFwcCBwcm9wZXJ0eS4gTXVzdCBiZSBhIGxlZ2FsIFdBU00gcG9pbnRlciB2YWx1ZS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB4RGVzdHJveSA9IG9wdC54RGVzdHJveSB8fCAwO1xuICAgICAgaWYoeERlc3Ryb3kgJiYgIWlzRnVuYyh4RGVzdHJveSkpe1xuICAgICAgICB0b3NzMyhcInhEZXN0cm95IHByb3BlcnR5IG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgICB9XG4gICAgICBsZXQgZkZsYWdzID0gMCA7XG4gICAgICBpZihnZXRPd25PcHRpb24ob3B0LCAnZGV0ZXJtaW5pc3RpYycpKSBmRmxhZ3MgfD0gY2FwaS5TUUxJVEVfREVURVJNSU5JU1RJQztcbiAgICAgIGlmKGdldE93bk9wdGlvbihvcHQsICdkaXJlY3RPbmx5JykpIGZGbGFncyB8PSBjYXBpLlNRTElURV9ESVJFQ1RPTkxZO1xuICAgICAgaWYoZ2V0T3duT3B0aW9uKG9wdCwgJ2lubm9jdW91cycpKSBmRmxhZ3MgfD0gY2FwaS5TUUxJVEVfSU5OT0NVT1VTO1xuICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHhBcml0eSA9IHhGdW5jIHx8IHhTdGVwO1xuICAgICAgY29uc3QgYXJpdHkgPSBnZXRPd25PcHRpb24ob3B0LCAnYXJpdHknKTtcbiAgICAgIGNvbnN0IGFyaXR5QXJnID0gKCdudW1iZXInPT09dHlwZW9mIGFyaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFyaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh4QXJpdHkubGVuZ3RoID8geEFyaXR5Lmxlbmd0aC0xIDogMCkpO1xuICAgICAgbGV0IHJjO1xuICAgICAgaWYoIGlzV2luZG93ICl7XG4gICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2NyZWF0ZV93aW5kb3dfZnVuY3Rpb24oXG4gICAgICAgICAgdGhpcy5wb2ludGVyLCBuYW1lLCBhcml0eUFyZyxcbiAgICAgICAgICBjYXBpLlNRTElURV9VVEY4IHwgZkZsYWdzLCBwQXBwIHx8IDAsXG4gICAgICAgICAgeFN0ZXAsIHhGaW5hbCwgeFZhbHVlLCB4SW52ZXJzZSwgeERlc3Ryb3kpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJjID0gY2FwaS5zcWxpdGUzX2NyZWF0ZV9mdW5jdGlvbl92MihcbiAgICAgICAgICB0aGlzLnBvaW50ZXIsIG5hbWUsIGFyaXR5QXJnLFxuICAgICAgICAgIGNhcGkuU1FMSVRFX1VURjggfCBmRmxhZ3MsIHBBcHAgfHwgMCxcbiAgICAgICAgICB4RnVuYywgeFN0ZXAsIHhGaW5hbCwgeERlc3Ryb3kpO1xuICAgICAgfVxuICAgICAgREIuY2hlY2tSYyh0aGlzLCByYyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIHNlbGVjdFZhbHVlOiBmdW5jdGlvbihzcWwsYmluZCxhc1R5cGUpe1xuICAgICAgcmV0dXJuIF9fc2VsZWN0Rmlyc3RSb3codGhpcywgc3FsLCBiaW5kLCAwLCBhc1R5cGUpO1xuICAgIH0sXG5cbiAgICBcbiAgICBzZWxlY3RWYWx1ZXM6IGZ1bmN0aW9uKHNxbCxiaW5kLGFzVHlwZSl7XG4gICAgICBjb25zdCBzdG10ID0gdGhpcy5wcmVwYXJlKHNxbCksIHJjID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBzdG10LmJpbmQoYmluZCk7XG4gICAgICAgIHdoaWxlKHN0bXQuc3RlcCgpKSByYy5wdXNoKHN0bXQuZ2V0KDAsYXNUeXBlKSk7XG4gICAgICAgIHN0bXQucmVzZXQoKTtcbiAgICAgIH1maW5hbGx5e1xuICAgICAgICBzdG10LmZpbmFsaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcblxuICAgIFxuICAgIHNlbGVjdEFycmF5OiBmdW5jdGlvbihzcWwsYmluZCl7XG4gICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIFtdKTtcbiAgICB9LFxuXG4gICAgXG4gICAgc2VsZWN0T2JqZWN0OiBmdW5jdGlvbihzcWwsYmluZCl7XG4gICAgICByZXR1cm4gX19zZWxlY3RGaXJzdFJvdyh0aGlzLCBzcWwsIGJpbmQsIHt9KTtcbiAgICB9LFxuXG4gICAgXG4gICAgc2VsZWN0QXJyYXlzOiBmdW5jdGlvbihzcWwsYmluZCl7XG4gICAgICByZXR1cm4gX19zZWxlY3RBbGwodGhpcywgc3FsLCBiaW5kLCAnYXJyYXknKTtcbiAgICB9LFxuXG4gICAgXG4gICAgc2VsZWN0T2JqZWN0czogZnVuY3Rpb24oc3FsLGJpbmQpe1xuICAgICAgcmV0dXJuIF9fc2VsZWN0QWxsKHRoaXMsIHNxbCwgYmluZCwgJ29iamVjdCcpO1xuICAgIH0sXG5cbiAgICBcbiAgICBvcGVuU3RhdGVtZW50Q291bnQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5wb2ludGVyID8gT2JqZWN0LmtleXMoX19zdG10TWFwLmdldCh0aGlzKSkubGVuZ3RoIDogMDtcbiAgICB9LFxuXG4gICAgXG4gICAgdHJhbnNhY3Rpb246IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICAgIGxldCBvcGVuZXIgPSAnQkVHSU4nO1xuICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aD4xKXtcbiAgICAgICAgaWYoL1teYS16QS1aXS8udGVzdChhcmd1bWVudHNbMF0pKXtcbiAgICAgICAgICB0b3NzMyhjYXBpLlNRTElURV9NSVNVU0UsIFwiSW52YWxpZCBhcmd1bWVudCBmb3IgQkVHSU4gcXVhbGlmaWVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuZXIgKz0gJyAnK2FyZ3VtZW50c1swXTtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG4gICAgICBhZmZpcm1EYk9wZW4odGhpcykuZXhlYyhvcGVuZXIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmMgPSBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgdGhpcy5leGVjKFwiQ09NTUlUXCIpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHRoaXMuZXhlYyhcIlJPTExCQUNLXCIpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcbiAgICBzYXZlcG9pbnQ6IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICAgIGFmZmlybURiT3Blbih0aGlzKS5leGVjKFwiU0FWRVBPSU5UIG9vMVwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJjID0gY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHRoaXMuZXhlYyhcIlJFTEVBU0Ugb28xXCIpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHRoaXMuZXhlYyhcIlJPTExCQUNLIHRvIFNBVkVQT0lOVCBvbzE7IFJFTEVBU0UgU0FWRVBPSU5UIG9vMVwiKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXG4gICAgY2hlY2tSYzogZnVuY3Rpb24ocmVzdWx0Q29kZSl7XG4gICAgICByZXR1cm4gY2hlY2tTcWxpdGUzUmModGhpcywgcmVzdWx0Q29kZSk7XG4gICAgfVxuICB9O1xuXG5cbiAgXG4gIGNvbnN0IGFmZmlybVN0bXRPcGVuID0gZnVuY3Rpb24oc3RtdCl7XG4gICAgaWYoIXN0bXQucG9pbnRlcikgdG9zczMoXCJTdG10IGhhcyBiZWVuIGNsb3NlZC5cIik7XG4gICAgcmV0dXJuIHN0bXQ7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGlzU3VwcG9ydGVkQmluZFR5cGUgPSBmdW5jdGlvbih2KXtcbiAgICBsZXQgdCA9IEJpbmRUeXBlc1sobnVsbD09PXZ8fHVuZGVmaW5lZD09PXYpID8gJ251bGwnIDogdHlwZW9mIHZdO1xuICAgIHN3aXRjaCh0KXtcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMuYm9vbGVhbjpcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVsbDpcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVtYmVyOlxuICAgICAgICBjYXNlIEJpbmRUeXBlcy5zdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLmJpZ2ludDpcbiAgICAgICAgICBpZih3YXNtLmJpZ0ludEVuYWJsZWQpIHJldHVybiB0O1xuICAgICAgICAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHYpID8gQmluZFR5cGVzLmJsb2IgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIFxuICBjb25zdCBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZSA9IGZ1bmN0aW9uKHYpe1xuICAgIFxuICAgIHJldHVybiBpc1N1cHBvcnRlZEJpbmRUeXBlKHYpIHx8IHRvc3MzKFwiVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6XCIsdHlwZW9mIHYpO1xuICB9O1xuXG4gIFxuICBjb25zdCBhZmZpcm1QYXJhbUluZGV4ID0gZnVuY3Rpb24oc3RtdCxrZXkpe1xuICAgIGNvbnN0IG4gPSAoJ251bWJlcic9PT10eXBlb2Yga2V5KVxuICAgICAgICAgID8ga2V5IDogY2FwaS5zcWxpdGUzX2JpbmRfcGFyYW1ldGVyX2luZGV4KHN0bXQucG9pbnRlciwga2V5KTtcbiAgICBpZigwPT09biB8fCAhdXRpbC5pc0ludDMyKG4pKXtcbiAgICAgIHRvc3MzKFwiSW52YWxpZCBiaW5kKCkgcGFyYW1ldGVyIG5hbWU6IFwiK2tleSk7XG4gICAgfVxuICAgIGVsc2UgaWYobjwxIHx8IG4+c3RtdC5wYXJhbWV0ZXJDb3VudCkgdG9zczMoXCJCaW5kIGluZGV4XCIsa2V5LFwiaXMgb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gbjtcbiAgfTtcblxuICBcbiAgY29uc3QgYWZmaXJtTm90TG9ja2VkQnlFeGVjID0gZnVuY3Rpb24oc3RtdCxjdXJyZW50T3BOYW1lKXtcbiAgICBpZihzdG10Ll9sb2NrZWRCeUV4ZWMpe1xuICAgICAgdG9zczMoXCJPcGVyYXRpb24gaXMgaWxsZWdhbCB3aGVuIHN0YXRlbWVudCBpcyBsb2NrZWQ6XCIsY3VycmVudE9wTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBzdG10O1xuICB9O1xuXG4gIFxuICBjb25zdCBiaW5kT25lID0gZnVuY3Rpb24gZihzdG10LG5keCxiaW5kVHlwZSx2YWwpe1xuICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyhhZmZpcm1TdG10T3BlbihzdG10KSwgJ2JpbmQoKScpO1xuICAgIGlmKCFmLl8pe1xuICAgICAgZi5fdG9vQmlnSW50ID0gKHYpPT50b3NzMyhcbiAgICAgICAgXCJCaWdJbnQgdmFsdWUgaXMgdG9vIGJpZyB0byBzdG9yZSB3aXRob3V0IHByZWNpc2lvbiBsb3NzOlwiLCB2XG4gICAgICApO1xuICAgICAgZi5fID0ge1xuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uKHN0bXQsIG5keCwgdmFsLCBhc0Jsb2Ipe1xuICAgICAgICAgIGNvbnN0IFtwU3RyLCBuXSA9IHdhc20uYWxsb2NDU3RyaW5nKHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgZiA9IGFzQmxvYiA/IGNhcGkuc3FsaXRlM19iaW5kX2Jsb2IgOiBjYXBpLnNxbGl0ZTNfYmluZF90ZXh0O1xuICAgICAgICAgIHJldHVybiBmKHN0bXQucG9pbnRlciwgbmR4LCBwU3RyLCBuLCBjYXBpLlNRTElURV9XQVNNX0RFQUxMT0MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBhZmZpcm1TdXBwb3J0ZWRCaW5kVHlwZSh2YWwpO1xuICAgIG5keCA9IGFmZmlybVBhcmFtSW5kZXgoc3RtdCxuZHgpO1xuICAgIGxldCByYyA9IDA7XG4gICAgc3dpdGNoKChudWxsPT09dmFsIHx8IHVuZGVmaW5lZD09PXZhbCkgPyBCaW5kVHlwZXMubnVsbCA6IGJpbmRUeXBlKXtcbiAgICAgICAgY2FzZSBCaW5kVHlwZXMubnVsbDpcbiAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX251bGwoc3RtdC5wb2ludGVyLCBuZHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJpbmRUeXBlcy5zdHJpbmc6XG4gICAgICAgICAgcmMgPSBmLl8uc3RyaW5nKHN0bXQsIG5keCwgdmFsLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmluZFR5cGVzLm51bWJlcjoge1xuICAgICAgICAgIGxldCBtO1xuICAgICAgICAgIGlmKHV0aWwuaXNJbnQzMih2YWwpKSBtID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50O1xuICAgICAgICAgIGVsc2UgaWYoJ2JpZ2ludCc9PT10eXBlb2YgdmFsKXtcbiAgICAgICAgICAgIGlmKCF1dGlsLmJpZ0ludEZpdHM2NCh2YWwpKXtcbiAgICAgICAgICAgICAgZi5fdG9vQmlnSW50KHZhbCk7XG4gICAgICAgICAgICB9ZWxzZSBpZih3YXNtLmJpZ0ludEVuYWJsZWQpe1xuICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfaW50NjQ7XG4gICAgICAgICAgICB9ZWxzZSBpZih1dGlsLmJpZ0ludEZpdHNEb3VibGUodmFsKSl7XG4gICAgICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfZG91YmxlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGYuX3Rvb0JpZ0ludCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNleyBcbiAgICAgICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICAgICAgaWYod2FzbS5iaWdJbnRFbmFibGVkICYmIE51bWJlci5pc0ludGVnZXIodmFsKSl7XG4gICAgICAgICAgICAgIG0gPSBjYXBpLnNxbGl0ZTNfYmluZF9pbnQ2NDtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBtID0gY2FwaS5zcWxpdGUzX2JpbmRfZG91YmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByYyA9IG0oc3RtdC5wb2ludGVyLCBuZHgsIHZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBCaW5kVHlwZXMuYm9vbGVhbjpcbiAgICAgICAgICByYyA9IGNhcGkuc3FsaXRlM19iaW5kX2ludChzdG10LnBvaW50ZXIsIG5keCwgdmFsID8gMSA6IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJpbmRUeXBlcy5ibG9iOiB7XG4gICAgICAgICAgaWYoJ3N0cmluZyc9PT10eXBlb2YgdmFsKXtcbiAgICAgICAgICAgIHJjID0gZi5fLnN0cmluZyhzdG10LCBuZHgsIHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9ZWxzZSBpZih2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7XG4gICAgICAgICAgICB2YWwgPSBuZXcgVWludDhBcnJheSh2YWwpO1xuICAgICAgICAgIH1lbHNlIGlmKCF1dGlsLmlzQmluZGFibGVUeXBlZEFycmF5KHZhbCkpe1xuICAgICAgICAgICAgdG9zczMoXCJCaW5kaW5nIGEgdmFsdWUgYXMgYSBibG9iIHJlcXVpcmVzXCIsXG4gICAgICAgICAgICAgICAgICBcInRoYXQgaXQgYmUgYSBzdHJpbmcsIFVpbnQ4QXJyYXksIEludDhBcnJheSwgb3IgQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwQmxvYiA9IHdhc20uYWxsb2ModmFsLmJ5dGVMZW5ndGggfHwgMSk7XG4gICAgICAgICAgd2FzbS5oZWFwOCgpLnNldCh2YWwuYnl0ZUxlbmd0aCA/IHZhbCA6IFswXSwgcEJsb2IpXG4gICAgICAgICAgcmMgPSBjYXBpLnNxbGl0ZTNfYmluZF9ibG9iKHN0bXQucG9pbnRlciwgbmR4LCBwQmxvYiwgdmFsLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcGkuU1FMSVRFX1dBU01fREVBTExPQyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFwiVW5zdXBwb3J0ZWQgYmluZCgpIGFyZ3VtZW50IHR5cGU6XCIsdmFsKTtcbiAgICAgICAgICB0b3NzMyhcIlVuc3VwcG9ydGVkIGJpbmQoKSBhcmd1bWVudCB0eXBlOiBcIisodHlwZW9mIHZhbCkpO1xuICAgIH1cbiAgICBpZihyYykgREIuY2hlY2tSYyhzdG10LmRiLnBvaW50ZXIsIHJjKTtcbiAgICBzdG10Ll9tYXlHZXQgPSBmYWxzZTtcbiAgICByZXR1cm4gc3RtdDtcbiAgfTtcblxuICBTdG10LnByb3RvdHlwZSA9IHtcbiAgICBcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgIGlmKHRoaXMucG9pbnRlcil7XG4gICAgICAgIGFmZmlybU5vdExvY2tlZEJ5RXhlYyh0aGlzLCdmaW5hbGl6ZSgpJyk7XG4gICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX2ZpbmFsaXplKHRoaXMucG9pbnRlcik7XG4gICAgICAgIGRlbGV0ZSBfX3N0bXRNYXAuZ2V0KHRoaXMuZGIpW3RoaXMucG9pbnRlcl07XG4gICAgICAgIF9fcHRyTWFwLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21heUdldDtcbiAgICAgICAgZGVsZXRlIHRoaXMucGFyYW1ldGVyQ291bnQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sb2NrZWRCeUV4ZWM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRiO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBjbGVhckJpbmRpbmdzOiBmdW5jdGlvbigpe1xuICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKGFmZmlybVN0bXRPcGVuKHRoaXMpLCAnY2xlYXJCaW5kaW5ncygpJylcbiAgICAgIGNhcGkuc3FsaXRlM19jbGVhcl9iaW5kaW5ncyh0aGlzLnBvaW50ZXIpO1xuICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIHJlc2V0OiBmdW5jdGlvbihhbHNvQ2xlYXJCaW5kcyl7XG4gICAgICBhZmZpcm1Ob3RMb2NrZWRCeUV4ZWModGhpcywncmVzZXQoKScpO1xuICAgICAgaWYoYWxzb0NsZWFyQmluZHMpIHRoaXMuY2xlYXJCaW5kaW5ncygpO1xuICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfcmVzZXQoYWZmaXJtU3RtdE9wZW4odGhpcykucG9pbnRlcik7XG4gICAgICB0aGlzLl9tYXlHZXQgPSBmYWxzZTtcbiAgICAgIGNoZWNrU3FsaXRlM1JjKHRoaXMuZGIsIHJjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgYmluZDogZnVuY3Rpb24oKXtcbiAgICAgIGFmZmlybVN0bXRPcGVuKHRoaXMpO1xuICAgICAgbGV0IG5keCwgYXJnO1xuICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgIGNhc2UgMTogbmR4ID0gMTsgYXJnID0gYXJndW1lbnRzWzBdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IG5keCA9IGFyZ3VtZW50c1swXTsgYXJnID0gYXJndW1lbnRzWzFdOyBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB0b3NzMyhcIkludmFsaWQgYmluZCgpIGFyZ3VtZW50cy5cIik7XG4gICAgICB9XG4gICAgICBpZih1bmRlZmluZWQ9PT1hcmcpe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9ZWxzZSBpZighdGhpcy5wYXJhbWV0ZXJDb3VudCl7XG4gICAgICAgIHRvc3MzKFwiVGhpcyBzdGF0ZW1lbnQgaGFzIG5vIGJpbmRhYmxlIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICBpZihudWxsPT09YXJnKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBiaW5kT25lKHRoaXMsIG5keCwgQmluZFR5cGVzLm51bGwsIGFyZyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkoYXJnKSl7XG4gICAgICAgIFxuICAgICAgICBpZigxIT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgdG9zczMoXCJXaGVuIGJpbmRpbmcgYW4gYXJyYXksIGFuIGluZGV4IGFyZ3VtZW50IGlzIG5vdCBwZXJtaXR0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGFyZy5mb3JFYWNoKCh2LGkpPT5iaW5kT25lKHRoaXMsIGkrMSwgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUodiksIHYpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9ZWxzZSBpZihhcmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7XG4gICAgICAgIGFyZyA9IG5ldyBVaW50OEFycmF5KGFyZyk7XG4gICAgICB9XG4gICAgICBpZignb2JqZWN0Jz09PXR5cGVvZiBhcmdcbiAgICAgICAgICAgICAgJiYgIXV0aWwuaXNCaW5kYWJsZVR5cGVkQXJyYXkoYXJnKSl7XG4gICAgICAgIFxuICAgICAgICBpZigxIT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgdG9zczMoXCJXaGVuIGJpbmRpbmcgYW4gb2JqZWN0LCBhbiBpbmRleCBhcmd1bWVudCBpcyBub3QgcGVybWl0dGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhhcmcpXG4gICAgICAgICAgLmZvckVhY2goaz0+YmluZE9uZSh0aGlzLCBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUoYXJnW2tdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1trXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYmluZE9uZSh0aGlzLCBuZHgsIGFmZmlybVN1cHBvcnRlZEJpbmRUeXBlKGFyZyksIGFyZyk7XG4gICAgICB9XG4gICAgICB0b3NzMyhcIlNob3VsZCBub3QgcmVhY2ggdGhpcyBwb2ludC5cIik7XG4gICAgfSxcbiAgICBcbiAgICBiaW5kQXNCbG9iOiBmdW5jdGlvbihuZHgsYXJnKXtcbiAgICAgIGFmZmlybVN0bXRPcGVuKHRoaXMpO1xuICAgICAgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICBhcmcgPSBuZHg7XG4gICAgICAgIG5keCA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gYWZmaXJtU3VwcG9ydGVkQmluZFR5cGUoYXJnKTtcbiAgICAgIGlmKEJpbmRUeXBlcy5zdHJpbmcgIT09IHQgJiYgQmluZFR5cGVzLmJsb2IgIT09IHRcbiAgICAgICAgICYmIEJpbmRUeXBlcy5udWxsICE9PSB0KXtcbiAgICAgICAgdG9zczMoXCJJbnZhbGlkIHZhbHVlIHR5cGUgZm9yIGJpbmRBc0Jsb2IoKVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5kT25lKHRoaXMsIG5keCwgQmluZFR5cGVzLmJsb2IsIGFyZyk7XG4gICAgfSxcbiAgICBcbiAgICBzdGVwOiBmdW5jdGlvbigpe1xuICAgICAgYWZmaXJtTm90TG9ja2VkQnlFeGVjKHRoaXMsICdzdGVwKCknKTtcbiAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX3N0ZXAoYWZmaXJtU3RtdE9wZW4odGhpcykucG9pbnRlcik7XG4gICAgICBzd2l0Y2gocmMpe1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfRE9ORTogcmV0dXJuIHRoaXMuX21heUdldCA9IGZhbHNlO1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfUk9XOiByZXR1cm4gdGhpcy5fbWF5R2V0ID0gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fbWF5R2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBzcWxpdGUzLmNvbmZpZy53YXJuKFwic3FsaXRlM19zdGVwKCkgcmM9XCIscmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2FwaS5zcWxpdGUzX2pzX3JjX3N0cihyYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJTUUwgPVwiLCBjYXBpLnNxbGl0ZTNfc3FsKHRoaXMucG9pbnRlcikpO1xuICAgICAgICAgICAgREIuY2hlY2tSYyh0aGlzLmRiLnBvaW50ZXIsIHJjKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0ZXBSZXNldDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuc3RlcCgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcbiAgICB9LFxuICAgIFxuICAgIHN0ZXBGaW5hbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgcmMgPSB0aGlzLnN0ZXAoKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9ZmluYWxseXtcbiAgICAgICAgdHJ5e3RoaXMuZmluYWxpemUoKX1cbiAgICAgICAgY2F0Y2goZSl7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZ2V0OiBmdW5jdGlvbihuZHgsYXNUeXBlKXtcbiAgICAgIGlmKCFhZmZpcm1TdG10T3Blbih0aGlzKS5fbWF5R2V0KXtcbiAgICAgICAgdG9zczMoXCJTdG10LnN0ZXAoKSBoYXMgbm90IChyZWNlbnRseSkgcmV0dXJuZWQgdHJ1ZS5cIik7XG4gICAgICB9XG4gICAgICBpZihBcnJheS5pc0FycmF5KG5keCkpe1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICB3aGlsZShpPG4pe1xuICAgICAgICAgIG5keFtpXSA9IHRoaXMuZ2V0KGkrKyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5keDtcbiAgICAgIH1lbHNlIGlmKG5keCAmJiAnb2JqZWN0Jz09PXR5cGVvZiBuZHgpe1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbHVtbkNvdW50O1xuICAgICAgICB3aGlsZShpPG4pe1xuICAgICAgICAgIG5keFtjYXBpLnNxbGl0ZTNfY29sdW1uX25hbWUodGhpcy5wb2ludGVyLGkpXSA9IHRoaXMuZ2V0KGkrKyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5keDtcbiAgICAgIH1cbiAgICAgIGFmZmlybUNvbEluZGV4KHRoaXMsIG5keCk7XG4gICAgICBzd2l0Y2godW5kZWZpbmVkPT09YXNUeXBlXG4gICAgICAgICAgICAgPyBjYXBpLnNxbGl0ZTNfY29sdW1uX3R5cGUodGhpcy5wb2ludGVyLCBuZHgpXG4gICAgICAgICAgICAgOiBhc1R5cGUpe1xuICAgICAgICAgIGNhc2UgY2FwaS5TUUxJVEVfTlVMTDogcmV0dXJuIG51bGw7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9JTlRFR0VSOntcbiAgICAgICAgICAgIGlmKHdhc20uYmlnSW50RW5hYmxlZCl7XG4gICAgICAgICAgICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9pbnQ2NCh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgIGlmKHJjPj1OdW1iZXIuTUlOX1NBRkVfSU5URUdFUiAmJiByYzw9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIocmMpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmM7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgY29uc3QgcmMgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2RvdWJsZSh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgICAgIGlmKHJjPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IHJjPE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0b3NzMyhcIkludGVnZXIgaXMgb3V0IG9mIHJhbmdlIGZvciBKUyBpbnRlZ2VyIHJhbmdlOiBcIityYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB1dGlsLmlzSW50MzIocmMpID8gKHJjIHwgMCkgOiByYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9GTE9BVDpcbiAgICAgICAgICAgIHJldHVybiBjYXBpLnNxbGl0ZTNfY29sdW1uX2RvdWJsZSh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9URVhUOlxuICAgICAgICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fdGV4dCh0aGlzLnBvaW50ZXIsIG5keCk7XG4gICAgICAgICAgY2FzZSBjYXBpLlNRTElURV9CTE9COiB7XG4gICAgICAgICAgICBjb25zdCBuID0gY2FwaS5zcWxpdGUzX2NvbHVtbl9ieXRlcyh0aGlzLnBvaW50ZXIsIG5keCksXG4gICAgICAgICAgICAgICAgICBwdHIgPSBjYXBpLnNxbGl0ZTNfY29sdW1uX2Jsb2IodGhpcy5wb2ludGVyLCBuZHgpLFxuICAgICAgICAgICAgICAgICAgcmMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYobikgcmMuc2V0KHdhc20uaGVhcDh1KCkuc2xpY2UocHRyLCBwdHIrbiksIDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihuICYmIHRoaXMuZGIuX2Jsb2JYZmVyIGluc3RhbmNlb2YgQXJyYXkpe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdGhpcy5kYi5fYmxvYlhmZXIucHVzaChyYy5idWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB0b3NzMyhcIkRvbid0IGtub3cgaG93IHRvIHRyYW5zbGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZSBvZiByZXN1bHQgY29sdW1uICNcIituZHgrXCIuXCIpO1xuICAgICAgfVxuICAgICAgdG9zczMoXCJOb3QgcmVhY2hlZC5cIik7XG4gICAgfSxcbiAgICBcbiAgICBnZXRJbnQ6IGZ1bmN0aW9uKG5keCl7cmV0dXJuIHRoaXMuZ2V0KG5keCxjYXBpLlNRTElURV9JTlRFR0VSKX0sXG4gICAgXG4gICAgZ2V0RmxvYXQ6IGZ1bmN0aW9uKG5keCl7cmV0dXJuIHRoaXMuZ2V0KG5keCxjYXBpLlNRTElURV9GTE9BVCl9LFxuICAgIFxuICAgIGdldFN0cmluZzogZnVuY3Rpb24obmR4KXtyZXR1cm4gdGhpcy5nZXQobmR4LGNhcGkuU1FMSVRFX1RFWFQpfSxcbiAgICBcbiAgICBnZXRCbG9iOiBmdW5jdGlvbihuZHgpe3JldHVybiB0aGlzLmdldChuZHgsY2FwaS5TUUxJVEVfQkxPQil9LFxuICAgIFxuICAgIGdldEpTT046IGZ1bmN0aW9uKG5keCl7XG4gICAgICBjb25zdCBzID0gdGhpcy5nZXQobmR4LCBjYXBpLlNRTElURV9TVFJJTkcpO1xuICAgICAgcmV0dXJuIG51bGw9PT1zID8gcyA6IEpTT04ucGFyc2Uocyk7XG4gICAgfSxcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBnZXRDb2x1bW5OYW1lOiBmdW5jdGlvbihuZHgpe1xuICAgICAgcmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fbmFtZShcbiAgICAgICAgYWZmaXJtQ29sSW5kZXgoYWZmaXJtU3RtdE9wZW4odGhpcyksbmR4KS5wb2ludGVyLCBuZHhcbiAgICAgICk7XG4gICAgfSxcbiAgICBcbiAgICBnZXRDb2x1bW5OYW1lczogZnVuY3Rpb24odGd0PVtdKXtcbiAgICAgIGFmZmlybUNvbEluZGV4KGFmZmlybVN0bXRPcGVuKHRoaXMpLDApO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29sdW1uQ291bnQ7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbjsgKytpKXtcbiAgICAgICAgdGd0LnB1c2goY2FwaS5zcWxpdGUzX2NvbHVtbl9uYW1lKHRoaXMucG9pbnRlciwgaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRndDtcbiAgICB9LFxuICAgIFxuICAgIGdldFBhcmFtSW5kZXg6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgcmV0dXJuIChhZmZpcm1TdG10T3Blbih0aGlzKS5wYXJhbWV0ZXJDb3VudFxuICAgICAgICAgICAgICA/IGNhcGkuc3FsaXRlM19iaW5kX3BhcmFtZXRlcl9pbmRleCh0aGlzLnBvaW50ZXIsIG5hbWUpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIGNvbnN0IHByb3AgPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpe3JldHVybiBfX3B0ck1hcC5nZXQodGhpcyl9LFxuICAgICAgc2V0OiAoKT0+dG9zczMoXCJUaGUgcG9pbnRlciBwcm9wZXJ0eSBpcyByZWFkLW9ubHkuXCIpXG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG10LnByb3RvdHlwZSwgJ3BvaW50ZXInLCBwcm9wKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoREIucHJvdG90eXBlLCAncG9pbnRlcicsIHByb3ApO1xuICB9XG4gIFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RtdC5wcm90b3R5cGUsICdjb2x1bW5Db3VudCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNhcGkuc3FsaXRlM19jb2x1bW5fY291bnQodGhpcy5wb2ludGVyKX0sXG4gICAgc2V0OiAoKT0+dG9zczMoXCJUaGUgY29sdW1uQ291bnQgcHJvcGVydHkgaXMgcmVhZC1vbmx5LlwiKVxuICB9KTtcblxuICBcbiAgc3FsaXRlMy5vbzEgPSB7XG4gICAgREIsXG4gICAgU3RtdFxuICB9O1xuXG4gIGlmKHV0aWwuaXNVSVRocmVhZCgpKXtcbiAgICBcbiAgICBzcWxpdGUzLm9vMS5Kc1N0b3JhZ2VEYiA9IGZ1bmN0aW9uKHN0b3JhZ2VOYW1lPSdzZXNzaW9uJyl7XG4gICAgICBpZignc2Vzc2lvbichPT1zdG9yYWdlTmFtZSAmJiAnbG9jYWwnIT09c3RvcmFnZU5hbWUpe1xuICAgICAgICB0b3NzMyhcIkpzU3RvcmFnZURiIGRiIG5hbWUgbXVzdCBiZSBvbmUgb2YgJ3Nlc3Npb24nIG9yICdsb2NhbCcuXCIpO1xuICAgICAgfVxuICAgICAgZGJDdG9ySGVscGVyLmNhbGwodGhpcywge1xuICAgICAgICBmaWxlbmFtZTogc3RvcmFnZU5hbWUsXG4gICAgICAgIGZsYWdzOiAnYycsXG4gICAgICAgIHZmczogXCJrdnZmc1wiXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGpkYiA9IHNxbGl0ZTMub28xLkpzU3RvcmFnZURiO1xuICAgIGpkYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERCLnByb3RvdHlwZSk7XG4gICAgXG4gICAgamRiLmNsZWFyU3RvcmFnZSA9IGNhcGkuc3FsaXRlM19qc19rdnZmc19jbGVhcjtcbiAgICBcbiAgICBqZGIucHJvdG90eXBlLmNsZWFyU3RvcmFnZSA9IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gamRiLmNsZWFyU3RvcmFnZShhZmZpcm1EYk9wZW4odGhpcykuZmlsZW5hbWUpO1xuICAgIH07XG4gICAgXG4gICAgamRiLnN0b3JhZ2VTaXplID0gY2FwaS5zcWxpdGUzX2pzX2t2dmZzX3NpemU7XG4gICAgXG4gICAgamRiLnByb3RvdHlwZS5zdG9yYWdlU2l6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gamRiLnN0b3JhZ2VTaXplKGFmZmlybURiT3Blbih0aGlzKS5maWxlbmFtZSk7XG4gICAgfTtcbiAgfVxuXG59KTtcblxuXG5cblxuXG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oc3FsaXRlMyl7XG5zcWxpdGUzLmluaXRXb3JrZXIxQVBJID0gZnVuY3Rpb24oKXtcbiAgJ3VzZSBzdHJpY3QnO1xuICBjb25zdCB0b3NzID0gKC4uLmFyZ3MpPT57dGhyb3cgbmV3IEVycm9yKGFyZ3Muam9pbignICcpKX07XG4gIGlmKCEoZ2xvYmFsVGhpcy5Xb3JrZXJHbG9iYWxTY29wZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl7XG4gICAgdG9zcyhcImluaXRXb3JrZXIxQVBJKCkgbXVzdCBiZSBydW4gZnJvbSBhIFdvcmtlciB0aHJlYWQuXCIpO1xuICB9XG4gIGNvbnN0IHNxbGl0ZTMgPSB0aGlzLnNxbGl0ZTMgfHwgdG9zcyhcIk1pc3NpbmcgdGhpcy5zcWxpdGUzIG9iamVjdC5cIik7XG4gIGNvbnN0IERCID0gc3FsaXRlMy5vbzEuREI7XG5cbiAgXG4gIGNvbnN0IGdldERiSWQgPSBmdW5jdGlvbihkYil7XG4gICAgbGV0IGlkID0gd1N0YXRlLmlkTWFwLmdldChkYik7XG4gICAgaWYoaWQpIHJldHVybiBpZDtcbiAgICBpZCA9ICdkYiMnKygrK3dTdGF0ZS5pZFNlcSkrJ0AnK2RiLnBvaW50ZXI7XG4gICAgXG4gICAgd1N0YXRlLmlkTWFwLnNldChkYiwgaWQpO1xuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICBcbiAgY29uc3Qgd1N0YXRlID0ge1xuICAgIFxuICAgIGRiTGlzdDogW10sXG4gICAgXG4gICAgaWRTZXE6IDAsXG4gICAgXG4gICAgaWRNYXA6IG5ldyBXZWFrTWFwLFxuICAgIFxuICAgIHhmZXI6IFtdLFxuICAgIG9wZW46IGZ1bmN0aW9uKG9wdCl7XG4gICAgICBjb25zdCBkYiA9IG5ldyBEQihvcHQpO1xuICAgICAgdGhpcy5kYnNbZ2V0RGJJZChkYildID0gZGI7XG4gICAgICBpZih0aGlzLmRiTGlzdC5pbmRleE9mKGRiKTwwKSB0aGlzLmRiTGlzdC5wdXNoKGRiKTtcbiAgICAgIHJldHVybiBkYjtcbiAgICB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbihkYixhbHNvVW5saW5rKXtcbiAgICAgIGlmKGRiKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGJzW2dldERiSWQoZGIpXTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgICAgY29uc3QgcFZmcyA9IHNxbGl0ZTMud2FzbS5zcWxpdGUzX3dhc21fZGJfdmZzKGRiLnBvaW50ZXIsIDApO1xuICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICBjb25zdCBkZE5keCA9IHRoaXMuZGJMaXN0LmluZGV4T2YoZGIpO1xuICAgICAgICBpZihkZE5keD49MCkgdGhpcy5kYkxpc3Quc3BsaWNlKGRkTmR4LCAxKTtcbiAgICAgICAgaWYoYWxzb1VubGluayAmJiBmaWxlbmFtZSAmJiBwVmZzKXtcbiAgICAgICAgICBzcWxpdGUzLndhc20uc3FsaXRlM193YXNtX3Zmc191bmxpbmsocFZmcywgZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBwb3N0OiBmdW5jdGlvbihtc2cseGZlckxpc3Qpe1xuICAgICAgaWYoeGZlckxpc3QgJiYgeGZlckxpc3QubGVuZ3RoKXtcbiAgICAgICAgZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSggbXNnLCBBcnJheS5mcm9tKHhmZXJMaXN0KSApO1xuICAgICAgICB4ZmVyTGlzdC5sZW5ndGggPSAwO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGdsb2JhbFRoaXMucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGRiczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBcbiAgICBnZXREYjogZnVuY3Rpb24oaWQscmVxdWlyZT10cnVlKXtcbiAgICAgIHJldHVybiB0aGlzLmRic1tpZF1cbiAgICAgICAgfHwgKHJlcXVpcmUgPyB0b3NzKFwiVW5rbm93biAob3IgY2xvc2VkKSBEQiBJRDpcIixpZCkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfTtcblxuICBcbiAgY29uc3QgYWZmaXJtRGJPcGVuID0gZnVuY3Rpb24oZGIgPSB3U3RhdGUuZGJMaXN0WzBdKXtcbiAgICByZXR1cm4gKGRiICYmIGRiLnBvaW50ZXIpID8gZGIgOiB0b3NzKFwiREIgaXMgbm90IG9wZW5lZC5cIik7XG4gIH07XG5cbiAgXG4gIGNvbnN0IGdldE1zZ0RiID0gZnVuY3Rpb24obXNnRGF0YSxhZmZpcm1FeGlzdHM9dHJ1ZSl7XG4gICAgY29uc3QgZGIgPSB3U3RhdGUuZ2V0RGIobXNnRGF0YS5kYklkLGZhbHNlKSB8fCB3U3RhdGUuZGJMaXN0WzBdO1xuICAgIHJldHVybiBhZmZpcm1FeGlzdHMgPyBhZmZpcm1EYk9wZW4oZGIpIDogZGI7XG4gIH07XG5cbiAgY29uc3QgZ2V0RGVmYXVsdERiSWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB3U3RhdGUuZGJMaXN0WzBdICYmIGdldERiSWQod1N0YXRlLmRiTGlzdFswXSk7XG4gIH07XG5cbiAgY29uc3QgZ3Vlc3NWZnMgPSBmdW5jdGlvbihmaWxlbmFtZSl7XG4gICAgY29uc3QgbSA9IC9eZmlsZTouKyh2ZnM9KFxcdyspKS8uZXhlYyhmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHNxbGl0ZTMuY2FwaS5zcWxpdGUzX3Zmc19maW5kKG0gPyBtWzJdIDogMCk7XG4gIH07XG5cbiAgY29uc3QgaXNTcGVjaWFsRGJGaWxlbmFtZSA9IChuKT0+e1xuICAgIHJldHVybiBcIlwiPT09biB8fCAnOic9PT1uWzBdO1xuICB9O1xuXG4gIFxuICBjb25zdCB3TXNnSGFuZGxlciA9IHtcbiAgICBvcGVuOiBmdW5jdGlvbihldil7XG4gICAgICBjb25zdCBvYXJncyA9IE9iamVjdC5jcmVhdGUobnVsbCksIGFyZ3MgPSAoZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgIGlmKGFyZ3Muc2ltdWxhdGVFcnJvcil7IFxuICAgICAgICB0b3NzKFwiVGhyb3dpbmcgYmVjYXVzZSBvZiBzaW11bGF0ZUVycm9yIGZsYWcuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbGV0IGJ5dGVBcnJheSwgcFZmcztcbiAgICAgIG9hcmdzLnZmcyA9IGFyZ3MudmZzO1xuICAgICAgaWYoaXNTcGVjaWFsRGJGaWxlbmFtZShhcmdzLmZpbGVuYW1lKSl7XG4gICAgICAgIG9hcmdzLmZpbGVuYW1lID0gYXJncy5maWxlbmFtZSB8fCBcIlwiO1xuICAgICAgfWVsc2V7XG4gICAgICAgIG9hcmdzLmZpbGVuYW1lID0gYXJncy5maWxlbmFtZTtcbiAgICAgICAgYnl0ZUFycmF5ID0gYXJncy5ieXRlQXJyYXk7XG4gICAgICAgIGlmKGJ5dGVBcnJheSkgcFZmcyA9IGd1ZXNzVmZzKGFyZ3MuZmlsZW5hbWUpO1xuICAgICAgfVxuICAgICAgaWYocFZmcyl7XG4gICAgICAgIFxuICAgICAgICBsZXQgcE1lbTtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIHBNZW0gPSBzcWxpdGUzLndhc20uYWxsb2NGcm9tVHlwZWRBcnJheShieXRlQXJyYXkpO1xuICAgICAgICAgIGNvbnN0IHJjID0gc3FsaXRlMy53YXNtLnNxbGl0ZTNfd2FzbV92ZnNfY3JlYXRlX2ZpbGUoXG4gICAgICAgICAgICBwVmZzLCBvYXJncy5maWxlbmFtZSwgcE1lbSwgYnl0ZUFycmF5LmJ5dGVMZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmKHJjKSBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKHJjKTtcbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIHRocm93IG5ldyBzcWxpdGUzLlNRTGl0ZTNFcnJvcihcbiAgICAgICAgICAgIGUubmFtZSsnIGNyZWF0aW5nICcrYXJncy5maWxlbmFtZStcIjogXCIrZS5tZXNzYWdlLCB7XG4gICAgICAgICAgICAgIGNhdXNlOiBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfWZpbmFsbHl7XG4gICAgICAgICAgaWYocE1lbSkgc3FsaXRlMy53YXNtLmRlYWxsb2MocE1lbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRiID0gd1N0YXRlLm9wZW4ob2FyZ3MpO1xuICAgICAgcmMuZmlsZW5hbWUgPSBkYi5maWxlbmFtZTtcbiAgICAgIHJjLnBlcnNpc3RlbnQgPSAhIXNxbGl0ZTMuY2FwaS5zcWxpdGUzX2pzX2RiX3VzZXNfdmZzKGRiLnBvaW50ZXIsIFwib3Bmc1wiKTtcbiAgICAgIHJjLmRiSWQgPSBnZXREYklkKGRiKTtcbiAgICAgIHJjLnZmcyA9IGRiLmRiVmZzTmFtZSgpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH0sXG5cbiAgICBjbG9zZTogZnVuY3Rpb24oZXYpe1xuICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldixmYWxzZSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgZmlsZW5hbWU6IGRiICYmIGRiLmZpbGVuYW1lXG4gICAgICB9O1xuICAgICAgaWYoZGIpe1xuICAgICAgICBjb25zdCBkb1VubGluayA9ICgoZXYuYXJncyAmJiAnb2JqZWN0Jz09PXR5cGVvZiBldi5hcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgID8gISFldi5hcmdzLnVubGluayA6IGZhbHNlKTtcbiAgICAgICAgd1N0YXRlLmNsb3NlKGRiLCBkb1VubGluayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcblxuICAgIGV4ZWM6IGZ1bmN0aW9uKGV2KXtcbiAgICAgIGNvbnN0IHJjID0gKFxuICAgICAgICAnc3RyaW5nJz09PXR5cGVvZiBldi5hcmdzXG4gICAgICApID8ge3NxbDogZXYuYXJnc30gOiAoZXYuYXJncyB8fCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgIGlmKCdzdG10Jz09PXJjLnJvd01vZGUpe1xuICAgICAgICB0b3NzKFwiSW52YWxpZCByb3dNb2RlIGZvciAnZXhlYyc6IHN0bXQgbW9kZVwiLFxuICAgICAgICAgICAgIFwiZG9lcyBub3Qgd29yayBpbiB0aGUgV29ya2VyIEFQSS5cIik7XG4gICAgICB9ZWxzZSBpZighcmMuc3FsKXtcbiAgICAgICAgdG9zcyhcIidleGVjJyByZXF1aXJlcyBpbnB1dCBTUUwuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGIgPSBnZXRNc2dEYihldik7XG4gICAgICBpZihyYy5jYWxsYmFjayB8fCBBcnJheS5pc0FycmF5KHJjLnJlc3VsdFJvd3MpKXtcbiAgICAgICAgXG4gICAgICAgIGRiLl9ibG9iWGZlciA9IHdTdGF0ZS54ZmVyO1xuICAgICAgfVxuICAgICAgY29uc3QgdGhlQ2FsbGJhY2sgPSByYy5jYWxsYmFjaztcbiAgICAgIGxldCByb3dOdW1iZXIgPSAwO1xuICAgICAgY29uc3QgaGFkQ29sTmFtZXMgPSAhIXJjLmNvbHVtbk5hbWVzO1xuICAgICAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiB0aGVDYWxsYmFjayl7XG4gICAgICAgIGlmKCFoYWRDb2xOYW1lcykgcmMuY29sdW1uTmFtZXMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIHJjLmNhbGxiYWNrID0gZnVuY3Rpb24ocm93LHN0bXQpe1xuICAgICAgICAgIHdTdGF0ZS5wb3N0KHtcbiAgICAgICAgICAgIHR5cGU6IHRoZUNhbGxiYWNrLFxuICAgICAgICAgICAgY29sdW1uTmFtZXM6IHJjLmNvbHVtbk5hbWVzLFxuICAgICAgICAgICAgcm93TnVtYmVyOiArK3Jvd051bWJlcixcbiAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgfSwgd1N0YXRlLnhmZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGFuZ2VDb3VudCA9ICEhcmMuY291bnRDaGFuZ2VzXG4gICAgICAgICAgICAgID8gZGIuY2hhbmdlcyh0cnVlLCg2ND09PXJjLmNvdW50Q2hhbmdlcykpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBkYi5leGVjKHJjKTtcbiAgICAgICAgaWYodW5kZWZpbmVkICE9PSBjaGFuZ2VDb3VudCl7XG4gICAgICAgICAgcmMuY2hhbmdlQ291bnQgPSBkYi5jaGFuZ2VzKHRydWUsNjQ9PT1yYy5jb3VudENoYW5nZXMpIC0gY2hhbmdlQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYocmMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG4gICAgICAgICAgcmMuY2FsbGJhY2sgPSB0aGVDYWxsYmFjaztcbiAgICAgICAgICBcbiAgICAgICAgICB3U3RhdGUucG9zdCh7XG4gICAgICAgICAgICB0eXBlOiB0aGVDYWxsYmFjayxcbiAgICAgICAgICAgIGNvbHVtbk5hbWVzOiByYy5jb2x1bW5OYW1lcyxcbiAgICAgICAgICAgIHJvd051bWJlcjogbnVsbCAsXG4gICAgICAgICAgICByb3c6IHVuZGVmaW5lZCBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIGRlbGV0ZSBkYi5fYmxvYlhmZXI7XG4gICAgICAgIGlmKHJjLmNhbGxiYWNrKSByYy5jYWxsYmFjayA9IHRoZUNhbGxiYWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJjO1xuICAgIH0sXG5cbiAgICAnY29uZmlnLWdldCc6IGZ1bmN0aW9uKCl7XG4gICAgICBjb25zdCByYyA9IE9iamVjdC5jcmVhdGUobnVsbCksIHNyYyA9IHNxbGl0ZTMuY29uZmlnO1xuICAgICAgW1xuICAgICAgICAnYmlnSW50RW5hYmxlZCdcbiAgICAgIF0uZm9yRWFjaChmdW5jdGlvbihrKXtcbiAgICAgICAgaWYoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGspKSByY1trXSA9IHNyY1trXTtcbiAgICAgIH0pO1xuICAgICAgcmMudmVyc2lvbiA9IHNxbGl0ZTMudmVyc2lvbjtcbiAgICAgIHJjLnZmc0xpc3QgPSBzcWxpdGUzLmNhcGkuc3FsaXRlM19qc192ZnNfbGlzdCgpO1xuICAgICAgcmMub3Bmc0VuYWJsZWQgPSAhIXNxbGl0ZTMub3BmcztcbiAgICAgIHJldHVybiByYztcbiAgICB9LFxuXG4gICAgXG4gICAgZXhwb3J0OiBmdW5jdGlvbihldil7XG4gICAgICBjb25zdCBkYiA9IGdldE1zZ0RiKGV2KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBieXRlQXJyYXk6IHNxbGl0ZTMuY2FwaS5zcWxpdGUzX2pzX2RiX2V4cG9ydChkYi5wb2ludGVyKSxcbiAgICAgICAgZmlsZW5hbWU6IGRiLmZpbGVuYW1lLFxuICAgICAgICBtaW1ldHlwZTogJ2FwcGxpY2F0aW9uL3gtc3FsaXRlMydcbiAgICAgIH07XG4gICAgICB3U3RhdGUueGZlci5wdXNoKHJlc3BvbnNlLmJ5dGVBcnJheS5idWZmZXIpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG5cbiAgICB0b3NzOiBmdW5jdGlvbihldil7XG4gICAgICB0b3NzKFwiVGVzdGluZyB3b3JrZXIgZXhjZXB0aW9uXCIpO1xuICAgIH0sXG5cbiAgICAnb3Bmcy10cmVlJzogYXN5bmMgZnVuY3Rpb24oZXYpe1xuICAgICAgaWYoIXNxbGl0ZTMub3BmcykgdG9zcyhcIk9QRlMgc3VwcG9ydCBpcyB1bmF2YWlsYWJsZS5cIik7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNxbGl0ZTMub3Bmcy50cmVlTGlzdCgpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgfTtcblxuICBnbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGFzeW5jIGZ1bmN0aW9uKGV2KXtcbiAgICBldiA9IGV2LmRhdGE7XG4gICAgbGV0IHJlc3VsdCwgZGJJZCA9IGV2LmRiSWQsIGV2VHlwZSA9IGV2LnR5cGU7XG4gICAgY29uc3QgYXJyaXZhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0cnkge1xuICAgICAgaWYod01zZ0hhbmRsZXIuaGFzT3duUHJvcGVydHkoZXZUeXBlKSAmJlxuICAgICAgICAgd01zZ0hhbmRsZXJbZXZUeXBlXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgd01zZ0hhbmRsZXJbZXZUeXBlXShldik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdG9zcyhcIlVua25vd24gZGIgd29ya2VyIG1lc3NhZ2UgdHlwZTpcIixldi50eXBlKTtcbiAgICAgIH1cbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIGV2VHlwZSA9ICdlcnJvcic7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG9wZXJhdGlvbjogZXYudHlwZSxcbiAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgIGVycm9yQ2xhc3M6IGVyci5uYW1lLFxuICAgICAgICBpbnB1dDogZXZcbiAgICAgIH07XG4gICAgICBpZihlcnIuc3RhY2spe1xuICAgICAgICByZXN1bHQuc3RhY2sgPSAoJ3N0cmluZyc9PT10eXBlb2YgZXJyLnN0YWNrKVxuICAgICAgICAgID8gZXJyLnN0YWNrLnNwbGl0KC9cXG5cXHMqLykgOiBlcnIuc3RhY2s7XG4gICAgICB9XG4gICAgICBpZigwKSBzcWxpdGUzLmNvbmZpZy53YXJuKFwiV29ya2VyIGlzIHByb3BhZ2F0aW5nIGFuIGV4Y2VwdGlvbiB0byBtYWluIHRocmVhZC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJSZXBvcnRpbmcgaXQgX2hlcmVfIGZvciB0aGUgc3RhY2sgdHJhY2U6XCIsZXJyLHJlc3VsdCk7XG4gICAgfVxuICAgIGlmKCFkYklkKXtcbiAgICAgIGRiSWQgPSByZXN1bHQuZGJJZFxuICAgICAgICB8fCBnZXREZWZhdWx0RGJJZCgpO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICB3U3RhdGUucG9zdCh7XG4gICAgICB0eXBlOiBldlR5cGUsXG4gICAgICBkYklkOiBkYklkLFxuICAgICAgbWVzc2FnZUlkOiBldi5tZXNzYWdlSWQsXG4gICAgICB3b3JrZXJSZWNlaXZlZFRpbWU6IGFycml2YWxUaW1lLFxuICAgICAgd29ya2VyUmVzcG9uZFRpbWU6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgZGVwYXJ0dXJlVGltZTogZXYuZGVwYXJ0dXJlVGltZSxcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgfSwgd1N0YXRlLnhmZXIpO1xuICB9O1xuICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKHt0eXBlOidzcWxpdGUzLWFwaScscmVzdWx0Oid3b3JrZXIxLXJlYWR5J30pO1xufS5iaW5kKHtzcWxpdGUzfSk7XG59KTtcblxuXG5cblxuXG4ndXNlIHN0cmljdCc7XG5nbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAuaW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oc3FsaXRlMyl7XG4gIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc20sIGNhcGkgPSBzcWxpdGUzLmNhcGksIHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gIGNvbnN0IHZmcyA9IE9iamVjdC5jcmVhdGUobnVsbCksIHZ0YWIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGNvbnN0IFN0cnVjdEJpbmRlciA9IHNxbGl0ZTMuU3RydWN0QmluZGVyXG4gIDtcbiAgc3FsaXRlMy52ZnMgPSB2ZnM7XG4gIHNxbGl0ZTMudnRhYiA9IHZ0YWI7XG5cbiAgY29uc3Qgc2lpID0gY2FwaS5zcWxpdGUzX2luZGV4X2luZm87XG4gIFxuICBzaWkucHJvdG90eXBlLm50aENvbnN0cmFpbnQgPSBmdW5jdGlvbihuLCBhc1B0cj1mYWxzZSl7XG4gICAgaWYobjwwIHx8IG4+PXRoaXMuJG5Db25zdHJhaW50KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcHRyID0gdGhpcy4kYUNvbnN0cmFpbnQgKyAoXG4gICAgICBzaWkuc3FsaXRlM19pbmRleF9jb25zdHJhaW50LnN0cnVjdEluZm8uc2l6ZW9mICogblxuICAgICk7XG4gICAgcmV0dXJuIGFzUHRyID8gcHRyIDogbmV3IHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnQocHRyKTtcbiAgfTtcblxuICBcbiAgc2lpLnByb3RvdHlwZS5udGhDb25zdHJhaW50VXNhZ2UgPSBmdW5jdGlvbihuLCBhc1B0cj1mYWxzZSl7XG4gICAgaWYobjwwIHx8IG4+PXRoaXMuJG5Db25zdHJhaW50KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcHRyID0gdGhpcy4kYUNvbnN0cmFpbnRVc2FnZSArIChcbiAgICAgIHNpaS5zcWxpdGUzX2luZGV4X2NvbnN0cmFpbnRfdXNhZ2Uuc3RydWN0SW5mby5zaXplb2YgKiBuXG4gICAgKTtcbiAgICByZXR1cm4gYXNQdHIgPyBwdHIgOiBuZXcgc2lpLnNxbGl0ZTNfaW5kZXhfY29uc3RyYWludF91c2FnZShwdHIpO1xuICB9O1xuXG4gIFxuICBzaWkucHJvdG90eXBlLm50aE9yZGVyQnkgPSBmdW5jdGlvbihuLCBhc1B0cj1mYWxzZSl7XG4gICAgaWYobjwwIHx8IG4+PXRoaXMuJG5PcmRlckJ5KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcHRyID0gdGhpcy4kYU9yZGVyQnkgKyAoXG4gICAgICBzaWkuc3FsaXRlM19pbmRleF9vcmRlcmJ5LnN0cnVjdEluZm8uc2l6ZW9mICogblxuICAgICk7XG4gICAgcmV0dXJuIGFzUHRyID8gcHRyIDogbmV3IHNpaS5zcWxpdGUzX2luZGV4X29yZGVyYnkocHRyKTtcbiAgfTtcblxuICBcbiAgY29uc3QgaW5zdGFsbE1ldGhvZCA9IGZ1bmN0aW9uIGNhbGxlZShcbiAgICB0Z3QsIG5hbWUsIGZ1bmMsIGFwcGx5QXJnY0NoZWNrID0gY2FsbGVlLmluc3RhbGxNZXRob2RBcmdjQ2hlY2tcbiAgKXtcbiAgICBpZighKHRndCBpbnN0YW5jZW9mIFN0cnVjdEJpbmRlci5TdHJ1Y3RUeXBlKSl7XG4gICAgICB0b3NzKFwiVXNhZ2UgZXJyb3I6IHRhcmdldCBvYmplY3QgaXMtbm90LWEgU3RydWN0VHlwZS5cIik7XG4gICAgfWVsc2UgaWYoIShmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24pICYmICF3YXNtLmlzUHRyKGZ1bmMpKXtcbiAgICAgIHRvc3MoXCJVc2FnZSBlcnJyb3I6IGV4cGVjdGluZyBhIEZ1bmN0aW9uIG9yIFdBU00gcG9pbnRlciB0byBvbmUuXCIpO1xuICAgIH1cbiAgICBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICByZXR1cm4gKG4sZik9PmNhbGxlZSh0Z3QsIG4sIGYsIGFwcGx5QXJnY0NoZWNrKTtcbiAgICB9XG4gICAgaWYoIWNhbGxlZS5hcmdjUHJveHkpe1xuICAgICAgY2FsbGVlLmFyZ2NQcm94eSA9IGZ1bmN0aW9uKHRndCwgZnVuY05hbWUsIGZ1bmMsc2lnKXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3Mpe1xuICAgICAgICAgIGlmKGZ1bmMubGVuZ3RoIT09YXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICB0b3NzKFwiQXJndW1lbnQgbWlzbWF0Y2ggZm9yXCIsXG4gICAgICAgICAgICAgICAgIHRndC5zdHJ1Y3RJbmZvLm5hbWUrXCI6OlwiK2Z1bmNOYW1lXG4gICAgICAgICAgICAgICAgICtcIjogTmF0aXZlIHNpZ25hdHVyZSBpczpcIixzaWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYodGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdCl7XG4gICAgICAgICAgdGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdC5mb3JFYWNoKFxuICAgICAgICAgICAgKHYsbmR4KT0+e1xuICAgICAgICAgICAgICBpZignbnVtYmVyJz09PXR5cGVvZiB2KXtcbiAgICAgICAgICAgICAgICB0cnl7d2FzbS51bmluc3RhbGxGdW5jdGlvbih2KX1cbiAgICAgICAgICAgICAgICBjYXRjaChlKXt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5vbmRpc3Bvc2UuX19yZW1vdmVGdW5jTGlzdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2lnTiA9IHRndC5tZW1iZXJTaWduYXR1cmUobmFtZSk7XG4gICAgaWYoc2lnTi5sZW5ndGg8Mil7XG4gICAgICB0b3NzKFwiTWVtYmVyXCIsbmFtZSxcImRvZXMgbm90IGhhdmUgYSBmdW5jdGlvbiBwb2ludGVyIHNpZ25hdHVyZTpcIixzaWdOKTtcbiAgICB9XG4gICAgY29uc3QgbWVtS2V5ID0gdGd0Lm1lbWJlcktleShuYW1lKTtcbiAgICBjb25zdCBmUHJveHkgPSAoYXBwbHlBcmdjQ2hlY2sgJiYgIXdhc20uaXNQdHIoZnVuYykpXG4gICAgXG4gICAgICAgICAgPyBjYWxsZWUuYXJnY1Byb3h5KHRndCwgbWVtS2V5LCBmdW5jLCBzaWdOKVxuICAgICAgICAgIDogZnVuYztcbiAgICBpZih3YXNtLmlzUHRyKGZQcm94eSkpe1xuICAgICAgaWYoZlByb3h5ICYmICF3YXNtLmZ1bmN0aW9uRW50cnkoZlByb3h5KSl7XG4gICAgICAgIHRvc3MoXCJQb2ludGVyXCIsZlByb3h5LFwiaXMgbm90IGEgV0FTTSBmdW5jdGlvbiB0YWJsZSBlbnRyeS5cIik7XG4gICAgICB9XG4gICAgICB0Z3RbbWVtS2V5XSA9IGZQcm94eTtcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnN0IHBGdW5jID0gd2FzbS5pbnN0YWxsRnVuY3Rpb24oZlByb3h5LCB0Z3QubWVtYmVyU2lnbmF0dXJlKG5hbWUsIHRydWUpKTtcbiAgICAgIHRndFttZW1LZXldID0gcEZ1bmM7XG4gICAgICBpZighdGd0Lm9uZGlzcG9zZSB8fCAhdGd0Lm9uZGlzcG9zZS5fX3JlbW92ZUZ1bmNMaXN0KXtcbiAgICAgICAgdGd0LmFkZE9uRGlzcG9zZSgnb25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QgaGFuZGxlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlLnJlbW92ZUZ1bmNMaXN0KTtcbiAgICAgICAgdGd0Lm9uZGlzcG9zZS5fX3JlbW92ZUZ1bmNMaXN0ID0gW107XG4gICAgICB9XG4gICAgICB0Z3Qub25kaXNwb3NlLl9fcmVtb3ZlRnVuY0xpc3QucHVzaChtZW1LZXksIHBGdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIChuLGYpPT5jYWxsZWUodGd0LCBuLCBmLCBhcHBseUFyZ2NDaGVjayk7XG4gIH07XG4gIGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVjayA9IGZhbHNlO1xuXG4gIFxuICBjb25zdCBpbnN0YWxsTWV0aG9kcyA9IGZ1bmN0aW9uKFxuICAgIHN0cnVjdEluc3RhbmNlLCBtZXRob2RzLCBhcHBseUFyZ2NDaGVjayA9IGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVja1xuICApe1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgTWFwIDtcbiAgICBmb3IoY29uc3QgayBvZiBPYmplY3Qua2V5cyhtZXRob2RzKSl7XG4gICAgICBjb25zdCBtID0gbWV0aG9kc1trXTtcbiAgICAgIGNvbnN0IHByaW9yID0gc2Vlbi5nZXQobSk7XG4gICAgICBpZihwcmlvcil7XG4gICAgICAgIGNvbnN0IG1rZXkgPSBzdHJ1Y3RJbnN0YW5jZS5tZW1iZXJLZXkoayk7XG4gICAgICAgIHN0cnVjdEluc3RhbmNlW21rZXldID0gc3RydWN0SW5zdGFuY2Vbc3RydWN0SW5zdGFuY2UubWVtYmVyS2V5KHByaW9yKV07XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaW5zdGFsbE1ldGhvZChzdHJ1Y3RJbnN0YW5jZSwgaywgbSwgYXBwbHlBcmdjQ2hlY2spO1xuICAgICAgICBzZWVuLnNldChtLCBrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdEluc3RhbmNlO1xuICB9O1xuXG4gIFxuICBTdHJ1Y3RCaW5kZXIuU3RydWN0VHlwZS5wcm90b3R5cGUuaW5zdGFsbE1ldGhvZCA9IGZ1bmN0aW9uIGNhbGxlZShcbiAgICBuYW1lLCBmdW5jLCBhcHBseUFyZ2NDaGVjayA9IGluc3RhbGxNZXRob2QuaW5zdGFsbE1ldGhvZEFyZ2NDaGVja1xuICApe1xuICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA8IDMgJiYgbmFtZSAmJiAnb2JqZWN0Jz09PXR5cGVvZiBuYW1lKVxuICAgICAgPyBpbnN0YWxsTWV0aG9kcyh0aGlzLCAuLi5hcmd1bWVudHMpXG4gICAgICA6IGluc3RhbGxNZXRob2QodGhpcywgLi4uYXJndW1lbnRzKTtcbiAgfTtcblxuICBcbiAgU3RydWN0QmluZGVyLlN0cnVjdFR5cGUucHJvdG90eXBlLmluc3RhbGxNZXRob2RzID0gZnVuY3Rpb24oXG4gICAgbWV0aG9kcywgYXBwbHlBcmdjQ2hlY2sgPSBpbnN0YWxsTWV0aG9kLmluc3RhbGxNZXRob2RBcmdjQ2hlY2tcbiAgKXtcbiAgICByZXR1cm4gaW5zdGFsbE1ldGhvZHModGhpcywgbWV0aG9kcywgYXBwbHlBcmdjQ2hlY2spO1xuICB9O1xuXG4gIFxuICBjYXBpLnNxbGl0ZTNfdmZzLnByb3RvdHlwZS5yZWdpc3RlclZmcyA9IGZ1bmN0aW9uKGFzRGVmYXVsdD1mYWxzZSl7XG4gICAgaWYoISh0aGlzIGluc3RhbmNlb2Ygc3FsaXRlMy5jYXBpLnNxbGl0ZTNfdmZzKSl7XG4gICAgICB0b3NzKFwiRXhwZWN0aW5nIGEgc3FsaXRlM192ZnMtdHlwZSBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJjID0gY2FwaS5zcWxpdGUzX3Zmc19yZWdpc3Rlcih0aGlzLCBhc0RlZmF1bHQgPyAxIDogMCk7XG4gICAgaWYocmMpe1xuICAgICAgdG9zcyhcInNxbGl0ZTNfdmZzX3JlZ2lzdGVyKFwiLHRoaXMsXCIpIGZhaWxlZCB3aXRoIHJjXCIscmMpO1xuICAgIH1cbiAgICBpZih0aGlzLnBvaW50ZXIgIT09IGNhcGkuc3FsaXRlM192ZnNfZmluZCh0aGlzLiR6TmFtZSkpe1xuICAgICAgdG9zcyhcIkJVRzogc3FsaXRlM192ZnNfZmluZCh2ZnMuJHpOYW1lKSBmYWlsZWQgZm9yIGp1c3QtaW5zdGFsbGVkIFZGU1wiLFxuICAgICAgICAgICB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXG4gIHZmcy5pbnN0YWxsVmZzID0gZnVuY3Rpb24ob3B0KXtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHByb3BMaXN0ID0gWydpbycsJ3ZmcyddO1xuICAgIGZvcihjb25zdCBrZXkgb2YgcHJvcExpc3Qpe1xuICAgICAgY29uc3QgbyA9IG9wdFtrZXldO1xuICAgICAgaWYobyl7XG4gICAgICAgICsrY291bnQ7XG4gICAgICAgIGluc3RhbGxNZXRob2RzKG8uc3RydWN0LCBvLm1ldGhvZHMsICEhby5hcHBseUFyZ2NDaGVjayk7XG4gICAgICAgIGlmKCd2ZnMnPT09a2V5KXtcbiAgICAgICAgICBpZighby5zdHJ1Y3QuJHpOYW1lICYmICdzdHJpbmcnPT09dHlwZW9mIG8ubmFtZSl7XG4gICAgICAgICAgICBvLnN0cnVjdC5hZGRPbkRpc3Bvc2UoXG4gICAgICAgICAgICAgIG8uc3RydWN0LiR6TmFtZSA9IHdhc20uYWxsb2NDU3RyaW5nKG8ubmFtZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG8uc3RydWN0LnJlZ2lzdGVyVmZzKCEhby5hc0RlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKCFjb3VudCkgdG9zcyhcIk1pc3VzZTogaW5zdGFsbFZmcygpIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVzIGF0IGxlYXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwib25lIG9mOlwiLCBwcm9wTGlzdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgXG4gIGNvbnN0IF9feFdyYXBGYWN0b3J5ID0gZnVuY3Rpb24obWV0aG9kTmFtZSxTdHJ1Y3RUeXBlKXtcbiAgICByZXR1cm4gZnVuY3Rpb24ocHRyLHJlbW92ZU1hcHBpbmc9ZmFsc2Upe1xuICAgICAgaWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpIHB0ciA9IG5ldyBTdHJ1Y3RUeXBlO1xuICAgICAgaWYocHRyIGluc3RhbmNlb2YgU3RydWN0VHlwZSl7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldChwdHIucG9pbnRlciwgcHRyKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgIH1lbHNlIGlmKCF3YXNtLmlzUHRyKHB0cikpe1xuICAgICAgICBzcWxpdGUzLlNRTGl0ZTNFcnJvci50b3NzKFwiSW52YWxpZCBhcmd1bWVudCB0b1wiLG1ldGhvZE5hbWUrXCIoKVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByYyA9IHRoaXMuZ2V0KHB0cik7XG4gICAgICBpZihyZW1vdmVNYXBwaW5nKSB0aGlzLmRlbGV0ZShwdHIpO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH0uYmluZChuZXcgTWFwKTtcbiAgfTtcblxuICBcbiAgY29uc3QgU3RydWN0UHRyTWFwcGVyID0gZnVuY3Rpb24obmFtZSwgU3RydWN0VHlwZSl7XG4gICAgY29uc3QgX194V3JhcCA9IF9feFdyYXBGYWN0b3J5KG5hbWUsU3RydWN0VHlwZSk7XG4gICAgXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7XG4gICAgICBcbiAgICAgIFN0cnVjdFR5cGUsXG4gICAgICBcbiAgICAgIGNyZWF0ZTogKHBwT3V0KT0+e1xuICAgICAgICBjb25zdCByYyA9IF9feFdyYXAoKTtcbiAgICAgICAgd2FzbS5wb2tlUHRyKHBwT3V0LCByYy5wb2ludGVyKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgZ2V0OiAocENPYmopPT5fX3hXcmFwKHBDT2JqKSxcbiAgICAgIFxuICAgICAgdW5nZXQ6IChwQ09iaik9Pl9feFdyYXAocENPYmosdHJ1ZSksXG4gICAgICBcbiAgICAgIGRpc3Bvc2U6IChwQ09iaik9PntcbiAgICAgICAgY29uc3QgbyA9IF9feFdyYXAocENPYmosdHJ1ZSk7XG4gICAgICAgIGlmKG8pIG8uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFxuICB2dGFiLnhWdGFiID0gU3RydWN0UHRyTWFwcGVyKCd4VnRhYicsIGNhcGkuc3FsaXRlM192dGFiKTtcblxuICBcbiAgdnRhYi54Q3Vyc29yID0gU3RydWN0UHRyTWFwcGVyKCd4Q3Vyc29yJywgY2FwaS5zcWxpdGUzX3Z0YWJfY3Vyc29yKTtcblxuICBcbiAgdnRhYi54SW5kZXhJbmZvID0gKHBJZHhJbmZvKT0+bmV3IGNhcGkuc3FsaXRlM19pbmRleF9pbmZvKHBJZHhJbmZvKTtcblxuICBcbiAgXG5cbiAgXG4gIHZ0YWIueEVycm9yID0gZnVuY3Rpb24gZihtZXRob2ROYW1lLCBlcnIsIGRlZmF1bHRSYyl7XG4gICAgaWYoZi5lcnJvclJlcG9ydGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgdHJ5e2YuZXJyb3JSZXBvcnRlcihcInNxbGl0ZTNfbW9kdWxlOjpcIittZXRob2ROYW1lK1wiKCk6IFwiK2Vyci5tZXNzYWdlKTt9XG4gICAgICBjYXRjaChlKXt9XG4gICAgfVxuICAgIGxldCByYztcbiAgICBpZihlcnIgaW5zdGFuY2VvZiBzcWxpdGUzLldhc21BbGxvY0Vycm9yKSByYyA9IGNhcGkuU1FMSVRFX05PTUVNO1xuICAgIGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aD4yKSByYyA9IGRlZmF1bHRSYztcbiAgICBlbHNlIGlmKGVyciBpbnN0YW5jZW9mIHNxbGl0ZTMuU1FMaXRlM0Vycm9yKSByYyA9IGVyci5yZXN1bHRDb2RlO1xuICAgIHJldHVybiByYyB8fCBjYXBpLlNRTElURV9FUlJPUjtcbiAgfTtcbiAgdnRhYi54RXJyb3IuZXJyb3JSZXBvcnRlciA9IDEgPyBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSkgOiBmYWxzZTtcblxuICBcbiAgXG5cbiAgXG4gIHZ0YWIueFJvd2lkID0gKHBwUm93aWQ2NCwgdmFsdWUpPT53YXNtLnBva2UocHBSb3dpZDY0LCB2YWx1ZSwgJ2k2NCcpO1xuXG4gIFxuICB2dGFiLnNldHVwTW9kdWxlID0gZnVuY3Rpb24ob3B0KXtcbiAgICBsZXQgY3JlYXRlZE1vZCA9IGZhbHNlO1xuICAgIGNvbnN0IG1vZCA9ICh0aGlzIGluc3RhbmNlb2YgY2FwaS5zcWxpdGUzX21vZHVsZSlcbiAgICAgICAgICA/IHRoaXMgOiAob3B0LnN0cnVjdCB8fCAoY3JlYXRlZE1vZCA9IG5ldyBjYXBpLnNxbGl0ZTNfbW9kdWxlKCkpKTtcbiAgICB0cnl7XG4gICAgICBjb25zdCBtZXRob2RzID0gb3B0Lm1ldGhvZHMgfHwgdG9zcyhcIk1pc3NpbmcgJ21ldGhvZHMnIG9iamVjdC5cIik7XG4gICAgICBmb3IoY29uc3QgZSBvZiBPYmplY3QuZW50cmllcyh7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgeENvbm5lY3Q6ICd4Q3JlYXRlJywgeERpc2Nvbm5lY3Q6ICd4RGVzdHJveSdcbiAgICAgIH0pKXtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGsgPSBlWzBdLCB2ID0gZVsxXTtcbiAgICAgICAgaWYodHJ1ZSA9PT0gbWV0aG9kc1trXSkgbWV0aG9kc1trXSA9IG1ldGhvZHNbdl07XG4gICAgICAgIGVsc2UgaWYodHJ1ZSA9PT0gbWV0aG9kc1t2XSkgbWV0aG9kc1t2XSA9IG1ldGhvZHNba107XG4gICAgICB9XG4gICAgICBpZihvcHQuY2F0Y2hFeGNlcHRpb25zKXtcbiAgICAgICAgY29uc3QgZndyYXAgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBmdW5jKXtcbiAgICAgICAgICBpZihbJ3hDb25uZWN0JywneENyZWF0ZSddLmluZGV4T2YobWV0aG9kTmFtZSkgPj0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocERiLCBwQXV4LCBhcmdjLCBhcmd2LCBwcFZ0YWIsIHB6RXJyKXtcbiAgICAgICAgICAgICAgdHJ5e3JldHVybiBmdW5jKC4uLmFyZ3VtZW50cykgfHwgMH1cbiAgICAgICAgICAgICAgY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgaWYoIShlIGluc3RhbmNlb2Ygc3FsaXRlMy5XYXNtQWxsb2NFcnJvcikpe1xuICAgICAgICAgICAgICAgICAgd2FzbS5kZWFsbG9jKHdhc20ucGVla1B0cihwekVycikpO1xuICAgICAgICAgICAgICAgICAgd2FzbS5wb2tlUHRyKHB6RXJyLCB3YXNtLmFsbG9jQ1N0cmluZyhlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZ0YWIueEVycm9yKG1ldGhvZE5hbWUsIGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3Mpe1xuICAgICAgICAgICAgICB0cnl7cmV0dXJuIGZ1bmMoLi4uYXJncykgfHwgMH1cbiAgICAgICAgICAgICAgY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZ0YWIueEVycm9yKG1ldGhvZE5hbWUsIGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbW5hbWVzID0gW1xuICAgICAgICAgICd4Q3JlYXRlJywgJ3hDb25uZWN0JywgJ3hCZXN0SW5kZXgnLCAneERpc2Nvbm5lY3QnLFxuICAgICAgICAgICd4RGVzdHJveScsICd4T3BlbicsICd4Q2xvc2UnLCAneEZpbHRlcicsICd4TmV4dCcsXG4gICAgICAgICAgJ3hFb2YnLCAneENvbHVtbicsICd4Um93aWQnLCAneFVwZGF0ZScsXG4gICAgICAgICAgJ3hCZWdpbicsICd4U3luYycsICd4Q29tbWl0JywgJ3hSb2xsYmFjaycsXG4gICAgICAgICAgJ3hGaW5kRnVuY3Rpb24nLCAneFJlbmFtZScsICd4U2F2ZXBvaW50JywgJ3hSZWxlYXNlJyxcbiAgICAgICAgICAneFJvbGxiYWNrVG8nLCAneFNoYWRvd05hbWUnXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJlbWV0aG9kcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvcihjb25zdCBrIG9mIG1uYW1lcyl7XG4gICAgICAgICAgY29uc3QgbSA9IG1ldGhvZHNba107XG4gICAgICAgICAgaWYoIShtIGluc3RhbmNlb2YgRnVuY3Rpb24pKSBjb250aW51ZTtcbiAgICAgICAgICBlbHNlIGlmKCd4Q29ubmVjdCc9PT1rICYmIG1ldGhvZHMueENyZWF0ZT09PW0pe1xuICAgICAgICAgICAgcmVtZXRob2RzW2tdID0gbWV0aG9kcy54Q3JlYXRlO1xuICAgICAgICAgIH1lbHNlIGlmKCd4Q3JlYXRlJz09PWsgJiYgbWV0aG9kcy54Q29ubmVjdD09PW0pe1xuICAgICAgICAgICAgcmVtZXRob2RzW2tdID0gbWV0aG9kcy54Q29ubmVjdDtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJlbWV0aG9kc1trXSA9IGZ3cmFwKGssIG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnN0YWxsTWV0aG9kcyhtb2QsIHJlbWV0aG9kcywgZmFsc2UpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaW5zdGFsbE1ldGhvZHMoXG4gICAgICAgICAgbW9kLCBtZXRob2RzLCAhIW9wdC5hcHBseUFyZ2NDaGVja1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYoMD09PW1vZC4kaVZlcnNpb24pe1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgaWYoJ251bWJlcic9PT10eXBlb2Ygb3B0LmlWZXJzaW9uKSB2ID0gb3B0LmlWZXJzaW9uO1xuICAgICAgICBlbHNlIGlmKG1vZC4keFNoYWRvd05hbWUpIHYgPSAzO1xuICAgICAgICBlbHNlIGlmKG1vZC4keFNhdmVQb2ludCB8fCBtb2QuJHhSZWxlYXNlIHx8IG1vZC4keFJvbGxiYWNrVG8pIHYgPSAyO1xuICAgICAgICBlbHNlIHYgPSAxO1xuICAgICAgICBtb2QuJGlWZXJzaW9uID0gdjtcbiAgICAgIH1cbiAgICB9Y2F0Y2goZSl7XG4gICAgICBpZihjcmVhdGVkTW9kKSBjcmVhdGVkTW9kLmRpc3Bvc2UoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiBtb2Q7XG4gIH07XG5cbiAgXG4gIGNhcGkuc3FsaXRlM19tb2R1bGUucHJvdG90eXBlLnNldHVwTW9kdWxlID0gZnVuY3Rpb24ob3B0KXtcbiAgICByZXR1cm4gdnRhYi5zZXR1cE1vZHVsZS5jYWxsKHRoaXMsIG9wdCk7XG4gIH07XG59KTtcblxuXG5cbid1c2Ugc3RyaWN0Jztcbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnMucHVzaChmdW5jdGlvbihzcWxpdGUzKXtcblxuY29uc3QgaW5zdGFsbE9wZnNWZnMgPSBmdW5jdGlvbiBjYWxsZWUob3B0aW9ucyl7XG4gIGlmKCFnbG9iYWxUaGlzLlNoYXJlZEFycmF5QnVmZmVyXG4gICAgfHwgIWdsb2JhbFRoaXMuQXRvbWljcyl7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKFwiQ2Fubm90IGluc3RhbGwgT1BGUzogTWlzc2luZyBTaGFyZWRBcnJheUJ1ZmZlciBhbmQvb3IgQXRvbWljcy4gXCIrXG4gICAgICAgICAgICAgICAgXCJUaGUgc2VydmVyIG11c3QgZW1pdCB0aGUgQ09PUC9DT0VQIHJlc3BvbnNlIGhlYWRlcnMgdG8gZW5hYmxlIHRob3NlLiBcIitcbiAgICAgICAgICAgICAgICBcIlNlZSBodHRwczovL3NxbGl0ZS5vcmcvd2FzbS9kb2MvdHJ1bmsvcGVyc2lzdGVuY2UubWQjY29vcC1jb2VwXCIpXG4gICAgKTtcbiAgfWVsc2UgaWYoJ3VuZGVmaW5lZCc9PT10eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUpe1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgIG5ldyBFcnJvcihcIlRoZSBPUEZTIHNxbGl0ZTNfdmZzIGNhbm5vdCBydW4gaW4gdGhlIG1haW4gdGhyZWFkIFwiK1xuICAgICAgICAgICAgICAgIFwiYmVjYXVzZSBpdCByZXF1aXJlcyBBdG9taWNzLndhaXQoKS5cIilcbiAgICApO1xuICB9ZWxzZSBpZighZ2xvYmFsVGhpcy5GaWxlU3lzdGVtSGFuZGxlIHx8XG4gICAgICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfHxcbiAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUgfHxcbiAgICAgICAgICAgIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUucHJvdG90eXBlLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUgfHxcbiAgICAgICAgICAgIW5hdmlnYXRvcj8uc3RvcmFnZT8uZ2V0RGlyZWN0b3J5KXtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIE9QRlMgQVBJcy5cIilcbiAgICApO1xuICB9XG4gIGlmKCFvcHRpb25zIHx8ICdvYmplY3QnIT09dHlwZW9mIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkwoZ2xvYmFsVGhpcy5sb2NhdGlvbi5ocmVmKS5zZWFyY2hQYXJhbXM7XG4gIGlmKHVybFBhcmFtcy5oYXMoJ29wZnMtZGlzYWJsZScpKXtcbiAgICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNxbGl0ZTMpO1xuICB9XG4gIGlmKHVuZGVmaW5lZD09PW9wdGlvbnMudmVyYm9zZSl7XG4gICAgb3B0aW9ucy52ZXJib3NlID0gdXJsUGFyYW1zLmhhcygnb3Bmcy12ZXJib3NlJylcbiAgICAgID8gKCt1cmxQYXJhbXMuZ2V0KCdvcGZzLXZlcmJvc2UnKSB8fCAyKSA6IDE7XG4gIH1cbiAgaWYodW5kZWZpbmVkPT09b3B0aW9ucy5zYW5pdHlDaGVja3Mpe1xuICAgIG9wdGlvbnMuc2FuaXR5Q2hlY2tzID0gdXJsUGFyYW1zLmhhcygnb3Bmcy1zYW5pdHktY2hlY2snKTtcbiAgfVxuICBpZih1bmRlZmluZWQ9PT1vcHRpb25zLnByb3h5VXJpKXtcbiAgICBvcHRpb25zLnByb3h5VXJpID0gY2FsbGVlLmRlZmF1bHRQcm94eVVyaTtcbiAgfVxuXG4gIFxuXG4gIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zLnByb3h5VXJpKXtcbiAgICBvcHRpb25zLnByb3h5VXJpID0gb3B0aW9ucy5wcm94eVVyaSgpO1xuICB9XG4gIGNvbnN0IHRoZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihwcm9taXNlUmVzb2x2ZV8sIHByb21pc2VSZWplY3RfKXtcbiAgICBjb25zdCBsb2dnZXJzID0gW1xuICAgICAgc3FsaXRlMy5jb25maWcuZXJyb3IsXG4gICAgICBzcWxpdGUzLmNvbmZpZy53YXJuLFxuICAgICAgc3FsaXRlMy5jb25maWcubG9nXG4gICAgXTtcbiAgICBjb25zdCBsb2dJbXBsID0gKGxldmVsLC4uLmFyZ3MpPT57XG4gICAgICBpZihvcHRpb25zLnZlcmJvc2U+bGV2ZWwpIGxvZ2dlcnNbbGV2ZWxdKFwiT1BGUyBzeW5jZXI6XCIsLi4uYXJncyk7XG4gICAgfTtcbiAgICBjb25zdCBsb2cgPSAgICAoLi4uYXJncyk9PmxvZ0ltcGwoMiwgLi4uYXJncyk7XG4gICAgY29uc3Qgd2FybiA9ICAgKC4uLmFyZ3MpPT5sb2dJbXBsKDEsIC4uLmFyZ3MpO1xuICAgIGNvbnN0IGVycm9yID0gICguLi5hcmdzKT0+bG9nSW1wbCgwLCAuLi5hcmdzKTtcbiAgICBjb25zdCB0b3NzID0gc3FsaXRlMy51dGlsLnRvc3M7XG4gICAgY29uc3QgY2FwaSA9IHNxbGl0ZTMuY2FwaTtcbiAgICBjb25zdCB1dGlsID0gc3FsaXRlMy51dGlsO1xuICAgIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG4gICAgY29uc3Qgc3FsaXRlM192ZnMgPSBjYXBpLnNxbGl0ZTNfdmZzO1xuICAgIGNvbnN0IHNxbGl0ZTNfZmlsZSA9IGNhcGkuc3FsaXRlM19maWxlO1xuICAgIGNvbnN0IHNxbGl0ZTNfaW9fbWV0aG9kcyA9IGNhcGkuc3FsaXRlM19pb19tZXRob2RzO1xuICAgIFxuICAgIGNvbnN0IG9wZnNVdGlsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIFxuICAgIGNvbnN0IHRoaXNUaHJlYWRIYXNPUEZTID0gKCk9PntcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLkZpbGVTeXN0ZW1IYW5kbGUgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlICYmXG4gICAgICAgIGdsb2JhbFRoaXMuRmlsZVN5c3RlbUZpbGVIYW5kbGUgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZS5wcm90b3R5cGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSAmJlxuICAgICAgICBuYXZpZ2F0b3I/LnN0b3JhZ2U/LmdldERpcmVjdG9yeTtcbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwubWV0cmljcyA9IHtcbiAgICAgIGR1bXA6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBrLCBuID0gMCwgdCA9IDAsIHcgPSAwO1xuICAgICAgICBmb3IoayBpbiBzdGF0ZS5vcElkcyl7XG4gICAgICAgICAgY29uc3QgbSA9IG1ldHJpY3Nba107XG4gICAgICAgICAgbiArPSBtLmNvdW50O1xuICAgICAgICAgIHQgKz0gbS50aW1lO1xuICAgICAgICAgIHcgKz0gbS53YWl0O1xuICAgICAgICAgIG0uYXZnVGltZSA9IChtLmNvdW50ICYmIG0udGltZSkgPyAobS50aW1lIC8gbS5jb3VudCkgOiAwO1xuICAgICAgICAgIG0uYXZnV2FpdCA9IChtLmNvdW50ICYmIG0ud2FpdCkgPyAobS53YWl0IC8gbS5jb3VudCkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHNxbGl0ZTMuY29uZmlnLmxvZyhnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIFwibWV0cmljcyBmb3JcIixnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYsXCI6XCIsbWV0cmljcyxcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5Ub3RhbCBvZlwiLG4sXCJvcChzKSBmb3JcIix0LFxuICAgICAgICAgICAgICAgICAgICBcIm1zIChpbmNsLiBcIit3K1wiIG1zIG9mIHdhaXRpbmcgb24gdGhlIGFzeW5jIHNpZGUpXCIpO1xuICAgICAgICBzcWxpdGUzLmNvbmZpZy5sb2coXCJTZXJpYWxpemF0aW9uIG1ldHJpY3M6XCIsbWV0cmljcy5zMTFuKTtcbiAgICAgICAgVy5wb3N0TWVzc2FnZSh7dHlwZTonb3Bmcy1hc3luYy1tZXRyaWNzJ30pO1xuICAgICAgfSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgaztcbiAgICAgICAgY29uc3QgciA9IChtKT0+KG0uY291bnQgPSBtLnRpbWUgPSBtLndhaXQgPSAwKTtcbiAgICAgICAgZm9yKGsgaW4gc3RhdGUub3BJZHMpe1xuICAgICAgICAgIHIobWV0cmljc1trXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzID0gbWV0cmljcy5zMTFuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcyA9IHMuc2VyaWFsaXplID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcy5jb3VudCA9IHMudGltZSA9IDA7XG4gICAgICAgIHMgPSBtZXRyaWNzLnMxMW4uZGVzZXJpYWxpemUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBzLmNvdW50ID0gcy50aW1lID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9wZnNJb01ldGhvZHMgPSBuZXcgc3FsaXRlM19pb19tZXRob2RzKCk7XG4gICAgY29uc3Qgb3Bmc1ZmcyA9IG5ldyBzcWxpdGUzX3ZmcygpXG4gICAgICAgICAgLmFkZE9uRGlzcG9zZSggKCk9Pm9wZnNJb01ldGhvZHMuZGlzcG9zZSgpKTtcbiAgICBsZXQgcHJvbWlzZVdhc1JlamVjdGVkID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb21pc2VSZWplY3QgPSAoZXJyKT0+e1xuICAgICAgcHJvbWlzZVdhc1JlamVjdGVkID0gdHJ1ZTtcbiAgICAgIG9wZnNWZnMuZGlzcG9zZSgpO1xuICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RfKGVycik7XG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlUmVzb2x2ZSA9ICgpPT57XG4gICAgICBwcm9taXNlV2FzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZV8oc3FsaXRlMyk7XG4gICAgfTtcbiAgICBjb25zdCBXID1cbiAgICBuZXcgV29ya2VyKG9wdGlvbnMucHJveHlVcmkpO1xuICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgIFxuICAgICAgaWYodW5kZWZpbmVkPT09cHJvbWlzZVdhc1JlamVjdGVkKXtcbiAgICAgICAgcHJvbWlzZVJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoXCJUaW1lb3V0IHdoaWxlIHdhaXRpbmcgZm9yIE9QRlMgYXN5bmMgcHJveHkgd29ya2VyLlwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIDQwMDApO1xuICAgIFcuX29yaWdpbmFsT25FcnJvciA9IFcub25lcnJvciA7XG4gICAgVy5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgICAgIFxuICAgICAgXG4gICAgICBlcnJvcihcIkVycm9yIGluaXRpYWxpemluZyBPUEZTIGFzeW5jZXI6XCIsZXJyKTtcbiAgICAgIHByb21pc2VSZWplY3QobmV3IEVycm9yKFwiTG9hZGluZyBPUEZTIGFzeW5jIFdvcmtlciBmYWlsZWQgZm9yIHVua25vd24gcmVhc29ucy5cIikpO1xuICAgIH07XG4gICAgY29uc3QgcERWZnMgPSBjYXBpLnNxbGl0ZTNfdmZzX2ZpbmQobnVsbCk7XG4gICAgY29uc3QgZFZmcyA9IHBEVmZzXG4gICAgICAgICAgPyBuZXcgc3FsaXRlM192ZnMocERWZnMpXG4gICAgICAgICAgOiBudWxsIDtcbiAgICBvcGZzSW9NZXRob2RzLiRpVmVyc2lvbiA9IDE7XG4gICAgb3Bmc1Zmcy4kaVZlcnNpb24gPSAyO1xuICAgIG9wZnNWZnMuJHN6T3NGaWxlID0gY2FwaS5zcWxpdGUzX2ZpbGUuc3RydWN0SW5mby5zaXplb2Y7XG4gICAgb3Bmc1Zmcy4kbXhQYXRobmFtZSA9IDEwMjQ7XG4gICAgb3Bmc1Zmcy4kek5hbWUgPSB3YXNtLmFsbG9jQ1N0cmluZyhcIm9wZnNcIik7XG4gICAgXG4gICAgb3Bmc1Zmcy4keERsT3BlbiA9IG9wZnNWZnMuJHhEbEVycm9yID0gb3Bmc1Zmcy4keERsU3ltID0gb3Bmc1Zmcy4keERsQ2xvc2UgPSBudWxsO1xuICAgIG9wZnNWZnMuYWRkT25EaXNwb3NlKFxuICAgICAgJyR6TmFtZScsIG9wZnNWZnMuJHpOYW1lLFxuICAgICAgJ2NsZWFudXAgZGVmYXVsdCBWRlMgd3JhcHBlcicsICgpPT4oZFZmcyA/IGRWZnMuZGlzcG9zZSgpIDogbnVsbClcbiAgICApO1xuICAgIFxuICAgIFxuICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBzdGF0ZS52ZXJib3NlID0gb3B0aW9ucy52ZXJib3NlO1xuICAgIHN0YXRlLmxpdHRsZUVuZGlhbiA9ICgoKT0+e1xuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDIpO1xuICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcikuc2V0SW50MTYoMCwgMjU2LCB0cnVlICk7XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShidWZmZXIpWzBdID09PSAyNTY7XG4gICAgfSkoKTtcbiAgICBcbiAgICBzdGF0ZS5hc3luY0lkbGVXYWl0VGltZSA9IDE1MDtcblxuICAgIFxuICAgIHN0YXRlLmFzeW5jUzExbkV4Y2VwdGlvbnMgPSAxO1xuICAgIFxuICAgIHN0YXRlLmZpbGVCdWZmZXJTaXplID0gMTAyNCAqIDY0O1xuICAgIHN0YXRlLnNhYlMxMW5PZmZzZXQgPSBzdGF0ZS5maWxlQnVmZmVyU2l6ZTtcbiAgICBcbiAgICBzdGF0ZS5zYWJTMTFuU2l6ZSA9IG9wZnNWZnMuJG14UGF0aG5hbWUgKiAyO1xuICAgIFxuICAgIHN0YXRlLnNhYklPID0gbmV3IFNoYXJlZEFycmF5QnVmZmVyKFxuICAgICAgc3RhdGUuZmlsZUJ1ZmZlclNpemVcbiAgICAgICsgc3RhdGUuc2FiUzExblNpemVcbiAgICApO1xuICAgIHN0YXRlLm9wSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBtZXRyaWNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB7XG4gICAgICBcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIFxuICAgICAgc3RhdGUub3BJZHMud2hpY2hPcCA9IGkrKztcbiAgICAgIFxuICAgICAgc3RhdGUub3BJZHMucmMgPSBpKys7XG4gICAgICBcbiAgICAgIHN0YXRlLm9wSWRzLnhBY2Nlc3MgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54Q2xvc2UgPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54RGVsZXRlID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueERlbGV0ZU5vV2FpdCA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhGaWxlU2l6ZSA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhMb2NrID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueE9wZW4gPSBpKys7XG4gICAgICBzdGF0ZS5vcElkcy54UmVhZCA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhTbGVlcCA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhTeW5jID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueFRydW5jYXRlID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHMueFVubG9jayA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLnhXcml0ZSA9IGkrKztcbiAgICAgIHN0YXRlLm9wSWRzLm1rZGlyID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHNbJ29wZnMtYXN5bmMtbWV0cmljcyddID0gaSsrO1xuICAgICAgc3RhdGUub3BJZHNbJ29wZnMtYXN5bmMtc2h1dGRvd24nXSA9IGkrKztcbiAgICAgIFxuICAgICAgc3RhdGUub3BJZHMucmV0cnkgPSBpKys7XG4gICAgICBzdGF0ZS5zYWJPUCA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihcbiAgICAgICAgaSAqIDQpO1xuICAgICAgb3Bmc1V0aWwubWV0cmljcy5yZXNldCgpO1xuICAgIH1cbiAgICBcbiAgICBzdGF0ZS5zcTNDb2RlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgW1xuICAgICAgJ1NRTElURV9BQ0NFU1NfRVhJU1RTJyxcbiAgICAgICdTUUxJVEVfQUNDRVNTX1JFQURXUklURScsXG4gICAgICAnU1FMSVRFX0JVU1knLFxuICAgICAgJ1NRTElURV9FUlJPUicsXG4gICAgICAnU1FMSVRFX0lPRVJSJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfQUNDRVNTJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfQ0xPU0UnLFxuICAgICAgJ1NRTElURV9JT0VSUl9ERUxFVEUnLFxuICAgICAgJ1NRTElURV9JT0VSUl9GU1lOQycsXG4gICAgICAnU1FMSVRFX0lPRVJSX0xPQ0snLFxuICAgICAgJ1NRTElURV9JT0VSUl9SRUFEJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfU0hPUlRfUkVBRCcsXG4gICAgICAnU1FMSVRFX0lPRVJSX1RSVU5DQVRFJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfVU5MT0NLJyxcbiAgICAgICdTUUxJVEVfSU9FUlJfV1JJVEUnLFxuICAgICAgJ1NRTElURV9MT0NLX0VYQ0xVU0lWRScsXG4gICAgICAnU1FMSVRFX0xPQ0tfTk9ORScsXG4gICAgICAnU1FMSVRFX0xPQ0tfUEVORElORycsXG4gICAgICAnU1FMSVRFX0xPQ0tfUkVTRVJWRUQnLFxuICAgICAgJ1NRTElURV9MT0NLX1NIQVJFRCcsXG4gICAgICAnU1FMSVRFX0xPQ0tFRCcsXG4gICAgICAnU1FMSVRFX01JU1VTRScsXG4gICAgICAnU1FMSVRFX05PVEZPVU5EJyxcbiAgICAgICdTUUxJVEVfT1BFTl9DUkVBVEUnLFxuICAgICAgJ1NRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UnLFxuICAgICAgJ1NRTElURV9PUEVOX01BSU5fREInLFxuICAgICAgJ1NRTElURV9PUEVOX1JFQURPTkxZJ1xuICAgIF0uZm9yRWFjaCgoayk9PntcbiAgICAgIGlmKHVuZGVmaW5lZCA9PT0gKHN0YXRlLnNxM0NvZGVzW2tdID0gY2FwaVtrXSkpe1xuICAgICAgICB0b3NzKFwiTWFpbnRlbmFuY2UgcmVxdWlyZWQ6IG5vdCBmb3VuZDpcIixrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGF0ZS5vcGZzRmxhZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgICAgXG4gICAgICBPUEZTX1VOTE9DS19BU0FQOiAweDAxLFxuICAgICAgXG4gICAgICBkZWZhdWx0VW5sb2NrQXNhcDogZmFsc2VcbiAgICB9KTtcblxuICAgIFxuICAgIGNvbnN0IG9wUnVuID0gKG9wLC4uLmFyZ3MpPT57XG4gICAgICBjb25zdCBvcE5keCA9IHN0YXRlLm9wSWRzW29wXSB8fCB0b3NzKFwiSW52YWxpZCBvcCBJRDpcIixvcCk7XG4gICAgICBzdGF0ZS5zMTFuLnNlcmlhbGl6ZSguLi5hcmdzKTtcbiAgICAgIEF0b21pY3Muc3RvcmUoc3RhdGUuc2FiT1BWaWV3LCBzdGF0ZS5vcElkcy5yYywgLTEpO1xuICAgICAgQXRvbWljcy5zdG9yZShzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLndoaWNoT3AsIG9wTmR4KTtcbiAgICAgIEF0b21pY3Mubm90aWZ5KHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMud2hpY2hPcClcbiAgICAgIDtcbiAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIEF0b21pY3Mud2FpdChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnJjLCAtMSlcbiAgICAgIDtcbiAgICAgIGNvbnN0IHJjID0gQXRvbWljcy5sb2FkKHN0YXRlLnNhYk9QVmlldywgc3RhdGUub3BJZHMucmMpO1xuICAgICAgbWV0cmljc1tvcF0ud2FpdCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgICBpZihyYyAmJiBzdGF0ZS5hc3luY1MxMW5FeGNlcHRpb25zKXtcbiAgICAgICAgY29uc3QgZXJyID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpO1xuICAgICAgICBpZihlcnIpIGVycm9yKG9wK1wiKCkgYXN5bmMgZXJyb3I6XCIsLi4uZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYztcbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwuZGVidWcgPSB7XG4gICAgICBhc3luY1NodXRkb3duOiAoKT0+e1xuICAgICAgICB3YXJuKFwiU2h1dHRpbmcgZG93biBPUEZTIGFzeW5jIGxpc3RlbmVyLiBUaGUgT1BGUyBWRlMgd2lsbCBubyBsb25nZXIgd29yay5cIik7XG4gICAgICAgIG9wUnVuKCdvcGZzLWFzeW5jLXNodXRkb3duJyk7XG4gICAgICB9LFxuICAgICAgYXN5bmNSZXN0YXJ0OiAoKT0+e1xuICAgICAgICB3YXJuKFwiQXR0ZW1wdGluZyB0byByZXN0YXJ0IE9QRlMgVkZTIGFzeW5jIGxpc3RlbmVyLiBNaWdodCB3b3JrLCBtaWdodCBub3QuXCIpO1xuICAgICAgICBXLnBvc3RNZXNzYWdlKHt0eXBlOiAnb3Bmcy1hc3luYy1yZXN0YXJ0J30pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpbml0UzExbiA9ICgpPT57XG4gICAgICBcbiAgICAgIGlmKHN0YXRlLnMxMW4pIHJldHVybiBzdGF0ZS5zMTFuO1xuICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKSxcbiAgICAgICAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpLFxuICAgICAgICAgICAgdmlld1U4ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUuc2FiSU8sIHN0YXRlLnNhYlMxMW5PZmZzZXQsIHN0YXRlLnNhYlMxMW5TaXplKSxcbiAgICAgICAgICAgIHZpZXdEViA9IG5ldyBEYXRhVmlldyhzdGF0ZS5zYWJJTywgc3RhdGUuc2FiUzExbk9mZnNldCwgc3RhdGUuc2FiUzExblNpemUpO1xuICAgICAgc3RhdGUuczExbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IFR5cGVJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgVHlwZUlkcy5udW1iZXIgID0geyBpZDogMSwgc2l6ZTogOCwgZ2V0dGVyOiAnZ2V0RmxvYXQ2NCcsIHNldHRlcjogJ3NldEZsb2F0NjQnIH07XG4gICAgICBUeXBlSWRzLmJpZ2ludCAgPSB7IGlkOiAyLCBzaXplOiA4LCBnZXR0ZXI6ICdnZXRCaWdJbnQ2NCcsIHNldHRlcjogJ3NldEJpZ0ludDY0JyB9O1xuICAgICAgVHlwZUlkcy5ib29sZWFuID0geyBpZDogMywgc2l6ZTogNCwgZ2V0dGVyOiAnZ2V0SW50MzInLCBzZXR0ZXI6ICdzZXRJbnQzMicgfTtcbiAgICAgIFR5cGVJZHMuc3RyaW5nID0gIHsgaWQ6IDQgfTtcblxuICAgICAgY29uc3QgZ2V0VHlwZUlkID0gKHYpPT4oXG4gICAgICAgIFR5cGVJZHNbdHlwZW9mIHZdXG4gICAgICAgICAgfHwgdG9zcyhcIk1haW50ZW5hbmNlIHJlcXVpcmVkOiB0aGlzIHZhbHVlIHR5cGUgY2Fubm90IGJlIHNlcmlhbGl6ZWQuXCIsdilcbiAgICAgICk7XG4gICAgICBjb25zdCBnZXRUeXBlSWRCeUlkID0gKHRpZCk9PntcbiAgICAgICAgc3dpdGNoKHRpZCl7XG4gICAgICAgICAgICBjYXNlIFR5cGVJZHMubnVtYmVyLmlkOiByZXR1cm4gVHlwZUlkcy5udW1iZXI7XG4gICAgICAgICAgICBjYXNlIFR5cGVJZHMuYmlnaW50LmlkOiByZXR1cm4gVHlwZUlkcy5iaWdpbnQ7XG4gICAgICAgICAgICBjYXNlIFR5cGVJZHMuYm9vbGVhbi5pZDogcmV0dXJuIFR5cGVJZHMuYm9vbGVhbjtcbiAgICAgICAgICAgIGNhc2UgVHlwZUlkcy5zdHJpbmcuaWQ6IHJldHVybiBUeXBlSWRzLnN0cmluZztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRvc3MoXCJJbnZhbGlkIHR5cGUgSUQ6XCIsdGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgXG4gICAgICBzdGF0ZS5zMTFuLmRlc2VyaWFsaXplID0gZnVuY3Rpb24oY2xlYXI9ZmFsc2Upe1xuICAgICAgICArK21ldHJpY3MuczExbi5kZXNlcmlhbGl6ZS5jb3VudDtcbiAgICAgICAgY29uc3QgdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBhcmdjID0gdmlld1U4WzBdO1xuICAgICAgICBjb25zdCByYyA9IGFyZ2MgPyBbXSA6IG51bGw7XG4gICAgICAgIGlmKGFyZ2Mpe1xuICAgICAgICAgIGNvbnN0IHR5cGVJZHMgPSBbXTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMSwgaSwgbiwgdjtcbiAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBhcmdjOyArK2ksICsrb2Zmc2V0KXtcbiAgICAgICAgICAgIHR5cGVJZHMucHVzaChnZXRUeXBlSWRCeUlkKHZpZXdVOFtvZmZzZXRdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcihpID0gMDsgaSA8IGFyZ2M7ICsraSl7XG4gICAgICAgICAgICBjb25zdCB0ID0gdHlwZUlkc1tpXTtcbiAgICAgICAgICAgIGlmKHQuZ2V0dGVyKXtcbiAgICAgICAgICAgICAgdiA9IHZpZXdEVlt0LmdldHRlcl0ob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gdC5zaXplO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIG4gPSB2aWV3RFYuZ2V0SW50MzIob2Zmc2V0LCBzdGF0ZS5saXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgdiA9IHRleHREZWNvZGVyLmRlY29kZSh2aWV3VTguc2xpY2Uob2Zmc2V0LCBvZmZzZXQrbikpO1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJjLnB1c2godik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGNsZWFyKSB2aWV3VThbMF0gPSAwO1xuICAgICAgICBcbiAgICAgICAgbWV0cmljcy5zMTFuLmRlc2VyaWFsaXplLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9O1xuXG4gICAgICBcbiAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplID0gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICAgIGNvbnN0IHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgKyttZXRyaWNzLnMxMW4uc2VyaWFsaXplLmNvdW50O1xuICAgICAgICBpZihhcmdzLmxlbmd0aCl7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdHlwZUlkcyA9IFtdO1xuICAgICAgICAgIGxldCBpID0gMCwgb2Zmc2V0ID0gMTtcbiAgICAgICAgICB2aWV3VThbMF0gPSBhcmdzLmxlbmd0aCAmIDB4ZmYgO1xuICAgICAgICAgIGZvcig7IGkgPCBhcmdzLmxlbmd0aDsgKytpLCArK29mZnNldCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHR5cGVJZHMucHVzaChnZXRUeXBlSWQoYXJnc1tpXSkpO1xuICAgICAgICAgICAgdmlld1U4W29mZnNldF0gPSB0eXBlSWRzW2ldLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0eXBlSWRzW2ldO1xuICAgICAgICAgICAgaWYodC5zZXR0ZXIpe1xuICAgICAgICAgICAgICB2aWV3RFZbdC5zZXR0ZXJdKG9mZnNldCwgYXJnc1tpXSwgc3RhdGUubGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IHQuc2l6ZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBjb25zdCBzID0gdGV4dEVuY29kZXIuZW5jb2RlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgICB2aWV3RFYuc2V0SW50MzIob2Zmc2V0LCBzLmJ5dGVMZW5ndGgsIHN0YXRlLmxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB2aWV3VTguc2V0KHMsIG9mZnNldCk7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBzLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB2aWV3VThbMF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIG1ldHJpY3MuczExbi5zZXJpYWxpemUudGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHN0YXRlLnMxMW47XG4gICAgfTtcblxuICAgIFxuICAgIGNvbnN0IHJhbmRvbUZpbGVuYW1lID0gZnVuY3Rpb24gZihsZW49MTYpe1xuICAgICAgaWYoIWYuX2NoYXJzKXtcbiAgICAgICAgZi5fY2hhcnMgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIrXG4gICAgICAgICAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiK1xuICAgICAgICAgIFwiMDEyMzQ2Nzg5XCI7XG4gICAgICAgIGYuX24gPSBmLl9jaGFycy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gW107XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IoIDsgaSA8IGxlbjsgKytpKXtcbiAgICAgICAgY29uc3QgbmR4ID0gTWF0aC5yYW5kb20oKSAqIChmLl9uICogNjQpICUgZi5fbiB8IDA7XG4gICAgICAgIGFbaV0gPSBmLl9jaGFyc1tuZHhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGEuam9pbihcIlwiKTtcbiAgICAgIFxuICAgIH07XG5cbiAgICBcbiAgICBjb25zdCBfX29wZW5GaWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBjb25zdCBvcFRpbWVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBvcFRpbWVyLm9wID0gdW5kZWZpbmVkO1xuICAgIG9wVGltZXIuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgbVRpbWVTdGFydCA9IChvcCk9PntcbiAgICAgIG9wVGltZXIuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIG9wVGltZXIub3AgPSBvcDtcbiAgICAgICsrbWV0cmljc1tvcF0uY291bnQ7XG4gICAgfTtcbiAgICBjb25zdCBtVGltZUVuZCA9ICgpPT4oXG4gICAgICBtZXRyaWNzW29wVGltZXIub3BdLnRpbWUgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBvcFRpbWVyLnN0YXJ0XG4gICAgKTtcblxuICAgIFxuICAgIGNvbnN0IGlvU3luY1dyYXBwZXJzID0ge1xuICAgICAgeENoZWNrUmVzZXJ2ZWRMb2NrOiBmdW5jdGlvbihwRmlsZSxwT3V0KXtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgIHdhc20ucG9rZShwT3V0LCBmLmxvY2tUeXBlID8gMSA6IDAsICdpMzInKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgeENsb3NlOiBmdW5jdGlvbihwRmlsZSl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hDbG9zZScpO1xuICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICBpZihmKXtcbiAgICAgICAgICBkZWxldGUgX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICAgIHJjID0gb3BSdW4oJ3hDbG9zZScsIHBGaWxlKTtcbiAgICAgICAgICBpZihmLnNxM0ZpbGUpIGYuc3EzRmlsZS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhEZXZpY2VDaGFyYWN0ZXJpc3RpY3M6IGZ1bmN0aW9uKHBGaWxlKXtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0NBUF9VTkRFTEVUQUJMRV9XSEVOX09QRU47XG4gICAgICB9LFxuICAgICAgeEZpbGVDb250cm9sOiBmdW5jdGlvbihwRmlsZSwgb3BJZCwgcEFyZyl7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9URk9VTkQ7XG4gICAgICB9LFxuICAgICAgeEZpbGVTaXplOiBmdW5jdGlvbihwRmlsZSxwU3o2NCl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hGaWxlU2l6ZScpO1xuICAgICAgICBsZXQgcmMgPSBvcFJ1bigneEZpbGVTaXplJywgcEZpbGUpO1xuICAgICAgICBpZigwPT1yYyl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN6ID0gc3RhdGUuczExbi5kZXNlcmlhbGl6ZSgpWzBdO1xuICAgICAgICAgICAgd2FzbS5wb2tlKHBTejY0LCBzeiwgJ2k2NCcpO1xuICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCBlcnJvciByZWFkaW5nIHhGaWxlU2l6ZSgpIHJlc3VsdDpcIixlKTtcbiAgICAgICAgICAgIHJjID0gc3RhdGUuc3EzQ29kZXMuU1FMSVRFX0lPRVJSO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeExvY2s6IGZ1bmN0aW9uKHBGaWxlLGxvY2tUeXBlKXtcbiAgICAgICAgbVRpbWVTdGFydCgneExvY2snKTtcbiAgICAgICAgY29uc3QgZiA9IF9fb3BlbkZpbGVzW3BGaWxlXTtcbiAgICAgICAgbGV0IHJjID0gMDtcbiAgICAgICAgXG4gICAgICAgIGlmKCAhZi5sb2NrVHlwZSApIHtcbiAgICAgICAgICByYyA9IG9wUnVuKCd4TG9jaycsIHBGaWxlLCBsb2NrVHlwZSk7XG4gICAgICAgICAgaWYoIDA9PT1yYyApIGYubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICB9XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4UmVhZDogZnVuY3Rpb24ocEZpbGUscERlc3QsbixvZmZzZXQ2NCl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hSZWFkJyk7XG4gICAgICAgIGNvbnN0IGYgPSBfX29wZW5GaWxlc1twRmlsZV07XG4gICAgICAgIGxldCByYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYyA9IG9wUnVuKCd4UmVhZCcscEZpbGUsIG4sIE51bWJlcihvZmZzZXQ2NCkpO1xuICAgICAgICAgIGlmKDA9PT1yYyB8fCBjYXBpLlNRTElURV9JT0VSUl9TSE9SVF9SRUFEPT09cmMpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB3YXNtLmhlYXA4dSgpLnNldChmLnNhYlZpZXcuc3ViYXJyYXkoMCwgbiksIHBEZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICBlcnJvcihcInhSZWFkKFwiLGFyZ3VtZW50cyxcIikgZmFpbGVkOlwiLGUsZik7XG4gICAgICAgICAgcmMgPSBjYXBpLlNRTElURV9JT0VSUl9SRUFEO1xuICAgICAgICB9XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4U3luYzogZnVuY3Rpb24ocEZpbGUsZmxhZ3Mpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4U3luYycpO1xuICAgICAgICArK21ldHJpY3MueFN5bmMuY291bnQ7XG4gICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hTeW5jJywgcEZpbGUsIGZsYWdzKTtcbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhUcnVuY2F0ZTogZnVuY3Rpb24ocEZpbGUsc3o2NCl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hUcnVuY2F0ZScpO1xuICAgICAgICBjb25zdCByYyA9IG9wUnVuKCd4VHJ1bmNhdGUnLCBwRmlsZSwgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSxcbiAgICAgIHhVbmxvY2s6IGZ1bmN0aW9uKHBGaWxlLGxvY2tUeXBlKXtcbiAgICAgICAgbVRpbWVTdGFydCgneFVubG9jaycpO1xuICAgICAgICBjb25zdCBmID0gX19vcGVuRmlsZXNbcEZpbGVdO1xuICAgICAgICBsZXQgcmMgPSAwO1xuICAgICAgICBpZiggY2FwaS5TUUxJVEVfTE9DS19OT05FID09PSBsb2NrVHlwZVxuICAgICAgICAgICYmIGYubG9ja1R5cGUgKXtcbiAgICAgICAgICByYyA9IG9wUnVuKCd4VW5sb2NrJywgcEZpbGUsIGxvY2tUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiggMD09PXJjICkgZi5sb2NrVHlwZSA9IGxvY2tUeXBlO1xuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gcmM7XG4gICAgICB9LFxuICAgICAgeFdyaXRlOiBmdW5jdGlvbihwRmlsZSxwU3JjLG4sb2Zmc2V0NjQpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4V3JpdGUnKTtcbiAgICAgICAgY29uc3QgZiA9IF9fb3BlbkZpbGVzW3BGaWxlXTtcbiAgICAgICAgbGV0IHJjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGYuc2FiVmlldy5zZXQod2FzbS5oZWFwOHUoKS5zdWJhcnJheShwU3JjLCBwU3JjK24pKTtcbiAgICAgICAgICByYyA9IG9wUnVuKCd4V3JpdGUnLCBwRmlsZSwgbiwgTnVtYmVyKG9mZnNldDY0KSk7XG4gICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICBlcnJvcihcInhXcml0ZShcIixhcmd1bWVudHMsXCIpIGZhaWxlZDpcIixlLGYpO1xuICAgICAgICAgIHJjID0gY2FwaS5TUUxJVEVfSU9FUlJfV1JJVEU7XG4gICAgICAgIH1cbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBjb25zdCB2ZnNTeW5jV3JhcHBlcnMgPSB7XG4gICAgICB4QWNjZXNzOiBmdW5jdGlvbihwVmZzLHpOYW1lLGZsYWdzLHBPdXQpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4QWNjZXNzJyk7XG4gICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hBY2Nlc3MnLCB3YXNtLmNzdHJUb0pzKHpOYW1lKSk7XG4gICAgICAgIHdhc20ucG9rZSggcE91dCwgKHJjID8gMCA6IDEpLCAnaTMyJyApO1xuICAgICAgICBtVGltZUVuZCgpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICB4Q3VycmVudFRpbWU6IGZ1bmN0aW9uKHBWZnMscE91dCl7XG4gICAgICAgIFxuICAgICAgICB3YXNtLnBva2UocE91dCwgMjQ0MDU4Ny41ICsgKG5ldyBEYXRlKCkuZ2V0VGltZSgpLzg2NDAwMDAwKSxcbiAgICAgICAgICAgICAgICAgICdkb3VibGUnKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgeEN1cnJlbnRUaW1lSW50NjQ6IGZ1bmN0aW9uKHBWZnMscE91dCl7XG4gICAgICAgIHdhc20ucG9rZShwT3V0LCAoMjQ0MDU4Ny41ICogODY0MDAwMDApICsgbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAnaTY0Jyk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIHhEZWxldGU6IGZ1bmN0aW9uKHBWZnMsIHpOYW1lLCBkb1N5bmNEaXIpe1xuICAgICAgICBtVGltZVN0YXJ0KCd4RGVsZXRlJyk7XG4gICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hEZWxldGUnLCB3YXNtLmNzdHJUb0pzKHpOYW1lKSwgZG9TeW5jRGlyLCBmYWxzZSk7XG4gICAgICAgIG1UaW1lRW5kKCk7XG4gICAgICAgIHJldHVybiByYztcbiAgICAgIH0sXG4gICAgICB4RnVsbFBhdGhuYW1lOiBmdW5jdGlvbihwVmZzLHpOYW1lLG5PdXQscE91dCl7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpID0gd2FzbS5jc3RybmNweShwT3V0LCB6TmFtZSwgbk91dCk7XG4gICAgICAgIHJldHVybiBpPG5PdXQgPyAwIDogY2FwaS5TUUxJVEVfQ0FOVE9QRU5cbiAgICAgICAgO1xuICAgICAgfSxcbiAgICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uKHBWZnMsbk91dCxwT3V0KXtcbiAgICAgICAgXG4gICAgICAgIHdhcm4oXCJPUEZTIHhHZXRMYXN0RXJyb3IoKSBoYXMgbm90aGluZyBzZW5zaWJsZSB0byByZXR1cm4uXCIpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIHhPcGVuOiBmdW5jdGlvbiBmKHBWZnMsIHpOYW1lLCBwRmlsZSwgZmxhZ3MsIHBPdXRGbGFncyl7XG4gICAgICAgIG1UaW1lU3RhcnQoJ3hPcGVuJyk7XG4gICAgICAgIGxldCBvcGZzRmxhZ3MgPSAwO1xuICAgICAgICBpZigwPT09ek5hbWUpe1xuICAgICAgICAgIHpOYW1lID0gcmFuZG9tRmlsZW5hbWUoKTtcbiAgICAgICAgfWVsc2UgaWYoJ251bWJlcic9PT10eXBlb2Ygek5hbWUpe1xuICAgICAgICAgIGlmKGNhcGkuc3FsaXRlM191cmlfYm9vbGVhbih6TmFtZSwgXCJvcGZzLXVubG9jay1hc2FwXCIsIDApKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb3Bmc0ZsYWdzIHw9IHN0YXRlLm9wZnNGbGFncy5PUEZTX1VOTE9DS19BU0FQO1xuICAgICAgICAgIH1cbiAgICAgICAgICB6TmFtZSA9IHdhc20uY3N0clRvSnMoek5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZmguZmlkID0gcEZpbGU7XG4gICAgICAgIGZoLmZpbGVuYW1lID0gek5hbWU7XG4gICAgICAgIGZoLnNhYiA9IG5ldyBTaGFyZWRBcnJheUJ1ZmZlcihzdGF0ZS5maWxlQnVmZmVyU2l6ZSk7XG4gICAgICAgIGZoLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIGNvbnN0IHJjID0gb3BSdW4oJ3hPcGVuJywgcEZpbGUsIHpOYW1lLCBmbGFncywgb3Bmc0ZsYWdzKTtcbiAgICAgICAgaWYoIXJjKXtcbiAgICAgICAgICBcbiAgICAgICAgICBpZihmaC5yZWFkT25seSl7XG4gICAgICAgICAgICB3YXNtLnBva2UocE91dEZsYWdzLCBjYXBpLlNRTElURV9PUEVOX1JFQURPTkxZLCAnaTMyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9fb3BlbkZpbGVzW3BGaWxlXSA9IGZoO1xuICAgICAgICAgIGZoLnNhYlZpZXcgPSBzdGF0ZS5zYWJGaWxlQnVmVmlldztcbiAgICAgICAgICBmaC5zcTNGaWxlID0gbmV3IHNxbGl0ZTNfZmlsZShwRmlsZSk7XG4gICAgICAgICAgZmguc3EzRmlsZS4kcE1ldGhvZHMgPSBvcGZzSW9NZXRob2RzLnBvaW50ZXI7XG4gICAgICAgICAgZmgubG9ja1R5cGUgPSBjYXBpLlNRTElURV9MT0NLX05PTkU7XG4gICAgICAgIH1cbiAgICAgICAgbVRpbWVFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZihkVmZzKXtcbiAgICAgIG9wZnNWZnMuJHhSYW5kb21uZXNzID0gZFZmcy4keFJhbmRvbW5lc3M7XG4gICAgICBvcGZzVmZzLiR4U2xlZXAgPSBkVmZzLiR4U2xlZXA7XG4gICAgfVxuICAgIGlmKCFvcGZzVmZzLiR4UmFuZG9tbmVzcyl7XG4gICAgICBcbiAgICAgIHZmc1N5bmNXcmFwcGVycy54UmFuZG9tbmVzcyA9IGZ1bmN0aW9uKHBWZnMsIG5PdXQsIHBPdXQpe1xuICAgICAgICBjb25zdCBoZWFwID0gd2FzbS5oZWFwOHUoKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IoOyBpIDwgbk91dDsgKytpKSBoZWFwW3BPdXQgKyBpXSA9IChNYXRoLnJhbmRvbSgpKjI1NTAwMCkgJiAweEZGO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmKCFvcGZzVmZzLiR4U2xlZXApe1xuICAgICAgXG4gICAgICB2ZnNTeW5jV3JhcHBlcnMueFNsZWVwID0gZnVuY3Rpb24ocFZmcyxtcyl7XG4gICAgICAgIEF0b21pY3Mud2FpdChzdGF0ZS5zYWJPUFZpZXcsIHN0YXRlLm9wSWRzLnhTbGVlcCwgMCwgbXMpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgXG4gICAgb3Bmc1V0aWwuZ2V0UmVzb2x2ZWRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUsc3BsaXRJdCl7XG4gICAgICBjb25zdCBwID0gbmV3IFVSTChmaWxlbmFtZSwgXCJmaWxlOi8vaXJyZWxldmFudFwiKS5wYXRobmFtZTtcbiAgICAgIHJldHVybiBzcGxpdEl0ID8gcC5zcGxpdCgnLycpLmZpbHRlcigodik9PiEhdikgOiBwO1xuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZSA9IGFzeW5jIGZ1bmN0aW9uIGYoYWJzRmlsZW5hbWUsIGNyZWF0ZURpcnMgPSBmYWxzZSl7XG4gICAgICBjb25zdCBwYXRoID0gb3Bmc1V0aWwuZ2V0UmVzb2x2ZWRQYXRoKGFic0ZpbGVuYW1lLCB0cnVlKTtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5wb3AoKTtcbiAgICAgIGxldCBkaCA9IG9wZnNVdGlsLnJvb3REaXJlY3Rvcnk7XG4gICAgICBmb3IoY29uc3QgZGlyTmFtZSBvZiBwYXRoKXtcbiAgICAgICAgaWYoZGlyTmFtZSl7XG4gICAgICAgICAgZGggPSBhd2FpdCBkaC5nZXREaXJlY3RvcnlIYW5kbGUoZGlyTmFtZSwge2NyZWF0ZTogISFjcmVhdGVEaXJzfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbZGgsIGZpbGVuYW1lXTtcbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwubWtkaXIgPSBhc3luYyBmdW5jdGlvbihhYnNEaXJOYW1lKXtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKGFic0Rpck5hbWUrXCIvZmlsZXBhcnRcIiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgb3Bmc1V0aWwuZW50cnlFeGlzdHMgPSBhc3luYyBmdW5jdGlvbihmc0VudHJ5TmFtZSl7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbZGgsIGZuXSA9IGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKGZzRW50cnlOYW1lKTtcbiAgICAgICAgYXdhaXQgZGguZ2V0RmlsZUhhbmRsZShmbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLnJhbmRvbUZpbGVuYW1lID0gcmFuZG9tRmlsZW5hbWU7XG5cbiAgICBcbiAgICBvcGZzVXRpbC5yZWdpc3RlclZmcyA9IChhc0RlZmF1bHQ9ZmFsc2UpPT57XG4gICAgICByZXR1cm4gd2FzbS5leHBvcnRzLnNxbGl0ZTNfdmZzX3JlZ2lzdGVyKFxuICAgICAgICBvcGZzVmZzLnBvaW50ZXIsIGFzRGVmYXVsdCA/IDEgOiAwXG4gICAgICApO1xuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC50cmVlTGlzdCA9IGFzeW5jIGZ1bmN0aW9uKCl7XG4gICAgICBjb25zdCBkb0RpciA9IGFzeW5jIGZ1bmN0aW9uIGNhbGxlZShkaXJIYW5kbGUsdGd0KXtcbiAgICAgICAgdGd0Lm5hbWUgPSBkaXJIYW5kbGUubmFtZTtcbiAgICAgICAgdGd0LmRpcnMgPSBbXTtcbiAgICAgICAgdGd0LmZpbGVzID0gW107XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaGFuZGxlIG9mIGRpckhhbmRsZS52YWx1ZXMoKSl7XG4gICAgICAgICAgaWYoJ2RpcmVjdG9yeScgPT09IGhhbmRsZS5raW5kKXtcbiAgICAgICAgICAgIGNvbnN0IHN1YkRpciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0Z3QuZGlycy5wdXNoKHN1YkRpcik7XG4gICAgICAgICAgICBhd2FpdCBjYWxsZWUoaGFuZGxlLCBzdWJEaXIpO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGd0LmZpbGVzLnB1c2goaGFuZGxlLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJvb3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgYXdhaXQgZG9EaXIob3Bmc1V0aWwucm9vdERpcmVjdG9yeSwgcm9vdCk7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuXG4gICAgXG4gICAgb3Bmc1V0aWwucm1mciA9IGFzeW5jIGZ1bmN0aW9uKCl7XG4gICAgICBjb25zdCBkaXIgPSBvcGZzVXRpbC5yb290RGlyZWN0b3J5LCBvcHQgPSB7cmVjdXJzZTogdHJ1ZX07XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGhhbmRsZSBvZiBkaXIudmFsdWVzKCkpe1xuICAgICAgICBkaXIucmVtb3ZlRW50cnkoaGFuZGxlLm5hbWUsIG9wdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLnVubGluayA9IGFzeW5jIGZ1bmN0aW9uKGZzRW50cnlOYW1lLCByZWN1cnNpdmUgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3IgPSBmYWxzZSl7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbaERpciwgZmlsZW5hbWVQYXJ0XSA9XG4gICAgICAgICAgICAgIGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKGZzRW50cnlOYW1lLCBmYWxzZSk7XG4gICAgICAgIGF3YWl0IGhEaXIucmVtb3ZlRW50cnkoZmlsZW5hbWVQYXJ0LCB7cmVjdXJzaXZlfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBpZih0aHJvd09uRXJyb3Ipe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVubGluayhcIixhcmd1bWVudHNbMF0sXCIpIGZhaWxlZDogXCIrZS5tZXNzYWdlLHtcbiAgICAgICAgICAgIGNhdXNlOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBcbiAgICBvcGZzVXRpbC50cmF2ZXJzZSA9IGFzeW5jIGZ1bmN0aW9uKG9wdCl7XG4gICAgICBjb25zdCBkZWZhdWx0T3B0ID0ge1xuICAgICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICAgIGRpcmVjdG9yeTogb3Bmc1V0aWwucm9vdERpcmVjdG9yeVxuICAgICAgfTtcbiAgICAgIGlmKCdmdW5jdGlvbic9PT10eXBlb2Ygb3B0KXtcbiAgICAgICAgb3B0ID0ge2NhbGxiYWNrOm9wdH07XG4gICAgICB9XG4gICAgICBvcHQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHQsIG9wdHx8e30pO1xuICAgICAgY29uc3QgZG9EaXIgPSBhc3luYyBmdW5jdGlvbiBjYWxsZWUoZGlySGFuZGxlLCBkZXB0aCl7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaGFuZGxlIG9mIGRpckhhbmRsZS52YWx1ZXMoKSl7XG4gICAgICAgICAgaWYoZmFsc2UgPT09IG9wdC5jYWxsYmFjayhoYW5kbGUsIGRpckhhbmRsZSwgZGVwdGgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgZWxzZSBpZihvcHQucmVjdXJzaXZlICYmICdkaXJlY3RvcnknID09PSBoYW5kbGUua2luZCl7XG4gICAgICAgICAgICBpZihmYWxzZSA9PT0gYXdhaXQgY2FsbGVlKGhhbmRsZSwgZGVwdGggKyAxKSkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZG9EaXIob3B0LmRpcmVjdG9yeSwgMCk7XG4gICAgfTtcblxuICAgIFxuICAgIGNvbnN0IGltcG9ydERiQ2h1bmtlZCA9IGFzeW5jIGZ1bmN0aW9uKGZpbGVuYW1lLCBjYWxsYmFjayl7XG4gICAgICBjb25zdCBbaERpciwgZm5hbWVQYXJ0XSA9IGF3YWl0IG9wZnNVdGlsLmdldERpckZvckZpbGVuYW1lKGZpbGVuYW1lLCB0cnVlKTtcbiAgICAgIGNvbnN0IGhGaWxlID0gYXdhaXQgaERpci5nZXRGaWxlSGFuZGxlKGZuYW1lUGFydCwge2NyZWF0ZTp0cnVlfSk7XG4gICAgICBsZXQgc2FoID0gYXdhaXQgaEZpbGUuY3JlYXRlU3luY0FjY2Vzc0hhbmRsZSgpO1xuICAgICAgbGV0IG5Xcm90ZSA9IDAsIGNodW5rLCBjaGVja2VkSGVhZGVyID0gZmFsc2UsIGVyciA9IGZhbHNlO1xuICAgICAgdHJ5e1xuICAgICAgICBzYWgudHJ1bmNhdGUoMCk7XG4gICAgICAgIHdoaWxlKCB1bmRlZmluZWQgIT09IChjaHVuayA9IGF3YWl0IGNhbGxiYWNrKCkpICl7XG4gICAgICAgICAgaWYoY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgY2h1bmsgPSBuZXcgVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgaWYoIDA9PT1uV3JvdGUgJiYgY2h1bmsuYnl0ZUxlbmd0aD49MTUgKXtcbiAgICAgICAgICAgIHV0aWwuYWZmaXJtRGJIZWFkZXIoY2h1bmspO1xuICAgICAgICAgICAgY2hlY2tlZEhlYWRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhaC53cml0ZShjaHVuaywge2F0OiBuV3JvdGV9KTtcbiAgICAgICAgICBuV3JvdGUgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiggbldyb3RlIDwgNTEyIHx8IDAhPT1uV3JvdGUgJSA1MTIgKXtcbiAgICAgICAgICB0b3NzKFwiSW5wdXQgc2l6ZVwiLG5Xcm90ZSxcImlzIG5vdCBjb3JyZWN0IGZvciBhbiBTUUxpdGUgZGF0YWJhc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhY2hlY2tlZEhlYWRlciApe1xuICAgICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KDIwKTtcbiAgICAgICAgICBzYWgucmVhZCggaGVhZGVyLCB7YXQ6IDB9ICk7XG4gICAgICAgICAgdXRpbC5hZmZpcm1EYkhlYWRlciggaGVhZGVyICk7XG4gICAgICAgIH1cbiAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLDFdKSwge2F0OiAxOH0pO1xuICAgICAgICByZXR1cm4gbldyb3RlO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgICAgc2FoID0gdW5kZWZpbmVkO1xuICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KCBmbmFtZVBhcnQgKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfWZpbmFsbHkge1xuICAgICAgICBpZiggc2FoICkgYXdhaXQgc2FoLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFxuICAgIG9wZnNVdGlsLmltcG9ydERiID0gYXN5bmMgZnVuY3Rpb24oZmlsZW5hbWUsIGJ5dGVzKXtcbiAgICAgIGlmKCBieXRlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uICl7XG4gICAgICAgIHJldHVybiBpbXBvcnREYkNodW5rZWQoZmlsZW5hbWUsIGJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmKGJ5dGVzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgdXRpbC5hZmZpcm1Jc0RiKGJ5dGVzKTtcbiAgICAgIGNvbnN0IG4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgY29uc3QgW2hEaXIsIGZuYW1lUGFydF0gPSBhd2FpdCBvcGZzVXRpbC5nZXREaXJGb3JGaWxlbmFtZShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICBsZXQgc2FoLCBlcnIsIG5Xcm90ZSA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoRmlsZSA9IGF3YWl0IGhEaXIuZ2V0RmlsZUhhbmRsZShmbmFtZVBhcnQsIHtjcmVhdGU6dHJ1ZX0pO1xuICAgICAgICBzYWggPSBhd2FpdCBoRmlsZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKCk7XG4gICAgICAgIHNhaC50cnVuY2F0ZSgwKTtcbiAgICAgICAgbldyb3RlID0gc2FoLndyaXRlKGJ5dGVzLCB7YXQ6IDB9KTtcbiAgICAgICAgaWYobldyb3RlICE9IG4pe1xuICAgICAgICAgIHRvc3MoXCJFeHBlY3RlZCB0byB3cml0ZSBcIituK1wiIGJ5dGVzIGJ1dCB3cm90ZSBcIituV3JvdGUrXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNhaC53cml0ZShuZXcgVWludDhBcnJheShbMSwxXSksIHthdDogMTh9KSA7XG4gICAgICAgIHJldHVybiBuV3JvdGU7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIGlmKCBzYWggKXsgYXdhaXQgc2FoLmNsb3NlKCk7IHNhaCA9IHVuZGVmaW5lZDsgfVxuICAgICAgICBhd2FpdCBoRGlyLnJlbW92ZUVudHJ5KCBmbmFtZVBhcnQgKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfWZpbmFsbHl7XG4gICAgICAgIGlmKCBzYWggKSBhd2FpdCBzYWguY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYoc3FsaXRlMy5vbzEpe1xuICAgICAgY29uc3QgT3Bmc0RiID0gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICAgIGNvbnN0IG9wdCA9IHNxbGl0ZTMub28xLkRCLmRiQ3RvckhlbHBlci5ub3JtYWxpemVBcmdzKC4uLmFyZ3MpO1xuICAgICAgICBvcHQudmZzID0gb3Bmc1Zmcy4kek5hbWU7XG4gICAgICAgIHNxbGl0ZTMub28xLkRCLmRiQ3RvckhlbHBlci5jYWxsKHRoaXMsIG9wdCk7XG4gICAgICB9O1xuICAgICAgT3Bmc0RiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3FsaXRlMy5vbzEuREIucHJvdG90eXBlKTtcbiAgICAgIHNxbGl0ZTMub28xLk9wZnNEYiA9IE9wZnNEYjtcbiAgICAgIE9wZnNEYi5pbXBvcnREYiA9IG9wZnNVdGlsLmltcG9ydERiO1xuICAgICAgc3FsaXRlMy5vbzEuREIuZGJDdG9ySGVscGVyLnNldFZmc1Bvc3RPcGVuU3FsKFxuICAgICAgICBvcGZzVmZzLnBvaW50ZXIsXG4gICAgICAgIGZ1bmN0aW9uKG9vMURiLCBzcWxpdGUzKXtcbiAgICAgICAgICBcbiAgICAgICAgICBzcWxpdGUzLmNhcGkuc3FsaXRlM19idXN5X3RpbWVvdXQob28xRGIsIDEwMDAwKTtcbiAgICAgICAgICBzcWxpdGUzLmNhcGkuc3FsaXRlM19leGVjKG9vMURiLCBbXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFwicHJhZ21hIGpvdXJuYWxfbW9kZT1ERUxFVEU7XCIsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFwicHJhZ21hIGNhY2hlX3NpemU9LTE2Mzg0O1wiXG4gICAgICAgICAgXSwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2FuaXR5Q2hlY2sgPSBmdW5jdGlvbigpe1xuICAgICAgY29uc3Qgc2NvcGUgPSB3YXNtLnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgY29uc3Qgc3EzRmlsZSA9IG5ldyBzcWxpdGUzX2ZpbGUoKTtcbiAgICAgIHRyeXtcbiAgICAgICAgY29uc3QgZmlkID0gc3EzRmlsZS5wb2ludGVyO1xuICAgICAgICBjb25zdCBvcGVuRmxhZ3MgPSBjYXBpLlNRTElURV9PUEVOX0NSRUFURVxuICAgICAgICAgICAgICB8IGNhcGkuU1FMSVRFX09QRU5fUkVBRFdSSVRFXG4gICAgICAgIFxuICAgICAgICAgICAgICB8IGNhcGkuU1FMSVRFX09QRU5fTUFJTl9EQjtcbiAgICAgICAgY29uc3QgcE91dCA9IHdhc20uc2NvcGVkQWxsb2MoOCk7XG4gICAgICAgIGNvbnN0IGRiRmlsZSA9IFwiL3Nhbml0eS9jaGVjay9maWxlXCIrcmFuZG9tRmlsZW5hbWUoOCk7XG4gICAgICAgIGNvbnN0IHpEYkZpbGUgPSB3YXNtLnNjb3BlZEFsbG9jQ1N0cmluZyhkYkZpbGUpO1xuICAgICAgICBsZXQgcmM7XG4gICAgICAgIHN0YXRlLnMxMW4uc2VyaWFsaXplKFwiVGhpcyBpcyDDpCBzdHJpbmcuXCIpO1xuICAgICAgICByYyA9IHN0YXRlLnMxMW4uZGVzZXJpYWxpemUoKTtcbiAgICAgICAgbG9nKFwiZGVzZXJpYWxpemUoKSBzYXlzOlwiLHJjKTtcbiAgICAgICAgaWYoXCJUaGlzIGlzIMOkIHN0cmluZy5cIiE9PXJjWzBdKSB0b3NzKFwiU3RyaW5nIGQxM24gZXJyb3IuXCIpO1xuICAgICAgICB2ZnNTeW5jV3JhcHBlcnMueEFjY2VzcyhvcGZzVmZzLnBvaW50ZXIsIHpEYkZpbGUsIDAsIHBPdXQpO1xuICAgICAgICByYyA9IHdhc20ucGVlayhwT3V0LCdpMzInKTtcbiAgICAgICAgbG9nKFwieEFjY2VzcyhcIixkYkZpbGUsXCIpIGV4aXN0cyA/PVwiLHJjKTtcbiAgICAgICAgcmMgPSB2ZnNTeW5jV3JhcHBlcnMueE9wZW4ob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWQsIG9wZW5GbGFncywgcE91dCk7XG4gICAgICAgIGxvZyhcIm9wZW4gcmMgPVwiLHJjLFwic3RhdGUuc2FiT1BWaWV3W3hPcGVuXSA9XCIsXG4gICAgICAgICAgICBzdGF0ZS5zYWJPUFZpZXdbc3RhdGUub3BJZHMueE9wZW5dKTtcbiAgICAgICAgaWYoMCE9PXJjKXtcbiAgICAgICAgICBlcnJvcihcIm9wZW4gZmFpbGVkIHdpdGggY29kZVwiLHJjKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhBY2Nlc3Mob3Bmc1Zmcy5wb2ludGVyLCB6RGJGaWxlLCAwLCBwT3V0KTtcbiAgICAgICAgcmMgPSB3YXNtLnBlZWsocE91dCwnaTMyJyk7XG4gICAgICAgIGlmKCFyYykgdG9zcyhcInhBY2Nlc3MoKSBmYWlsZWQgdG8gZGV0ZWN0IGZpbGUuXCIpO1xuICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhTeW5jKHNxM0ZpbGUucG9pbnRlciwgMCk7XG4gICAgICAgIGlmKHJjKSB0b3NzKCdzeW5jIGZhaWxlZCB3LyByYycscmMpO1xuICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhUcnVuY2F0ZShzcTNGaWxlLnBvaW50ZXIsIDEwMjQpO1xuICAgICAgICBpZihyYykgdG9zcygndHJ1bmNhdGUgZmFpbGVkIHcvIHJjJyxyYyk7XG4gICAgICAgIHdhc20ucG9rZShwT3V0LDAsJ2k2NCcpO1xuICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhGaWxlU2l6ZShzcTNGaWxlLnBvaW50ZXIsIHBPdXQpO1xuICAgICAgICBpZihyYykgdG9zcygneEZpbGVTaXplIGZhaWxlZCB3LyByYycscmMpO1xuICAgICAgICBsb2coXCJ4RmlsZVNpemUgc2F5czpcIix3YXNtLnBlZWsocE91dCwgJ2k2NCcpKTtcbiAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54V3JpdGUoc3EzRmlsZS5wb2ludGVyLCB6RGJGaWxlLCAxMCwgMSk7XG4gICAgICAgIGlmKHJjKSB0b3NzKFwieFdyaXRlKCkgZmFpbGVkIVwiKTtcbiAgICAgICAgY29uc3QgcmVhZEJ1ZiA9IHdhc20uc2NvcGVkQWxsb2MoMTYpO1xuICAgICAgICByYyA9IGlvU3luY1dyYXBwZXJzLnhSZWFkKHNxM0ZpbGUucG9pbnRlciwgcmVhZEJ1ZiwgNiwgMik7XG4gICAgICAgIHdhc20ucG9rZShyZWFkQnVmKzYsMCk7XG4gICAgICAgIGxldCBqUmVhZCA9IHdhc20uY3N0clRvSnMocmVhZEJ1Zik7XG4gICAgICAgIGxvZyhcInhSZWFkKCkgZ290OlwiLGpSZWFkKTtcbiAgICAgICAgaWYoXCJzYW5pdHlcIiE9PWpSZWFkKSB0b3NzKFwiVW5leHBlY3RlZCB4UmVhZCgpIHZhbHVlLlwiKTtcbiAgICAgICAgaWYodmZzU3luY1dyYXBwZXJzLnhTbGVlcCl7XG4gICAgICAgICAgbG9nKFwieFNsZWVwKClpbmcgYmVmb3JlIGNsb3NlKClpbmcuLi5cIik7XG4gICAgICAgICAgdmZzU3luY1dyYXBwZXJzLnhTbGVlcChvcGZzVmZzLnBvaW50ZXIsMjAwMCk7XG4gICAgICAgICAgbG9nKFwid2FraW5nIHVwIGZyb20geFNsZWVwKClcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmMgPSBpb1N5bmNXcmFwcGVycy54Q2xvc2UoZmlkKTtcbiAgICAgICAgbG9nKFwieENsb3NlIHJjID1cIixyYyxcInNhYk9QVmlldyA9XCIsc3RhdGUuc2FiT1BWaWV3KTtcbiAgICAgICAgbG9nKFwiRGVsZXRpbmcgZmlsZTpcIixkYkZpbGUpO1xuICAgICAgICB2ZnNTeW5jV3JhcHBlcnMueERlbGV0ZShvcGZzVmZzLnBvaW50ZXIsIHpEYkZpbGUsIDB4MTIzNCk7XG4gICAgICAgIHZmc1N5bmNXcmFwcGVycy54QWNjZXNzKG9wZnNWZnMucG9pbnRlciwgekRiRmlsZSwgMCwgcE91dCk7XG4gICAgICAgIHJjID0gd2FzbS5wZWVrKHBPdXQsJ2kzMicpO1xuICAgICAgICBpZihyYykgdG9zcyhcIkV4cGVjdGluZyAwIGZyb20geEFjY2VzcyhcIixkYkZpbGUsXCIpIGFmdGVyIHhEZWxldGUoKS5cIik7XG4gICAgICAgIHdhcm4oXCJFbmQgb2YgT1BGUyBzYW5pdHkgY2hlY2tzLlwiKTtcbiAgICAgIH1maW5hbGx5e1xuICAgICAgICBzcTNGaWxlLmRpc3Bvc2UoKTtcbiAgICAgICAgd2FzbS5zY29wZWRBbGxvY1BvcChzY29wZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFcub25tZXNzYWdlID0gZnVuY3Rpb24oe2RhdGF9KXtcbiAgICAgIFxuICAgICAgc3dpdGNoKGRhdGEudHlwZSl7XG4gICAgICAgICAgY2FzZSAnb3Bmcy11bmF2YWlsYWJsZSc6XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHByb21pc2VSZWplY3QobmV3IEVycm9yKGRhdGEucGF5bG9hZC5qb2luKCcgJykpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtbG9hZGVkJzpcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgVy5wb3N0TWVzc2FnZSh7dHlwZTogJ29wZnMtYXN5bmMtaW5pdCcsYXJnczogc3RhdGV9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29wZnMtYXN5bmMtaW5pdGVkJzoge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0cnVlPT09cHJvbWlzZVdhc1JlamVjdGVkKXtcbiAgICAgICAgICAgICAgYnJlYWsgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3FsaXRlMy52ZnMuaW5zdGFsbFZmcyh7XG4gICAgICAgICAgICAgICAgaW86IHtzdHJ1Y3Q6IG9wZnNJb01ldGhvZHMsIG1ldGhvZHM6IGlvU3luY1dyYXBwZXJzfSxcbiAgICAgICAgICAgICAgICB2ZnM6IHtzdHJ1Y3Q6IG9wZnNWZnMsIG1ldGhvZHM6IHZmc1N5bmNXcmFwcGVyc31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN0YXRlLnNhYk9QVmlldyA9IG5ldyBJbnQzMkFycmF5KHN0YXRlLnNhYk9QKTtcbiAgICAgICAgICAgICAgc3RhdGUuc2FiRmlsZUJ1ZlZpZXcgPSBuZXcgVWludDhBcnJheShzdGF0ZS5zYWJJTywgMCwgc3RhdGUuZmlsZUJ1ZmZlclNpemUpO1xuICAgICAgICAgICAgICBzdGF0ZS5zYWJTMTFuVmlldyA9IG5ldyBVaW50OEFycmF5KHN0YXRlLnNhYklPLCBzdGF0ZS5zYWJTMTFuT2Zmc2V0LCBzdGF0ZS5zYWJTMTFuU2l6ZSk7XG4gICAgICAgICAgICAgIGluaXRTMTFuKCk7XG4gICAgICAgICAgICAgIGlmKG9wdGlvbnMuc2FuaXR5Q2hlY2tzKXtcbiAgICAgICAgICAgICAgICB3YXJuKFwiUnVubmluZyBzYW5pdHkgY2hlY2tzIGJlY2F1c2Ugb2Ygb3Bmcy1zYW5pdHktY2hlY2sgVVJMIGFyZy4uLlwiKTtcbiAgICAgICAgICAgICAgICBzYW5pdHlDaGVjaygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHRoaXNUaHJlYWRIYXNPUEZTKCkpe1xuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5zdG9yYWdlLmdldERpcmVjdG9yeSgpLnRoZW4oKGQpPT57XG4gICAgICAgICAgICAgICAgICBXLm9uZXJyb3IgPSBXLl9vcmlnaW5hbE9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgVy5fb3JpZ2luYWxPbkVycm9yO1xuICAgICAgICAgICAgICAgICAgc3FsaXRlMy5vcGZzID0gb3Bmc1V0aWw7XG4gICAgICAgICAgICAgICAgICBvcGZzVXRpbC5yb290RGlyZWN0b3J5ID0gZDtcbiAgICAgICAgICAgICAgICAgIGxvZyhcIkVuZCBvZiBPUEZTIHNxbGl0ZTNfdmZzIHNldHVwLlwiLCBvcGZzVmZzKTtcbiAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocHJvbWlzZVJlamVjdCk7XG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgICAgZXJyb3IoZSk7XG4gICAgICAgICAgICAgIHByb21pc2VSZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gKFxuICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWVzc2FnZSBmcm9tIHRoZSBPUEZTIGFzeW5jIHdvcmtlcjogXCIgK1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICBwcm9taXNlUmVqZWN0KG5ldyBFcnJvcihlcnJNc2cpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHRoZVByb21pc2U7XG59O1xuaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID1cbiAgXCJzcWxpdGUzLW9wZnMtYXN5bmMtcHJveHkuanNcIjtcbmdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcC5pbml0aWFsaXplcnNBc3luYy5wdXNoKGFzeW5jIChzcWxpdGUzKT0+e1xuICB0cnl7XG4gICAgbGV0IHByb3h5SnMgPSBpbnN0YWxsT3Bmc1Zmcy5kZWZhdWx0UHJveHlVcmk7XG4gICAgaWYoc3FsaXRlMy5zY3JpcHRJbmZvLnNxbGl0ZTNEaXIpe1xuICAgICAgaW5zdGFsbE9wZnNWZnMuZGVmYXVsdFByb3h5VXJpID1cbiAgICAgICAgc3FsaXRlMy5zY3JpcHRJbmZvLnNxbGl0ZTNEaXIgKyBwcm94eUpzO1xuICAgICAgXG4gICAgfVxuICAgIHJldHVybiBpbnN0YWxsT3Bmc1ZmcygpLmNhdGNoKChlKT0+e1xuICAgICAgc3FsaXRlMy5jb25maWcud2FybihcIklnbm9yaW5nIGluYWJpbGl0eSB0byBpbnN0YWxsIE9QRlMgc3FsaXRlM192ZnM6XCIsZS5tZXNzYWdlKTtcbiAgICB9KTtcbiAgfWNhdGNoKGUpe1xuICAgIHNxbGl0ZTMuY29uZmlnLmVycm9yKFwiaW5zdGFsbE9wZnNWZnMoKSBleGNlcHRpb246XCIsZSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59KTtcbn0pO1xuXG5cblxuZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQm9vdHN0cmFwLmluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uKHNxbGl0ZTMpe1xuICAndXNlIHN0cmljdCc7XG4gIGNvbnN0IHRvc3MgPSBzcWxpdGUzLnV0aWwudG9zcztcbiAgY29uc3QgdG9zczMgPSBzcWxpdGUzLnV0aWwudG9zczM7XG4gIGNvbnN0IGluaXRQcm9taXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGNhcGkgPSBzcWxpdGUzLmNhcGk7XG4gIGNvbnN0IHV0aWwgPSBzcWxpdGUzLnV0aWw7XG4gIGNvbnN0IHdhc20gPSBzcWxpdGUzLndhc207XG4gIFxuICBjb25zdCBTRUNUT1JfU0laRSA9IDQwOTY7XG4gIGNvbnN0IEhFQURFUl9NQVhfUEFUSF9TSVpFID0gNTEyO1xuICBjb25zdCBIRUFERVJfRkxBR1NfU0laRSA9IDQ7XG4gIGNvbnN0IEhFQURFUl9ESUdFU1RfU0laRSA9IDg7XG4gIGNvbnN0IEhFQURFUl9DT1JQVVNfU0laRSA9IEhFQURFUl9NQVhfUEFUSF9TSVpFICsgSEVBREVSX0ZMQUdTX1NJWkU7XG4gIGNvbnN0IEhFQURFUl9PRkZTRVRfRkxBR1MgPSBIRUFERVJfTUFYX1BBVEhfU0laRTtcbiAgY29uc3QgSEVBREVSX09GRlNFVF9ESUdFU1QgPSBIRUFERVJfQ09SUFVTX1NJWkU7XG4gIGNvbnN0IEhFQURFUl9PRkZTRVRfREFUQSA9IFNFQ1RPUl9TSVpFO1xuICBcbiAgY29uc3QgUEVSU0lTVEVOVF9GSUxFX1RZUEVTID1cbiAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0RCIHxcbiAgICAgICAgY2FwaS5TUUxJVEVfT1BFTl9NQUlOX0pPVVJOQUwgfFxuICAgICAgICBjYXBpLlNRTElURV9PUEVOX1NVUEVSX0pPVVJOQUwgfFxuICAgICAgICBjYXBpLlNRTElURV9PUEVOX1dBTCA7XG5cbiAgXG4gIGNvbnN0IE9QQVFVRV9ESVJfTkFNRSA9IFwiLm9wYXF1ZVwiO1xuXG4gIFxuICBjb25zdCBnZXRSYW5kb21OYW1lID0gKCk9Pk1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgY29uc3Qgb3B0aW9uRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgIG5hbWU6ICdvcGZzLXNhaHBvb2wnLFxuICAgIGRpcmVjdG9yeTogdW5kZWZpbmVkICxcbiAgICBpbml0aWFsQ2FwYWNpdHk6IDYsXG4gICAgY2xlYXJPbkluaXQ6IGZhbHNlLFxuICAgIFxuICAgIHZlcmJvc2l0eTogMlxuICB9KTtcblxuICBcbiAgY29uc3QgbG9nZ2VycyA9IFtcbiAgICBzcWxpdGUzLmNvbmZpZy5lcnJvcixcbiAgICBzcWxpdGUzLmNvbmZpZy53YXJuLFxuICAgIHNxbGl0ZTMuY29uZmlnLmxvZ1xuICBdO1xuICBjb25zdCBsb2cgPSBzcWxpdGUzLmNvbmZpZy5sb2c7XG4gIGNvbnN0IHdhcm4gPSBzcWxpdGUzLmNvbmZpZy53YXJuO1xuICBjb25zdCBlcnJvciA9IHNxbGl0ZTMuY29uZmlnLmVycm9yO1xuXG4gIFxuICBjb25zdCBfX21hcFZmc1RvUG9vbCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0UG9vbEZvclZmcyA9IChwVmZzKT0+X19tYXBWZnNUb1Bvb2wuZ2V0KHBWZnMpO1xuICBjb25zdCBzZXRQb29sRm9yVmZzID0gKHBWZnMscG9vbCk9PntcbiAgICBpZihwb29sKSBfX21hcFZmc1RvUG9vbC5zZXQocFZmcywgcG9vbCk7XG4gICAgZWxzZSBfX21hcFZmc1RvUG9vbC5kZWxldGUocFZmcyk7XG4gIH07XG4gIFxuICBjb25zdCBfX21hcFNxbGl0ZTNGaWxlID0gbmV3IE1hcCgpO1xuICBjb25zdCBnZXRQb29sRm9yUEZpbGUgPSAocEZpbGUpPT5fX21hcFNxbGl0ZTNGaWxlLmdldChwRmlsZSk7XG4gIGNvbnN0IHNldFBvb2xGb3JQRmlsZSA9IChwRmlsZSxwb29sKT0+e1xuICAgIGlmKHBvb2wpIF9fbWFwU3FsaXRlM0ZpbGUuc2V0KHBGaWxlLCBwb29sKTtcbiAgICBlbHNlIF9fbWFwU3FsaXRlM0ZpbGUuZGVsZXRlKHBGaWxlKTtcbiAgfTtcblxuICBcbiAgY29uc3QgaW9NZXRob2RzID0ge1xuICAgIHhDaGVja1Jlc2VydmVkTG9jazogZnVuY3Rpb24ocEZpbGUscE91dCl7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclBGaWxlKHBGaWxlKTtcbiAgICAgIHBvb2wubG9nKCd4Q2hlY2tSZXNlcnZlZExvY2snKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIHdhc20ucG9rZTMyKHBPdXQsIDEpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB4Q2xvc2U6IGZ1bmN0aW9uKHBGaWxlKXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgaWYoZmlsZSkge1xuICAgICAgICB0cnl7XG4gICAgICAgICAgcG9vbC5sb2coYHhDbG9zZSAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICBwb29sLm1hcFMzRmlsZVRvT0ZpbGUocEZpbGUsIGZhbHNlKTtcbiAgICAgICAgICBmaWxlLnNhaC5mbHVzaCgpO1xuICAgICAgICAgIGlmKGZpbGUuZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0Upe1xuICAgICAgICAgICAgcG9vbC5kZWxldGVQYXRoKGZpbGUucGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhEZXZpY2VDaGFyYWN0ZXJpc3RpY3M6IGZ1bmN0aW9uKHBGaWxlKXtcbiAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0NBUF9VTkRFTEVUQUJMRV9XSEVOX09QRU47XG4gICAgfSxcbiAgICB4RmlsZUNvbnRyb2w6IGZ1bmN0aW9uKHBGaWxlLCBvcElkLCBwQXJnKXtcbiAgICAgIHJldHVybiBjYXBpLlNRTElURV9OT1RGT1VORDtcbiAgICB9LFxuICAgIHhGaWxlU2l6ZTogZnVuY3Rpb24ocEZpbGUscFN6NjQpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZyhgeEZpbGVTaXplYCk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBjb25zdCBzaXplID0gZmlsZS5zYWguZ2V0U2l6ZSgpIC0gSEVBREVSX09GRlNFVF9EQVRBO1xuICAgICAgXG4gICAgICB3YXNtLnBva2U2NChwU3o2NCwgQmlnSW50KHNpemUpKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeExvY2s6IGZ1bmN0aW9uKHBGaWxlLGxvY2tUeXBlKXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coYHhMb2NrICR7bG9ja1R5cGV9YCk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBmaWxlLmxvY2tUeXBlID0gbG9ja1R5cGU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhSZWFkOiBmdW5jdGlvbihwRmlsZSxwRGVzdCxuLG9mZnNldDY0KXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5zdG9yZUVycigpO1xuICAgICAgY29uc3QgZmlsZSA9IHBvb2wuZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coYHhSZWFkICR7ZmlsZS5wYXRofSAke259IEAgJHtvZmZzZXQ2NH1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5SZWFkID0gZmlsZS5zYWgucmVhZChcbiAgICAgICAgICB3YXNtLmhlYXA4dSgpLnN1YmFycmF5KHBEZXN0LCBwRGVzdCtuKSxcbiAgICAgICAgICB7YXQ6IEhFQURFUl9PRkZTRVRfREFUQSArIE51bWJlcihvZmZzZXQ2NCl9XG4gICAgICAgICk7XG4gICAgICAgIGlmKG5SZWFkIDwgbil7XG4gICAgICAgICAgd2FzbS5oZWFwOHUoKS5maWxsKDAsIHBEZXN0ICsgblJlYWQsIHBEZXN0ICsgbik7XG4gICAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0lPRVJSX1NIT1JUX1JFQUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHhTZWN0b3JTaXplOiBmdW5jdGlvbihwRmlsZSl7XG4gICAgICByZXR1cm4gU0VDVE9SX1NJWkU7XG4gICAgfSxcbiAgICB4U3luYzogZnVuY3Rpb24ocEZpbGUsZmxhZ3Mpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZyhgeFN5bmMgJHtmbGFnc31gKTtcbiAgICAgIHBvb2wuc3RvcmVFcnIoKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIFxuICAgICAgdHJ5e1xuICAgICAgICBmaWxlLnNhaC5mbHVzaCgpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeFRydW5jYXRlOiBmdW5jdGlvbihwRmlsZSxzejY0KXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coYHhUcnVuY2F0ZSAke3N6NjR9YCk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBcbiAgICAgIHRyeXtcbiAgICAgICAgZmlsZS5zYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBICsgTnVtYmVyKHN6NjQpKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHJldHVybiBwb29sLnN0b3JlRXJyKGUsIGNhcGkuU1FMSVRFX0lPRVJSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHhVbmxvY2s6IGZ1bmN0aW9uKHBGaWxlLGxvY2tUeXBlKXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yUEZpbGUocEZpbGUpO1xuICAgICAgcG9vbC5sb2coJ3hVbmxvY2snKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBwb29sLmdldE9GaWxlRm9yUzNGaWxlKHBGaWxlKTtcbiAgICAgIGZpbGUubG9ja1R5cGUgPSBsb2NrVHlwZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeFdyaXRlOiBmdW5jdGlvbihwRmlsZSxwU3JjLG4sb2Zmc2V0NjQpe1xuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JQRmlsZShwRmlsZSk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICBjb25zdCBmaWxlID0gcG9vbC5nZXRPRmlsZUZvclMzRmlsZShwRmlsZSk7XG4gICAgICBwb29sLmxvZyhgeFdyaXRlICR7ZmlsZS5wYXRofSAke259ICR7b2Zmc2V0NjR9YCk7XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IG5CeXRlcyA9IGZpbGUuc2FoLndyaXRlKFxuICAgICAgICAgIHdhc20uaGVhcDh1KCkuc3ViYXJyYXkocFNyYywgcFNyYytuKSxcbiAgICAgICAgICB7IGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyBOdW1iZXIob2Zmc2V0NjQpIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG49PT1uQnl0ZXMgPyAwIDogdG9zcyhcIlVua25vd24gd3JpdGUoKSBmYWlsdXJlLlwiKTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcmV0dXJuIHBvb2wuc3RvcmVFcnIoZSwgY2FwaS5TUUxJVEVfSU9FUlIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBvcGZzSW9NZXRob2RzID0gbmV3IGNhcGkuc3FsaXRlM19pb19tZXRob2RzKCk7XG4gIG9wZnNJb01ldGhvZHMuJGlWZXJzaW9uID0gMTtcbiAgc3FsaXRlMy52ZnMuaW5zdGFsbFZmcyh7XG4gICAgaW86IHtzdHJ1Y3Q6IG9wZnNJb01ldGhvZHMsIG1ldGhvZHM6IGlvTWV0aG9kc31cbiAgfSk7XG5cbiAgXG4gIGNvbnN0IHZmc01ldGhvZHMgPSB7XG4gICAgeEFjY2VzczogZnVuY3Rpb24ocFZmcyx6TmFtZSxmbGFncyxwT3V0KXtcbiAgICAgIFxuICAgICAgY29uc3QgcG9vbCA9IGdldFBvb2xGb3JWZnMocFZmcyk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICB0cnl7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwb29sLmdldFBhdGgoek5hbWUpO1xuICAgICAgICB3YXNtLnBva2UzMihwT3V0LCBwb29sLmhhc0ZpbGVuYW1lKG5hbWUpID8gMSA6IDApO1xuICAgICAgfWNhdGNoKGUpe1xuICAgICAgICBcbiAgICAgICAgd2FzbS5wb2tlMzIocE91dCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHhDdXJyZW50VGltZTogZnVuY3Rpb24ocFZmcyxwT3V0KXtcbiAgICAgIHdhc20ucG9rZShwT3V0LCAyNDQwNTg3LjUgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkvODY0MDAwMDApLFxuICAgICAgICAgICAgICAgICdkb3VibGUnKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeEN1cnJlbnRUaW1lSW50NjQ6IGZ1bmN0aW9uKHBWZnMscE91dCl7XG4gICAgICB3YXNtLnBva2UocE91dCwgKDI0NDA1ODcuNSAqIDg2NDAwMDAwKSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICdpNjQnKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgeERlbGV0ZTogZnVuY3Rpb24ocFZmcywgek5hbWUsIGRvU3luY0Rpcil7XG4gICAgICBjb25zdCBwb29sID0gZ2V0UG9vbEZvclZmcyhwVmZzKTtcbiAgICAgIHBvb2wubG9nKGB4RGVsZXRlICR7d2FzbS5jc3RyVG9Kcyh6TmFtZSl9YCk7XG4gICAgICBwb29sLnN0b3JlRXJyKCk7XG4gICAgICB0cnl7XG4gICAgICAgIHBvb2wuZGVsZXRlUGF0aChwb29sLmdldFBhdGgoek5hbWUpKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHBvb2wuc3RvcmVFcnIoZSk7XG4gICAgICAgIHJldHVybiBjYXBpLlNRTElURV9JT0VSUl9ERUxFVEU7XG4gICAgICB9XG4gICAgfSxcbiAgICB4RnVsbFBhdGhuYW1lOiBmdW5jdGlvbihwVmZzLHpOYW1lLG5PdXQscE91dCl7XG4gICAgICBcbiAgICAgIFxuICAgICAgY29uc3QgaSA9IHdhc20uY3N0cm5jcHkocE91dCwgek5hbWUsIG5PdXQpO1xuICAgICAgcmV0dXJuIGk8bk91dCA/IDAgOiBjYXBpLlNRTElURV9DQU5UT1BFTjtcbiAgICB9LFxuICAgIHhHZXRMYXN0RXJyb3I6IGZ1bmN0aW9uKHBWZnMsbk91dCxwT3V0KXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgY29uc3QgZSA9IHBvb2wucG9wRXJyKCk7XG4gICAgICBwb29sLmxvZyhgeEdldExhc3RFcnJvciAke25PdXR9IGUgPWAsZSk7XG4gICAgICBpZihlKXtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSB3YXNtLnNjb3BlZEFsbG9jUHVzaCgpO1xuICAgICAgICB0cnl7XG4gICAgICAgICAgY29uc3QgW2NNc2csIG5dID0gd2FzbS5zY29wZWRBbGxvY0NTdHJpbmcoZS5tZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgICB3YXNtLmNzdHJuY3B5KHBPdXQsIGNNc2csIG5PdXQpO1xuICAgICAgICAgIGlmKG4gPiBuT3V0KSB3YXNtLnBva2U4KHBPdXQgKyBuT3V0IC0gMSwgMCk7XG4gICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICByZXR1cm4gY2FwaS5TUUxJVEVfTk9NRU07XG4gICAgICAgIH1maW5hbGx5e1xuICAgICAgICAgIHdhc20uc2NvcGVkQWxsb2NQb3Aoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZSA/IChlLnNxbGl0ZTNSYyB8fCBjYXBpLlNRTElURV9JT0VSUikgOiAwO1xuICAgIH0sXG4gICAgXG4gICAgeE9wZW46IGZ1bmN0aW9uIGYocFZmcywgek5hbWUsIHBGaWxlLCBmbGFncywgcE91dEZsYWdzKXtcbiAgICAgIGNvbnN0IHBvb2wgPSBnZXRQb29sRm9yVmZzKHBWZnMpO1xuICAgICAgdHJ5e1xuICAgICAgICBwb29sLmxvZyhgeE9wZW4gJHt3YXNtLmNzdHJUb0pzKHpOYW1lKX0gJHtmbGFnc31gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBhdGggPSAoek5hbWUgJiYgd2FzbS5wZWVrOCh6TmFtZSkpXG4gICAgICAgICAgICAgID8gcG9vbC5nZXRQYXRoKHpOYW1lKVxuICAgICAgICAgICAgICA6IGdldFJhbmRvbU5hbWUoKTtcbiAgICAgICAgbGV0IHNhaCA9IHBvb2wuZ2V0U0FIRm9yUGF0aChwYXRoKTtcbiAgICAgICAgaWYoIXNhaCAmJiAoZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0NSRUFURSkpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBpZihwb29sLmdldEZpbGVDb3VudCgpIDwgcG9vbC5nZXRDYXBhY2l0eSgpKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNhaCA9IHBvb2wubmV4dEF2YWlsYWJsZVNBSCgpO1xuICAgICAgICAgICAgcG9vbC5zZXRBc3NvY2lhdGVkUGF0aChzYWgsIHBhdGgsIGZsYWdzKTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdG9zcygnU0FIIHBvb2wgaXMgZnVsbC4gQ2Fubm90IGNyZWF0ZSBmaWxlJyxwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXNhaCl7XG4gICAgICAgICAgdG9zcygnZmlsZSBub3QgZm91bmQ6JyxwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZpbGUgPSB7cGF0aCwgZmxhZ3MsIHNhaH07XG4gICAgICAgIHBvb2wubWFwUzNGaWxlVG9PRmlsZShwRmlsZSwgZmlsZSk7XG4gICAgICAgIGZpbGUubG9ja1R5cGUgPSBjYXBpLlNRTElURV9MT0NLX05PTkU7XG4gICAgICAgIGNvbnN0IHNxM0ZpbGUgPSBuZXcgY2FwaS5zcWxpdGUzX2ZpbGUocEZpbGUpO1xuICAgICAgICBzcTNGaWxlLiRwTWV0aG9kcyA9IG9wZnNJb01ldGhvZHMucG9pbnRlcjtcbiAgICAgICAgc3EzRmlsZS5kaXNwb3NlKCk7XG4gICAgICAgIHdhc20ucG9rZTMyKHBPdXRGbGFncywgZmxhZ3MpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgcG9vbC5zdG9yZUVycihlKTtcbiAgICAgICAgcmV0dXJuIGNhcGkuU1FMSVRFX0NBTlRPUEVOO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBcbiAgY29uc3QgY3JlYXRlT3Bmc1ZmcyA9IGZ1bmN0aW9uKHZmc05hbWUpe1xuICAgIGlmKCBzcWxpdGUzLmNhcGkuc3FsaXRlM192ZnNfZmluZCh2ZnNOYW1lKSl7XG4gICAgICB0b3NzMyhcIlZGUyBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZDpcIiwgdmZzTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IG9wZnNWZnMgPSBuZXcgY2FwaS5zcWxpdGUzX3ZmcygpO1xuICAgIFxuICAgIGNvbnN0IHBEVmZzID0gY2FwaS5zcWxpdGUzX3Zmc19maW5kKG51bGwpO1xuICAgIGNvbnN0IGRWZnMgPSBwRFZmc1xuICAgICAgICAgID8gbmV3IGNhcGkuc3FsaXRlM192ZnMocERWZnMpXG4gICAgICAgICAgOiBudWxsIDtcbiAgICBvcGZzVmZzLiRpVmVyc2lvbiA9IDI7XG4gICAgb3Bmc1Zmcy4kc3pPc0ZpbGUgPSBjYXBpLnNxbGl0ZTNfZmlsZS5zdHJ1Y3RJbmZvLnNpemVvZjtcbiAgICBvcGZzVmZzLiRteFBhdGhuYW1lID0gSEVBREVSX01BWF9QQVRIX1NJWkU7XG4gICAgb3Bmc1Zmcy5hZGRPbkRpc3Bvc2UoXG4gICAgICBvcGZzVmZzLiR6TmFtZSA9IHdhc20uYWxsb2NDU3RyaW5nKHZmc05hbWUpLFxuICAgICAgKCk9PnNldFBvb2xGb3JWZnMob3Bmc1Zmcy5wb2ludGVyLCAwKVxuICAgICk7XG5cbiAgICBpZihkVmZzKXtcbiAgICAgIFxuICAgICAgb3Bmc1Zmcy4keFJhbmRvbW5lc3MgPSBkVmZzLiR4UmFuZG9tbmVzcztcbiAgICAgIG9wZnNWZnMuJHhTbGVlcCA9IGRWZnMuJHhTbGVlcDtcbiAgICAgIGRWZnMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZighb3Bmc1Zmcy4keFJhbmRvbW5lc3MgJiYgIXZmc01ldGhvZHMueFJhbmRvbW5lc3Mpe1xuICAgICAgXG4gICAgICB2ZnNNZXRob2RzLnhSYW5kb21uZXNzID0gZnVuY3Rpb24ocFZmcywgbk91dCwgcE91dCl7XG4gICAgICAgIGNvbnN0IGhlYXAgPSB3YXNtLmhlYXA4dSgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvcig7IGkgPCBuT3V0OyArK2kpIGhlYXBbcE91dCArIGldID0gKE1hdGgucmFuZG9tKCkqMjU1MDAwKSAmIDB4RkY7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYoIW9wZnNWZnMuJHhTbGVlcCAmJiAhdmZzTWV0aG9kcy54U2xlZXApe1xuICAgICAgdmZzTWV0aG9kcy54U2xlZXAgPSAocFZmcyxtcyk9PjA7XG4gICAgfVxuICAgIHNxbGl0ZTMudmZzLmluc3RhbGxWZnMoe1xuICAgICAgdmZzOiB7c3RydWN0OiBvcGZzVmZzLCBtZXRob2RzOiB2ZnNNZXRob2RzfVxuICAgIH0pO1xuICAgIHJldHVybiBvcGZzVmZzO1xuICB9O1xuXG4gIFxuICBjbGFzcyBPcGZzU0FIUG9vbCB7XG4gICAgXG4gICAgdmZzRGlyO1xuICAgIFxuICAgICNkaFZmc1Jvb3Q7XG4gICAgXG4gICAgI2RoT3BhcXVlO1xuICAgIFxuICAgICNkaFZmc1BhcmVudDtcbiAgICBcbiAgICAjbWFwU0FIVG9OYW1lID0gbmV3IE1hcCgpO1xuICAgIFxuICAgICNtYXBGaWxlbmFtZVRvU0FIID0gbmV3IE1hcCgpO1xuICAgIFxuICAgICNhdmFpbGFibGVTQUggPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgI21hcFMzRmlsZVRvT0ZpbGVfID0gbmV3IE1hcCgpO1xuXG4gICAgXG4gICAgXG5cbiAgICBcbiAgICAjYXBCb2R5ID0gbmV3IFVpbnQ4QXJyYXkoSEVBREVSX0NPUlBVU19TSVpFKTtcbiAgICBcbiAgICAjZHZCb2R5O1xuXG4gICAgXG4gICAgI2NWZnM7XG5cbiAgICBcbiAgICAjdmVyYm9zaXR5O1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpe1xuICAgICAgdGhpcy4jdmVyYm9zaXR5ID0gb3B0aW9ucy52ZXJib3NpdHkgPz8gb3B0aW9uRGVmYXVsdHMudmVyYm9zaXR5O1xuICAgICAgdGhpcy52ZnNOYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbkRlZmF1bHRzLm5hbWU7XG4gICAgICB0aGlzLiNjVmZzID0gY3JlYXRlT3Bmc1Zmcyh0aGlzLnZmc05hbWUpO1xuICAgICAgc2V0UG9vbEZvclZmcyh0aGlzLiNjVmZzLnBvaW50ZXIsIHRoaXMpO1xuICAgICAgdGhpcy52ZnNEaXIgPSBvcHRpb25zLmRpcmVjdG9yeSB8fCAoXCIuXCIrdGhpcy52ZnNOYW1lKTtcbiAgICAgIHRoaXMuI2R2Qm9keSA9XG4gICAgICAgIG5ldyBEYXRhVmlldyh0aGlzLiNhcEJvZHkuYnVmZmVyLCB0aGlzLiNhcEJvZHkuYnl0ZU9mZnNldCk7XG4gICAgICB0aGlzLmlzUmVhZHkgPSB0aGlzXG4gICAgICAgIC5yZXNldCghIShvcHRpb25zLmNsZWFyT25Jbml0ID8/IG9wdGlvbkRlZmF1bHRzLmNsZWFyT25Jbml0KSlcbiAgICAgICAgLnRoZW4oKCk9PntcbiAgICAgICAgICBpZih0aGlzLiRlcnJvcikgdGhyb3cgdGhpcy4kZXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FwYWNpdHkoKVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgICAgICAgOiB0aGlzLmFkZENhcGFjaXR5KG9wdGlvbnMuaW5pdGlhbENhcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgb3B0aW9uRGVmYXVsdHMuaW5pdGlhbENhcGFjaXR5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgI2xvZ0ltcGwobGV2ZWwsLi4uYXJncyl7XG4gICAgICBpZih0aGlzLiN2ZXJib3NpdHk+bGV2ZWwpIGxvZ2dlcnNbbGV2ZWxdKHRoaXMudmZzTmFtZStcIjpcIiwuLi5hcmdzKTtcbiAgICB9O1xuICAgIGxvZyguLi5hcmdzKXt0aGlzLiNsb2dJbXBsKDIsIC4uLmFyZ3MpfTtcbiAgICB3YXJuKC4uLmFyZ3Mpe3RoaXMuI2xvZ0ltcGwoMSwgLi4uYXJncyl9O1xuICAgIGVycm9yKC4uLmFyZ3Mpe3RoaXMuI2xvZ0ltcGwoMCwgLi4uYXJncyl9O1xuXG4gICAgZ2V0VmZzKCl7cmV0dXJuIHRoaXMuI2NWZnN9XG5cbiAgICBcbiAgICBnZXRDYXBhY2l0eSgpe3JldHVybiB0aGlzLiNtYXBTQUhUb05hbWUuc2l6ZX1cblxuICAgIFxuICAgIGdldEZpbGVDb3VudCgpe3JldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILnNpemV9XG5cbiAgICBcbiAgICBnZXRGaWxlTmFtZXMoKXtcbiAgICAgIGNvbnN0IHJjID0gW107XG4gICAgICBjb25zdCBpdGVyID0gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5rZXlzKCk7XG4gICAgICBmb3IoY29uc3QgbiBvZiBpdGVyKSByYy5wdXNoKG4pO1xuICAgICAgcmV0dXJuIHJjO1xuICAgIH1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICBcbiAgICBhc3luYyBhZGRDYXBhY2l0eShuKXtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBuOyArK2kpe1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0UmFuZG9tTmFtZSgpO1xuICAgICAgICBjb25zdCBoID0gYXdhaXQgdGhpcy4jZGhPcGFxdWUuZ2V0RmlsZUhhbmRsZShuYW1lLCB7Y3JlYXRlOnRydWV9KTtcbiAgICAgICAgY29uc3QgYWggPSBhd2FpdCBoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLnNldChhaCxuYW1lKTtcbiAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChhaCwgJycsIDApO1xuICAgICAgICBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldENhcGFjaXR5KCk7XG4gICAgfVxuXG4gICAgXG4gICAgYXN5bmMgcmVkdWNlQ2FwYWNpdHkobil7XG4gICAgICBsZXQgblJtID0gMDtcbiAgICAgIGZvcihjb25zdCBhaCBvZiBBcnJheS5mcm9tKHRoaXMuI2F2YWlsYWJsZVNBSCkpe1xuICAgICAgICBpZihuUm0gPT09IG4gfHwgdGhpcy5nZXRGaWxlQ291bnQoKSA9PT0gdGhpcy5nZXRDYXBhY2l0eSgpKXtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy4jbWFwU0FIVG9OYW1lLmdldChhaCk7XG4gICAgICAgIFxuICAgICAgICBhaC5jbG9zZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLiNkaE9wYXF1ZS5yZW1vdmVFbnRyeShuYW1lKTtcbiAgICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLmRlbGV0ZShhaCk7XG4gICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoYWgpO1xuICAgICAgICArK25SbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuUm07XG4gICAgfVxuXG4gICAgXG4gICAgcmVsZWFzZUFjY2Vzc0hhbmRsZXMoKXtcbiAgICAgIGZvcihjb25zdCBhaCBvZiB0aGlzLiNtYXBTQUhUb05hbWUua2V5cygpKSBhaC5jbG9zZSgpO1xuICAgICAgdGhpcy4jbWFwU0FIVG9OYW1lLmNsZWFyKCk7XG4gICAgICB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmNsZWFyKCk7XG4gICAgICB0aGlzLiNhdmFpbGFibGVTQUguY2xlYXIoKTtcbiAgICB9XG5cbiAgICBcbiAgICBhc3luYyBhY3F1aXJlQWNjZXNzSGFuZGxlcyhjbGVhckZpbGVzKXtcbiAgICAgIGNvbnN0IGZpbGVzID0gW107XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IFtuYW1lLGhdIG9mIHRoaXMuI2RoT3BhcXVlKXtcbiAgICAgICAgaWYoJ2ZpbGUnPT09aC5raW5kKXtcbiAgICAgICAgICBmaWxlcy5wdXNoKFtuYW1lLGhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZpbGVzLm1hcChhc3luYyhbbmFtZSxoXSk9PntcbiAgICAgICAgdHJ5e1xuICAgICAgICAgIGNvbnN0IGFoID0gYXdhaXQgaC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKClcbiAgICAgICAgICB0aGlzLiNtYXBTQUhUb05hbWUuc2V0KGFoLCBuYW1lKTtcbiAgICAgICAgICBpZihjbGVhckZpbGVzKXtcbiAgICAgICAgICAgIGFoLnRydW5jYXRlKEhFQURFUl9PRkZTRVRfREFUQSk7XG4gICAgICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKGFoLCAnJywgMCk7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5nZXRBc3NvY2lhdGVkUGF0aChhaCk7XG4gICAgICAgICAgICBpZihwYXRoKXtcbiAgICAgICAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5zZXQocGF0aCwgYWgpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5hZGQoYWgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgIHRoaXMuc3RvcmVFcnIoZSk7XG4gICAgICAgICAgdGhpcy5yZWxlYXNlQWNjZXNzSGFuZGxlcygpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBcbiAgICBnZXRBc3NvY2lhdGVkUGF0aChzYWgpe1xuICAgICAgc2FoLnJlYWQodGhpcy4jYXBCb2R5LCB7YXQ6IDB9KTtcbiAgICAgIFxuICAgICAgXG4gICAgICBjb25zdCBmbGFncyA9IHRoaXMuI2R2Qm9keS5nZXRVaW50MzIoSEVBREVSX09GRlNFVF9GTEFHUyk7XG4gICAgICBpZih0aGlzLiNhcEJvZHlbMF0gJiZcbiAgICAgICAgICgoZmxhZ3MgJiBjYXBpLlNRTElURV9PUEVOX0RFTEVURU9OQ0xPU0UpIHx8XG4gICAgICAgICAgKGZsYWdzICYgUEVSU0lTVEVOVF9GSUxFX1RZUEVTKT09PTApKXtcbiAgICAgICAgd2FybihgUmVtb3ZpbmcgZmlsZSB3aXRoIHVuZXhwZWN0ZWQgZmxhZ3MgJHtmbGFncy50b1N0cmluZygxNil9YCxcbiAgICAgICAgICAgICB0aGlzLiNhcEJvZHkpO1xuICAgICAgICB0aGlzLnNldEFzc29jaWF0ZWRQYXRoKHNhaCwgJycsIDApO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbGVEaWdlc3QgPSBuZXcgVWludDMyQXJyYXkoSEVBREVSX0RJR0VTVF9TSVpFIC8gNCk7XG4gICAgICBzYWgucmVhZChmaWxlRGlnZXN0LCB7YXQ6IEhFQURFUl9PRkZTRVRfRElHRVNUfSk7XG4gICAgICBjb25zdCBjb21wRGlnZXN0ID0gdGhpcy5jb21wdXRlRGlnZXN0KHRoaXMuI2FwQm9keSk7XG4gICAgICBpZihmaWxlRGlnZXN0LmV2ZXJ5KCh2LGkpID0+IHY9PT1jb21wRGlnZXN0W2ldKSl7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYXRoQnl0ZXMgPSB0aGlzLiNhcEJvZHkuZmluZEluZGV4KCh2KT0+MD09PXYpO1xuICAgICAgICBpZigwPT09cGF0aEJ5dGVzKXtcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBzYWgudHJ1bmNhdGUoSEVBREVSX09GRlNFVF9EQVRBKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aEJ5dGVzXG4gICAgICAgICAgPyB0ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy4jYXBCb2R5LnN1YmFycmF5KDAscGF0aEJ5dGVzKSlcbiAgICAgICAgICA6ICcnO1xuICAgICAgfWVsc2V7XG4gICAgICAgIFxuICAgICAgICB3YXJuKCdEaXNhc3NvY2lhdGluZyBmaWxlIHdpdGggYmFkIGRpZ2VzdC4nKTtcbiAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIFxuICAgIHNldEFzc29jaWF0ZWRQYXRoKHNhaCwgcGF0aCwgZmxhZ3Mpe1xuICAgICAgY29uc3QgZW5jID0gdGV4dEVuY29kZXIuZW5jb2RlSW50byhwYXRoLCB0aGlzLiNhcEJvZHkpO1xuICAgICAgaWYoSEVBREVSX01BWF9QQVRIX1NJWkUgPD0gZW5jLndyaXR0ZW4gKyAxKXtcbiAgICAgICAgdG9zcyhcIlBhdGggdG9vIGxvbmc6XCIscGF0aCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNhcEJvZHkuZmlsbCgwLCBlbmMud3JpdHRlbiwgSEVBREVSX01BWF9QQVRIX1NJWkUpO1xuICAgICAgdGhpcy4jZHZCb2R5LnNldFVpbnQzMihIRUFERVJfT0ZGU0VUX0ZMQUdTLCBmbGFncyk7XG5cbiAgICAgIGNvbnN0IGRpZ2VzdCA9IHRoaXMuY29tcHV0ZURpZ2VzdCh0aGlzLiNhcEJvZHkpO1xuICAgICAgc2FoLndyaXRlKHRoaXMuI2FwQm9keSwge2F0OiAwfSk7XG4gICAgICBzYWgud3JpdGUoZGlnZXN0LCB7YXQ6IEhFQURFUl9PRkZTRVRfRElHRVNUfSk7XG4gICAgICBzYWguZmx1c2goKTtcblxuICAgICAgaWYocGF0aCl7XG4gICAgICAgIHRoaXMuI21hcEZpbGVuYW1lVG9TQUguc2V0KHBhdGgsIHNhaCk7XG4gICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5kZWxldGUoc2FoKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBcbiAgICAgICAgc2FoLnRydW5jYXRlKEhFQURFUl9PRkZTRVRfREFUQSk7XG4gICAgICAgIHRoaXMuI2F2YWlsYWJsZVNBSC5hZGQoc2FoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBcbiAgICBjb21wdXRlRGlnZXN0KGJ5dGVBcnJheSl7XG4gICAgICBsZXQgaDEgPSAweGRlYWRiZWVmO1xuICAgICAgbGV0IGgyID0gMHg0MWM2Y2U1NztcbiAgICAgIGZvcihjb25zdCB2IG9mIGJ5dGVBcnJheSl7XG4gICAgICAgIGgxID0gMzEgKiBoMSArICh2ICogMzA3KTtcbiAgICAgICAgaDIgPSAzMSAqIGgyICsgKHYgKiAzMDcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShbaDE+Pj4wLCBoMj4+PjBdKTtcbiAgICB9XG5cbiAgICBcbiAgICBhc3luYyByZXNldChjbGVhckZpbGVzKXtcbiAgICAgIGF3YWl0IHRoaXMuaXNSZWFkeTtcbiAgICAgIGxldCBoID0gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7XG4gICAgICBsZXQgcHJldiwgcHJldk5hbWU7XG4gICAgICBmb3IoY29uc3QgZCBvZiB0aGlzLnZmc0Rpci5zcGxpdCgnLycpKXtcbiAgICAgICAgaWYoZCl7XG4gICAgICAgICAgcHJldiA9IGg7XG4gICAgICAgICAgaCA9IGF3YWl0IGguZ2V0RGlyZWN0b3J5SGFuZGxlKGQse2NyZWF0ZTp0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI2RoVmZzUm9vdCA9IGg7XG4gICAgICB0aGlzLiNkaFZmc1BhcmVudCA9IHByZXY7XG4gICAgICB0aGlzLiNkaE9wYXF1ZSA9IGF3YWl0IHRoaXMuI2RoVmZzUm9vdC5nZXREaXJlY3RvcnlIYW5kbGUoXG4gICAgICAgIE9QQVFVRV9ESVJfTkFNRSx7Y3JlYXRlOnRydWV9XG4gICAgICApO1xuICAgICAgdGhpcy5yZWxlYXNlQWNjZXNzSGFuZGxlcygpO1xuICAgICAgcmV0dXJuIHRoaXMuYWNxdWlyZUFjY2Vzc0hhbmRsZXMoY2xlYXJGaWxlcyk7XG4gICAgfVxuXG4gICAgXG4gICAgZ2V0UGF0aChhcmcpIHtcbiAgICAgIGlmKHdhc20uaXNQdHIoYXJnKSkgYXJnID0gd2FzbS5jc3RyVG9KcyhhcmcpO1xuICAgICAgcmV0dXJuICgoYXJnIGluc3RhbmNlb2YgVVJMKVxuICAgICAgICAgICAgICA/IGFyZ1xuICAgICAgICAgICAgICA6IG5ldyBVUkwoYXJnLCAnZmlsZTovL2xvY2FsaG9zdC8nKSkucGF0aG5hbWU7XG4gICAgfVxuXG4gICAgXG4gICAgZGVsZXRlUGF0aChwYXRoKSB7XG4gICAgICBjb25zdCBzYWggPSB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChwYXRoKTtcbiAgICAgIGlmKHNhaCkge1xuICAgICAgICBcbiAgICAgICAgdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5kZWxldGUocGF0aCk7XG4gICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gISFzYWg7XG4gICAgfVxuXG4gICAgXG4gICAgc3RvcmVFcnIoZSxjb2RlKXtcbiAgICAgIGlmKGUpe1xuICAgICAgICBlLnNxbGl0ZTNSYyA9IGNvZGUgfHwgY2FwaS5TUUxJVEVfSU9FUlI7XG4gICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLiRlcnJvciA9IGU7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgXG4gICAgcG9wRXJyKCl7XG4gICAgICBjb25zdCByYyA9IHRoaXMuJGVycm9yO1xuICAgICAgdGhpcy4kZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfVxuXG4gICAgXG4gICAgbmV4dEF2YWlsYWJsZVNBSCgpe1xuICAgICAgY29uc3QgW3JjXSA9IHRoaXMuI2F2YWlsYWJsZVNBSC5rZXlzKCk7XG4gICAgICByZXR1cm4gcmM7XG4gICAgfVxuXG4gICAgXG4gICAgZ2V0T0ZpbGVGb3JTM0ZpbGUocEZpbGUpe1xuICAgICAgcmV0dXJuIHRoaXMuI21hcFMzRmlsZVRvT0ZpbGVfLmdldChwRmlsZSk7XG4gICAgfVxuICAgIFxuICAgIG1hcFMzRmlsZVRvT0ZpbGUocEZpbGUsZmlsZSl7XG4gICAgICBpZihmaWxlKXtcbiAgICAgICAgdGhpcy4jbWFwUzNGaWxlVG9PRmlsZV8uc2V0KHBGaWxlLCBmaWxlKTtcbiAgICAgICAgc2V0UG9vbEZvclBGaWxlKHBGaWxlLCB0aGlzKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLiNtYXBTM0ZpbGVUb09GaWxlXy5kZWxldGUocEZpbGUpO1xuICAgICAgICBzZXRQb29sRm9yUEZpbGUocEZpbGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBcbiAgICBoYXNGaWxlbmFtZShuYW1lKXtcbiAgICAgIHJldHVybiB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmhhcyhuYW1lKVxuICAgIH1cblxuICAgIFxuICAgIGdldFNBSEZvclBhdGgocGF0aCl7XG4gICAgICByZXR1cm4gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQocGF0aCk7XG4gICAgfVxuXG4gICAgXG4gICAgYXN5bmMgcmVtb3ZlVmZzKCl7XG4gICAgICBpZighdGhpcy4jY1Zmcy5wb2ludGVyIHx8ICF0aGlzLiNkaE9wYXF1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FwaS5zcWxpdGUzX3Zmc191bnJlZ2lzdGVyKHRoaXMuI2NWZnMucG9pbnRlcik7XG4gICAgICB0aGlzLiNjVmZzLmRpc3Bvc2UoKTtcbiAgICAgIHRyeXtcbiAgICAgICAgdGhpcy5yZWxlYXNlQWNjZXNzSGFuZGxlcygpO1xuICAgICAgICBhd2FpdCB0aGlzLiNkaFZmc1Jvb3QucmVtb3ZlRW50cnkoT1BBUVVFX0RJUl9OQU1FLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gICAgICAgIHRoaXMuI2RoT3BhcXVlID0gdW5kZWZpbmVkO1xuICAgICAgICBhd2FpdCB0aGlzLiNkaFZmc1BhcmVudC5yZW1vdmVFbnRyeShcbiAgICAgICAgICB0aGlzLiNkaFZmc1Jvb3QubmFtZSwge3JlY3Vyc2l2ZTogdHJ1ZX1cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy4jZGhWZnNSb290ID0gdGhpcy4jZGhWZnNQYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9Y2F0Y2goZSl7XG4gICAgICAgIHNxbGl0ZTMuY29uZmlnLmVycm9yKHRoaXMudmZzTmFtZSxcInJlbW92ZVZmcygpIGZhaWxlZDpcIixlKTtcbiAgICAgICAgXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIFxuICAgIGV4cG9ydEZpbGUobmFtZSl7XG4gICAgICBjb25zdCBzYWggPSB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKSB8fCB0b3NzKFwiRmlsZSBub3QgZm91bmQ6XCIsbmFtZSk7XG4gICAgICBjb25zdCBuID0gc2FoLmdldFNpemUoKSAtIEhFQURFUl9PRkZTRVRfREFUQTtcbiAgICAgIGNvbnN0IGIgPSBuZXcgVWludDhBcnJheShuPjAgPyBuIDogMCk7XG4gICAgICBpZihuPjApe1xuICAgICAgICBjb25zdCBuUmVhZCA9IHNhaC5yZWFkKGIsIHthdDogSEVBREVSX09GRlNFVF9EQVRBfSk7XG4gICAgICAgIGlmKG5SZWFkICE9IG4pe1xuICAgICAgICAgIHRvc3MoXCJFeHBlY3RlZCB0byByZWFkIFwiK24rXCIgYnl0ZXMgYnV0IHJlYWQgXCIrblJlYWQrXCIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG5cbiAgICBcbiAgICBhc3luYyBpbXBvcnREYkNodW5rZWQobmFtZSwgY2FsbGJhY2spe1xuICAgICAgY29uc3Qgc2FoID0gdGhpcy4jbWFwRmlsZW5hbWVUb1NBSC5nZXQobmFtZSlcbiAgICAgICAgICAgIHx8IHRoaXMubmV4dEF2YWlsYWJsZVNBSCgpXG4gICAgICAgICAgICB8fCB0b3NzKFwiTm8gYXZhaWxhYmxlIGhhbmRsZXMgdG8gaW1wb3J0IHRvLlwiKTtcbiAgICAgIHNhaC50cnVuY2F0ZSgwKTtcbiAgICAgIGxldCBuV3JvdGUgPSAwLCBjaHVuaywgY2hlY2tlZEhlYWRlciA9IGZhbHNlLCBlcnIgPSBmYWxzZTtcbiAgICAgIHRyeXtcbiAgICAgICAgd2hpbGUoIHVuZGVmaW5lZCAhPT0gKGNodW5rID0gYXdhaXQgY2FsbGJhY2soKSkgKXtcbiAgICAgICAgICBpZihjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBjaHVuayA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICBpZiggMD09PW5Xcm90ZSAmJiBjaHVuay5ieXRlTGVuZ3RoPj0xNSApe1xuICAgICAgICAgICAgdXRpbC5hZmZpcm1EYkhlYWRlcihjaHVuayk7XG4gICAgICAgICAgICBjaGVja2VkSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2FoLndyaXRlKGNodW5rLCB7YXQ6ICBIRUFERVJfT0ZGU0VUX0RBVEEgKyBuV3JvdGV9KTtcbiAgICAgICAgICBuV3JvdGUgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiggbldyb3RlIDwgNTEyIHx8IDAhPT1uV3JvdGUgJSA1MTIgKXtcbiAgICAgICAgICB0b3NzKFwiSW5wdXQgc2l6ZVwiLG5Xcm90ZSxcImlzIG5vdCBjb3JyZWN0IGZvciBhbiBTUUxpdGUgZGF0YWJhc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCAhY2hlY2tlZEhlYWRlciApe1xuICAgICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50OEFycmF5KDIwKTtcbiAgICAgICAgICBzYWgucmVhZCggaGVhZGVyLCB7YXQ6IDB9ICk7XG4gICAgICAgICAgdXRpbC5hZmZpcm1EYkhlYWRlciggaGVhZGVyICk7XG4gICAgICAgIH1cbiAgICAgICAgc2FoLndyaXRlKG5ldyBVaW50OEFycmF5KFsxLDFdKSwge1xuICAgICAgICAgIGF0OiBIRUFERVJfT0ZGU0VUX0RBVEEgKyAxOFxuICAgICAgICB9KTtcbiAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgdGhpcy5zZXRBc3NvY2lhdGVkUGF0aChzYWgsICcnLCAwKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBuYW1lLCBjYXBpLlNRTElURV9PUEVOX01BSU5fREIpO1xuICAgICAgcmV0dXJuIG5Xcm90ZTtcbiAgICB9XG5cbiAgICBcbiAgICBpbXBvcnREYihuYW1lLCBieXRlcyl7XG4gICAgICBpZiggYnl0ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgZWxzZSBpZiggYnl0ZXMgaW5zdGFuY2VvZiBGdW5jdGlvbiApIHJldHVybiB0aGlzLmltcG9ydERiQ2h1bmtlZChuYW1lLCBieXRlcyk7XG4gICAgICBjb25zdCBzYWggPSB0aGlzLiNtYXBGaWxlbmFtZVRvU0FILmdldChuYW1lKVxuICAgICAgICAgICAgfHwgdGhpcy5uZXh0QXZhaWxhYmxlU0FIKClcbiAgICAgICAgICAgIHx8IHRvc3MoXCJObyBhdmFpbGFibGUgaGFuZGxlcyB0byBpbXBvcnQgdG8uXCIpO1xuICAgICAgY29uc3QgbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICBpZihuPDUxMiB8fCBuJTUxMiE9MCl7XG4gICAgICAgIHRvc3MoXCJCeXRlIGFycmF5IHNpemUgaXMgaW52YWxpZCBmb3IgYW4gU1FMaXRlIGRiLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlYWRlciA9IFwiU1FMaXRlIGZvcm1hdCAzXCI7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgaWYoIGhlYWRlci5jaGFyQ29kZUF0KGkpICE9PSBieXRlc1tpXSApe1xuICAgICAgICAgIHRvc3MoXCJJbnB1dCBkb2VzIG5vdCBjb250YWluIGFuIFNRTGl0ZSBkYXRhYmFzZSBoZWFkZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuV3JvdGUgPSBzYWgud3JpdGUoYnl0ZXMsIHthdDogSEVBREVSX09GRlNFVF9EQVRBfSk7XG4gICAgICBpZihuV3JvdGUgIT0gbil7XG4gICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCAnJywgMCk7XG4gICAgICAgIHRvc3MoXCJFeHBlY3RlZCB0byB3cml0ZSBcIituK1wiIGJ5dGVzIGJ1dCB3cm90ZSBcIituV3JvdGUrXCIuXCIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHNhaC53cml0ZShuZXcgVWludDhBcnJheShbMSwxXSksIHthdDogSEVBREVSX09GRlNFVF9EQVRBKzE4fVxuICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHRoaXMuc2V0QXNzb2NpYXRlZFBhdGgoc2FoLCBuYW1lLCBjYXBpLlNRTElURV9PUEVOX01BSU5fREIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5Xcm90ZTtcbiAgICB9XG5cbiAgfTtcblxuXG4gIFxuICBjbGFzcyBPcGZzU0FIUG9vbFV0aWwge1xuICAgIFxuICAgICNwO1xuXG4gICAgY29uc3RydWN0b3Ioc2FoUG9vbCl7XG4gICAgICB0aGlzLiNwID0gc2FoUG9vbDtcbiAgICAgIHRoaXMudmZzTmFtZSA9IHNhaFBvb2wudmZzTmFtZTtcbiAgICB9XG5cbiAgICBhc3luYyBhZGRDYXBhY2l0eShuKXsgcmV0dXJuIHRoaXMuI3AuYWRkQ2FwYWNpdHkobikgfVxuXG4gICAgYXN5bmMgcmVkdWNlQ2FwYWNpdHkobil7IHJldHVybiB0aGlzLiNwLnJlZHVjZUNhcGFjaXR5KG4pIH1cblxuICAgIGdldENhcGFjaXR5KCl7IHJldHVybiB0aGlzLiNwLmdldENhcGFjaXR5KHRoaXMuI3ApIH1cblxuICAgIGdldEZpbGVDb3VudCgpeyByZXR1cm4gdGhpcy4jcC5nZXRGaWxlQ291bnQoKSB9XG4gICAgZ2V0RmlsZU5hbWVzKCl7IHJldHVybiB0aGlzLiNwLmdldEZpbGVOYW1lcygpIH1cblxuICAgIGFzeW5jIHJlc2VydmVNaW5pbXVtQ2FwYWNpdHkobWluKXtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLiNwLmdldENhcGFjaXR5KCk7XG4gICAgICByZXR1cm4gKGMgPCBtaW4pID8gdGhpcy4jcC5hZGRDYXBhY2l0eShtaW4gLSBjKSA6IGM7XG4gICAgfVxuXG4gICAgZXhwb3J0RmlsZShuYW1lKXsgcmV0dXJuIHRoaXMuI3AuZXhwb3J0RmlsZShuYW1lKSB9XG5cbiAgICBpbXBvcnREYihuYW1lLCBieXRlcyl7IHJldHVybiB0aGlzLiNwLmltcG9ydERiKG5hbWUsYnl0ZXMpIH1cblxuICAgIGFzeW5jIHdpcGVGaWxlcygpeyByZXR1cm4gdGhpcy4jcC5yZXNldCh0cnVlKSB9XG5cbiAgICB1bmxpbmsoZmlsZW5hbWUpeyByZXR1cm4gdGhpcy4jcC5kZWxldGVQYXRoKGZpbGVuYW1lKSB9XG5cbiAgICBhc3luYyByZW1vdmVWZnMoKXsgcmV0dXJuIHRoaXMuI3AucmVtb3ZlVmZzKCkgfVxuXG4gIH07XG5cbiAgXG4gIGNvbnN0IGFwaVZlcnNpb25DaGVjayA9IGFzeW5jICgpPT57XG4gICAgY29uc3QgZGggPSBhd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtcbiAgICBjb25zdCBmbiA9ICcub3Bmcy1zYWhwb29sLXN5bmMtY2hlY2stJytnZXRSYW5kb21OYW1lKCk7XG4gICAgY29uc3QgZmggPSBhd2FpdCBkaC5nZXRGaWxlSGFuZGxlKGZuLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBhaCA9IGF3YWl0IGZoLmNyZWF0ZVN5bmNBY2Nlc3NIYW5kbGUoKTtcbiAgICBjb25zdCBjbG9zZSA9IGFoLmNsb3NlKCk7XG4gICAgYXdhaXQgY2xvc2U7XG4gICAgYXdhaXQgZGgucmVtb3ZlRW50cnkoZm4pO1xuICAgIGlmKGNsb3NlPy50aGVuKXtcbiAgICAgIHRvc3MoXCJUaGUgbG9jYWwgT1BGUyBBUEkgaXMgdG9vIG9sZCBmb3Igb3Bmcy1zYWhwb29sOlwiLFxuICAgICAgICAgICBcIml0IGhhcyBhbiBhc3luYyBGaWxlU3lzdGVtU3luY0FjY2Vzc0hhbmRsZS5jbG9zZSgpIG1ldGhvZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFxuICBsZXQgaW5zdGFuY2VDb3VudGVyID0gMDtcblxuICBcbiAgc3FsaXRlMy5pbnN0YWxsT3Bmc1NBSFBvb2xWZnMgPSBhc3luYyBmdW5jdGlvbihvcHRpb25zPU9iamVjdC5jcmVhdGUobnVsbCkpe1xuICAgIGNvbnN0IHZmc05hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9uRGVmYXVsdHMubmFtZTtcbiAgICBpZigwICYmIDI9PT0rK2luc3RhbmNlQ291bnRlcil7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKdXN0IHRlc3RpbmcgcmVqZWN0aW9uLlwiKTtcbiAgICB9XG4gICAgaWYoaW5pdFByb21pc2VzW3Zmc05hbWVdKXtcbiAgICAgIFxuICAgICAgcmV0dXJuIGluaXRQcm9taXNlc1t2ZnNOYW1lXTtcbiAgICB9XG4gICAgaWYoIWdsb2JhbFRoaXMuRmlsZVN5c3RlbUhhbmRsZSB8fFxuICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUgfHxcbiAgICAgICAhZ2xvYmFsVGhpcy5GaWxlU3lzdGVtRmlsZUhhbmRsZSB8fFxuICAgICAgICFnbG9iYWxUaGlzLkZpbGVTeXN0ZW1GaWxlSGFuZGxlLnByb3RvdHlwZS5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlIHx8XG4gICAgICAgIW5hdmlnYXRvcj8uc3RvcmFnZT8uZ2V0RGlyZWN0b3J5KXtcbiAgICAgIHJldHVybiAoaW5pdFByb21pc2VzW3Zmc05hbWVdID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBPUEZTIEFQSXMuXCIpKSk7XG4gICAgfVxuXG4gICAgXG4gICAgcmV0dXJuIGluaXRQcm9taXNlc1t2ZnNOYW1lXSA9IGFwaVZlcnNpb25DaGVjaygpLnRoZW4oYXN5bmMgZnVuY3Rpb24oKXtcbiAgICAgIGlmKG9wdGlvbnMuJHRlc3RUaHJvd0luSW5pdCl7XG4gICAgICAgIHRocm93IG9wdGlvbnMuJHRlc3RUaHJvd0luSW5pdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRoZVBvb2wgPSBuZXcgT3Bmc1NBSFBvb2wob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhlUG9vbC5pc1JlYWR5LnRoZW4oYXN5bmMoKT0+e1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcG9vbFV0aWwgPSBuZXcgT3Bmc1NBSFBvb2xVdGlsKHRoZVBvb2wpO1xuICAgICAgICBpZihzcWxpdGUzLm9vMSl7XG4gICAgICAgICAgY29uc3Qgb28xID0gc3FsaXRlMy5vbzE7XG4gICAgICAgICAgY29uc3QgdGhlVmZzID0gdGhlUG9vbC5nZXRWZnMoKTtcbiAgICAgICAgICBjb25zdCBPcGZzU0FIUG9vbERiID0gZnVuY3Rpb24oLi4uYXJncyl7XG4gICAgICAgICAgICBjb25zdCBvcHQgPSBvbzEuREIuZGJDdG9ySGVscGVyLm5vcm1hbGl6ZUFyZ3MoLi4uYXJncyk7XG4gICAgICAgICAgICBvcHQudmZzID0gdGhlVmZzLiR6TmFtZTtcbiAgICAgICAgICAgIG9vMS5EQi5kYkN0b3JIZWxwZXIuY2FsbCh0aGlzLCBvcHQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgT3Bmc1NBSFBvb2xEYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG9vMS5EQi5wcm90b3R5cGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIHBvb2xVdGlsLk9wZnNTQUhQb29sRGIgPSBPcGZzU0FIUG9vbERiO1xuICAgICAgICAgIG9vMS5EQi5kYkN0b3JIZWxwZXIuc2V0VmZzUG9zdE9wZW5TcWwoXG4gICAgICAgICAgICB0aGVWZnMucG9pbnRlcixcbiAgICAgICAgICAgIGZ1bmN0aW9uKG9vMURiLCBzcWxpdGUzKXtcbiAgICAgICAgICAgICAgc3FsaXRlMy5jYXBpLnNxbGl0ZTNfZXhlYyhvbzFEYiwgW1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFwicHJhZ21hIGpvdXJuYWxfbW9kZT1ERUxFVEU7XCIsXG4gICAgICAgICAgICAgICAgXCJwcmFnbWEgY2FjaGVfc2l6ZT0tMTYzODQ7XCJcbiAgICAgICAgICAgICAgXSwgMCwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVQb29sLmxvZyhcIlZGUyBpbml0aWFsaXplZC5cIik7XG4gICAgICAgIHJldHVybiBwb29sVXRpbDtcbiAgICAgIH0pLmNhdGNoKGFzeW5jIChlKT0+e1xuICAgICAgICBhd2FpdCB0aGVQb29sLnJlbW92ZVZmcygpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgIFxuICAgICAgcmV0dXJuIGluaXRQcm9taXNlc1t2ZnNOYW1lXSA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfSk7XG4gIH07XG59KTtcblxuXG5cbid1c2Ugc3RyaWN0JztcbmlmKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgTW9kdWxlKXsgXG4gIFxuICBjb25zdCBTQUJDID0gT2JqZWN0LmFzc2lnbihcbiAgICBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgICBleHBvcnRzOiAoJ3VuZGVmaW5lZCc9PT10eXBlb2Ygd2FzbUV4cG9ydHMpXG4gICAgICAgID8gTW9kdWxlWydhc20nXVxuICAgICAgICA6IHdhc21FeHBvcnRzICAsXG4gICAgICBtZW1vcnk6IE1vZHVsZS53YXNtTWVtb3J5IFxuICAgIH0sXG4gICAgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQ29uZmlnIHx8IHt9XG4gICk7XG5cbiAgXG4gIFxuICBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlDb25maWcgPSBTQUJDO1xuICBsZXQgc3FsaXRlMztcbiAgdHJ5e1xuICAgIHNxbGl0ZTMgPSBnbG9iYWxUaGlzLnNxbGl0ZTNBcGlCb290c3RyYXAoKTtcbiAgfWNhdGNoKGUpe1xuICAgIGNvbnNvbGUuZXJyb3IoXCJzcWxpdGUzQXBpQm9vdHN0cmFwKCkgZXJyb3I6XCIsZSk7XG4gICAgdGhyb3cgZTtcbiAgfWZpbmFsbHl7XG4gICAgZGVsZXRlIGdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcDtcbiAgICBkZWxldGUgZ2xvYmFsVGhpcy5zcWxpdGUzQXBpQ29uZmlnO1xuICB9XG5cbiAgTW9kdWxlLnNxbGl0ZTMgPSBzcWxpdGUzIDtcbn1lbHNle1xuICBjb25zb2xlLndhcm4oXCJUaGlzIGlzIG5vdCBydW5uaW5nIGluIGFuIEVtc2NyaXB0ZW4gbW9kdWxlIGNvbnRleHQsIHNvXCIsXG4gICAgICAgICAgICAgICBcImdsb2JhbFRoaXMuc3FsaXRlM0FwaUJvb3RzdHJhcCgpIGlzIF9ub3RfIGJlaW5nIGNhbGxlZCBkdWUgdG8gbGFja1wiLFxuICAgICAgICAgICAgICAgXCJvZiBjb25maWcgaW5mbyBmb3IgdGhlIFdBU00gZW52aXJvbm1lbnQuXCIsXG4gICAgICAgICAgICAgICBcIkl0IG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5LlwiKTtcbn1cblxuXG5cblxufSk7XG5cblxuXG4gIHJldHVybiBzcWxpdGUzSW5pdE1vZHVsZS5yZWFkeVxufVxuKTtcbn0pKCk7XG5pZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICBtb2R1bGUuZXhwb3J0cyA9IHNxbGl0ZTNJbml0TW9kdWxlO1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKVxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gc3FsaXRlM0luaXRNb2R1bGU7IH0pO1xuZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuICBleHBvcnRzW1wic3FsaXRlM0luaXRNb2R1bGVcIl0gPSBzcWxpdGUzSW5pdE1vZHVsZTtcblxuXG5cbihmdW5jdGlvbigpe1xuICBcbiAgY29uc3Qgb3JpZ2luYWxJbml0ID0gc3FsaXRlM0luaXRNb2R1bGU7XG4gIGlmKCFvcmlnaW5hbEluaXQpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlIHRvIGJlIGRlZmluZWQgYnkgdGhlIEVtc2NyaXB0ZW4gYnVpbGQuXCIpO1xuICB9XG4gIFxuICBjb25zdCBpbml0TW9kdWxlU3RhdGUgPSBnbG9iYWxUaGlzLnNxbGl0ZTNJbml0TW9kdWxlU3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCkse1xuICAgIG1vZHVsZVNjcmlwdDogZ2xvYmFsVGhpcz8uZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQsXG4gICAgaXNXb3JrZXI6ICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlKSxcbiAgICBsb2NhdGlvbjogZ2xvYmFsVGhpcy5sb2NhdGlvbixcbiAgICB1cmxQYXJhbXM6ICBnbG9iYWxUaGlzPy5sb2NhdGlvbj8uaHJlZlxuICAgICAgPyBuZXcgVVJMKGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZikuc2VhcmNoUGFyYW1zXG4gICAgICA6IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICB9KTtcbiAgaW5pdE1vZHVsZVN0YXRlLmRlYnVnTW9kdWxlID1cbiAgICBpbml0TW9kdWxlU3RhdGUudXJsUGFyYW1zLmhhcygnc3FsaXRlMy5kZWJ1Z01vZHVsZScpXG4gICAgPyAoLi4uYXJncyk9PmNvbnNvbGUud2Fybignc3FsaXRlMy5kZWJ1Z01vZHVsZTonLC4uLmFyZ3MpXG4gICAgOiAoKT0+e307XG5cbiAgaWYoaW5pdE1vZHVsZVN0YXRlLnVybFBhcmFtcy5oYXMoJ3NxbGl0ZTMuZGlyJykpe1xuICAgIGluaXRNb2R1bGVTdGF0ZS5zcWxpdGUzRGlyID0gaW5pdE1vZHVsZVN0YXRlLnVybFBhcmFtcy5nZXQoJ3NxbGl0ZTMuZGlyJykgKycvJztcbiAgfWVsc2UgaWYoaW5pdE1vZHVsZVN0YXRlLm1vZHVsZVNjcmlwdCl7XG4gICAgY29uc3QgbGkgPSBpbml0TW9kdWxlU3RhdGUubW9kdWxlU2NyaXB0LnNyYy5zcGxpdCgnLycpO1xuICAgIGxpLnBvcCgpO1xuICAgIGluaXRNb2R1bGVTdGF0ZS5zcWxpdGUzRGlyID0gbGkuam9pbignLycpICsgJy8nO1xuICB9XG5cbiAgZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZSA9IGZ1bmN0aW9uIGZmKC4uLmFyZ3Mpe1xuICAgIFxuICAgIHJldHVybiBvcmlnaW5hbEluaXQoLi4uYXJncykudGhlbigoRW1zY3JpcHRlbk1vZHVsZSk9PntcbiAgICAgIFxuICAgICAgY29uc3QgcyA9IEVtc2NyaXB0ZW5Nb2R1bGUuc3FsaXRlMztcbiAgICAgIHMuc2NyaXB0SW5mbyA9IGluaXRNb2R1bGVTdGF0ZTtcbiAgICAgIFxuICAgICAgaWYoZmYuX19pc1VuZGVyVGVzdCkgcy5fX2lzVW5kZXJUZXN0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGYgPSBzLmFzeW5jUG9zdEluaXQ7XG4gICAgICBkZWxldGUgcy5hc3luY1Bvc3RJbml0O1xuICAgICAgcmV0dXJuIGYoKTtcbiAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFeGNlcHRpb24gbG9hZGluZyBzcWxpdGUzIG1vZHVsZTpcIixlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH07XG4gIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGUucmVhZHkgPSBvcmlnaW5hbEluaXQucmVhZHk7XG5cbiAgaWYoZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlLm1vZHVsZVNjcmlwdCl7XG4gICAgY29uc3Qgc2ltID0gZ2xvYmFsVGhpcy5zcWxpdGUzSW5pdE1vZHVsZVN0YXRlO1xuICAgIGxldCBzcmMgPSBzaW0ubW9kdWxlU2NyaXB0LnNyYy5zcGxpdCgnLycpO1xuICAgIHNyYy5wb3AoKTtcbiAgICBzaW0uc2NyaXB0RGlyID0gc3JjLmpvaW4oJy8nKSArICcvJztcbiAgfVxuICBpbml0TW9kdWxlU3RhdGUuZGVidWdNb2R1bGUoJ3NxbGl0ZTNJbml0TW9kdWxlU3RhdGUgPScsaW5pdE1vZHVsZVN0YXRlKTtcbiAgaWYoMCl7XG4gICAgY29uc29sZS53YXJuKFwiUmVwbGFjZWQgc3FsaXRlM0luaXRNb2R1bGUoKVwiKTtcbiAgICBjb25zb2xlLndhcm4oXCJnbG9iYWxUaGlzLmxvY2F0aW9uLmhyZWYgPVwiLGdsb2JhbFRoaXMubG9jYXRpb24uaHJlZik7XG4gICAgaWYoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBkb2N1bWVudCl7XG4gICAgICBjb25zb2xlLndhcm4oXCJkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA9XCIsXG4gICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQ/LnNyYyk7XG4gICAgfVxuICB9XG5cblxuXG4gIFxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNxbGl0ZTNJbml0TW9kdWxlO1xuICB9ZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKXtcbiAgICBleHBvcnRzW1wic3FsaXRlM0luaXRNb2R1bGVcIl0gPSBzcWxpdGUzSW5pdE1vZHVsZTtcbiAgfVxuICBcbiAgcmV0dXJuIGdsb2JhbFRoaXMuc3FsaXRlM0luaXRNb2R1bGUgO1xufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9odHRwc19yYXdfZ2l0aGFja19jb21fZGVuaXNfbWlnZGFsX0xJU1NfbWFpbl9pbmRleF9qc19iYjZhM2NhZV9fOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJ2YXIgd2VicGFja1F1ZXVlcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbChcIndlYnBhY2sgcXVldWVzXCIpIDogXCJfX3dlYnBhY2tfcXVldWVzX19cIjtcbnZhciB3ZWJwYWNrRXhwb3J0cyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbChcIndlYnBhY2sgZXhwb3J0c1wiKSA6IFwiX193ZWJwYWNrX2V4cG9ydHNfX1wiO1xudmFyIHdlYnBhY2tFcnJvciA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbChcIndlYnBhY2sgZXJyb3JcIikgOiBcIl9fd2VicGFja19lcnJvcl9fXCI7XG52YXIgcmVzb2x2ZVF1ZXVlID0gKHF1ZXVlKSA9PiB7XG5cdGlmKHF1ZXVlICYmIHF1ZXVlLmQgPCAxKSB7XG5cdFx0cXVldWUuZCA9IDE7XG5cdFx0cXVldWUuZm9yRWFjaCgoZm4pID0+IChmbi5yLS0pKTtcblx0XHRxdWV1ZS5mb3JFYWNoKChmbikgPT4gKGZuLnItLSA/IGZuLnIrKyA6IGZuKCkpKTtcblx0fVxufVxudmFyIHdyYXBEZXBzID0gKGRlcHMpID0+IChkZXBzLm1hcCgoZGVwKSA9PiB7XG5cdGlmKGRlcCAhPT0gbnVsbCAmJiB0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKSB7XG5cdFx0aWYoZGVwW3dlYnBhY2tRdWV1ZXNdKSByZXR1cm4gZGVwO1xuXHRcdGlmKGRlcC50aGVuKSB7XG5cdFx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHRcdHF1ZXVlLmQgPSAwO1xuXHRcdFx0ZGVwLnRoZW4oKHIpID0+IHtcblx0XHRcdFx0b2JqW3dlYnBhY2tFeHBvcnRzXSA9IHI7XG5cdFx0XHRcdHJlc29sdmVRdWV1ZShxdWV1ZSk7XG5cdFx0XHR9LCAoZSkgPT4ge1xuXHRcdFx0XHRvYmpbd2VicGFja0Vycm9yXSA9IGU7XG5cdFx0XHRcdHJlc29sdmVRdWV1ZShxdWV1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHZhciBvYmogPSB7fTtcblx0XHRcdG9ialt3ZWJwYWNrUXVldWVzXSA9IChmbikgPT4gKGZuKHF1ZXVlKSk7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH1cblx0fVxuXHR2YXIgcmV0ID0ge307XG5cdHJldFt3ZWJwYWNrUXVldWVzXSA9IHggPT4ge307XG5cdHJldFt3ZWJwYWNrRXhwb3J0c10gPSBkZXA7XG5cdHJldHVybiByZXQ7XG59KSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmEgPSAobW9kdWxlLCBib2R5LCBoYXNBd2FpdCkgPT4ge1xuXHR2YXIgcXVldWU7XG5cdGhhc0F3YWl0ICYmICgocXVldWUgPSBbXSkuZCA9IC0xKTtcblx0dmFyIGRlcFF1ZXVlcyA9IG5ldyBTZXQoKTtcblx0dmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cztcblx0dmFyIGN1cnJlbnREZXBzO1xuXHR2YXIgb3V0ZXJSZXNvbHZlO1xuXHR2YXIgcmVqZWN0O1xuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWopID0+IHtcblx0XHRyZWplY3QgPSByZWo7XG5cdFx0b3V0ZXJSZXNvbHZlID0gcmVzb2x2ZTtcblx0fSk7XG5cdHByb21pc2Vbd2VicGFja0V4cG9ydHNdID0gZXhwb3J0cztcblx0cHJvbWlzZVt3ZWJwYWNrUXVldWVzXSA9IChmbikgPT4gKHF1ZXVlICYmIGZuKHF1ZXVlKSwgZGVwUXVldWVzLmZvckVhY2goZm4pLCBwcm9taXNlW1wiY2F0Y2hcIl0oeCA9PiB7fSkpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IHByb21pc2U7XG5cdGJvZHkoKGRlcHMpID0+IHtcblx0XHRjdXJyZW50RGVwcyA9IHdyYXBEZXBzKGRlcHMpO1xuXHRcdHZhciBmbjtcblx0XHR2YXIgZ2V0UmVzdWx0ID0gKCkgPT4gKGN1cnJlbnREZXBzLm1hcCgoZCkgPT4ge1xuXHRcdFx0aWYoZFt3ZWJwYWNrRXJyb3JdKSB0aHJvdyBkW3dlYnBhY2tFcnJvcl07XG5cdFx0XHRyZXR1cm4gZFt3ZWJwYWNrRXhwb3J0c107XG5cdFx0fSkpXG5cdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0Zm4gPSAoKSA9PiAocmVzb2x2ZShnZXRSZXN1bHQpKTtcblx0XHRcdGZuLnIgPSAwO1xuXHRcdFx0dmFyIGZuUXVldWUgPSAocSkgPT4gKHEgIT09IHF1ZXVlICYmICFkZXBRdWV1ZXMuaGFzKHEpICYmIChkZXBRdWV1ZXMuYWRkKHEpLCBxICYmICFxLmQgJiYgKGZuLnIrKywgcS5wdXNoKGZuKSkpKTtcblx0XHRcdGN1cnJlbnREZXBzLm1hcCgoZGVwKSA9PiAoZGVwW3dlYnBhY2tRdWV1ZXNdKGZuUXVldWUpKSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGZuLnIgPyBwcm9taXNlIDogZ2V0UmVzdWx0KCk7XG5cdH0sIChlcnIpID0+ICgoZXJyID8gcmVqZWN0KHByb21pc2Vbd2VicGFja0Vycm9yXSA9IGVycikgOiBvdXRlclJlc29sdmUoZXhwb3J0cykpLCByZXNvbHZlUXVldWUocXVldWUpKSk7XG5cdHF1ZXVlICYmIHF1ZXVlLmQgPCAwICYmIChxdWV1ZS5kID0gMCk7XG59OyIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdtb2R1bGUnIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9wYWdlcy9SMS0wMi9DTS9pbmRleC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9wYWdlcy9SMS0wMi9DTS9pbmRleC5jc3NcIik7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9wYWdlcy9SMS0wMi9DTS9pbmRleC5tZFwiKTtcbiIsIiJdLCJuYW1lcyI6WyJTaGFkb3dDZmciLCJfX2NzdHJfaG9zdCIsIkNBTl9IQVZFX1NIQURPVyIsIl9jYW5IYXNTaGFkb3ciLCJ0YWciLCJpbmNsdWRlcyIsIl9lbGVtZW50MnRhZ25hbWUiLCJMSVNTIiwiZXh0ZW5kcyIsInBfZXh0ZW5kcyIsImhvc3QiLCJwX2hvc3QiLCJkZXBlbmRlbmNpZXMiLCJwX2RlcHMiLCJhdHRyaWJ1dGVzIiwicF9hdHRycyIsInBhcmFtcyIsImNvbnRlbnQiLCJjc3MiLCJzaGFkb3ciLCJwX3NoYWRvdyIsIkhUTUxFbGVtZW50IiwiX2V4dGVuZHMiLCJPYmplY3QiLCJjYW5IYXNTaGFkb3ciLCJFcnJvciIsInVuZGVmaW5lZCIsInB1c2giLCJIVE1MVGVtcGxhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwidHJpbSIsIlJlc3BvbnNlIiwidGV4dCIsIkxJU1NCYXNlIiwiUGFyYW1ldGVycyIsInN0eWxlc2hlZXRzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZmV0Y2hfY3NzIiwiQ1NTU3R5bGVTaGVldCIsIkhUTUxTdHlsZUVsZW1lbnQiLCJzaGVldCIsInN0eWxlIiwicmVwbGFjZSIsIm1hcCIsImlkeCIsImNvbnN0cnVjdG9yIiwiYXR0cnMiLCJzZXRBdHRyRGVmYXVsdCIsImF0dHIiLCJ2YWx1ZSIsInNldFBhcmFtIiwibmFtZSIsIm9uQXR0ckNoYW5nZWQiLCJfbmFtZSIsIl9vbGRWYWx1ZSIsIl9uZXdWYWx1ZSIsImlzSW5ET00iLCJvbkRPTUNvbm5lY3RlZCIsIm9uRE9NRGlzY29ubmVjdGVkIiwiZXh0ZW5kc0xJU1MiLCJMaXNzIiwicGFyYW1ldGVycyIsImFzc2lnbiIsIkV4dGVuZGVkTElTUyIsInQiLCJpZCIsImJ1aWxkTElTU0hvc3QiLCJfcGFyYW1zIiwiYWxyZWFkeURlY2xhcmVkQ1NTIiwiU2V0IiwiR0VUIiwiU3ltYm9sIiwiU0VUIiwicHJvcGVydGllcyIsImZyb21FbnRyaWVzIiwibiIsImVudW1lcmFibGUiLCJnZXQiLCJzZXQiLCJBdHRyaWJ1dGVzIiwiZGF0YSIsImRlZmF1bHRzIiwic2V0dGVyIiwiZGVmaW5lUHJvcGVydGllcyIsIkxJU1NIb3N0QmFzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaXNJbml0IiwiaW5pdGlhbGl6ZSIsImFwaSIsImluaXQiLCJMSVNTU3luYyIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJjdXN0b21FbGVtZW50cyIsInVwZ3JhZGUiLCJhdHRhY2hTaGFkb3ciLCJtb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uQ2xpY2tFdmVudCIsIm9icyIsImdldEF0dHJpYnV0ZSIsImFkb3B0ZWRTdHlsZVNoZWV0cyIsInNoYXJlZENTUyIsImNzc3NlbGVjdG9yIiwiQ1NTU2VsZWN0b3IiLCJoYXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJodG1sX3N0eWxlc2hlZXRzIiwicnVsZSIsImNzc1J1bGVzIiwiY3NzVGV4dCIsImhlYWQiLCJhcHBlbmQiLCJhZGQiLCJ0ZW1wbGF0ZV9lbGVtIiwic3RyIiwiXyIsIm1hdGNoIiwiY2hpbGROb2RlcyIsIm9iaiIsImhhc1NoYWRvdyIsImdldFBhcnQiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0UGFydHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaGFzQXR0cmlidXRlIiwidGFnTmFtZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9ic2VydmVkQXR0cmlidXRlcyIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJfRE9NQ29udGVudExvYWRlZCIsInJlYWR5U3RhdGUiLCJkZWZpbmUiLCJ0YWduYW1lIiwiQ29tcG9uZW50Q2xhc3MiLCJDbGFzcyIsImh0bWx0YWciLCJhbGwiLCJMSVNTY2xhc3MiLCJvcHRzIiwiaW5zZXJ0R2xvYmFsQ1NTUnVsZXMiLCJjc3Nfc3R5bGUiLCJyZXBsYWNlU3luYyIsImluc2VydFJ1bGUiLCJERUxFR0FURURfRVZFTlRTIiwiQUxSRUFEWV9QUk9DRVNTRUQiLCJldiIsImhhbmRsZXJzIiwidHlwZSIsImVsZW0iLCJjb21wb3NlZFBhdGgiLCJTaGFkb3dSb290Iiwid2luZG93IiwidGFyZ2V0Iiwic2VsZWN0b3IiLCJoYW5kbGVyIiwibWF0Y2hlcyIsImluc2VydEdsb2JhbERlbGVnYXRlZExpc3RlbmVyIiwiZXZlbnRfbmFtZSIsImNsb3Nlc3QiLCJlbGVtZW50IiwicmVzdWx0Iiwicm9vdCIsImdldFJvb3ROb2RlIiwiYnVpbGQiLCJwYXJlbnQiLCJjbGFzc2VzIiwiY3NzdmFycyIsImxpc3RlbmVycyIsIkN1c3RvbUNsYXNzIiwid2hlbkRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsImNsYXNzTGlzdCIsInNldFByb3BlcnR5IiwidG9nZ2xlQXR0cmlidXRlIiwiZGF0YXNldCIsInJlcGxhY2VDaGlsZHJlbiIsImdldExJU1MiLCJidWlsZFN5bmMiLCJpbml0aWFsaXplU3luYyIsImdldExJU1NTeW5jIiwiY2FsbGJhY2siLCJ3aGVuQWxsRGVmaW5lZCIsInRhZ25hbWVzIiwiaXNEZWZpbmVkIiwiZ2V0TmFtZSIsIl9idWlsZFFTIiwidGFnbmFtZV9vcl9wYXJlbnQiLCJxcyIsInFzbyIsInFzYSIsImVsZW1lbnRzIiwicHJvbWlzZXMiLCJxc2MiLCJyZXMiLCJxc1N5bmMiLCJxc2FTeW5jIiwicXNjU3luYyIsIkxJU1NfQXV0byIsIm5hdmlnYXRvciIsInNlcnZpY2VXb3JrZXIiLCJyZWdpc3RlciIsImNvbnRyb2xsZXIiLCJzcmMiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsIm11dGF0aW9uIiwiYWRkaXRpb24iLCJhZGRlZE5vZGVzIiwiRWxlbWVudCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwicmVzb3VyY2VzIiwiZGVmaW5lV2ViQ29tcG9uZW50IiwiZmlsZXMiLCJqcyIsImtsYXNzIiwiV2ViQ29tcG9uZW50IiwiZmlsZW5hbWVzIiwiZmlsZSIsImVuZHNXaXRoIiwiX2ltcG9ydCIsIl9mZXRjaFRleHQiLCJpIiwiQ3N0bUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJhcmdzIiwiZGV0YWlsIiwiZmV0Y2hSZXNvdXJjZSIsInJlc291cmNlIiwiZmV0Y2giLCJ1cmkiLCJpc0xpc3NBdXRvIiwib3B0aW9ucyIsImhlYWRlcnMiLCJyZXNwb25zZSIsInN0YXR1cyIsImRlZmF1bHQiLCJlIiwiY29uc29sZSIsImxvZyIsIkhUTUxDTEFTU19SRUdFWCIsImVsZW1lbnROYW1lTG9va3VwVGFibGUiLCJleGVjIiwicmVxdWlyZSIsInMiLCJzcWxpdGUzIiwib28xIiwianMyc3FsIiwiREIiLCJkZXNjIiwiZnVsbFJlc2V0IiwiY29scyIsImVudHJpZXMiLCJzY2hlbWEiLCJqb2luIiwiY29uc3RyYWludHMiLCJ2YWx1ZXMiLCJjIiwicmVzZXRUYWJsZSIsInJlc2V0IiwicmV2ZXJzZSIsImNsZWFyIiwibmFtZXMiLCJrZXlzIiwidGFibGUiLCJzcWwiLCJ0eXBlcyIsInNxbF90eXBlIiwiZmluZCIsInYiLCJzdGFydHNXaXRoIiwic3RhcnRfcG9zIiwiZW5kX3BvcyIsInRhYmxlX25hbWUiLCJzbGljZSIsImV4ZWNfb25lIiwic2VsZWN0T2JqZWN0cyIsImV4ZWNfbWFueSIsInJlc3VsdHMiLCJ3YXJuIiwibWVzc2FnZSIsInNwbGl0IiwiZGIyIiwiVXNlcnMiLCJJRCIsIk5vbSIsIlByZW5vbSIsIkFnZSIsIlByb2R1aXRzIiwiRGF0ZSIsIlJlZiIsIlEiLCJUMSIsIlQyIiwic25hbWUiLCJwYXRoIiwiY2hpbGRyZW4iLCJyb290X3BhdGgiLCJob3N0bmFtZSIsInBhZ2VzIiwibWFpbiIsImhlYWRlciIsInRpdGxlcyIsImh0cmVlIiwiaHRtbCIsImxldmVsIiwiaHRyZWVfY3Vyc29yIiwidGl0bGUiLCJzZWFyY2hDdXJIZWFkZXIiLCJwb3NpdGlvbiIsIm9mZnNldFRvcCIsImhpZCIsImdldFRpdGxlUHJlZml4IiwiaW5kZXhPZiIsIm51bSIsImJ1aWxkTWVudSIsIm5vZGVzIiwibWVudSIsIml0ZW0iLCJ0ZXh0Q29udGVudCIsInVwZGF0ZUhlYWRlciIsImxhc3QiLCJzY3JvbGxUb3AiLCJjdXJzb3IiLCJobm9kZSIsImgiLCJoX2h0bWwiLCJsaW5rIiwiZW1wdHkiLCJtYWtlX3BhZ2VfaHJlZiIsInBhdGhwcmVmaXgiLCJocmVmIiwibWFrZV9wYWdlX21lbnUiLCJwYWdlIiwiY3VycGFnZSIsIm1vZHVsZV9odG1sIiwidHlwZV9odG1sIiwiZGVzY190eXBlIiwiZGVzYzJfaWR4IiwiZmluZEluZGV4IiwiYm9keSIsInNlc3Npb25faHRtbCJdLCJzb3VyY2VSb290IjoiIn0=