<!DOCTYPE html>
<html>
    <head>
        <title>CM (BDR1)</title>
        <link rel="stylesheet" href="./index.css">
        <script type="module" src="./index.js" defer></script>
    </head>
    <body>
        <style>
        </style>
        <header></header>
        <main>
<div id='menu' style="display:none"></div>

<todo> 

<p>Contenu:</p>
<ul>
<li>subqueries animations...<ul>
<li>T1 table</li>
<li>subquery (updated if correlated)</li>
<li>subquery table
-&gt; exec op for cmp</li>
<li>result table.</li>
</ul>
</li>
</ul>
<p>D√©tails:</p>
<ul>
<li>split CM into different files.</li>
<li>espace moodle (avec navigation)</li>
<li>slides PDF LaTeX.</li>
<li>cheat-sheet...</li>
</ul>
<!--

CM4

- exemples dynamiques/anim√©s (jointures/cart√©sien).

- ss-rq visu (?)
  - normale : calcul√©e une seule fois.

  - animation : < [P/=] >
    - X in (....)
    - 4 in (....) - 1) curseur sur liste 2) when found, next value and add line.

    - X in (QUERY)
    - 4 in [...] <- (QUERY [replace values ?])
      - 1) liste construite avec le curseur
      - 2) when found, next value.

  - normale
    - X in (liste/value) => once (....). 
      -> build result table below, one line by one.
  - corr√©l√©e, recalcul√©e √† chaque fois.
    - X in |¬†(value change (car calcul√©))
      -> build result table below, one line by one.
-->
</todo>

<h1 id="requ√™ter-une-base-de-donn√©es">Requ√™ter une base de donn√©es</h1>
<h2 id="introduction-√†-sql">Introduction √† SQL</h2>
<h3 id="les-sgbd">Les SGBD</h3>
<p>Il est fr√©quent de devoir traiter de larges quantit√©s de donn√©es :</p>
<ul>
<li>pour une entreprise : des listes de clients, de commandes, de produits, etc.</li>
<li>pour une administration : des listes d&#39;administr√©s, de transactions, etc.</li>
<li>pour un site Web : des logs de consultation de ses diff√©rentes pages, etc.</li>
<li>...</li>
</ul>
<p>Ces donn√©es peuvent repr√©senter des milliers, des millions (voire bien plus), d&#39;√©l√©ments. Il est √©vident qu&#39;on ne peut pas les manipuler &quot;√† la main&quot;. Par exemple, si on souhaite compter le nombre de ventes d&#39;une entreprise √† la main, c&#39;est :</p>
<ul>
<li><strong>chronophage</strong> :<br/>
<em>35 jours pour un million de ventes √† raison de 1 vente/seconde et 8h/jours.</em></li>
<li><strong>source d&#39;erreurs</strong> :<br/>
<em>Ventes compt√©es en double, saut√©es, etc.</em></li>
<li><strong>incomplet</strong> :<br/>
<em>Les ventes peuvent √™tre stock√©es √† plusieurs endroits diff√©rents, certaines perdues.</em></li>
</ul>
<p>Il est alors n√©cessaire d&#39;utiliser un logiciel permettant d&#39;efficacement :</p>
<ul>
<li><strong>stocker et organiser les donn√©es</strong>.</li>
<li><strong>manipuler les donn√©es</strong> : ajouter/modifier/supprimer des donn√©es.</li>
<li><strong>requ√™ter les donn√©es</strong> : e.g. compter le nombre de ventes.</li>
</ul>
<p>Pour r√©pondre √† ces besoins, on utilise un <strong>Syst√®me de Gestion de Bases de Donn√©es</strong> (SGBD). Un SGBD est un logiciel permettant de cr√©er, stocker, manipuler et requ√™ter des bases de donn√©es. Un SGBD r√©pond aussi √† d&#39;autres besoins comme :</p>
<ul>
<li><strong>la coh√©rence des donn√©es :</strong> garantie l&#39;absence de donn√©es invalides.<br/>
<em>e.g. avoir un √¢ge n√©gatif.</em></li>
<li><strong>la robustesse :</strong> r√©sister aux pannes.<br/>
<em>e.g. l&#39;ordinateur plante alors qu&#39;on est en train de modifier une donn√©e.</em></li>
<li><strong>le contr√¥le d&#39;acc√®s :</strong> qui peut faire quoi sur quelles donn√©es ?.<br/>
<em>e.g. l&#39;administrateur peut modifier et les utilisateurs lire les donn√©es.</em></li>
<li><strong>les logs :</strong> que s&#39;est-il pass√© ? qui a fait quoi et quand ?<br/>
<em>e.g. apr√®s une panne, qu&#39;√©tait-il en train de faire ?</em><br/>
<em>e.g. le stagiaire a fait une fausse manipulation, qu&#39;a-t-il r√©ellement fait ?</em></li>
<li><strong>acc√®s concurrent :</strong> modifications simultan√©es de donn√©es.</li>
</ul>
<p>üí° Dans le cadre de ce module, on se concentrera sur <strong>SQL</strong> (<em>Structured Query Language</em>), un langage permettant, entres autres, de structurer et de manipuler des bases de donn√©es.</p>
<h3 id="les-sgbd-sql">Les SGBD SQL</h3>
<p>Le langage SQL est normalis√© par la norme ISO/CEI 9075. Cependant certaines fonctionnalit√©s diff√®rent selon le SGBD utilis√©.</p>
<p>Parmi eux, <strong>SQLite</strong> est un SGBD l√©ger o√π chaque base est stock√©e sous la forme d&#39;un fichier. Il est tr√®s utilis√© pour stocker et g√©rer des donn√©es locales ayant peu d&#39;acc√®s concurrents.</p>
<p>Pour des usages plus intensifs, <strong>PostgreSQL</strong>, <strong>MySQL</strong>, et <strong>MariaDB</strong> sont des SGBD open sources plus complets, sous la forme de <strong>serveurs SQL</strong>. On interagit alors avec le SGBD via un <strong>client</strong> qui se charge de :</p>
<ul>
<li>se connecter au serveur ;</li>
<li>d&#39;envoyer la requ√™te SQL ;</li>
<li>et de r√©ceptionner la r√©ponse.</li>
</ul>
<p>Les clients peuvent prendre plusieurs formes :</p>
<ul>
<li>une interface graphique de requ√™tage (<em>e.g.  ???</em>).</li>
<li>une interface graphique de gestion de bases de donn√©es (<em>e.g. pgAdmin</em>).</li>
<li>une application en ligne de commandes (<em>e.g. psgl, mysql</em>).</li>
<li>une API utilis√©e dans le langage de programmation de votre choix.</li>
</ul>
<h3 id="les-tables-sql">Les tables SQL</h3>
<p>Comme dans un tableur, les donn√©es sont repr√©sent√©es sous forme de <strong>tables</strong> :</p>
<ul>
<li>les lignes correspondent √† des <strong>entr√©es</strong> ;</li>
<li>les colonnes correspondent aux diff√©rentes propri√©t√©s de ces entr√©es.</li>
</ul>
<p>Par exemple, la table suivante contient 2 entr√©es ayant les propri√©t√©s <code>ID</code>, <code>Nom</code>, <code>Prenom</code>, <code>Age</code> :</p>
<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Nom</th>
      <th>Prenom</th>
      <th>Age</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Doe</td>
      <td>John</td>
      <td>32</td>
    </tr><tr>
      <td>2</td>
      <td>Durand</td>
      <td>John</td>
      <td>64</td>
    </tr>
  </tbody>
</table>

<h4 id="vocabulaire">Vocabulaire</h4>
<ul>
<li>Une <strong>base de donn√©e</strong> est compos√©e de plusieurs tables.</li>
<li>Un <strong>sch√©ma</strong> de table d√©crit les colonnes de la table (cf CM3).</li>
<li>Les lignes d&#39;une table sont appel√©es <strong>entr√©es</strong> ou <strong>enregistrements</strong>.</li>
</ul>
<p>üí° Vous pouvez voir la base de donn√©es comme un fichier tableur, et les tables comme les feuilles de calculs contenues dans ce fichier.</p>
<p>üí° Les tables sont aussi parfois appel√©es <strong>relations</strong>, d&#39;o√π le terme <em>base de donn√©es relationnelle</em>.</p>
<h3 id="les-types-sql">Les types SQL</h3>
<p>En SQL chaque colonne a un type, i.e. le type des donn√©es qu&#39;on peut y ins√©rer. SQL supporte en g√©n√©ral 4 familles de types :</p>
<ul>
<li><code>TEXT</code> :¬†une cha√Æne de caract√®re.</li>
<li><code>BLOB</code> : des donn√©es binaires. </li>
<li><code>INT</code>/<code>INTEGER</code> : un nombre entier.</li>
<li><code>REAL</code> : un nombre d√©cimal.</li>
<li><code>ANY</code>  :¬†accepte n&#39;importe quelle valeur.</li>
</ul>
<p>üí° Par d√©faut, chaque type accepte la valeur <code>NULL</code>, qui indique une absence de donn√©es.</p>
<p>üí° En SQL les cha√Ænes de caract√®res s&#39;√©crivent entre guillemets simples (<code>&#39;</code>). Pour √©chapper un guillemet simple dans la cha√Æne de caract√®res, il suffit de l&#39;√©crire en double, e.g. <code>&#39;J&#39;&#39;ai √©chapp√©.&#39;</code>. </p>
<p>En g√©n√©ral, les SGBD (sauf SQLite) offrent une vari√©t√© de sous-types permettant d&#39;optimiser leur stockage. Une table (non-exhaustive) des sous-types les plus communs vous est propos√©e ci-dessous √† titre informatif :</p>
<details>
  <summary><em><strong>Montrer la table des sous-types</strong></em></summary>

  <table>
    <thead>
      <tr>
        <th>Famille</th>
        <th>Type</th>
        <th>Octets</th>
        <th>Description<th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan='9'>TEXT</td>
        <td>CHAR</td>
        <td>1 √† 3</td>
        <td>Caract√®re UTF8</td>
      </tr><tr>
        <td>CHAR(N)</td>
        <td>N*1 √† N*3</td>
        <td>Taille fixe</td>
      </tr><tr>
        <td>VARCHAR(N)</td>
        <td>0 √† N*3</td>
        <td>Taille variable</td>
      </tr>
      <tr><td></td><td></td><td></td></tr>
      <tr>
        <td>NCHAR</td>
        <td>2</td>
        <td>Caract√®re UTF16</td>
      </tr><tr>
        <td>NCHAR(N)</td>
        <td>N*2</td>
        <td>Taille fixe</td>
      </tr><tr>
        <td>NVARCHAR(N)</td>
        <td>0 √† N*2</td>
        <td>Taille variable</td>
      </tr>
      <tr><td></td><td></td><td></td></tr>
      <tr>
        <td>TEXT(N)</td>
        <td>N</td>
        <td>Pour de gros textes.</td>
      </tr>
      <tr><td></td><td></td><td></td><td></td></tr>
      <tr>
        <td rowspan='2'>BLOB</td>
        <td>BIT(N)</td>
        <td>N/8</td>
        <td>Champ de bits</td>
      </tr><tr>
        <td>BLOB(N)</td>
        <td>N</td>
        <td></td>
      </tr>
      <tr><td></td><td></td><td></td><td></td></tr>
      <tr></tr>
        <td rowspan='6'>INT</td>
        <td>BOOLEAN</td>
        <td>1</td>
        <td></td>
      </tr>
        <td>SMALLINT</td>
        <td>2</td>
        <td></td>
      </tr><tr>
        <td>INTEGER</td>
        <td>4</td>
        <td></td>
      </tr><tr>
        <td>BIGINT</td>
        <td>8</td>
        <td></td>
      </tr><tr>
        <td>NUMERIC(N)</td>
        <td>N</td>
        <td></td>
      </tr><tr>
        <td>ENUM(val[,...])</td>
        <td>2</td>
        <td>Peut aussi √™tre TEXT</td>
      </tr>
      <tr><td></td><td></td><td></td><td></td></tr>
      <tr>
        <td rowspan='4'>REAL</td>
        <td>FLOAT</td>
        <td>4</td>
        <td></td>
      </tr>
      <tr>
        <td>DOUBLE</td>
        <td>8</td>
        <td></td>
      </tr>
      <tr>
        <td>FLOAT(N)</td>
        <td>N</td>
        <td>Virgule flottante</td>
      </tr>
      <tr>
        <td>DECIMAL(N,S)</td>
        <td>N</td>
        <td>Pr√©cision fixe</td>
      </tr><tr><td></td><td></td><td></td><td></td></tr>
      <tr>
        <td rowspan='4'>DATE</td>
        <td>DATE</td>
        <td>4</td>
        <td>10 en SQLite (TEXT)</td>
      </tr>
      <tr>
        <td>TIME</td>
        <td>8 √† 12</td>
        <td></td>
      </tr>
      <tr>
        <td>DATETIME</td>
        <td>12 √† 16?</td>
        <td>19 en SQLite (TEXT)</td>
      </tr>
      <tr>
        <td>TIMESTAMP</td>
        <td>8</td>
        <td></td>
      </tr>
    </tbody>
  </table>

<p>  üí° En fonction du SGBD utilis√©, il existe une pl√©thore d&#39;autres types plus ou moins complexes.</p>
</details>

<h3 id="documentation">Documentation</h3>
<p>üí° Vous trouver plus amples documentation via les liens suivants :</p>
<ul>
<li>SQL :<ul>
<li><a href="https://www.w3schools.com/sql/">https://www.w3schools.com/sql/</a></li>
<li><a href="https://sql.sh">https://sql.sh</a></li>
</ul>
</li>
<li>SGBD :<ul>
<li>SQLite¬†:¬†<a href="https://www.sqlite.org">https://www.sqlite.org</a></li>
<li>PostgreSQL¬†:¬†<a href="https://www.postgresql.org/docs/">https://www.postgresql.org/docs/</a></li>
<li>MySQL : <a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></li>
</ul>
</li>
</ul>
<h2 id="requ√™tes-de-bases">Requ√™tes de bases</h2>
<h3 id="les-types-de-requ√™tes">Les types de requ√™tes</h3>
<p>Il existe plusieurs types de commandes SQL permettant d&#39;effectuer diff√©rent types actions :</p>
<ul>
<li><code>SELECT</code> : lire des donn√©es ;</li>
<li><code>UPDATE</code> : modifier des entr√©es ;</li>
<li><code>INSERT</code> : ins√©rer des entr√©es ;</li>
<li><code>DELETE</code> : supprimer des entr√©es.</li>
</ul>
<p>Nous allons dans un premier temps nous concentrer sur le premier, et verrons les 3 autres par la suite.</p>
<h2 id="la-requ√™te-select">La requ√™te SELECT</h2>
<p>La requ√™te SQL <code>SELECT</code> permet de r√©cup√©rer des donn√©es pr√©sentes dans une base de donn√©e, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS[,...] <span class="hljs-keyword">FROM</span> $<span class="hljs-keyword">TABLE</span>; 
</code></pre><ul>
<li><p><code>$TABLE</code> est le nom de la table SQL √† requ√™ter.</p>
</li>
<li><p><code>$COLS[,...]</code> est la liste des colonnes √† r√©cup√©rer s√©par√©es par &quot;,&quot;.</p>
<p>üí° <code>*</code> correspond √† l&#39;ensemble des colonnes.</p>
</li>
</ul>
<p>‚ö† Il est d&#39;usage de ne r√©cup√©rer que les colonnes dont on a r√©ellement besoin. En effet, sur de grandes tables et de grosses requ√™tes, r√©duire le nombre de colonnes r√©cup√©r√©es permet de r√©duire le volume des donn√©es transf√©r√©es. </p>
<p>‚ö† Le nom de la colonne devra √™tre √©crite entre guillemets s&#39;il contient des caract√®res non-alphanum√©riques.</p>
<h3 id="s√©lection-des-colonnes">S√©lection des colonnes</h3>
<sql-interactive id="col-sql">
  <sql-dymtable slot="post" id="col-table" table="Users"></sql-dymtable>
  <span slot="options" data-cols="*">Retourner toutes les colonnes</span>
  <span slot="options" data-cols="Nom">Retourner une seule colonne</span>
  <span slot="options" data-cols="ID, Prenom">Retourner plusieurs colonnes</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const coltable = await LISS.qs("#col-table");
  const colsql   = await LISS.qs("#col-sql");

  colsql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( colsql.lastDatas );

  function update(datas) {

    const cols = Object.keys(datas[0][0]);

    coltable.highlightCol( (colname) => cols.includes(colname) ); //TODO...
  }

</script>

<h3 id="alias-de-colonnes">Alias de colonnes</h3>
<p>üí° Dans le cadre d&#39;une requ√™te SQL, vous pouvez temporairement associer un alias √† une colonne gr√¢ce au mot cl√© <code>as</code> :</p>
<sql-interactive>
  <span slot="options" data-col_as="">Requ√™te normale</span>
  <span slot="options" data-col_as="as User">Renommer une colonne</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Nom $COL_AS, Age <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<h3 id="trier-par-ordre-croissantd√©croissant-les-lignes">Trier par ordre croissant/d√©croissant les lignes</h3>
<p>La clause <code>ORDER BY $COL [DESC|ASC][,...]</code> permet de trier les lignes retourn√©es par ordre croissant (<code>ASC</code>) ou d√©croissant (<code>DESC</code>).</p>
<sql-interactive>
  <span slot="options" data-row_sort="Age ASC">Trier par Age croissant</span>
  <span slot="options" data-row_sort="Age DESC">Trier par Age d√©croissant</span>
  <span slot="options" data-row_sort="Age DESC, Nom ASC">Trier par Age d√©croissant, puis par Nom croissant</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> $ROW_SORT;
</code></pre></sql-interactive>

<h2 id="selection-des-lignes">Selection des lignes</h2>
<p><code>SELECT</code> retourne l&#39;int√©gralit√© des entr√©es de la table, ce qui peut repr√©senter des milliers de lignes. Or, bien souvent, seules quelques entr√©es nous int√©ressent.</p>
<p>Il est ainsi important de s√©lectionner uniquement les lignes qui nous int√©ressent afin de r√©duire le volume des donn√©es transf√©r√©es, ainsi que de r√©duire la consommation de ressources serveurs (processeur, RAM, disque).</p>
<p>Il est ainsi possible de s√©lectionner des lignes de diff√©rentes mani√®res :</p>
<ul>
<li>via un filtre via la clause <code>WHERE $COND</code> :<br/>
<em>e.g. les entr√©es correspondant aux utilisateurs mineurs.</em></li>
<li>en supprimant les doublons via la clause <code>DISTINCT</code> :<br/>
<em>e.g. les √¢ges sans doublons.</em></li>
<li>en limitant le nombre de lignes retourn√©es via les clauses <code>LIMIT $N OFFSET $O</code> :<br/>
<em>e.g. les 10 plus jeunes utilisateurs.</em></li>
</ul>
<h3 id="clause-where">Clause WHERE</h3>
<p>La mani√®re g√©n√©rique de filter les lignes √† retourner est d&#39;ajouter une clause <code>WHERE¬†$COND</code> √† la requ√™te. Seules les lignes pour lesquelles <code>$COND</code> est vraie seront retourn√©es.</p>
<sql-interactive id="row-sql">
  <sql-dymtable slot="post" id="row-table" table="Users"></sql-dymtable>
  <span slot="options" data-cond="Age > 18">Retourner les entr√©es o√π Age > 18</span>
  <span slot="options" data-cond="Nom == 'Doe'">Retourner les entr√©es o√π Nom est "Doe"</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>


<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const rowtable = await LISS.qs("#row-table");
  const rowsql   = await LISS.qs("#row-sql");

  rowsql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( rowsql.lastDatas );

  function update(datas) {

    const ids = datas[0].map(r => r.ID);

    rowtable.highlightRow( ({ID}) => ids.includes(+ID) );
  }

</script>

<h4 id="op√©rateurs-de-comparaisons">Op√©rateurs de comparaisons</h4>
<p>üí° La structure d&#39;une condition est tr√®s simple, utilisant les op√©rateurs de comparaison que vous connaissez d√©j√† : <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>.</p>
<sql-interactive>
  <span slot="options" data-cond="ID > 1">Comparaison simple</span>
  <span slot="options" data-cond="Prenom == Nom">Comparaison entre 2 colonnes</span>
  <span slot="options" data-cond="0 < Age < 18">Cha√Æner les op√©rateurs produit un r√©sultat √©trange</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Age, Nom, Prenom <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>üí° Vous pouvez utiliser les noms de colonnes comme op√©randes, m√™me si elles n&#39;apparaissent pas dans les colonnes √† retourner.</p>
<p>‚ö† Comme vous le constatez dans l&#39;exemple ci-dessus, bien que cela soit syntaxiquement valide, <strong>cha√Æner les op√©rateurs de comparaisons ne produira pas le r√©sultat attendu</strong>.<br/>
Vous ne devez ainsi pas √©crire, e.g. <code>0 &lt; Age &lt; 18</code>, mais (cf suite du cours) :</p>
<ul>
  <li>soit <code>0 < Age AND Age < 18</code> ;</li>
  <li>soit <code>Age BETWEEN 0 AND 18</code> .</li>
</ul>

<h4 id="op√©rateurs-logiques">Op√©rateurs logiques</h4>
<p>Vous pouvez composer des conditions √† l&#39;aide d&#39;op√©rateurs logiques que vous connaissez d√©j√† : <code>AND</code>, <code>OR</code>, <code>NOT</code>.</p>
<sql-interactive>
  <span slot="options" data-cond="Age > 18 AND Age < 45">Intersection (et)</span>
  <span slot="options" data-cond="Age > 18 OR Age < 45">Union (ou)</span>
  <span slot="options" data-cond="NOT ( Age > 18 )">N√©gation (non)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Age, Nom, Prenom <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>üí° Vous pouvez aussi utiliser des parenth√®ses.</p>
<h4 id="autres-op√©rateurs">Autres op√©rateurs</h4>
<sql-interactive>
  <span slot="options" data-cond="Age IS NULL">Entr√©es o√π Age vaut null</span>
  <span slot="options" data-cond="Nom IN ('Doe', 'Nescio')">Entr√©es o√π Nom est dans la liste</span>
  <span slot="options" data-cond="Age BETWEEN 0 AND 18">Entr√©es o√π Age est compris entre 0 et 18</span>
  <span slot="options" data-cond="Nom LIKE 'D%'">Entr√©es o√π Nom commence par "D"</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> Age, Nom, Prenom <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<ul>
<li><p><code>[NOT] IS NULL</code> : si la valeur est nulle/n&#39;est pas nulle.<br/>
‚ö† En SQL <code>NULL == NULL</code> est g√©n√©ralement √©valu√© √† <code>False</code>.</p>
</li>
<li><p><code>[NOT] IN ($VALS[,...])</code> : si la valeur est/n&#39;est pas dans une liste donn√©e.</p>
</li>
<li><p><code>[NOT] BETWEEN $MIN AND $MAX</code> : si la valeur est/n&#39;est pas entre <code>$MIN</code> et <code>$MAX</code>.<br/>
üí° C&#39;est l&#39;√©quivalant de <code>$VAL &gt;= $MIN AND $VAL &lt;= $MAX</code><br/>
‚ö† Le comportement de l&#39;op√©rateur <code>BETWEEN</code> peut changer en fonction du syst√®me, et peut alors √™tre √©quivalent √† <code>$VAL &gt; $MIN AND $VAL &lt; $MAX</code>.</p>
</li>
<li><p><code>[NOT] LIKE $PATTERN</code> : si la valeur correspond/ne correspond pas √† <code>$PATTERN</code>.<br/>
<code>_</code> correspond √† n&#39;importe quel caract√®re.<br/>
<code>%</code> correspond √† un nombre ind√©termin√© de n&#39;importe quel caract√®re.<br/>
e.g. <code>LIKE &#39;D%&#39;</code>: une valeur commen√ßant par &quot;D&quot;.</p>
</li>
</ul>
<h3 id="supprimer-les-doublons">Supprimer les doublons</h3>
<p>La clause <code>DISTINCT</code> permet de supprimer les doublons dans les lignes retourn√©es :</p>
<sql-interactive>
  <span slot="options" data-row_distinct="">Requ√™te normale</span>
  <span slot="options" data-row_distinct="DISTINCT">Ne pas retourner les doublons</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $ROW_DISTINCT Age <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<h3 id="tops-et-pagination">Tops et pagination</h3>
<h4 id="tops">Tops</h4>
<p>La clause <code>LIMIT $N</code> permet de ne r√©cup√©rer que les <code>$N</code> premi√®res entr√©es retourn√©es. Souvent utilis√©e avec la clause <code>ORDER BY</code>, elle permet notamment de g√©n√©rer des tops, e.g. les X utilisateurs les plus jeunes.</p>
<sql-interactive>
  <span slot="options" data-pagination="1">Ne r√©cup√©rer que la premi√®re entr√©e</span>
  <span slot="options" data-pagination="2">Ne r√©cup√©rer que les deux premi√®res entr√©es</span>
  <span slot="options" data-orderby="ORDER BY Age" data-pagination="1">Ne r√©cup√©rer que l'utilisateur le plus jeune</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users $ORDERBY LIMIT $PAGINATION;
</code></pre></sql-interactive>

<h4 id="pagination">Pagination</h4>
<p>Lorsqu&#39;une requ√™te retourne des milliers de lignes, il peut √™tre co√ªteux de toutes les r√©cup√©rer et les afficher en m√™me temps. On peut alors d√©couper la liste en plusieurs pages, en affichant que e.g. 50 lignes par pages. Ainsi la premi√®re page r√©cup√®re et affiche les 50 premi√®res lignes, la seconde les 50 suivantes, et ainsi de suite.</p>
<p>Pour cela, on utilisera la clause <code>LIMIT 50</code> afin de ne r√©cup√©rer que 50 entr√©es par requ√™tes. En conjonction, on utilisera la clause <code>OFFSET $P*50</code> qui permet de ne pas r√©cup√©rer les <code>$P*50</code> premi√®res entr√©es retourn√©es. <code>$P+1</code> √©tant alors le num√©ro de la page actuelle.</p>
<sql-interactive id="pagination-sql">
  <sql-dymtable slot="post" id="pagination-table" table="Users"></sql-dymtable>
  <span slot="options" data-pagination="1" data-p="0">Page 1 (1 entr√©e par page)</span>
  <span slot="options" data-pagination="1" data-p="1">Page 2 (1 entr√©e par page)</span>
  <span slot="options" data-pagination="1" data-p="2">Page 3 (1 entr√©e par page)</span>
  <span slot="options" data-pagination="2" data-p="0*2">Page 1 (2 entr√©e par page)</span>
  <span slot="options" data-pagination="2" data-p="1*2">Page 2 (2 entr√©e par page)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Users LIMIT $PAGINATION <span class="hljs-keyword">OFFSET</span> $P ;
</code></pre></sql-interactive>

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const table = await LISS.qs("#pagination-table");
  const sql   = await LISS.qs("#pagination-sql");

  sql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( sql.lastDatas );

  function update(datas) {

    const ids = datas[0].map(r => r.ID);
    table.highlightRow( ({ID}) => ids.includes(+ID) );
  }

</script>

<h2 id="astuces-pour-r√©diger-efficacement-les-requ√™tes-sql">Astuces pour r√©diger efficacement les requ√™tes SQL</h2>
<ol>
<li>Indentez vos requ√™tes (e.g. en alignant les clauses), elle en devient bien plus lisible (et facile √† modifier).</li>
<li>Lorsque vous ouvrez une parenth√®se/guillemet/etc. fermez-la imm√©diatement, puis remplissez son contenu.</li>
<li>√âvitez autant que possible d&#39;√©crire √† la main :<ol>
<li>Utilisez l&#39;auto-compl√©tion pour les mots clefs et noms de colonnes (touche de tabulation <code>‚≠æ</code>).</li>
<li>Utilisez les fl√®ches (<code>‚Üë</code>/<code>‚Üì</code>) pour remonter l&#39;historique et (<code>‚Üê</code>/<code>‚Üí</code>) pour modifier une requ√™te.</li>
<li>Utilisez les copier/coller (<code>^+‚áß+C</code>/<code>^+‚áß+V</code>).</li>
</ol>
</li>
<li>Comme en programmation, ne <strong>jamais</strong> tout √©crire d&#39;un coup, mais proc√©dez par √©tapes :<ol>
<li>commencez par un <code>SELECT * FROM $T;</code> basique.</li>
<li>affichez les colonnes que vous utiliserez.</li>
<li>ajoutez les nouvelles clauses une par une, en testant √† chaque fois.</li>
<li>idem pour les expressions, commencez simple, puis ajoutez les op√©rations au fur et √† mesure.</li>
</ol>
</li>
</ol>
<p>üí° Cela vous aidera √† √©crire plus simplement des requ√™tes SQL avec m√©thode, en transformant un probl√®me complexe, en plusieurs petits probl√®mes simples. De surcro√Æt, en cas d&#39;erreur, vous saurez imm√©diatement son origine, et sera alors bien plus facile √† d√©boguer et corriger.</p>
<h3 id="ordre-dex√©cution-et-d√©criture">Ordre d&#39;ex√©cution et d&#39;√©criture</h3>
<p>Le diff√©rentes <strong>clauses</strong> des requ√™tes SQL sont g√©n√©ralement √©crites dans leur ordre d&#39;ex√©cution, et ex√©cut√©es dans leur ordre d&#39;√©criture, i.e. de gauche √† droite.</p>
<style>
  .later {
    color: gray;
    font-style: italic;
    opacity: 0.5;
  }
  .warning {
    color: red;
  }

</style>

<p>Par exemple lors d&#39;une requ√™te <code>SELECT</code>:</p>
<div style="display:flex">
  <ol id="order-list">
    <li step="1">On r√©cup√®re la table (clause <code>FROM</code>).</li>
    <li step="2" class="warning"><em>Alias de colonnes d√©finies ici.</em></li>
    <li step="3">On filtre les entr√©es (clause <code>WHERE</code>).</li>
    <li class="later">On groupe les entr√©es en lignes (clause <code>GROUP BY</code>).</li>
    <li class="later warning"><em>Alias de colonnes d'agr√©gats d√©finies ici.</em></li>
    <li class="later">On filtre les lignes agr√©g√©es (clause <code>HAVING</code>).</li>
    <li class="warning" step="4">On supprime les doublons (clause <code>SELECT DISTINCT</code>).</li>
    <li step="5">On trie les lignes (clause <code>ORDER BY</code>).</li>
    <li step="6">On limite le nombre de lignes retourn√©es (clauses <code>LIMIT</code>/<code>OFFSET</code>).</li>
  </ol>
  <div>
    <div style="text-align: center">
      <anim-player speed="1500" id="order-player"></anim-player>
    </div>
    <div style="display:flex;height: fit-content;">
      <style>
        .notyet {
          color: gray;
        }
        .cur {
          color: yellow;
        }
        .warning.cur {
          color: orange;
        }
      </style>
      <pre style="margin:0"><code id="order_sql">SELECT <span class="notyet">DISTINCT</span> Date, Ref, Q as Nb
    FROM Produits
    WHERE Ref = "Gomme"
    ORDER BY Q
    LIMIT 2;</code></pre>
      <sql-dymtable header="" table="Produits" id="order-table"><sql-dym-table>>
    </div>
  </div>
</div>

<script type="module">


  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const player = await LISS.qs("#order-player");
  const table  = await LISS.qs("#order-table");
  const order_sql = document.querySelector("#order_sql");

  const list = document.querySelectorAll("#order-list > li");

  const query = [
`SELECT `, [4, `DISTINCT `], `Date, Ref, Q `, [2, "as Nb"],
    [ 1, `\n    FROM Produits`],
    [ 3, `\n    WHERE Ref = 'Gomme'`],
    [ 5, `\n    ORDER BY Q`],
    [ 6, `\n    LIMIT 2`], ';' ];

  function buildQuery(step) {
    let output = "";
    for(let elem of query) {
      if( Array.isArray(elem) ) {
        if( elem[0] > step && step !== 0 )
          continue;
        elem = elem[1];
      }
      output += elem;
    }

    return output;
  }
  function buildOutput(step) {
    let output = [];
    for(let elem of query) {
      if( Array.isArray(elem) ) {
        const html = document.createElement('span');
        html.textContent = elem[1];
        html.classList.toggle("cur", elem[0] === step);
        
        if( elem[0] > step && step !== 0 )
          html.classList.add("notyet");
        elem = html;
      }
      output.push(elem);
    }

    return output;
  }

  function doStep(i) {

    if( i > 6)
      return player.reset();

    order_sql.replaceChildren( ...buildOutput(i) ); //TODO highlight
    for(let li of list)
      li.classList.toggle("cur", li.getAttribute("step") === `${i}`);

    table.exec( buildQuery(i) );
  }

  player.host.addEventListener("reset", ()   => { doStep(0)          });
  player.host.addEventListener("step" , (ev) => { doStep( ev.detail) });

  doStep(0);
</script>

<p>üí° Les √©tapes en gris seront √©tudi√©es au CM suivant.</p>
<p>‚ö† En rouge sont indiqu√©s des cas d&#39;exceptions dont l&#39;ordre d&#39;√©criture ne correspond pas √† leur ordre d&#39;ex√©cution. Une autre exception existe dans les requ√™tes <code>UPDATE</code> o√π la clause <code>SET</code> s&#39;√©crit <strong>avant</strong> la clause <code>WHERE</code>.</p>
<h1 id="manipuler-des-entr√©es">Manipuler des entr√©es</h1>
<h2 id="modifier-le-contenu-dune-table">Modifier le contenu d&#39;une table</h2>
<p>Pour rappel, il existe plusieurs types de commandes SQL permettant d&#39;effectuer diff√©rent types actions :</p>
<ul>
<li><code>SELECT</code> : lire des donn√©es ;</li>
<li><code>UPDATE</code> : modifier des entr√©es ;</li>
<li><code>INSERT</code> : ins√©rer des entr√©es ;</li>
<li><code>DELETE</code> : supprimer des entr√©es.</li>
</ul>
<p>Nous allons d√©sormais nous int√©resser aux 3 derni√®res.</p>
<h3 id="ins√©rer-des-lignes">Ins√©rer des lignes</h3>
<p>La requ√™te SQL <code>INSERT</code> permet d&#39;ins√©rer des entr√©es dans une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> $TABLENAME <span class="hljs-keyword">VALUES</span> ($VALS[,...])[,...];
</code></pre><ul>
<li><code>($VALS[,...])</code> repr√©sente une entr√©e √† ins√©rer. Les diff√©rentes valeurs de l&#39;entr√©e sont s√©par√©es par une virgule.<br/>
üí° Vous pouvez ins√©rer plusieurs entr√©es √† la fois en les s√©parant par une virgule.</li>
</ul>
<sql-interactive>
  <span slot='select'>SELECT * FROM Users;</span>
  <span slot="options" data-m_vals="(NULL, 'Doe', 'Jon', 32)">Ins√©rer une entr√©e</span>
  <span slot="options" data-m_vals="      (NULL, 'Doe',    'Jon', 32),
       (NULL, 'Sawyer', 'Tom', 15)">Ins√©rer plusieurs entr√©es</span>
  <span slot="options" data-cols="(Prenom, Nom)" data-m_vals="('Jon', 'Doe')">Ins√©rer une entr√©e sans renseigner Age</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Users $COLS <span class="hljs-keyword">VALUES</span>
$M_VALS;
</code></pre></sql-interactive>

<p>üí° Vous pouvez aussi ne renseigner les valeurs que pour certaines colonnes dont vous indiquez les noms avant <code>VALUES</code>. Dans ce cas, les colonnes non renseign√©es vaudront <code>NULL</code>.</p>
<h3 id="modifier-des-lignes">Modifier des lignes</h3>
<p>La requ√™te SQL <code>UPDATE</code> de modifier des entr√©es dans une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">UPDATE</span> $TABLENAME <span class="hljs-keyword">SET</span> $COL <span class="hljs-operator">=</span> $VAL[,...] <span class="hljs-keyword">WHERE</span> $COND;
</code></pre><ul>
<li><code>$COL</code> est le nom de la colonne √† modifier.</li>
<li><code>$VAL</code> est la nouvelle valeur de cette colonne.</li>
<li><code>$COND</code> indique quelles entr√©es doivent √™tre modifi√©es.</li>
</ul>
<p>üí° Vous pouvez modifier plusieurs colonnes √† la fois en s√©parant les <code>$COL = $VAL</code> par une virgule.</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM Users;</span>
  <span slot="options" data-vals="Nom = 'Durand'" data-cond="Nom == 'Durant'">Modifier une colonne</span>
  <span slot="options" data-vals="Nom = 'Durand', Prenom='Th√©o'" data-cond="ID == 2">Modifier plusieurs colonnes</span>
  <span slot="options" data-vals="Age = 23" data-cond="Age == 43">Plusieurs lignes modifi√©es</span>
  <span slot="options" data-vals="Age = Age + 10" data-cond="Nom LIKE 'D%'">Valeur calcul√©e √† partir de l'entr√©e</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">UPDATE</span> Users
  <span class="hljs-keyword">SET</span> $VALS
  <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>üí° Vous pouvez calculer les nouvelles valeurs √† partir des valeurs initiales de l&#39;entr√©e.</p>
<p>‚ö† Il est possible d&#39;avoir des utilisateurs avec le m√™me nom et/ou pr√©noms. Il est ainsi pr√©f√©rable, autant que possible, d&#39;effectuer la condition <code>$COND</code> les ID pour s&#39;assurer de modifier les bonnes entr√©es, et non celles d&#39;homonymes.</p>
<h3 id="supprimer-des-lignes">Supprimer des lignes</h3>
<p>La requ√™te SQL <code>DELETE</code> de supprimer des entr√©es dans une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> $TABLENAME <span class="hljs-keyword">WHERE</span> $COND;
</code></pre><ul>
<li><code>$COND</code> indique quelles entr√©es doivent √™tre supprim√©es.</li>
</ul>
<sql-interactive>
  <span slot='select'>SELECT * FROM Users;</span>
  <span slot="options" data-cond="Age < 18">Supprimer les entr√©es o√π Age > 18</span>
  <span slot="options" data-cond="Age > 18">Supprimer les entr√©es o√π Age > 18</span>
  <span slot="options" data-cond="ID == 2">Supprimer un utilisateur donn√©</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Users <span class="hljs-keyword">WHERE</span> $COND;
</code></pre></sql-interactive>

<p>‚ö† Il est possible d&#39;avoir des utilisateurs avec le m√™me nom et/ou pr√©noms. Il est ainsi pr√©f√©rable, autant que possible, d&#39;effectuer la condition <code>$COND</code> les ID pour s&#39;assurer de supprimer les bonnes entr√©es, et non celles d&#39;homonymes.</p>
<h2 id="pr√©traitements">Pr√©traitements</h2>
<p>Il est bien souvent important de pr√©-traiter les donn√©es avant de les utiliser (e.g. comparaisons, insertions), ce afin de s&#39;assurer que les informations soient bien repr√©sent√©es de la m√™me mani√®re. Par exemple, un nom de famille peut s&#39;√©crire de plusieurs mani√®res : <code>&quot;Nom&quot;</code>, &quot;<code>NOM</code>&quot;, ou &quot;<code>nom</code>&quot;. Si ces trois cha√Ænes de caract√®res repr√©sentent bien la m√™me information, elles ne sont pas √©gales pour autant. Ainsi, aucune entr√©e ne sera retourn√©e si on recherche <code>&quot;Nom&quot;</code> dans la base de donn√©es, alors qu&#39;il est stock√© en majuscules (i.e. <code>&quot;NOM&quot;</code>).</p>
<p>Pr√©-traiter les donn√©es permet alors de s&#39;assurer de l&#39;uniformit√© des donn√©es, i.e. que les donn√©es manipul√©es suivent le m√™me format, facilitant e.g. leur comparaisons. Pr√©-traiter les donn√©es avant insertions permet aussi de s&#39;assurer de la coh√©rence et consistance de la base de donn√©es.</p>
<p>üí° Il est possible de <strong>tester</strong> les diff√©rentes fonctions de pr√©traitements en effectuant une requ√™te <code>SELECT</code> sans la clause <code>FROM</code> (ou avec <code>FROM DUAL</code> pour certains SGBD) :</p>
<sql-interactive>
  <span slot="options" data-col1="'nom'" data-col2="UPPER('nom')">Mettre en majuscules</span>
  <span slot="options" data-col1="1.2" data-col2="ROUND(1.2)">Arrondir</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COL1 <span class="hljs-keyword">as</span> BEFORE, $COL2 <span class="hljs-keyword">as</span> AFTER;
</code></pre></sql-interactive>

<p>‚ö† Dans les requ√™tes <code>SELECT</code>, il ne faut pas trop abuser de ces pr√©-traitements pour les valeurs retourn√©es. Il est souvent pr√©f√©rable de g√©rer des donn√©es structur√©es en SQL, et de g√©rer leur pr√©-traitement via le langage utilis√© par votre application (e.g. Python, R, JavaScript, etc). Cela permet notamment de pouvoir r√©utiliser une m√™me requ√™te pour diff√©rents usages.</p>
<p>üí° Certains SGBD ont aussi des syst√®mes de cache, permettant de recalculer plus rapidement le r√©sultat d&#39;une requ√™te ex√©cut√©e fr√©quemment.</p>
<h3 id="sur-les-nombres">Sur les nombres</h3>
<p>Avec SQL, vous pouvez utiliser les op√©rateurs et fonctions arithm√©tiques classiques :</p>
<sql-interactive>
  <span slot="options" data-cols="1+1, 4%3, 4/3, 4/3.0">Op√©rations math√©matiques</span>
  <span slot="options" data-cols="FLOOR(1.2), ROUND(1.2), CEIL(1.2)">Arrondis</span>
  <span slot="options" data-cols="ABS(1), ABS(-1)">Valeur absolue</span>
  <span slot="options" data-cols="RANDOM()">Entier al√©atoire</span>
  <span slot="options" data-cols="ABS(RANDOM()) % 10">Entier al√©atoire (dans [[0;10[[)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<p>‚ö† <code>/</code> utilis√© avec des nombres entiers effectuera la division enti√®re. Si vous souhaitez faire la division d√©cimale, vous devez avoir au moins une op√©rande d√©cimale.</p>
<ul>
<li><code>FLOOR/ROUND/CEIL($N[, $D])</code> : arrondir <code>$N</code> √† <code>$D</code> d√©cimales.</li>
<li><code>ABS($N)</code> : la valeur absolue du nombre <code>$N</code>.</li>
<li><code>RANDOM()</code> : g√©n√®re un entier al√©atoire.<br/>
üí° Utilisez <code>ABS(RANDOM()) % $N</code> pour g√©n√©rer un entier dans <code>[[0;$N[[</code>.<br/>
üí° Certains SGBD proposent une fonction <code>RAND()</code> permettant de g√©n√©rer un r√©el dans <code>[0,1[</code>.<br/></li>
</ul>
<p>üí° Vous avez aussi beaucoup d&#39;autres fonctions trigonom√©triques, de logs, etc.</p>
<h3 id="sur-les-dates">Sur les dates</h3>
<p>Les op√©rations sur les dates sont complexes √† effectuer √† la main. En effet, il faut alors g√©rer :</p>
<ul>
<li>les mois avec des nombres de jours diff√©rents ;</li>
<li>les ann√©es bissextiles ;</li>
<li>les fuseaux horaires ;</li>
<li>les heures d&#39;√©t√© et d&#39;hiver.</li>
</ul>
<p>Les SGBD fournissent donc des fonctions permettant de manipuler les dates qui s&#39;occupent de prendre tout cela en compte. Par exemple <code>TIMEDIFF()</code> permet de calculer la dur√©e entre deux dates.</p>
<p>Il est aussi fr√©quent d&#39;utiliser des <strong>timestamps</strong>, e.g. l&#39;unix timestamp, qui repr√©sente une date par le nombre de secondes √©coul√©es depuis le 1er janvier 1970. Il permet notamment d&#39;ais√©ment comparer et stocker des dates.</p>
<sql-interactive>
  <span slot="options" data-cols="DATE(), TIME(), DATETIME()">Date et/ou heure actuelle</span>
  <span slot="options" data-cols="DATE(), STRFTIME('%d/%m/%Y', DATE())">Formatter une date</span>
  <span slot="options" data-cols="UNIXEPOCH('now')">Timestamp actuel</span>
  <span slot="options" data-cols="DATETIME(10, 'unixepoch')">Convertir un timestamp (10) en date</span>
  <span slot="options" data-cols="TIMEDIFF('now', '2001-01-01')">Calculer la dur√©e entre deux dates</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<ul>
<li><code>DATE()</code>/<code>TIME()</code>/<code>DATETIME()</code> : retourne la date et/ou l&#39;heure actuelle.</li>
<li><code>FORMAT_DATE($F, $D)</code>/<code>STRFTIME($F, $D)</code> : formate la date <code>$D</code> au format <code>$F</code> (cf TP2).</li>
<li><code>TIMEDIFF($a, $b)</code> : donne la dur√©e entre deux dates.</li>
<li><code>UNIXEPOCH($d)</code> : donne le nombre de secondes √©coul√©es entre le 1er janvier 1970 et la date <code>$d</code>.</li>
</ul>
<p>üí° Idem, il existe de nombreuses autres op√©rations et formatage sur les dates que nous ne verrons pas dans le cadre de ce cours.</p>
<p>‚ö† Les fonctions de dates ne sont pas normalis√©es et d√©pendent donc du SGBD utilis√©.</p>
<h3 id="sur-les-cha√Ænes-de-caract√®res">Sur les cha√Ænes de caract√®res</h3>
<p>D&#39;un utilisateur √† un autre, la casse des lettres dans les chaines de caract√®res est souvent inconsistante. Lorsque la casse importe peu quant √† l&#39;information stock√©e, il est alors fr√©quent de mettre la cha√Æne de caract√®re en minuscule (ou en majuscule) afin de pouvoir ensuite plus facilement les manipuler/comparer en s&#39;assurant de la consistance des donn√©es (e.g. e-mail, nom, etc.).</p>
<p>Les cha√Ænes de caract√®res sont g√©n√©ralement stock√©es sur des colonnes √† taille variables. Mais il arrive que pour des raisons d&#39;optimisations, elles soient stock√©es sur des colonnes √† tailles fixes. D√®s lors, pour stocker une cha√Æne de caract√®re d&#39;une taille moindre, on lui ajoutera g√©n√©ralement des espaces en d√©but ou fin de cha√Æne (<em>pad</em>). L&#39;op√©ration inverse consiste √† retirer les espaces en d√©but ou fin de cha√Æne (<em>trim</em>).</p>
<sql-interactive>
  <span slot="options" data-cols="LOWER('Hello'), UPPER('Hello')">Transformer la casse</span>
  <span slot="options" data-cols="LENGTH('23'), LENGTH(32)">Taille</span>
  <span slot="options" data-cols="TRIM(' w '), LTRIM(' w '), RTRIM(' w ')">Retirer les espaces en d√©but/fin</span>
  <span slot="options" data-cols="PRINTF('{x=%.2f, y=%.2f}', 1.2, 1.)">Formatter des donn√©es</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<ul>
<li><code>LOWER($W)</code>/<code>UPPER($W)</code> : transforme tous les caract√®res en minuscules/majuscules.</li>
<li><code>LENGTH($N)</code> : la taille de <code>$N</code>.</li>
<li><code>[L/R]TRIM($W)</code> : enl√®ve les espaces en d√©but et/ou fin de cha√Æne.</li>
<li><code>[L/R]PAD($W, $N, $C)</code> : l&#39;inverse de <code>[L/R]TRIM()</code>, ajoute des caract√®res <code>$C</code> en d√©but/fin de <code>$W</code>, de sorte √† avoir une cha√Æne de caract√®re de taille <code>$N</code>.<br/>
‚ö† Cette fonction n&#39;est pas disponible sur SQLite.</li>
<li><code>FORMAT($F, $T[,...])</code> : formate des donn√©es <code>$T</code> au format <code>$F</code> (cf TP2).<br/>
‚ö† Pour SQLite &lt; 3.38, cette fonction s&#39;appelle <code>PRINTF()</code>.</li>
</ul>
<p>Il existe bien d&#39;autres fonctions que nous ne verrons pas dans le cadre de ce cours :</p>
<details>
  <summary>
    <strong><em>Afficher les autres pr√©-traitements</em></strong>
  </summary>

<ul>
<li><code>REVERSE($W)</code> : inverse l&#39;ordre des caract√®res.</li>
<li><code>REPLACE($W, $S, $R)</code> : dans <code>$W</code>, remplace <code>$S</code> par <code>$R</code>.</li>
<li><code>SUBSTR($W, $B[, $L])</code> : retourne la sous-cha√Æne de <code>$W</code> commen√ßant √† l&#39;index <code>$B</code> et de taille <code>$L</code>.</li>
<li><code>LOCATE($W, $S)</code> : retourne l&#39;index √† laquelle se trouve <code>$S</code> dans <code>$W</code>.</li>
</ul>
</details>


<details>
  <summary>

<h2 id="autres-pr√©traitements-en-tp">Autres pr√©traitements (en TP)</h2>
  </summary>

<h3 id="sur-les-valeurs-nulles">Sur les valeurs nulles</h3>
<sql-interactive>
  <span slot="options" data-cols="NULL"></span>
  <span slot="options" data-cols="COALESCE(NULL, 4)"></span>
  <span slot="options" data-cols="COALESCE(NULL, NULL)"></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS;
</code></pre></sql-interactive>

<ul>
<li><code>COALESCE($args[,...])</code> : renvoie la premi√®re valeur non nulle (ou null si toutes nulles).</li>
</ul>
<h3 id="conversions">Conversions</h3>
<sql-interactive>
  <span slot="options" data-col_cast="'1.2' AS REAL">Convertir en r√©el</span>
  <span slot="options" data-col_cast="'1.2' AS INT">Convertir en entier</span>
  <span slot="options" data-col_cast="1.2 AS TEXT">Convertir en texte</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CAST</span>( $COL_CAST );
</code></pre></sql-interactive>

<ul>
<li><code>CAST($V AS $T)</code> : converti la valeur <code>$V</code> dans le type <code>$T</code>.<br/>
üí° <code>$T</code> sera ainsi g√©n√©ralement : <code>REAL</code>, <code>INT</code>/<code>INTEGER</code>, ou <code>TEXT</code>.</li>
</ul>
<p>üí° Il existe bien d&#39;autres fonctions de conversions plus ou moins sp√©cifiques aux SGBD.</p>
<h3 id="concat√©ner-des-colonnes">Concat√©ner des colonnes</h3>
<p>üí° Vous pouvez aussi concat√©ner des colonnes en utilisant l&#39;op√©rateur <code>||</code> :</p>
<sql-interactive>
  <span slot="options" data-col_concat="Nom">Nom</span>
  <span slot="options" data-col_concat="Nom || ' ' || Prenom">Nom Prenom</span>
  <span slot="options" data-col_concat="Nom || ' (' || Age || ')'">Nom (Age)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COL_CONCAT <span class="hljs-keyword">as</span> <span class="hljs-keyword">User</span> <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<p>‚ö† Attention √† ne pas abuser des concat√©nations. Il est bien souvent pr√©f√©rable de r√©cup√©rer des donn√©es structur√©es, puis de g√©rer leurs formatages et affichages via le langage utilis√© par votre application (e.g. Python, R, JavaScript, etc). Cela permet notamment de pouvoir r√©utiliser une m√™me requ√™te pour diff√©rents usages.</p>
<p>üí° Certains SGBD ont aussi des syst√®mes de cache, permettant de recalculer plus rapidement le r√©sultat d&#39;une requ√™te ex√©cut√©e fr√©quemment.</p>
<h3 id="conditions">Conditions</h3>
<p>De mani√®re <strong>rare</strong>, il est possible qu&#39;on souhaite effectuer des conditions.</p>
<sql-interactive>
  <span slot="options" data-age='2'>Utilisateur mineur</span>
  <span slot="options" data-age='20'>Utilisateur majeur</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">CASE</span>
  <span class="hljs-keyword">WHEN</span> Age <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>  <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;???&#x27;</span>
  <span class="hljs-keyword">WHEN</span> Age <span class="hljs-operator">&lt;</span> <span class="hljs-number">18</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;mineur&#x27;</span>
                <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;majeur&#x27;</span>
<span class="hljs-keyword">END</span>) <span class="hljs-keyword">as</span> Status <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> $Age <span class="hljs-keyword">as</span> Age);
</code></pre></sql-interactive>

<p>Le format est relativement simple :</p>
<ul>
<li>il commence par <code>(CASE</code> et fini par <code>END)</code>.</li>
<li><code>WHEN $COND THEN $VAL</code> retourne la valeur <code>$VAL</code> si <code>$COND</code> est √©valu√© √† vrai.</li>
<li><code>ELSE $VAL</code> est la valeur par d√©faut si aucune condition n&#39;est vraie.</li>
</ul>
<p>‚ö† Le <code>(SELECT $Age as Age)</code> n&#39;est l√† qu&#39;√† des fins de d√©monstrations, afin de vous permettre de modifier la valeur de l&#39;√¢ge. Pour le moment ignorez-le.</p>
<p>‚ö† Si vous utilisez fr√©quemment la clause <code>CASE</code> dans les <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> pour :</p>
<ul>
<li>calculer la valeur d&#39;une colonne d√©pendant d&#39;autres colonnes : est-il vraiment n√©cessaire de la stocker ?</li>
<li>transformer la valeur d&#39;une colonne : serait-il int√©ressant de plut√¥t stocker la valeur transform√©e ?</li>
</ul>
<details>
  <summary>
  
<h3 id="consid√©rations-de-s√©curit√©">Consid√©rations de s√©curit√©</h3>
  </summary>


<p>Il est possible de hasher certaines donn√©es avant de les ins√©rer dans la base de donn√©es. Cela peut par exemple √™tre utilis√© afin de rapidement comparer deux fichiers, ou de contr√¥ler l&#39;int√©grit√© d&#39;un fichier.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">INSERT</span>¬†<span class="hljs-keyword">INTO</span> Files <span class="hljs-keyword">VALUES</span> ($FILENAME, LENGTH($FILECONTENT), SHA256($FILECONTENT) );
<span class="hljs-keyword">SELECT</span> Filename, Filesize <span class="hljs-keyword">FROM</span> Files <span class="hljs-keyword">WHERE</span> Filehash <span class="hljs-operator">=</span><span class="hljs-operator">=</span> SHA256($FILECONTENT);
</code></pre><p>‚ö† La fonction <code>SHA256($D)</code> permet de hasher les donn√©es <code>$D</code> pass√©es en param√®tre. Elle n&#39;est cependant pas disponible dans tous les SGBD. Sur SQLite, elle requi√®re d&#39;installer une extension.</p>
<p>‚ö† Il faut imp√©rativement hasher ou chiffrer les donn√©es sensibles <strong>AVANT</strong> de les transmettre √† la requ√™te SQL. En effet, si vous hashez/chiffrez des donn√©es sensibles √† l&#39;int√©rieur m√™me d&#39;une requ√™te SQL, il y a de fortes chances qu&#39;elles soient ensuite stock√©es en clair dans les logs du SGBD...</p>
<p>üí° Vous approfondirez les questions de chiffrement et de hashage dans d&#39;autres modules.</p>
</details>

</details>

<h2 id="agr√©gation">Agr√©gation</h2>
<p>Une agr√©gation permet de regrouper, au sein d&#39;une m√™me ligne, plusieurs entr√©es, e.g. pour obtenir la liste des nombres de produits vendus, par dates ou par produits : </p>
<sql-interactive>
  <span slot="options" data-grp='Ref'>Agr√©g√© par r√©f√©rences</span>
  <span slot="options" data-grp='Date'>Agr√©g√© par dates</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, GROUP_CONCAT(Q)
  <span class="hljs-keyword">FROM</span> Produits <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP;
</code></pre></sql-interactive>

<p>Pour cela, on utilise la clause <code>GROUP BY $COLS[,...]</code> qui permet de fusionner, au sein d&#39;une m√™me ligne, les entr√©es dont les valeurs de <code>$COLS[,...]</code> sont √©gales. Vous trouverez ci-dessous une repr√©sentation visuelle d&#39;une agr√©gation :</p>
<div style="display:flex;justify-content: space-around;width:100%">
  <sql-dymtable table="Produits"></sql-dymtable>
  <sql-dymtable id="group-date" table="Produits" header="Group by Date"></sql-dymtable>
  <sql-dymtable id="group-ref"  table="Produits" header="Group by Ref"></sql-dymtable>
</div>

<script type="module">

  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const gdate_table = await LISS.qs("#group-date");
  const  gref_table = await LISS.qs("#group-ref");

  gdate_table.groupBy("Date");
   gref_table.groupBy("Ref");


/*  const rowsql   = await LISS.qs("#row-sql");

  rowsql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update( rowsql.lastDatas );

  function update(datas) {

    const ids = datas[0].map(r => r.ID);

    rowtable.highlightRow( (ID) => ids.includes(+ID) );
  }*/
</script>

<p>Vous remarquerez alors que les lignes contiennent plusieurs valeurs pour une m√™me colonne. Il convient alors d&#39;utiliser une <strong>fonction d&#39;agr√©gation</strong> qui prendra la liste des valeurs et retournera une valeur unique. Par exemple, <code>GROUP_CONCAT(Q)</code> concat√®ne, pour chaque ligne, la colonne <code>Q</code> de ses entr√©es :</p>
<sql-interactive>
  <span slot="options" data-op='GROUP_CONCAT(Q)' data-grp="Ref">Concat√©nation</span>
  <span slot="options" data-op='SUM(Q)' data-grp="Date">Somme</span>
  <span slot="options" data-op='AVG(Q)' data-grp="Ref">Moyenne</span>
  <span slot="options" data-op='MIN(Q)' data-grp="Date">Minimum</span>
  <span slot="options" data-op='MAX(Q)' data-grp="Date">Maximum</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, $OP
  <span class="hljs-keyword">FROM</span> Produits <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP;
</code></pre></sql-interactive>

<ul>
<li><code>GROUP_CONCAT($COL)</code> : concat√®ne les valeurs.</li>
<li><code>SUM($COL)</code>/<code>TOTAL($COL)</code> :¬†fait la somme des valeurs.</li>
<li><code>AVG($COL)</code> : fait la moyenne des valeurs.</li>
<li><code>MIN($COL)</code> : retourne la valeur minimale.</li>
<li><code>MAX($COL)</code> : retourne la valeur maximale.</li>
</ul>
<p>üí° Par d√©faut, en l&#39;absence d&#39;une fonction d&#39;agr√©gation, SQL retourne la premi√®re valeur.</p>
<p>üí° Par d√©faut, si une fonction d&#39;agr√©gation est utilis√©e sans clause <code>GROUP BY</code>, alors toutes les entr√©es sont regroup√©es dans la m√™me ligne.</p>
<h3 id="compter-les-lignesentr√©es">Compter les lignes/entr√©es</h3>
<p><todo>Improve example</todo></p>
<p>üí° Il est aussi possible de compter les entr√©es/valeurs de chaque lignes :</p>
<sql-interactive>
  <span slot="options" data-op='COUNT(*)' data-grp="Date">Compte le nombre d'entr√©es</span>
  <span slot="options" data-op='COUNT(Q)' data-grp="Date">Compte les valeurs non-nulles</span>
  <span slot="options" data-op='COUNT(DISTINCT Q)' data-grp="Date">Compte les valeurs distinctes</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, $OP
  <span class="hljs-keyword">FROM</span> Produits <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP;
</code></pre></sql-interactive>

<ul>
<li><code>COUNT(*)</code> : compte le nombre d&#39;entr√©es.</li>
<li><code>COUNT($COL)</code> : compte le nombre de valeurs non-nulles.</li>
<li><code>COUNT(DISTINCT $COL)</code> : permet de ne pas compter les doublons.</li>
</ul>
<h3 id="conditions-sur-les-agr√©gations">Conditions sur les agr√©gations</h3>
<p>Jusqu&#39;√† pr√©sent, nous utilisions la clause <code>WHERE</code> pour s√©lectionner les entr√©es √† r√©cup√©rer. Cependant, la clause <code>WHERE</code> filtre les entr√©es <strong>avant</strong> leur agr√©gation au sein d&#39;une m√™me ligne. Ainsi, l&#39;usage d&#39;une fonction d&#39;agr√©gation dans sa condition g√©n√©rera un message d&#39;erreur :</p>
<sql-interactive>
  <span slot="options" data-aggr=""    data-cond=">=10" data-cols="Q">Retirer des entr√©es avant agr√©gation</span>
  <span slot="options" data-aggr=""    data-cond=">=20" data-cols="Q">Retirer des entr√©es avant agr√©gation</span>
  <span slot="options" data-aggr="SUM" data-cond=">=20" data-cols="Q">Fonction d'agr√©gation g√©n√®re erreur</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">Date</span>, group_concat($COLS) <span class="hljs-keyword">FROM</span> Produits
  <span class="hljs-keyword">WHERE</span> $AGGR($COLS) $COND
  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-type">Date</span>;
</code></pre></sql-interactive>

<p>Pour filtrer les lignes <strong>apr√®s</strong> l&#39;agr√©gation, il convient alors d&#39;utiliser la clause <code>HAVING $COND</code> :</p>
<sql-interactive>
  <span slot="options" data-grp='Date' data-lcondp="" data-lcond="SUM(Q)" data-rcond =">= 0">Sans alias d'agr√©gat</span>
  <span slot="options" data-grp='Date' data-lcondp="SUM(Q) as" data-lcond="Total" data-rcond =">= 30">Lignes dont la somme est >= 30</span>
  <span slot="options" data-grp='Date' data-lcondp="SUM(Q) as" data-lcond="Total" data-rcond =">= 50">Lignes dont la somme est >= 50</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $GRP, $LCONDP $LCOND <span class="hljs-keyword">FROM</span> Produits
  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> $GRP <span class="hljs-keyword">HAVING</span> $LCOND $RCOND;
</code></pre></sql-interactive>


<h1 id="tables-et-contraintes">Tables et contraintes</h1>
<h2 id="sch√©mas-de-tables">Sch√©mas de tables</h2>
<p>La structure d&#39;une table, appel√©e <strong>sch√©mas</strong>, est constitu√©e du nom et du type de chaque colonne :</p>
<sql-interactive>
  <span slot="options" data-tablename="'Users'">Sch√©ma de la table Users</span>
  <span slot="options" data-tablename="'Produits'">Sch√©ma de la table Produits</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span>
pragma_table_xinfo($TABLENAME);
</code></pre></sql-interactive>

<ul>
<li><code>cid</code> est l&#39;identifiant de la colonne.</li>
<li><code>name</code> est le nom de la colonne.</li>
<li><code>type</code> est le type de donn√©es stock√©es dans la colonne.</li>
<li><code>notnull</code> indique si la colonne peut contenir des valeurs <code>NULL</code>.</li>
<li><code>dflt_value</code> est la valeur par d√©faut de la colonne (i.e. valeur ins√©r√©e si non sp√©cifi√©e lors de l&#39;insertion).</li>
<li><code>pk</code> indique si la colonne fait partie d&#39;une cl√© primaire (cf suite du cours).</li>
<li><code>hidden</code> indique si la colonne est g√©n√©r√©e (cf suite du cours)</li>
</ul>
<p>‚ö† La mani√®re d&#39;afficher le sch√©ma d&#39;une table diff√®re d&#39;un SGBD √† l&#39;autre :</p>
<table>
  <thead>
    <tr>
      <th>SGBD</th>
      <th>Commande</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SQLite</td>
      <td>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pragma_table_xinfo($TABLENAME);
</code></pre></td>
    </tr><tr>
      <td>PostgreSQL</td>
      <td>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.columns 
<span class="hljs-keyword">WHERE</span> table_name <span class="hljs-operator">=</span><span class="hljs-operator">=</span> $TABLENAME;
</code></pre></td>
    </tr><tr>
      <td>MySQL</td>
      <td>

<pre><code class="hljs language-sql"><span class="hljs-keyword">DESCRIBE</span> $TABLENAME;  
</code></pre></td>
    </tr>
  </tbody>
</table>

<h2 id="op√©rations-sur-les-tables">Op√©rations sur les tables</h2>
<p>Jusqu&#39;√† pr√©sent, nous avons √©crit des requ√™tes SQL pour r√©cup√©rer, ins√©rer, modifier, et supprimer des entr√©es d&#39;une table. De mani√®re analogue est aussi possible de cr√©er, modifier, et supprimer des tables via des commandes SQL :</p>
<ul>
<li><code>CREATE TABLE</code> : cr√©er une table ;</li>
<li><code>ALTER TABLE</code> : modifier une table ;</li>
<li><code>TRUNCATE TABLE</code> : supprimer toutes les entr√©es d&#39;une table ;</li>
<li><code>DELETE TABLE</code> : supprimer une table.</li>
</ul>
<h3 id="cr√©ation-dune-table">Cr√©ation d&#39;une table</h3>
<p>La requ√™te SQL <code>CREATE¬†TABLE</code> permet de cr√©er une nouvelle table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF¬†<span class="hljs-keyword">NOT</span>¬†<span class="hljs-keyword">EXISTS</span>]¬†$TABLENAME ($COLNAME $COLTYPE[,...]);
</code></pre><ul>
<li><code>$COLNAME</code> est le nom de la colonne ;</li>
<li><code>$COLTYPE</code> est le type des donn√©es stock√©es dans la colonne.</li>
</ul>
<p>‚ö† Si vous utilisez SQLite, il faut ajouter <code>STRICT</code> √† la fin de la requ√™te SQL afin de le forcer √† v√©rifier les types des colonnes lors des op√©rations sur la table.</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-m_cols="(Ref TEXT, Q INT)" data-m_vals="('Crayon', 4)">Cr√©ation d'une table</span>
  <span slot="options" data-m_cols="(Ref TEXT, Q INT)" data-m_vals="(4, 'Crayon')">Violation contrainte de type</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T
      $M_COLS STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> T <span class="hljs-keyword">VALUES</span>
      $M_VALS;
</code></pre></sql-interactive>

<h4 id="if-not-exists">IF¬†NOT¬†EXISTS</h4>
<p>Si la table existe d√©j√†, une erreur sera lanc√©e. Pour √©viter cela, vous pouvez ajouter la clause <code>IF¬†NOT¬†EXISTS</code> qui cr√©era la table seulement si elle n&#39;existe pas.</p>
<p>‚ö† Apr√®s un <code>IF¬†NOT¬†EXISTS</code>, la table ne sera pas n√©cessairement vide. Si vous avez besoin que la table soit vide, utilisez une requ√™te <code>TRUNCATE TABLE</code> (cf suite du cours).</p>
<p>‚ö† Si le sch√©ma de table du <code>IF¬†NOT¬†EXISTS</code> est diff√©rent de la table existante, aucune erreur ne sera lanc√©e.</p>
<sql-interactive>
  <span slot="options" data-ifexists="">Re-cr√©ation d'une table</span>
  <span slot="options" data-ifexists="IF NOT EXISTS">Avec IF NOT EXISTS</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T
      (<span class="hljs-type">Date</span> TEXT) STRICT;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> $IFEXISTS T
      (<span class="hljs-type">Date</span> <span class="hljs-type">INT</span>) STRICT;
</code></pre></sql-interactive>

<h4 id="create-table-as">CREATE¬†TABLE¬†AS</h4>
<p>üí° Vous pouvez aussi cr√©er et remplir une nouvelle table √† partir du r√©sultat d&#39;une requ√™te <code>SELECT</code>.</p>
<sql-interactive>
  <span slot="select">SELECT * FROM T;</span>
  <span slot="options" data-cols="*" data-tablename="Produits" data-cond="1==1"></span>
  <span slot="options" data-cols="Date, Q" data-tablename="Produits" data-cond="Ref == 'Gomme'"></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T <span class="hljs-keyword">AS</span>
    <span class="hljs-keyword">SELECT</span> $COLS
    <span class="hljs-keyword">FROM</span> $TABLENAME
    <span class="hljs-keyword">WHERE</span> $COND;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T;
</code></pre></sql-interactive>

<p>‚ö† Sur SQLite, les tables cr√©√©es de cette mani√®re ne sont pas <code>STRICT</code>.</p>
<h4 id="exemples">Exemples</h4>
<p>üí° Pour r√©f√©rences, les requ√™tes SQL utilis√©es pour cr√©er les tables des exemples peuvent √™tre visualis√©es ci-dessous :</p>
<sql-interactive>
  <span slot="options" data-tablename="'Produits'">CREATE TABLE pour Produits</span>
  <span slot="options" data-tablename="'Users'">CREATE TABLE pour Users</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">sql</span> <span class="hljs-keyword">FROM</span> sqlite_schema
<span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span><span class="hljs-operator">=</span> $TABLENAME;
</code></pre></sql-interactive>

<h3 id="suppression-dune-table">Suppression d&#39;une table</h3>
<p>Les requ√™tes SQL <code>DROP TABLE</code> et <code>TRUNCATE TABLE</code> permettent, respectivement, de supprimer et de vider une table existantes, et se pr√©sentent usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span>¬†[IF¬†<span class="hljs-keyword">EXISTS</span>] $TABLENAME;
<span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span>¬†$TABLENAME;
</code></pre><sql-interactive>
  <span slot="select">SELECT name, type, "notnull", dflt_value, pk, hidden
        FROM pragma_table_xinfo('Produits');
SELECT COUNT(*) as "NB ENTRIES" FROM Produits;</span>
  <span slot="options" data-command="DROP TABLE">Suppression de la table</span>
  <span slot="options" data-command="DELETE FROM">Suppression des entr√©es</span>

<pre><code class="hljs language-sql">$COMMAND Produits;
</code></pre></sql-interactive>

<p>üí° Dans certains SGBD, <code>DROP¬†TABLE</code> supporte une clause <code>IF¬†EXISTS</code>. Ainsi, si vous souhaitez cr√©er une table vide, vous pouvez la <code>DROP¬†TABLE¬†IF¬†EXISTS</code> avant sa cr√©ation pour vous assurer de la construire correctement.</p>
<p>‚ö† <code>TRUNCATE TABLE</code> n&#39;existe pas sur SQLite. Il vous faut alors utiliser <code>DELETE¬†FROM $TABLENAME;</code> √† la place.</p>
<h3 id="modification-dune-table">Modification d&#39;une table</h3>
<p>La requ√™te SQL <code>ALTER TABLE</code> permet de modifier une table, et se pr√©sente usuellement sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span>¬†<span class="hljs-keyword">TABLE</span>¬†$TABLENAME (RENAME<span class="hljs-operator">|</span><span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span>) <span class="hljs-keyword">COLUMN</span> $OPT;
</code></pre><ul>
<li><code>RENAME</code> renomme une colonne (<code>$OPT</code> = <code>$OLD_COLNAME TO $NEW_COLNAME</code>).</li>
<li><code>ADD</code> ajoute une colonne (<code>$OPT</code> = <code>$COLNAME¬†$COLTYPE</code>).</li>
<li><code>DROP</code> supprime une colonne (<code>$OPT</code> = <code>$COLNAME</code>).</li>
</ul>
<sql-interactive>
  <span slot="select">SELECT name, type, "notnull", dflt_value, pk, hidden
        FROM pragma_table_xinfo('Produits');</span>
  <span slot="options" data-command="RENAME" data-opts="Ref TO Prod">Renommer une colonne</span>
  <span slot="options" data-command="ADD" data-opts="Sum INT">Ajouter une colonne</span>
  <span slot="options" data-command="DROP" data-opts="Date">Supprimer une colonne</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Produits
  $COMMAND <span class="hljs-keyword">COLUMN</span> $OPTS;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Produits;
</code></pre></sql-interactive>

<p>‚ö† Renommer ou supprimer la colonne d&#39;une table n&#39;est pas anodin. En effet, si ces colonnes sont utilis√©es ailleurs, e.g. dans des requ√™tes SQL, ces derni√®res ne fonctionneront plus correctement.</p>
<p>üí° Certains SGBD supportent des clauses <code>IF¬†EXISTS</code> et <code>IF¬†NOT¬†EXISTS</code> sur les colonnes.</p>
<p>üí° Vous pouvez aussi renommer une table avec la commande SQL suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>¬†$OLD_TABLENAME RENAME¬†<span class="hljs-keyword">TO</span>¬†$NEW_TABLENAME;
</code></pre><h2 id="les-contraintes">Les contraintes</h2>
<p>Afin de garantir la coh√©rence et consistence des tables, il est possible de d√©finir des contraintes sur les colonnes, ainsi que sur les tables. Par exemple, il est possible de d√©finir des contraintes sur des colonnes &quot;num√©ro de t√©l√©phone&quot;, &quot;adresse e-mail&quot;, etc. pour s&#39;assurer que les donn√©es stock√©es suivent bien le format d&#39;un num√©ro de t√©l√©phone ou d&#39;une adresse mail. </p>
<p>üí° L&#39;assurance de la structure des donn√©es stock√©es et manipul√©es constitue un des avantages majeurs des bases de donn√©es SQL.</p>
<h3 id="contraintes-sur-les-colonnes">Contraintes sur les colonnes</h3>
<p>Lors de la cr√©ation de la table, il est possible de sp√©cifier des contraintes sur des colonnes. Pour ce faire, on ajoute le(s) contrainte(s) apr√®s le type de la colonne :</p>
<sql-interactive>
  <span slot="select">SELECT * FROM T;</span>
  <span slot="options" data-cstrnt="DEFAULT 'D'" data-vals="(1)" data-cols='(A)' >Valeur par d√©faut</span>
  <span slot="options" data-cstrnt="NOT NULL" data-vals="(1, NULL)">Valeur non-nulle</span>
  <span slot="options" data-cstrnt="UNIQUE" data-vals="(1, 2), (1, 2)">Valeur unique</span>
  <span slot="options" data-cstrnt="CHECK(B == UPPER(B) )" data-vals="(1, 'Nom')" >Condition sur la valeur</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T ( A TEXT,
    B TEXT $CSTRNT
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T $COLS <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<ul>
<li><code>DEFAULT $VAL</code> : valeur par d√©faut si non renseign√©e lors d&#39;un <code>INSERT</code>.</li>
<li><code>NOT NULL</code> : la valeur ne peut pas √™tre <code>NULL</code>.</li>
<li><code>UNIQUE</code> : il ne peut pas y avoir deux valeurs identiques dans la colonne.<br/>
‚ö† La colonne peut contenir plusieurs valeurs <code>NULL</code>.</li>
<li><code>CHECK($COND)</code> : la valeur de la colonne doit respecter la condition <code>$COND</code>.</li>
</ul>
<h3 id="contraintes-sur-la-table">Contraintes sur la table</h3>
<p>Les contraintes <code>UNIQUE</code> et <code>CHECK</code> peuvent d√©pendre de plusieurs colonnes. Dans ce cas, la contrainte est ajout√©e apr√®s la liste des colonnes :</p>
<sql-interactive>
  <span slot="options" data-cstrnt="UNIQUE(A,B)" data-vals="(1, 2), (1, 2)">Colonnes uniques</span>
  <span slot="options" data-cstrnt="CHECK(B != A)" data-vals="(1, 1)" >Condition</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    A TEXT, B TEXT,
    $CSTRNT
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<h3 id="colonnes-g√©n√©r√©es">Colonnes g√©n√©r√©es</h3>
<p>Il est possible de g√©n√©rer la valeur d&#39;une colonne √† partir des valeurs d&#39;autres colonnes gr√¢ce √† la contrainte <code>AS</code> :</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-cstrnt="(PU*Q )" data-vals="(1,2), (3,4)">Colonne g√©n√©r√©e virtuelle</span>
  <span slot="options" data-cstrnt="(PU*Q) STORED" data-vals="(1,2), (3,4)">Colonne g√©n√©r√©e stock√©e</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    PU <span class="hljs-type">INT</span>, Q <span class="hljs-type">INTEGER</span>,
    T <span class="hljs-type">INT</span> <span class="hljs-keyword">AS</span> $CSTRNT
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° <code>STORED</code> signifie que la valeur sera calcul√©e lors des insertions/modifications puis stock√©es. Si absent, la valeur sera recalcul√©e √† chaque acc√®s.</p>
<h2 id="les-index">Les index</h2>
<p>Il est fr√©quent de vouloir r√©cup√©rer une entr√©e √† partir d&#39;un identifiant donn√©. Cependant, s&#39;il faut √† chaque fois parcourir toutes les entr√©es de la table unes √† unes, cela peut s&#39;av√©rer relativement lent sur de grandes tables.</p>
<p>Un <strong>index</strong> est une structure permettant de trouver tr√®s rapidement la/les entr√©e(s) associ√©e(s) √† un tel identifiant.</p>
<p>üí° Lorsqu&#39;une colonne a la contrainte <code>UNIQUE</code>, il est fr√©quent que le SGBD cr√©√© automatiquement un index.</p>
<h3 id="les-clefs-primaires-pk">Les clefs primaires (PK)</h3>
<p>Une clef primaire est un index un peu sp√©cial acc√©l√©rant encore plus les recherches d&#39;entr√©es √† partir d&#39;un identifiant. Il est un champ (ou un ensemble de champs) identifiant de mani√®re unique une entr√©e.</p>
<p>Elle est cr√©√©e via une contrainte <code>PRIMARY KEY</code> et implique les contraintes <code>UNIQUE¬†NOT¬†NULL</code>. Il ne peut y avoir qu&#39;une clef primaire par table.</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-pk="TEXT PRIMARY KEY" data-vals="('1'), ('2')">Cl√© primaire (texte)</span>
  <span slot="options" data-pk="TEXT PRIMARY KEY" data-vals="('1'), ('1')">Cl√© primaire (dupliqu√©e)</span>
  <span slot="options" data-pk="INTEGER
      PRIMARY KEY AUTOINCREMENT" data-vals="(NULL), (NULL)">Cl√© primaire (auto-incr√©ment)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    K $PK
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° La contrainte <code>AUTOINCREMENT</code> permet d&#39;automatiquement incr√©menter la clef primaire des entr√©es ins√©r√©es. Elle ne peut √™tre utilis√©e que sur une colonne <code>INTEGER¬†PRIMARY¬†KEY</code>.</p>
<p>üí° Comme avec la contrainte <code>UNIQUE</code>, il est aussi possible de cr√©er une clef primaire sur plusieurs colonnes via contrainte de table :</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;</span>
  <span slot="options" data-pk="PRIMARY KEY(ID, CODE)" data-vals="(1, 'E')">Cl√© primaire (multi-cols)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (
    ID <span class="hljs-type">INT</span>, CODE TEXT,
    $PK
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° Certains SGBD cr√©√©ent automatiquement, pour chaque table, une clef primaire cach√©e nomm√©e <code>ROWID</code>.</p>
<h3 id="les-clefs-√©trang√®res-fk">Les clefs √©trang√®res (FK)</h3>
<p>Il est fr√©quent, dans une base de donn√©es, que des entr√©es fassent r√©f√©rence √† des entr√©es d&#39;une autre table. Par exemple, une table <code>Vente</code> pourra mettre en relation une table <code>Vendeur</code> et une table <code>Client</code>.</p>
<p>üí° Le terme de &quot;base de donn√©es relationnelles&quot; vient en partie de l√† : on √©tablie des relations entre diff√©rentes entr√©es/donn√©es. Ceci constitue une des fonctionnalit√©s majeurs des bases de donn√©es SQL.</p>
<p>Pour cela, on utilise une clef √©trang√®re (FK) qui est un moyen l√©ger en m√©moire (et en performances) de r√©f√©rencer les donn√©es d&#39;une table r√©f√©renc√©e. Elle est compos√©e d&#39;une ou plusieurs colonnes r√©f√©ren√ßant une ou plusieurs colonnes de contraine <code>UNIQUE</code> ou <code>PRIMARY¬†KEY</code>. On l&#39;indique via une contrainte de table sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">FOREIGN</span> KEY($COLS_FK[,...]) <span class="hljs-keyword">REFERENCES</span> $T
<span class="hljs-keyword">FOREIGN</span> KEY($COLS_FK[,...]) <span class="hljs-keyword">REFERENCES</span> $T($COLS_PK[,...])
</code></pre><ul>
<li><code>$T</code> est la table r√©f√©renc√©e.</li>
<li><code>$COL_FK</code> sont les colonnes constituant la cl√© √©trang√®re.</li>
<li><code>$COL_PK</code> sont les colonnes r√©f√©renc√©es.</li>
</ul>
<p>üí° Si la/les colonne(s) de la table r√©f√©renc√©e ne sont pas sp√©cifi√©es, la/les colonne(s) de la clef primaire sont utilis√©e(s).</p>
<sql-interactive>
  <span slot='select'>SELECT * FROM T;
SELECT * FROM Users;</span>
  <span slot="options" data-fk="FOREIGN KEY(ID)
    REFERENCES Users" data-vals="(1, 'E')">Clef √©trang√®re existante</span>
  <span slot="options" data-fk="FOREIGN KEY(ID)
    REFERENCES Users" data-vals="(4, 'E')">Clef √©trang√®re non-existante</span>
  <span slot="options" data-fk="FOREIGN KEY(ID)
    REFERENCES Users" data-vals="(NULL, 'E')">Clef √©trang√®re nulle</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T (ID <span class="hljs-type">INT</span>, C TEXT,
    $FK
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span>  T <span class="hljs-keyword">VALUES</span>
    $VALS;
</code></pre></sql-interactive>

<p>üí° La cl√© √©trang√®re peut √™tre nulle (sauf si contrainte <code>NOT¬†NULL</code>).</p>
<p>üí° On pr√©f√®re souvent nommer la/les colonne(s) de la clef √©trang√®res avec les noms de la/les colonne(s) r√©f√©renc√©e(s).</p>
<p>‚ö† La v√©rification des clefs √©trang√®res n&#39;est pas activ√© par d√©faut sur SQLite. La commande <code>PRAGMA foreign_keys = ON</code> permet de l&#39;activer.</p>
<h3 id="uml">UML</h3>
<p>Les bases de donn√©es ont g√©n√©ralement de tr√®s nombreuses tables. Il est alors difficile de se faire une id√©e de sa structure, du sch√©ma des tables et de leurs relations, sans une repr√©sentation appropri√©e. Pour cela on utilise soit un diagramme UML, soit un diagramme Merise. Le dernier √©tant tr√®s franco-fran√ßais, nous nous concentrerons sur le premier.</p>
<p>Dans un diagramme UML, chaque table est repr√©sent√©e par un rectangle d√©coup√© en 3 cadres contenant :</p>
<ul>
<li>le nom de la table ;</li>
<li>les colonnes de la table ;</li>
<li>les contraintes de la table.</li>
</ul>
<p>Par convention, les noms de colonnes sont formatt√©s comme suit :</p>
<ul>
<li>en gras pour les clefs primaires ;</li>
<li>en italique pour les clefs √©trang√®res ;</li>
<li>soulign√©s pour les colonnes uniques.</li>
</ul>
<p>Une fl√®che est aussi tir√©e des clefs √©trang√®res jusqu&#39;aux clefs primaires qu&#39;elles r√©f√©rencent.</p>
<p>üí° En fonction des besoins, il est possible d&#39;ajouter plus ou moins de d√©tails, comme e.g. les types et contraintes de colonnes.</p>
<sql-interactive id="uml-sql">
  <span slot="options" data-pk="ID" data-fk="ID" data-cols_a="ID INT, CODE TEXT" data-cols_b="ID INT, CODE TEXT">Clef primaire (uni-col)</span>
  <span slot="options" data-pk="ID, CODE" data-fk="ID, CODE" data-cols_a="CODE TEXT, X INT, ID INT" data-cols_b="ID INT, CODE TEXT">Clef primaire (multi-cols)</span>
  <!-- TODO: LISS -->
  <pre id="uml" slot="post" class="hljs">
    <code>
      <div class="output"></div>
    </code>
  </pre>

<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> A (
    $COLS_A,
    <span class="hljs-keyword">PRIMARY</span> KEY($PK)
  ) STRICT;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> B (
    $COLS_B,
    <span class="hljs-keyword">FOREIGN</span> KEY($FK)
    <span class="hljs-keyword">REFERENCES</span> B
  ) STRICT;
</code></pre></sql-interactive>

<!-- test -->

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const uml_output = document.querySelector("#uml .output");
  //await LISS.qs("#col-table");
  const umlsql   = await LISS.qs("#uml-sql");

  umlsql.host.addEventListener("change", (ev) => {
    console.warn( umlsql.lastVars );
    update( umlsql.lastVars );
  });
  update( umlsql.lastVars );

  function update({cols_a, cols_b, fk, pk}) {

    fk = fk.split(',').map( k => k.trim() );
    pk = pk.split(',').map( k => k.trim() );

    function buildTable(cols, hcols, isPK) {
      let content = [];

      const hmethod = isPK ? "strong" : "em";

      let max_w  = 0;
      let max_nw = 0;
      let max_cw = 0;

      const cnstr = `${isPK ? "PK" : "FK"}(${(isPK ? pk : fk).join(', ')})`;
      max_w = cnstr.length;

      cols = cols.split(',').map( l => {
          l = l.trim();
          const pos = l.indexOf(' ');
          const colname = l.slice(0, pos);
          const constrainst = l.slice(pos+1);

          const nw = colname.length;
          const cw = constrainst.length;
          if( nw > max_nw)
            max_nw = nw;
          if( cw > max_cw)
            max_cw = cw;

          return [colname, constrainst];
      });

      if( max_w > max_nw + max_cw)
        max_cw = max_w - max_nw;
      if( max_w < max_nw + max_cw )
        max_w = max_nw + max_cw;


      let prefix = "";
      let suffix = "";

      if( isPK )
        suffix = "   ";
      else
        prefix = "   ";


      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);
      const lpad_len = Math.floor( (max_w+2-1)/2);
      let lpad = "".padEnd(lpad_len);
      let rpad = "".padEnd(max_w+2-1 - lpad_len);
      content.push(`${prefix}| ${lpad}<strong>${(isPK ? "A" : "B")}</strong>${rpad} |${suffix}`);
      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);

      for(let col of cols) {

        let w = max_w;

        let lsuffix = suffix;
        let lprefix = prefix

        let colname = col[0].padEnd(max_nw);

        if( hcols.includes(col[0]) ) {
          colname = `<${hmethod}>${colname}</${hmethod}>`;

          if( isPK )
            lsuffix = "<--";
          else
            lprefix = "---";
        }
        
        const line = `${colname}: ${col[1].padEnd(max_cw)}`;
        content.push(`${lprefix}| ${line} |${lsuffix}`);
      }

      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);
      content.push(`${prefix}| ${cnstr.padEnd(max_w+2)} |${suffix}`);
      content.push(`${prefix}+-${"".padEnd(max_w+2, "-")}-+${suffix}`);

      return content;
    }

    let tA = buildTable(cols_a, pk, true);
    let tB = buildTable(cols_b, fk, false);

    if( tB.length > tA.length) {
      tA.push(... new Array(tB.length - tA.length).fill("".padEnd(tA[0].length)) );
    }
    if( tA.length > tB.length) { // just to simplify code.
      tB.push(... new Array(tA.length - tB.length).fill("".padEnd(tB[0].length)) );
    }

    let start_idx, end_idx;
    for(let i = 0; i < tA.length; ++i) {
      const idx = tA[i].length-1;
      if(tA[i][idx] === "-" || tB[i][0] === "-") {
        start_idx = i;
        break;
      }
    }
    for(let i = tA.length - 1; i >= 0 ; --i) {
      const idx = tA[i].length-1;
      if(tA[i][idx] === "-" || tB[i][0] === "-") {
        end_idx = i;
        break;
      }
    }

    let content = "";
    for(let i = 0; i < tA.length; ++i) {

      let sep = "   ";

      if( pk.length === 1 && fk.length === 1) { // unique.
        if(start_idx === end_idx) {
          if(i === start_idx)
            sep = "---";
        } else {
          if(i === start_idx || i === end_idx) {
            if(tA[i][ tA[i].length - 1 ] !== " ")
              sep = "-+ ";
            else
              sep = " +-";
          }
          if( i > start_idx && i < end_idx)
            sep = " | ";
        }
      }

      if( pk.length > 1 || fk.length > 1) { // 1 vs N and N vs 1 shouldn't occur ?
        if( i >= start_idx && i <= end_idx) {

          sep = [" ", "|", "¬†"];

          if(tA[i][ tA[i].length - 1 ] !== " ") {
            sep[0] = "-";
            sep[1] = "+";
          }
          if(tB[i][0] !== " ") {
            sep[1] = "+";
            sep[2] = "-";
          }

          sep = sep.join("");
        }
      } 

      content += `${tA[i]}${sep}${i < tB.length ? tB[i] : ""}\n`;
    }

    uml_output.innerHTML = content;
  }

</script>

<h2 id="op√©rations-sur-table-avec-contraintes">Op√©rations sur table avec contraintes</h2>
<h3 id="modificationsuppression-sur-des-colonnes-r√©f√©renc√©es">Modification/Suppression sur des colonnes r√©f√©renc√©es</h3>
<p>Comme nous l&#39;avons vu √† la section pr√©c√©dente, une clef √©trang√®re r√©f√©rence des colonnes d&#39;une autre table. Mais que se passe-t-il lorsqu&#39;on modifie ou supprime des entr√©es dans les colonnes r√©f√©renc√©es ?</p>
<p>C&#39;est √† vous de le d√©finir via les clauses <code>ON DELETE $POLICY</code> et <code>ON UPDATE $POLICY</code> sur la clef √©trang√®re :</p>
<sql-interactive full-reset="true">
  <span slot='select'>SELECT * FROM T3;</span>
  <span slot="options" data-pol="RESTRICT">Emp√™cher la suppression</span>
  <span slot="options" data-pol="CASCADE">Supprimer l'entr√©e</span>
  <span slot="options" data-pol="SET NULL">Mettre la colonne √† NULL</span>


<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T3 (
    ID <span class="hljs-type">INT</span>, A TEXT,
    <span class="hljs-keyword">FOREIGN</span> KEY(ID) <span class="hljs-keyword">REFERENCES</span> T1
    <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> $POL
  ) STRICT;
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> T3 <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;A&#x27;</span>);
<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">WHERE</span> ID <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
</code></pre></sql-interactive>

<ul>
<li><code>RESTRICT</code>: emp√™che la modification/suppression si les valeurs sont r√©f√©renc√©es par une clef √©trang√®re.</li>
<li><code>CASCADE</code> : modifie/supprime la clef √©trang√®re lorsque des valeurs des colonnes r√©f√©renc√©es sont modifi√©es.</li>
<li><code>SET NULL|DEFAULT</code> : modifie la clef √©trang√®re lorsque des valeurs des colonnes r√©f√©renc√©es sont modifi√©es.</li>
</ul>
<details>
  <summary>

<h3 id="merge--mettre-√†-jour-si-existe-sinon-ins√©rer-en-td-">Merge : mettre √† jour si existe, sinon ins√©rer (en TD ?).</h3>
</summary>

<p><todo>R√©diger</todo></p>
<p>En gros la probl√©matique est d&#39;ajouter si inexistant, et de modifier si existant.</p>
<p>On peut faire un select, puis refaire une requ√™te pour update ou insert, mais c&#39;est pas pratique de faire plusieurs requ√™tes.</p>
<p>On a des choses comme REPLACE (MySQL) supprime l&#39;entr√©e si elle existe, puis ajoute la nouvelle. Sauf que s&#39;il y a des clefs primaires r√©f√©renc√©es par des clefs √©trang√®res √ßa casse tout.</p>
<p>Il faut ainsi faire cela en une seule op√©ration.
Pour cela on a UPSERT et INSERT ON DUPLICATE KEYS UPDATE (d√©pend du SGBD) qui s&#39;utilise comme INSERT et qui sont plut√¥t simples (v√©rifient si la clef primaire existe).</p>
<p>Et pour d&#39;autres, MERGE (SQL2003), qui est plus puissant (on peut personnaliser la condition), et l&#39;utiliser pour d&#39;autres usages (on peut aussi supprimer).</todo></p>
<ul>
<li>√©voquer <a href="https://sql.sh/cours/merge">https://sql.sh/cours/merge</a> (√† la fin d&#39;un TP ?)</li>
</ul>
<p>=&gt; ajouter (ou modifier si existe) =&gt; besoin notion de clef primaire.</p>
<ul>
<li><p>UPSERT.</p>
</li>
<li><p>ajouter ou modifier si existe (seulement mysql)
<a href="https://dev.mysql.com/doc/refman/8.4/en/insert-on-duplicate.html">https://dev.mysql.com/doc/refman/8.4/en/insert-on-duplicate.html</a>
<a href="https://dev.mysql.com/doc/refman/9.0/en/replace.html">https://dev.mysql.com/doc/refman/9.0/en/replace.html</a></p>
</li>
</ul>
<p>Replace √† √©viter ( <a href="https://stackoverflow.com/questions/9168928/what-are-practical-differences-between-replace-and-insert-on-duplicate-key">https://stackoverflow.com/questions/9168928/what-are-practical-differences-between-replace-and-insert-on-duplicate-key</a> ).</p>
</details>

<h3 id="modifier-les-contraintes">Modifier les contraintes</h3>
<p>Pour information, certains SGBD (pas sur SQLite) permettent de modifier les contraintes de colonnes et de tables :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span>¬†<span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ALTER</span><span class="hljs-operator">|</span>MODIFY <span class="hljs-keyword">COLUMN</span> $NAME $<span class="hljs-keyword">DESC</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CHECK</span> $<span class="hljs-keyword">DESC</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY ($COL);
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> CONSTRAINST PK_$T <span class="hljs-keyword">PRIMARY</span> KEY ($COL[,...]);
</code></pre><p>‚ö† Modifier le sch√©ma et les contraintes d&#39;une table existante/non-vide n&#39;est pas anodin.</p>
<h1 id="fusions-et-jointures">Fusions et jointures</h1>
<h2 id="op√©rations-densembles">Op√©rations d&#39;ensembles</h2>
<p>Il est possible d&#39;op√©rer des op√©rations d&#39;ensembles sur les <strong>lignes</strong> retourn√©es par deux requ√™te <code>SELECT</code>, √† conditions qu&#39;elles aient le m√™me nombre de colonnes (et id√©alement la m√™me structure) :</p>
<ul>
<li><code>UNION</code>     :¬†concat√©ner les lignes.</li>
<li><code>INTERSECT</code> : les lignes communes aux deux requ√™tes.</li>
<li><code>EXCEPT</code>    : les lignes de la premi√®re requ√™te absentes de la seconde.</li>
</ul>
<p>Les op√©rations d&#39;ensembles sont en pratique relativement rares. Elles peuvent toutefois √™tre pertinentes quand une table a √©t√© divis√©e en plusieurs tables pour des raisons de performances. Par exemple, une table <code>Vente</code> contenant de tr√®s nombreuses entr√©es, et dont la manipulation se fait quasi-exclusivement en pr√©cisant une ann√©e de vente, pourrait √™tre d√©coup√©e en vue d&#39;obtenir une table par ann√©e.</p>
<p>Ces op√©rations s&#39;utilisent sous la forme suivante :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $QUERY_1
<span class="hljs-keyword">UNION</span><span class="hljs-operator">|</span><span class="hljs-keyword">INTERSECT</span><span class="hljs-operator">|</span><span class="hljs-keyword">EXCEPT</span> [<span class="hljs-keyword">ALL</span>]
<span class="hljs-keyword">SELECT</span> $QUERY_2
</code></pre><sql-interactive>
  <span slot="options" data-op='UNION'></span>
  <span slot="options" data-op='UNION ALL'></span>
  <span slot="options" data-op='INTERSECT'></span>
  <span slot="options" data-op='EXCEPT'></span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Produits
$OP
<span class="hljs-keyword">SELECT</span> Nom, Prenom, Age <span class="hljs-keyword">FROM</span> Users;
</code></pre></sql-interactive>

<p>üí° Par d√©faut, les lignes en doublons sont supprim√©es. L&#39;option <code>ALL</code> permet de conserver l&#39;ensemble des lignes.</p>
<h2 id="sous-requ√™tes">Sous requ√™tes</h2>
<p>Vous pouvez utiliser le r√©sultat d&#39;une requ√™te <code>SELECT</code> (alors appel√©e &quot;sous-requ√™te&quot;) comme valeur dans une autre requ√™te. Par exemple, pour utiliser une sous-requ√™te dans une condition <code>WHERE</code>, il suffit de l&#39;ajouter entre parenth√®ses :</p>
<sql-interactive>
  <span slot="options" data-cond='>' data-subquery='SELECT AVG(ID) FROM T2'>Sous-requ√™te (op. de comparaison sur une valeur)</span>
  <span slot="options" data-cond='>' data-subquery='SELECT ID FROM T2'>Sous-requ√™te (op. de comparaison sur une liste)</span>
  <span slot="options" data-cond='IN' data-subquery='SELECT ID FROM T2'>Sous-requ√™te (IN)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">WHERE</span> ID $COND ( $SUBQUERY );
</code></pre></sql-interactive>

<p>‚ö† La sous-requ√™te doit retourner une liste (i.e. une seule colonne).</p>
<p>üí° Les op√©rateurs de comparaisons utilis√©s sur une liste retourneront vrai si la condition est vraie pour au moins un √©l√©ment de la liste.</p>
<p>‚ö† Certains SGBD requi√®rent d&#39;ajouter <code>ANY</code> entre l&#39;op√©rateur de comparaison et la liste.</p>
<h3 id="sous-requ√™te-corr√©l√©e">Sous-requ√™te corr√©l√©e</h3>
<p>Lorsque la sous-requ√™te d√©pend d&#39;une colonne de la requ√™te principale, elle est dite &quot;corr√©l√©e&quot;, et sera r√©ex√©cut√©e √† chaque ligne de la requ√™te principale. D√®s lors, pour des raisons de performances on utilisera les op√©rateurs :</p>
<ul>
<li><code>EXISTS</code> √† la place de <code>IN</code>.</li>
<li><code>ANY</code>/<code>SOME</code> ou <code>ALL</code> au lieu d&#39;utiliser certaines fonctions d&#39;agr√©gations.</li>
</ul>
<sql-interactive>
  <span slot="options" data-cond='EXISTS'>Sous-requ√™te corr√©l√©e</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">WHERE</span> $COND (
  <span class="hljs-keyword">SELECT</span> ID <span class="hljs-keyword">FROM</span> T2 <span class="hljs-keyword">WHERE</span> T2.ID <span class="hljs-operator">=</span> T1.ID
);
</code></pre></sql-interactive>

<p>En effet, une sous-requ√™te non-corr√©l√©e n&#39;√©tant ex√©cut√©e qu&#39;une seule fois, il est int√©ressant de l&#39;√©valuer enti√®rement en amont (i.e. r√©cup√©rer toutes les lignes), pour ensuite utiliser son r√©sultat, √† chaque entr√©e de la requ√™te principale, lors de l&#39;√©valuation la clause <code>WHERE</code>, sans avoir √† le recalculer √† chaque fois.</p>
<p>En revanche, quand une sous-requ√™te est corr√©l√©e, il faudra n√©cessairement √©valuer la sous-requ√™te √† chaque entr√©e de la requ√™te principale. Cependant il n&#39;est alors pas utile de calculer l&#39;ensemble des lignes de la sous-requ√™te, car on peut s&#39;arr√™ter √† :</p>
<ul>
<li>la premi√®re ligne existante pour <code>EXISTS</code>.</li>
<li>la premi√®re ligne satisfaisant la condition pour <code>ALL</code>.</li>
<li>la premi√®re ligne ne satisfaisant pas la condition pour <code>ALL</code>.</li>
</ul>
<p>‚ö† Il va de soit qu&#39;il faut √©viter les sous-requ√™tes corr√©l√©es autant que possible...</p>
<p>‚ö† SQLite ne supporte que <code>IN</code>, il ne supporte ni <code>ANY</code>, ni <code>ALL</code>.</p>
<h2 id="jointures">Jointures</h2>
<p>Pour rappel, une table (e.g. <code>Vente</code>) peut en r√©f√©rencer une autre (e.g. <code>Vendeur</code>). Il est alors possible d&#39;obtenir e.g. :</p>
<ul>
<li>la liste des vendeurs ayant au moins 10 ventes ?</li>
<li>la liste des ventes des vendeurs embauch√©s il y a moins de 5 ans.</li>
</ul>
<p>Pour cela il est possible d&#39;utiliser des requ√™tes corr√©l√©es, mais la syntaxe serait lourde et la requ√™te peu performante. Dans ce cas de figure on utilise ce qu&#39;on appelle des <strong>jointures</strong>, qui permettent de fusionner des entr√©es de tables diff√©rentes au sein d&#39;une m√™me ligne.</p>
<h3 id="le-produit-cart√©sien">Le produit cart√©sien</h3>
<p>Une m√©thode na√Øve (<strong>et √† ne jamais utiliser</strong>) d&#39;effectuer une jointure est d&#39;utiliser un produit cart√©sien :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> $T1, $T2 <span class="hljs-keyword">WHERE</span> $T1.$KEY <span class="hljs-operator">=</span><span class="hljs-operator">=</span> $T2.$KEY;
</code></pre><p>Pour ex√©cuter cette requ√™te, le SGDB va construire une table interm√©diaire constitu√©e de toutes les combinaisons de lignes possibles entre <code>$T1</code> et <code>$T2</code>, qu&#39;elle va ensuite parcourir pour filtrer les lignes via la clause <code>WHERE</code>.</p>
<style>
  .color1 {
    background-color: red;
  }
  .color2 {
    background-color: blue;
  }
  .color3 {
    background-color: green;
  }
  .color4 {
    background-color: orange;
  }

  .table_flex {
    display: flex;
    align-items: top;
    gap: 10px;
  }
</style>

<div style="text-align: center">
  <anim-player id="cart_anim"></anim-player>
</div>
<div class='table_flex'>
  <sql-dymtable id="cart_T1" table="T1" header="T1"></sql-dymtable>
    <span><strong>x</strong></span>
  <sql-dymtable id="cart_T2" table="T2" header="T2"></sql-dymtable>
    <span><strong>=</strong></span>
  <sql-dymtable id="cart_T1_T2" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1, T2" header="T1xT2"></sql-dymtable>
    <span><strong>-- WHERE T1.ID == T2.ID --></strong></span>
  <sql-dymtable id="cart_T1_T2W" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1, T2" header="T1xT2 WHERE T1.ID == T2.ID"></sql-dymtable>
</div>


<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const T1 = await LISS.qs("#cart_T1");
  const T2 = await LISS.qs("#cart_T2");

  const T1_T2  = await LISS.qs("#cart_T1_T2");
  const T1_T2W = await LISS.qs("#cart_T1_T2W");

  const anim   = await LISS.qs("#cart_anim");

  T1.highlightRow( ({ID}) => `high_${ID}` );
  T2.highlightRow( ({ID}) => `high_${ID}` );

  T1_T2.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
  T1_T2W.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
  
  function doStep(step) {

    let genT1_T2_max_step = T1.nbRows * (T2.nbRows + 2) + 2;

    if( step - genT1_T2_max_step > T1_T2.nbRows )
      return anim.reset();

    let T1_rownum;
    let T2_rownum;
    let T1_T2_rownum;
    let T1_T2_generated = step === 0 ? undefined : -1;

    if( step > 1 && step < genT1_T2_max_step ) { // build T1xT2
      T1_rownum = Math.trunc( (step - 2) / (T2.nbRows + 2) );
      T2_rownum =             (step - 2) % (T2.nbRows + 2) - 1;

      T1_T2_generated = T1_rownum * T2.nbRows + T2_rownum;

      if( T2_rownum === -1 )
        T2_rownum = undefined;
      if( T2_rownum === T2.nbRows ) {
        T2_rownum = undefined;
        --T1_T2_generated;
      }

      T1_T2_rownum = T1_rownum * T2.nbRows + T2_rownum;
    }

    let T1_T2W_rownum = step === 0 ? T1_T2.nbRows : -1;

    if( step >= genT1_T2_max_step ) { // filter T1xT2
      T1_T2_generated = T1_T2.nbRows;
      T1_T2W_rownum = T1_T2_rownum = step - genT1_T2_max_step;
    }


    T1.highlightRow( (_, row_num) => {
      return {cur: row_num === T1_rownum}
    });
    T2.highlightRow( (_, row_num) => {
      return {cur: row_num === T2_rownum}
    });

    T1_T2.highlightRow( (_, row_num) => {
      return {
        cur : row_num === T1_T2_rownum,
        hide: row_num >   T1_T2_generated
      }
    });
    T1_T2W.highlightRow( (row, row_num) => {
      return {
        cur : row_num === T1_T2W_rownum,
        hide: row_num >   T1_T2W_rownum || row["T1.ID"] !== row["T2.ID"]
      }
    });
  }

  anim.host.addEventListener("step", (ev) => doStep(ev.detail) );
  doStep(0);
</script>

<p>Ainsi, le produit cart√©sien de deux tables de 3 entr√©es produira une table interm√©diaire de 9 lignes, dont la majorit√© des lignes seront ensuite rejett√©es par la clause <code>WHERE</code>. M√™me sur de petites tables, la construction de la table interm√©diaire explose tr√®s vite les capacit√©s du SGDB :</p>
<style>
  .danger {
    background-color: red;
  }
</style>

<table>
  <thead>
    <tr>
      <th># Entr√©es</th>
      <th># Tables</th>
      <th># Table interm√©diaire</th>
      <th># R√©sultats</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>E</td>
      <td>T</td>
      <td>E^T</td>
      <td>E</td>
    </tr>
    <tr>
    <tr>
      <td>1 000</td>
      <td>2</td>
      <td>1 000 000</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>1 000</td>
      <td>3</td>
      <td class='danger'>1 000 000 000</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>32 000</td>
      <td>2</td>
      <td class='danger'>1 024 000 000</td>
      <td>32 000</td>
    </tr>
    <tr>
      <td>1 000</td>
      <td>6</td>
      <td class='danger'>10^18</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>1 000 000</td>
      <td>3</td>
      <td class='danger'>10^18</td>
      <td>1 000 000</td>
    </tr>
    <tr>
      <td><input class='join_nbEntries' 
      value='2'
      type=number></input></td>
      <td><input class='join_nbTables' value='2' type=number min='2'></input></td>
      <td class='join_cartesien'></td>
      <td class='join_best'></td>
    </tr>
  </tbody>
</table>

<script>
  const nb_tables_input = document.querySelector('.join_nbTables');
  const nb_entries_input = document.querySelector('.join_nbEntries');

  const result_cartesien = document.querySelector('.join_cartesien');
  const result_mieux = document.querySelector('.join_best');

  function update() {
    const nb_table   = +nb_tables_input.value;
    const nb_entries = +nb_entries_input.value;

    result_cartesien.textContent = Math.pow(nb_entries, nb_table).toLocaleString();

    result_mieux.textContent = nb_entries.toLocaleString();
  }

  nb_tables_input.addEventListener('input', update);
  nb_entries_input.addEventListener('input', update);

  update();
</script>

<p>Pour rappel, 1 milliard de lignes correspondent √† plusieurs Go en m√©moire, et 10^18 √† plusieurs Po !!!</p>
<p>‚ö† Pour cette raison, on n&#39;utilise <strong>JAMAIS</strong> les produits cart√©sien en SQL ! <strong>JA-MAIS !</strong></p>
<h3 id="le-principe-des-jointures">Le principe des jointures</h3>
<p>La bonne mani√®re de proc√©der est d&#39;utiliser la clause <code>JOIN</code> qui s&#39;utilise usuellement de la sorte :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> $T1 <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> $T2;
</code></pre><p>Pour chaque entr√©e de <code>$T1</code>, le SGBD va rechercher les entr√©es de <code>$T2</code> dont les valeurs des colonnes communes sont identiques √† celles de l&#39;entr√©e de <code>$T1</code>. Ainsi, contrairement au produit cart√©sien, le SGBD n&#39;a pas besoin de construire une table interm√©diaire colossale, r√©duisant tr√®s fortement la consommation de m√©moire vive.</p>
<div style="text-align: center">
  <anim-player id="join_anim"></anim-player>
</div>

<div class='table_flex'>
  <sql-dymtable id="join_T1" table="T1" header="T1"></sql-dymtable>
    <span><strong>JOIN</strong></span>
  <sql-dymtable id="join_T2" table="T2" header="T2"></sql-dymtable>
    <span><strong>=</strong></span>
  <sql-dymtable id="join_T1_T2W" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1 RIGHT JOIN T2 USING(ID)" header="T1 JOIN T2"></sql-dymtable>
</div>


<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const T1 = await LISS.qs("#join_T1");
  const T2 = await LISS.qs("#join_T2");

  const T1_T2W = await LISS.qs("#join_T1_T2W");

  const anim   = await LISS.qs("#join_anim");

  T1.highlightRow( ({ID}) => `high_${ID}` );
  T2.highlightRow( ({ID}) => `high_${ID}` );

  T1_T2W.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
  
  function doStep(step) {

    let T2_rownum;
    let substep;

    if( step > 1 ) { // build T1 JOIN T2
      T2_rownum = Math.trunc( (step - 2) / 3);
      substep = (step - 2) % 3;
    }

    if( T2_rownum !== undefined && T2_rownum >= T2.nbRows){
      anim.reset();
      return 
    }

    T1.highlightRow( ({ID}) => {

      return {cur: T2_rownum !== undefined && ID === T2.getRow(T2_rownum)[0].ID && substep > 0 }
    });
    T2.highlightRow( (_, row_num) => {
      return {cur: row_num === T2_rownum}
    });

    T1_T2W.highlightRow( (row, row_num) => {
      return {
        cur : step !== 0 && row_num === T2_rownum && substep === 2,
        hide: step !== 0 && (step === 1 || row_num > T2_rownum || row_num === T2_rownum && substep !== 2)
      }
    });
  }

  anim.host.addEventListener("reset", (ev) => doStep(0) );
  anim.host.addEventListener("step", (ev) => doStep(ev.detail) );
  doStep(0);
</script>

<p>üí° Si les colonnes en communs constituent un index, la recherche des entr√©es de <code>$T2</code> s&#39;en retrouve grandement accel√©r√©e. Si elles constituent une cl√© primaire/√©trang√®re, la recherche devient quasi instantan√©e.</p>
<p>‚ö† Il est ainsi <strong>plus que fortement recommand√©</strong> d&#39;effectuer des jointures sur des cl√©s primaires/√©trang√®res.</p>
<p>üí° Vous pouvez ajouter une clause <code>WHERE</code> √† v√¥tre requ√™te SQL. En th√©orie la clause <code>WHERE</code> est appliqu√©e aux entr√©es <strong>apr√®s</strong> jointures. Cependant, les SGBD sont capables d&#39;optimiser la requ√™te en pr√©filtrant, lorsque possible, les tables <strong>avant</strong> jointures.</p>
<h3 id="les-types-de-jointures">Les types de jointures</h3>
<p>En r√©alit√©, il existe 3 types de jointures fr√©quemment utilis√©es :</p>
<style>
.join_table :is(td,th):last-child {
  border :none;
  font-style:italic;
}
.join_table :is(td,th):first-child {
  border :none;
  text-align: right;
}
</style>
<table class="join_table">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" style="text-align:center">Entries</th>
      <th style="text-align:center">WHERE</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr><td>INNER :</td><td>T1</td><td>x</td><td>T2</td><td>T1.ID == T2.ID</td><td></td></tr>
    <tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>LEFT :</td><td>T1</td><td>x</td><td>NULL</td><td>T1.ID <strong>NOT IN</strong> T2.ID</td><td>(+ entr√©es INNER)</td></tr>
    <tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>FULL :</td><td>NULL</td><td>x</td><td>T2</td><td>T2.ID <strong>NOT IN</strong> T1.ID</td><td>(+ entr√©es LEFT)</td></tr>
  </tbody>
</table>

<ul>
<li><code>INNER</code> : par d√©faut.</li>
<li><code>LEFT</code>  : comme <code>INNER</code>, mais ajoute au r√©sultat les entr√©es de <code>$T1</code> dont aucune entr√©e de <code>$T2</code> ne correspond.</li>
<li><code>FULL</code> (plus rare) : comme <code>LEFT</code>, mais ajoute au r√©sultat les entr√©es de <code>$T2</code> dont aucune entr√©e de <code>$T1</code> ne correspond.<br/>
üí° Il est √©quivalant √† l&#39;union de <code>$T1 LEFT JOIN $T2</code> et <code>$T2 LEFT JOIN $T1</code>.</li>
</ul>
<sql-interactive id="join2_sql">
  <span slot="options" data-jointype='INNER'></span>
  <span slot="options" data-jointype='LEFT' ></span>
  <span slot="options" data-jointype='RIGHT'></span>
  <span slot="options" data-jointype='FULL' ></span>
  <sql-dymtable slot="post" id="join2_T1_T2W" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1 FULL JOIN T2 USING(ID)" header="T1 JOIN T2"></sql-dymtable>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">NATURAL</span> $JOINTYPE <span class="hljs-keyword">JOIN</span> T2;
</code></pre></sql-interactive>

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const T1_T2W = await LISS.qs("#join2_T1_T2W");
  const sql    = await LISS.qs("#join2_sql");

  function update(datas) {

    const t2 = datas[0].map( e => e.T2);

    T1_T2W.highlightRow( (row) => {
      return { lowlight: ! t2.includes(row["T2.T2"]) }
    });
  }

  sql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update(sql.lastDatas);

  T1_T2W.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
</script>

<p>‚ö† Il existe 2 autres types de jointures, √† √©viter :</p>
<ul>
<li><code>RIGHT</code> : <code>$T1 RIGHT¬†JOIN¬†$T2</code> est √©quivalant √† <code>$T2 LEFT¬†JOIN $T1</code><br/>
‚ö†  Pour des raisons de lisibilit√©, autant que possible, utilisez <code>LEFT</code> √† la place.</li>
<li><code>CROSS</code> : produit cart√©sien (<strong>√† √©viter</strong>).</li>
</ul>
<p>üí° Vous pourrez aussi trouver <code>LEFT/RIGHT/FULL OUTER JOIN</code> dans certaines requ√™tes SQL. Ils sont en r√©alit√© √©quivalents √† <code>LEFT/RIGHT/FULL¬†JOIN</code>.</p>
<h3 id="pr√©ciser-la-condition-de-jointure">Pr√©ciser la condition de jointure</h3>
<p>Il se peut que vous souhaitiez expliciter les colonnes sur lesquelles effectuer la jointure pour :</p>
<ul>
<li>exclure une colonne de la jointure, avec :<br/>
<code>USING($COLS[,...])</code> indiquant les colonnes √† utiliser.</li>
<li>utiliser des colonnes de noms diff√©rents, avec :<br/>
<code>ON T1.$COL1 == T2.$COL2</code> indiquant la condition de jointure.</li>
</ul>
<p>‚ö† Dans les deux cas, il vous faudra retirer le mot clef <code>NATURAL</code>.</p>
<p>üí° Il est recommand√© d&#39;utiliser <code>USING</code> au lieu de jointures naturelles (i.e. avec <code>NATURAL</code>) afin d&#39;√©viter des jointures accidentelles.</p>
<sql-interactive>
  <span slot="options" data-jointype='NATURAL'>Jointure naturelle (√† √©viter)</span>
  <span slot="options" data-joincond='USING(ID)'>Jointure explicite (noms de colonnes identiques)</span>
  <span slot="options" data-joincond='ON T1.T1 == T2.T2'>Jointure explicite (noms de colonnes diff√©rentes)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 $JOINTYPE <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> T2 $JOINCOND;
</code></pre></sql-interactive>

<p>‚ö† Si deux colonnes ont le m√™me nom, seule la premi√®re sera affich√©e. Si vous souhaitez afficher la seconde, il est alors n√©cessaire de la renommer :</p>
<sql-interactive>
  <span slot="options" data-cols='*'>Sans renommer les colonnes de m√™me noms</span>
  <span slot="options" data-cols='*, T2.ID as ID2'>En renommant les colonnes de m√™me noms</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> T2 <span class="hljs-keyword">USING</span>(ID);
</code></pre></sql-interactive>

<!--
  Non-correlated:
    - initialState : X in (....) // compute the list/value...
      + [ ] in (...)
    - step (new value)
      - 4 in (....)
    - step (check) => until end or found.
      - 4 in ([.]...)
    - if found : add line.

  - correlated:
    - initialState : X in (QUERY)
      + [ ] in () <- (QUERY [ ] )
    - step (new value)
      - 4 in () <- (QUERY [4])
    - step (check) => until end or found.
      - 4 in ([.]...) <- query [4]
    - if found : add line.
-->

</main>
    </body>
</html>