<!DOCTYPE html>
<html>
<head>
    <title>BDR CM4</title>
    <link rel="stylesheet" href="./index.css">
    <script src="./index.js" type="module" defer></script>
</head>
<body>
<header></header>
<main>
<frame-uca-title
    caption   = "R1-02 Bases de DonnÃ©es Relationnelles"
    subcaption= "CM4 : Fusions et jointures"
    author    = "Denis MIGDAL"
    mail      = "denis.migdal@uca.fr">
</frame-uca-title>

<frame-section>
  OpÃ©rations d'ensembles
</frame-section>

<frame-uca>

<div>
<b><i>ProblÃ¨me :</i></b> manipulations quasi-exclusives sur une annÃ©e donnÃ©e => tables <sql-code>Ventes_<var>$YEAR</var></sql-code>.
<ul>
  <li>Comment requÃªter plusieurs annÃ©es en mÃªme temps ?</li>
</ul>
</div>

<ul>
  <li>OpÃ©rations d'ensembles sur 2 requÃªtes <sql-code>SELECT</sql-code> (idÃ©alement mÃªme colonnes) :
    <ul>
      <li><sql-code>UNION</sql-code>     :Â <b>concatÃ©ner</b> les lignes.</li>
      <li onslide="2-"><sql-code>INTERSECT</sql-code> : les lignes <b>communes</b> aux deux requÃªtes.</li>
      <li onslide="3-"><sql-code>EXCEPT</sql-code>    : les lignes de la premiÃ¨re requÃªte <b>absentes</b> de la seconde.</li>
      <li onslide="1-">ğŸ’¡ Par dÃ©faut, sans <sql-code>ALL</sql-code> n'inclue pas les lignes en doublons.</li>
    </ul>
  </li>
</ul>

<div class="flex">
  <sql-system>
    <sql-queries>
SELECT * FROM Produits WHERE Ref == 'Gomme'
$OP
SELECT NULL, Nom, Age FROM Users;
    </sql-queries>
    <sql-option onslide="0">
    {
      "OP": "UNION"
    }
    </sql-option>
    <sql-option onslide="1">
    {
      "OP": "UNION ALL"
    }
    </sql-option>
    <sql-option onslide="2">
    {
      "OP": "INTERSECT"
    }
    </sql-option>
    <sql-option onslide="3">
    {
      "OP": "EXCEPT"
    }
    </sql-option>
    <sql-output>
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div>
    </sql-output>
  </sql-system>
</div>

</frame-uca>
<frame-section>Sous requÃªtes</frame-section>
<frame-uca>

<ul>
  <li><b>Sous requÃªte :</b> utiliser une requÃªte <sql-code>SELECT</sql-code> comme valeur dans une autre requÃªte.
    <ul>
      <li>âš  La sous-requÃªte doit retourner une liste (i.e. une seule colonne).</li>
    </ul>
  </li>
</ul>

<div class="flex">
  <sql-system>
    <sql-queries>
SELECT * FROM T1 WHERE ID $OP ( $SUBQUERY );
    </sql-queries>
    <sql-option onslide="0">
    {
      "OP": "IN",
      "SUBQUERY": "SELECT ID FROM T2"
    }
    </sql-option>
    <sql-option onslide="1">
    {
      "OP": ">",
      "SUBQUERY": "SELECT ID FROM T2"
    }
    </sql-option>
    <sql-option onslide="2">
    {
      "OP": ">=",
      "SUBQUERY": "SELECT MAX(ID) FROM T2"
    }
    </sql-option>
    <sql-output>
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div>
    </sql-output>
  </sql-system>
</div>

<div onslide="1-">

<p>ğŸ’¡ Retourne vrai si comparaison vraie pour <strong>au moins un</strong> Ã©lÃ©ment de la liste.</p>
<p>âš  Certains SGBD requiÃ¨rent d&#39;ajouter <sql-code>ANY</sql-code> entre l&#39;opÃ©rateur de comparaison et la liste.</p>
</div>

</frame-uca>
<frame-subsection>Sous-requÃªte corrÃ©lÃ©e</frame-subsection>
<frame-uca>

<ul>
  <li><b>Sous requÃªte corrÃ©lÃ©e :</b> la sous-requÃªte dÃ©pend de la requÃªte principale.
    <ul>
      <li>ğŸ’¡ requÃªte non-corrÃ©lÃ©e : sous-requÃªte exÃ©cutÃ©e <b>une unique fois</b>.</li>
      <li>âš  requÃªte correlÃ©e : rÃ©exÃ©cutÃ©e <b>Ã  chaque ligne</b> de la requÃªte principale.</li>
      <ul>
        <li>âš  Il faut les Ã©viter autant que possible...</li>
        <li>âš  Ne pas calculer toutes les lignes, s'arrÃªter le plus tÃ´t possible.
          <ul>
            <li><sql-code>EXISTS</sql-code> Ã  la place de <sql-code>IN</sql-code>.</li>
            <li><sql-code>ANY</sql-code>/<sql-code>SOME</sql-code> ou <sql-code>ALL</sql-code> Ã  la place de certaines fonctions d'agrÃ©gations.</li>
          </ul>
        </li>
      </ul>
    </ul>
  </li>
</ul>

<div class="flex">
  <sql-system>
    <sql-queries>
SELECT * FROM T1 WHERE $COND (
  SELECT ID FROM T2 WHERE T2.ID = T1.ID
);
    </sql-queries>
    <sql-option onslide="0">
    {
      "COND": "EXISTS"
    }
    </sql-option>
    <sql-output>
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div>
    </sql-output>
  </sql-system>
</div>

</frame-uca>
<frame-section>Jointures</frame-section>
<frame-uca>

<p>Pour rappel, une table (e.g. <code>Vente</code>) peut en rÃ©fÃ©rencer une autre (e.g. <code>Vendeur</code>). Il est alors possible d&#39;obtenir e.g. :</p>
<ul>
<li>la liste des vendeurs ayant au moins 10 ventes ?</li>
<li>la liste des ventes des vendeurs embauchÃ©s il y a moins de 5 ans.</li>
</ul>
<p>Pour cela il est possible d&#39;utiliser des requÃªtes corrÃ©lÃ©es, mais la syntaxe serait lourde et la requÃªte peu performante. Dans ce cas de figure on utilise ce qu&#39;on appelle des <strong>jointures</strong>, qui permettent de fusionner des entrÃ©es de tables diffÃ©rentes au sein d&#39;une mÃªme ligne.</p>
</frame-uca>
<frame-subsection>Produit cartÃ©sien</frame-subsection>
<frame-uca>

<p>Une mÃ©thode naÃ¯ve (<strong>et Ã  ne jamais utiliser</strong>) d&#39;effectuer une jointure est d&#39;utiliser un produit cartÃ©sien :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> $T1, $T2 <span class="hljs-keyword">WHERE</span> $T1.$KEY <span class="hljs-operator">=</span><span class="hljs-operator">=</span> $T2.$KEY;
</code></pre><p>Pour exÃ©cuter cette requÃªte, le SGDB va construire une table intermÃ©diaire constituÃ©e de toutes les combinaisons de lignes possibles entre <code>$T1</code> et <code>$T2</code>, qu&#39;elle va ensuite parcourir pour filtrer les lignes via la clause <code>WHERE</code>.</p>
<style>
  .color1 {
    background-color: red;
  }
  .color2 {
    background-color: blue;
  }
  .color3 {
    background-color: green;
  }
  .color4 {
    background-color: orange;
  }

  .table_flex {
    display: flex;
    align-items: top;
    gap: 10px;
  }
</style>

<div style="text-align: center">
  <anim-player id="cart_anim"></anim-player>
</div>
<div class='table_flex'>
  <sql-dymtable id="cart_T1" table="T1" header="T1"></sql-dymtable>
    <span><strong>x</strong></span>
  <sql-dymtable id="cart_T2" table="T2" header="T2"></sql-dymtable>
    <span><strong>=</strong></span>
  <sql-dymtable id="cart_T1_T2" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1, T2" header="T1xT2"></sql-dymtable>
    <span><strong>-- WHERE T1.ID == T2.ID --></strong></span>
  <sql-dymtable id="cart_T1_T2W" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1, T2" header="T1xT2 WHERE T1.ID == T2.ID"></sql-dymtable>
</div>


<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const T1 = await LISS.qs("#cart_T1");
  const T2 = await LISS.qs("#cart_T2");

  const T1_T2  = await LISS.qs("#cart_T1_T2");
  const T1_T2W = await LISS.qs("#cart_T1_T2W");

  const anim   = await LISS.qs("#cart_anim");

  T1.highlightRow( ({ID}) => `high_${ID}` );
  T2.highlightRow( ({ID}) => `high_${ID}` );

  T1_T2.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
  T1_T2W.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
  
  function doStep(step) {

    let genT1_T2_max_step = T1.nbRows * (T2.nbRows + 2) + 2;

    if( step - genT1_T2_max_step > T1_T2.nbRows )
      return anim.reset();

    let T1_rownum;
    let T2_rownum;
    let T1_T2_rownum;
    let T1_T2_generated = step === 0 ? undefined : -1;

    if( step > 1 && step < genT1_T2_max_step ) { // build T1xT2
      T1_rownum = Math.trunc( (step - 2) / (T2.nbRows + 2) );
      T2_rownum =             (step - 2) % (T2.nbRows + 2) - 1;

      T1_T2_generated = T1_rownum * T2.nbRows + T2_rownum;

      if( T2_rownum === -1 )
        T2_rownum = undefined;
      if( T2_rownum === T2.nbRows ) {
        T2_rownum = undefined;
        --T1_T2_generated;
      }

      T1_T2_rownum = T1_rownum * T2.nbRows + T2_rownum;
    }

    let T1_T2W_rownum = step === 0 ? T1_T2.nbRows : -1;

    if( step >= genT1_T2_max_step ) { // filter T1xT2
      T1_T2_generated = T1_T2.nbRows;
      T1_T2W_rownum = T1_T2_rownum = step - genT1_T2_max_step;
    }


    T1.highlightRow( (_, row_num) => {
      return {cur: row_num === T1_rownum}
    });
    T2.highlightRow( (_, row_num) => {
      return {cur: row_num === T2_rownum}
    });

    T1_T2.highlightRow( (_, row_num) => {
      return {
        cur : row_num === T1_T2_rownum,
        hide: row_num >   T1_T2_generated
      }
    });
    T1_T2W.highlightRow( (row, row_num) => {
      return {
        cur : row_num === T1_T2W_rownum,
        hide: row_num >   T1_T2W_rownum || row["T1.ID"] !== row["T2.ID"]
      }
    });
  }

  anim.host.addEventListener("step", (ev) => doStep(ev.detail) );
  doStep(0);
</script>

<p>Ainsi, le produit cartÃ©sien de deux tables de 3 entrÃ©es produira une table intermÃ©diaire de 9 lignes, dont la majoritÃ© des lignes seront ensuite rejettÃ©es par la clause <code>WHERE</code>. MÃªme sur de petites tables, la construction de la table intermÃ©diaire explose trÃ¨s vite les capacitÃ©s du SGDB :</p>
<style>
  .danger {
    background-color: red;
  }
</style>

<table>
  <thead>
    <tr>
      <th># EntrÃ©es</th>
      <th># Tables</th>
      <th># Table intermÃ©diaire</th>
      <th># RÃ©sultats</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>E</td>
      <td>T</td>
      <td>E^T</td>
      <td>E</td>
    </tr>
    <tr>
    <tr>
      <td>1 000</td>
      <td>2</td>
      <td>1 000 000</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>1 000</td>
      <td>3</td>
      <td class='danger'>1 000 000 000</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>32 000</td>
      <td>2</td>
      <td class='danger'>1 024 000 000</td>
      <td>32 000</td>
    </tr>
    <tr>
      <td>1 000</td>
      <td>6</td>
      <td class='danger'>10^18</td>
      <td>1 000</td>
    </tr>
    <tr>
      <td>1 000 000</td>
      <td>3</td>
      <td class='danger'>10^18</td>
      <td>1 000 000</td>
    </tr>
    <tr>
      <td><input class='join_nbEntries' 
      value='2'
      type=number></input></td>
      <td><input class='join_nbTables' value='2' type=number min='2'></input></td>
      <td class='join_cartesien'></td>
      <td class='join_best'></td>
    </tr>
  </tbody>
</table>

<script>
  const nb_tables_input = document.querySelector('.join_nbTables');
  const nb_entries_input = document.querySelector('.join_nbEntries');

  const result_cartesien = document.querySelector('.join_cartesien');
  const result_mieux = document.querySelector('.join_best');

  function update() {
    const nb_table   = +nb_tables_input.value;
    const nb_entries = +nb_entries_input.value;

    result_cartesien.textContent = Math.pow(nb_entries, nb_table).toLocaleString();

    result_mieux.textContent = nb_entries.toLocaleString();
  }

  nb_tables_input.addEventListener('input', update);
  nb_entries_input.addEventListener('input', update);

  update();
</script>

<p>Pour rappel, 1 milliard de lignes correspondent Ã  plusieurs Go en mÃ©moire, et 10^18 Ã  plusieurs Po !!!</p>
<p>âš  Pour cette raison, on n&#39;utilise <strong>JAMAIS</strong> les produits cartÃ©sien en SQL ! <strong>JA-MAIS !</strong></p>
</frame-uca>
<frame-subsection>Le principe des jointures</frame-subsection>
<frame-uca>

<p>La bonne maniÃ¨re de procÃ©der est d&#39;utiliser la clause <code>JOIN</code> qui s&#39;utilise usuellement de la sorte :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> $T1 <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> $T2;
</code></pre><p>Pour chaque entrÃ©e de <code>$T1</code>, le SGBD va rechercher les entrÃ©es de <code>$T2</code> dont les valeurs des colonnes communes sont identiques Ã  celles de l&#39;entrÃ©e de <code>$T1</code>. Ainsi, contrairement au produit cartÃ©sien, le SGBD n&#39;a pas besoin de construire une table intermÃ©diaire colossale, rÃ©duisant trÃ¨s fortement la consommation de mÃ©moire vive.</p>
<div style="text-align: center">
  <anim-player id="join_anim"></anim-player>
</div>

<div class='table_flex'>
  <sql-dymtable id="join_T1" table="T1" header="T1"></sql-dymtable>
    <span><strong>JOIN</strong></span>
  <sql-dymtable id="join_T2" table="T2" header="T2"></sql-dymtable>
    <span><strong>=</strong></span>
  <sql-dymtable id="join_T1_T2W" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1 RIGHT JOIN T2 USING(ID)" header="T1 JOIN T2"></sql-dymtable>
</div>


<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const T1 = await LISS.qs("#join_T1");
  const T2 = await LISS.qs("#join_T2");

  const T1_T2W = await LISS.qs("#join_T1_T2W");

  const anim   = await LISS.qs("#join_anim");

  T1.highlightRow( ({ID}) => `high_${ID}` );
  T2.highlightRow( ({ID}) => `high_${ID}` );

  T1_T2W.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
  
  function doStep(step) {

    let T2_rownum;
    let substep;

    if( step > 1 ) { // build T1 JOIN T2
      T2_rownum = Math.trunc( (step - 2) / 3);
      substep = (step - 2) % 3;
    }

    if( T2_rownum !== undefined && T2_rownum >= T2.nbRows){
      anim.reset();
      return 
    }

    T1.highlightRow( ({ID}) => {

      return {cur: T2_rownum !== undefined && ID === T2.getRow(T2_rownum)[0].ID && substep > 0 }
    });
    T2.highlightRow( (_, row_num) => {
      return {cur: row_num === T2_rownum}
    });

    T1_T2W.highlightRow( (row, row_num) => {
      return {
        cur : step !== 0 && row_num === T2_rownum && substep === 2,
        hide: step !== 0 && (step === 1 || row_num > T2_rownum || row_num === T2_rownum && substep !== 2)
      }
    });
  }

  anim.host.addEventListener("reset", (ev) => doStep(0) );
  anim.host.addEventListener("step", (ev) => doStep(ev.detail) );
  doStep(0);
</script>

<p>ğŸ’¡ Si les colonnes en communs constituent un index, la recherche des entrÃ©es de <code>$T2</code> s&#39;en retrouve grandement accelÃ©rÃ©e. Si elles constituent une clÃ© primaire/Ã©trangÃ¨re, la recherche devient quasi instantanÃ©e.</p>
<p>âš  Il est ainsi <strong>plus que fortement recommandÃ©</strong> d&#39;effectuer des jointures sur des clÃ©s primaires/Ã©trangÃ¨res.</p>
<p>ğŸ’¡ Vous pouvez ajouter une clause <code>WHERE</code> Ã  vÃ´tre requÃªte SQL. En thÃ©orie la clause <code>WHERE</code> est appliquÃ©e aux entrÃ©es <strong>aprÃ¨s</strong> jointures. Cependant, les SGBD sont capables d&#39;optimiser la requÃªte en prÃ©filtrant, lorsque possible, les tables <strong>avant</strong> jointures.</p>
</frame-uca>
<frame-subsection>Les types de jointures</frame-subsection>
<frame-uca>

<p>En rÃ©alitÃ©, il existe 3 types de jointures frÃ©quemment utilisÃ©es :</p>
<style>
.join_table :is(td,th):last-child {
  border :none;
  font-style:italic;
}
.join_table :is(td,th):first-child {
  border :none;
  text-align: right;
}
</style>
<table class="join_table">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" style="text-align:center">Entries</th>
      <th style="text-align:center">WHERE</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr><td>INNER :</td><td>T1</td><td>x</td><td>T2</td><td>T1.ID == T2.ID</td><td></td></tr>
    <tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>LEFT :</td><td>T1</td><td>x</td><td>NULL</td><td>T1.ID <strong>NOT IN</strong> T2.ID</td><td>(+ entrÃ©es INNER)</td></tr>
    <tr><td></td><td></td><td></td><td></td><td></td><td></td></tr>
    <tr><td>FULL :</td><td>NULL</td><td>x</td><td>T2</td><td>T2.ID <strong>NOT IN</strong> T1.ID</td><td>(+ entrÃ©es LEFT)</td></tr>
  </tbody>
</table>

<ul>
<li><code>INNER</code> : par dÃ©faut.</li>
<li><code>LEFT</code>  : comme <code>INNER</code>, mais ajoute au rÃ©sultat les entrÃ©es de <code>$T1</code> dont aucune entrÃ©e de <code>$T2</code> ne correspond.</li>
<li><code>FULL</code> (plus rare) : comme <code>LEFT</code>, mais ajoute au rÃ©sultat les entrÃ©es de <code>$T2</code> dont aucune entrÃ©e de <code>$T1</code> ne correspond.<br/>
ğŸ’¡ Il est Ã©quivalant Ã  l&#39;union de <code>$T1 LEFT JOIN $T2</code> et <code>$T2 LEFT JOIN $T1</code>.</li>
</ul>
<sql-interactive id="join2_sql">
  <span slot="options" data-jointype='INNER'></span>
  <span slot="options" data-jointype='LEFT' ></span>
  <span slot="options" data-jointype='RIGHT'></span>
  <span slot="options" data-jointype='FULL' ></span>
  <sql-dymtable slot="post" id="join2_T1_T2W" cols="T1.ID as 'T1.ID', T1.T1 as 'T1.T1', T2.ID as 'T2.ID', T2.T2 as 'T2.T2'" table="T1 FULL JOIN T2 USING(ID)" header="T1 JOIN T2"></sql-dymtable>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">NATURAL</span> $JOINTYPE <span class="hljs-keyword">JOIN</span> T2;
</code></pre></sql-interactive>

<script type="module">
  import LISS from "https://raw.githack.com/denis-migdal/LISS/main/index.js"

  const T1_T2W = await LISS.qs("#join2_T1_T2W");
  const sql    = await LISS.qs("#join2_sql");

  function update(datas) {

    const t2 = datas[0].map( e => e.T2);

    T1_T2W.highlightRow( (row) => {
      return { lowlight: ! t2.includes(row["T2.T2"]) }
    });
  }

  sql.host.addEventListener("change", (ev) => {
    update(ev.detail.datas);
  });
  update(sql.lastDatas);

  T1_T2W.highlightCells( (row, colname) => {
    const id = row[ colname.split('.')[0] + ".ID"];
    return `high_${id}`;
  });
</script>

<p>âš  Il existe 2 autres types de jointures, Ã  Ã©viter :</p>
<ul>
<li><code>RIGHT</code> : <code>$T1 RIGHTÂ JOINÂ $T2</code> est Ã©quivalant Ã  <code>$T2 LEFTÂ JOIN $T1</code><br/>
âš   Pour des raisons de lisibilitÃ©, autant que possible, utilisez <code>LEFT</code> Ã  la place.</li>
<li><code>CROSS</code> : produit cartÃ©sien (<strong>Ã  Ã©viter</strong>).</li>
</ul>
<p>ğŸ’¡ Vous pourrez aussi trouver <code>LEFT/RIGHT/FULL OUTER JOIN</code> dans certaines requÃªtes SQL. Ils sont en rÃ©alitÃ© Ã©quivalents Ã  <code>LEFT/RIGHT/FULLÂ JOIN</code>.</p>
</frame-uca>
<frame-subsection>PrÃ©ciser la condition de jointure</frame-subsection>
<frame-uca>

<p>Il se peut que vous souhaitiez expliciter les colonnes sur lesquelles effectuer la jointure pour :</p>
<ul>
<li>exclure une colonne de la jointure, avec :<br/>
<code>USING($COLS[,...])</code> indiquant les colonnes Ã  utiliser.</li>
<li>utiliser des colonnes de noms diffÃ©rents, avec :<br/>
<code>ON T1.$COL1 == T2.$COL2</code> indiquant la condition de jointure.</li>
</ul>
<p>âš  Dans les deux cas, il vous faudra retirer le mot clef <code>NATURAL</code>.</p>
<p>ğŸ’¡ Il est recommandÃ© d&#39;utiliser <code>USING</code> au lieu de jointures naturelles (i.e. avec <code>NATURAL</code>) afin d&#39;Ã©viter des jointures accidentelles.</p>
<sql-interactive>
  <span slot="options" data-jointype='NATURAL'>Jointure naturelle (Ã  Ã©viter)</span>
  <span slot="options" data-joincond='USING(ID)'>Jointure explicite (noms de colonnes identiques)</span>
  <span slot="options" data-joincond='ON T1.T1 == T2.T2'>Jointure explicite (noms de colonnes diffÃ©rentes)</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> T1 $JOINTYPE <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> T2 $JOINCOND;
</code></pre></sql-interactive>

<p>âš  Si deux colonnes ont le mÃªme nom, seule la premiÃ¨re sera affichÃ©e. Si vous souhaitez afficher la seconde, il est alors nÃ©cessaire de la renommer :</p>
<sql-interactive>
  <span slot="options" data-cols='*'>Sans renommer les colonnes de mÃªme noms</span>
  <span slot="options" data-cols='*, T2.ID as ID2'>En renommant les colonnes de mÃªme noms</span>

<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> $COLS <span class="hljs-keyword">FROM</span> T1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> T2 <span class="hljs-keyword">USING</span>(ID);
</code></pre></sql-interactive>

<!--
  Non-correlated:
    - initialState : X in (....) // compute the list/value...
      + [ ] in (...)
    - step (new value)
      - 4 in (....)
    - step (check) => until end or found.
      - 4 in ([.]...)
    - if found : add line.

  - correlated:
    - initialState : X in (QUERY)
      + [ ] in () <- (QUERY [ ] )
    - step (new value)
      - 4 in () <- (QUERY [4])
    - step (check) => until end or found.
      - 4 in ([.]...) <- query [4]
    - if found : add line.
-->

</frame-uca>

</html>