<!DOCTYPE html>
<html>
<head>
    <title>BDR CM3</title>
    <link rel="stylesheet" href="./index.css">
    <script src="./index.js" type="module" defer></script>
</head>
<body>
<header></header>
<main>
<frame-uca-title
    caption   = "R1-02 Bases de Donn√©es Relationnelles"
    subcaption= "CM3 : Tables et contraintes"
    author    = "Denis MIGDAL"
    mail      = "denis.migdal@uca.fr">
</frame-uca-title>

<frame-section>
  Sch√©mas de tables
</frame-section>
<frame-uca>

<div>
  <b>Sch√©mas de table :</b> entre autres, nom et type de chaque colonne.
  <br/><br/>
  <sql-system>
    <sql-queries>
SELECT * FROM pragma_table_xinfo('$TABLE1');
    </sql-queries>
    <sql-option onslide="0">
    {
      "TABLE1": "Users",
      "TABLE2": "Produits"
    }
    </sql-option>
    <sql-output class="flex">
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div><!--
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div> -->
    </sql-output>
  </sql-system>
  <ul class="flex-2">
    <li><sql-code>cid</sql-code> : identifiant.</li>
    <li><sql-code>name</sql-code> : nom.</li>
    <li><sql-code>type</sql-code> : type des donn√©es stock√©es.</li>
    <li><sql-code>notnull</sql-code> : si peut contenir <sql-code>NULL</sql-code>.</li>
    <li><sql-code>dflt_value</sql-code> : valeur par d√©faut (si vide).</li>
    <li><sql-code>pk</sql-code> : partie de la cl√© primaire (cf suite).</li>
    <li><sql-code>hidden</sql-code> : si g√©n√©r√©e (cf suite).</li>
  </ul>
</div>

<div>
  <ul>
    <li><b>PostgreSQL :</b> <sql-code>SELECT * FROM information_schema.columns 
WHERE table_name == <var>$TABLE</var>;</sql-code></li>
    <li><b>MySQL :</b> <sql-code>DESCRIBE <var>$TABLE</var>;</sql-code></li>
  </ul>
</div>

</frame-uca>
<frame-section>Op√©rations sur les tables</frame-section>
<frame-uca>

<div>

<p><em><strong>Op√©rations sur les tables :</strong></em></p>
<ul>
<li><sql-code>CREATE   TABLE</sql-code> : <strong>cr√©er</strong> une table ;</li>
<li><sql-code>ALTER    TABLE</sql-code> : <strong>modifier</strong> une table ;</li>
<li><sql-code>TRUNCATE TABLE</sql-code> : <strong>supprimer les entr√©es</strong> d&#39;une table ;</li>
<li><sql-code>DELETE   TABLE</sql-code> : <strong>supprimer</strong> une table.</li>
</ul>
</div>
</frame-uca>
<frame-subsection>Cr√©ation d'une table</frame-subsection>
<frame-uca>

<div>
  <sql-code>CREATE TABLE <var onslide="2">[IF¬†NOT¬†EXISTS]</var>¬†<var>$TABLE</var> (<var>$COLNAME $COLTYPE[,...]</var>);</sql-code>
  <ul class="flex-2">
    <li><sql-code><var>$COLNAME</var></sql-code> : nom de la colonne ;</li>
    <li><sql-code><var>$COLTYPE</var></sql-code> : type des donn√©es stock√©es.</li>
  </ul>
  <ul>
    <li onslide="2"><sql-code>IF NOT EXISTS</sql-code> : ne pas recr√©er la table si existe d√©j√†.
    <ul>
      <li>‚ö† table pas n√©cessairement vide !</li>
      <li>‚ö† les sch√©mas peuvent √™tre diff√©rents !</li>
    </ul>
    </li>
  </ul>
  <br/>
<div class="flex">
  <sql-system>
    <sql-queries>
CREATE TABLE $IFEXISTS1 T ($COLS);
CREATE TABLE $IFEXISTS2 T ($COLS);
INSERT INTO T VALUES ('Crayon', 4);
SELECT * FROM T;
CREATE TABLE T ($COLS);
    </sql-queries>
    <sql-option onslide="0">
    {
      "COLS": "Ref TEXT, Q INT",
      "IFEXISTS2": "IF NOT EXISTS"
    }
    </sql-option>
    <sql-option onslide="1">
    {
      "COLS": "Ref TEXT, Q INT"
    }
    </sql-option>
    <sql-option onslide="2">
    {
      "COLS": "Ref TEXT, Q INT",
      "IFEXISTS1": "IF NOT EXISTS",
      "IFEXISTS2": "IF NOT EXISTS"
    }
    </sql-option>
    <sql-output>
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div>
        <div class="overlay">
        <div onslide="0,2">
          <div>
            <div class="sql_query"  q="3"></div>
            <div class="sql_result" q="3"></div>
          </div>
          <div>
            <div class="sql_query"  q="4"></div>
            <div class="sql_result" q="4"></div>
          </div>
        </div>
        <div onslide="1">
            <div class="sql_query"  q="2"></div>
            <div class="sql_result" q="2"></div>
        </div>
      </div>
    </sql-output>
  </sql-system>
</div>
</div>
</frame-uca>
<frame-subsubsection>CREATE¬†TABLE¬†AS</frame-subsubsection>
<frame-uca>

<ul>
  <li>üí° <sql-code>AS <var>$VALUES_OR_SELECT</var></sql-code> : cr√©er et remplir une table √† partir d'entr√©es :
  <ul>
    <li>‚ö† Pr√©f√©rez <sql-code>CREATE TABLE</sql-code> + <sql-code>INSERT INTO</sql-code> (permet d'indiquer les contraintes).</li>
    </ul>
  </li>
</ul>

  <sql-system class="flex">
    <sql-queries>
CREATE TABLE T AS
$VALUES_OR_SELECT;
SELECT * FROM T;
SELECT * FROM pragma_table_xinfo('T');
    </sql-queries>
    <sql-option onslide="0">
    {
      "VALUES_OR_SELECT": "VALUES (1, 'A'), (2, 'B')"
    }
    </sql-option>
    <sql-option onslide="1">
    {
      "VALUES_OR_SELECT": "SELECT * FROM Produits WHERE Ref == 'Gomme'"
    }
    </sql-option>
    <sql-output>
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div>
      <div>
        <div class="sql_query"  q="2"></div>
        <div class="sql_result" q="2"></div>
      </div>
      <div>
        <div class="sql_query"  q="3"></div>
        <div class="sql_result" q="3"></div>
      </div>
    </sql-output>
  </sql-system>
</frame-uca>
<frame-subsubsection>exemples</frame-subsubsection>
<frame-uca>

<div>
<ul>
  <li>üí° Obtenir le code SQL de cr√©ation de tables existantes (SQLite) :</li>
</ul>
<br>
<sql-system>
  <sql-queries>
SELECT sql FROM sqlite_schema WHERE name IN ($TABLES);
  </sql-queries>
  <sql-option onslide="0">
  {
    "TABLES": "'Users', 'Produits'"
  }
  </sql-option>
  <sql-output class="flex">
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div><!--
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div> -->
  </sql-output>
</sql-system>
</div>

</frame-uca>
<frame-subsection>Suppression d'une table</frame-subsection>
<frame-uca>

<div class="flex-2">
  <div>
    <ul><li><b>Supprimer une table :</b></li></ul>
    <sql-system>
      <sql-queries>
DROP TABLE $IFEXISTS $TABLE;
SELECT COUNT(*) FROM $TABLE;
      </sql-queries>
      <sql-option onslide="0">
      {
        "TABLE": "Produits"
      }
      </sql-option>
      <sql-option onslide="1">
      {
        "IFEXISTS": "IF EXISTS",
        "TABLE": "Produits"
      }
      </sql-option>
      <sql-output>
        <div>
          <div class="sql_query"  q="1"></div>
          <div class="sql_result" q="1"></div>
        </div>
        <div>
          <div class="sql_query"  q="2"></div>
          <div class="sql_result" q="2"></div>
        </div>
      </sql-output>
    </sql-system>
  </div>
  <div>
    <ul><li><b>Supprimer les entr√©es :</b></li></ul>
    <sql-system>
      <sql-queries>
DELETE FROM $TABLE;
SELECT COUNT(*) FROM $TABLE;
      </sql-queries>
      <sql-option onslide="0">
      {
        "TABLE": "Produits"
      }
      </sql-option>
      <sql-output>
        <div>
          <div class="sql_query"  q="1"></div>
          <div class="sql_result" q="1"></div>
        </div>
        <div>
          <div class="sql_query"  q="2"></div>
          <div class="sql_result" q="2"></div>
        </div>
      </sql-output>
    </sql-system>
  </div>

  <div> </div>
  <div>
    ‚ö† <sql-code>TRUNCATE TABLE</sql-code> n'existe pas sur SQLite.</div>
</div>

<ul onslide="1">
  <li><sql-code>CREATE TABLE IF EXISTS</sql-code> pose probl√®me si sch√©mas diff√©rents.</li>
  <li><sql-code>DROP TABLE IF EXISTS</sql-code> puis <sql-code>CREATE TABLE</sql-code> pour s'assurer du sch√©mas.
</ul>

</frame-uca>
<frame-subsection>Modification d'une table</frame-subsection>
<frame-uca>

<div>
  <sql-code>ALTER TABLE <var>$TABLE</var> <var>(RENAME|ADD|DROP)</var> COLUMN <var>$OPT</var>;</sql-code>
  <ul class="overlay">
    <li onslide="0"><sql-code>RENAME COLUMN <var>COLNAME</var> TO <var>$NEW_NAME</var></sql-code> : <b>renomme</b> une colonne.</li>
    <li onslide="1"><sql-code>ADD COLUMN <var>$COLNAME</var>¬†<var>$COLTYPE</var></sql-code> : <b>ajoute</b> une colonne.</li>
    <li onslide="2-3"><sql-code>DROP COLUMN <var>$COLNAME</var></sql-code> : <b>supprime</b> une colonne.</li>
    <li onslide="4"><sql-code>RENAME¬†TO¬†<var>$NEW_NAME</var></sql-code> : <b>renommer</b> une table.</li>
  </ul>
</div>

<sql-system onslide="0-3">
  <sql-queries>
SELECT * FROM pragma_table_xinfo('Produits');
ALTER TABLE Produits $COMMAND COLUMN $OPTS;
SELECT * FROM pragma_table_xinfo('Produits');
SELECT * FROM Produits;
  </sql-queries>
  <sql-option onslide="0">
  {
    "COMMAND": "RENAME",
    "OPTS": "Ref TO Prod"
  }
  </sql-option>
  <sql-option onslide="1">
  {
    "COMMAND": "ADD",
    "OPTS": "Sum INT"
  }
  </sql-option>
  <sql-option onslide="2-3">
  {
    "COMMAND": "DROP",
    "OPTS": "Q"
  }
  </sql-option>
  <sql-output class="flex-2">
    <div>
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div>
      <div>
        <div class="sql_query"  q="2"></div>
        <div class="sql_result" q="2"></div>
      </div>
      <div>
        <div class="sql_query"  q="3"></div>
        <div class="sql_result" q="3"></div>
      </div>
    </div>
    <div>
      <div>
        <div class="sql_query"  q="4"></div>
        <div class="sql_result" q="4"></div>
      </div>
    </div>
  </sql-output>
</sql-system>

<div class="overlay">
  <div onslide="0-2,4-">‚ö† Modifier le sch√©ma d'une table existante est dangereux si requ√™tes SQL d√©j√† √©crites.</div>
  <div onslide="3">üí° Certains SGBD supportent des clauses <sql-code>IF¬†[NOT] EXISTS</sql-code>.</div>
</div>

</frame-uca>
<frame-section>Les contraintes</frame-section>
<frame-subsection>Motivation</frame-subsection>
<frame-uca>

<div>

<p><em><strong>Probl√®me :</strong></em> On veut garantir la validit√© des donn√©es stock√©es dans les tables :</p>
<ul class="flex">
  <li>Num√©ro de t√©l√©phone</li>
  <li>Adresses e-mail</li>
  <li>...</li>
</ul>

</div>

<p>üí° L&#39;assurance de la structure des donn√©es est un des avantages majeurs de SQL.</p>
<div>
‚ö† Sur SQLite, afin d'activer les contraintes, les <sql-code>CREATE TABLE</sql-code> doivent se terminer par <sql-code>STRICT;</sql-code><br/>
<ul>
  <li>‚ö† Ne marche pas avec les <sql-code>CREATE TABLE <var>$T</var> AS</sql-code>.</li>
</ul>
</div>

<sql-system>
  <sql-queries>
CREATE TABLE T (Prod TEXT, Q INT) STRICT;
INSERT INTO T VALUES (4, 'Crayon');
  </sql-queries>
  <sql-option onslide="0">
  {
    "COMMAND": "RENAME",
    "OPTS": "Ref TO Prod"
  }
  </sql-option>
  <sql-output>
    <div>
      <div>
        <div class="sql_query"  q="1"></div>
        <div class="sql_result" q="1"></div>
      </div>
      <div>
        <div class="sql_query"  q="2"></div>
        <div class="sql_result" q="2"></div>
      </div>
    </div>
  </sql-output>
</sql-system>

</frame-uca>
<frame-subsection>Contraintes sur les colonnes</frame-subsection>
<frame-uca>

<div>
<sql-code>CREATE TABLE T (A TEXT <var>$CONTRAINTE</var>) STRICT;</sql-code>
<ul>
  <li><sql-code>DEFAULT <var>$VAL</var></sql-code> : valeur par d√©faut si non renseign√©e lors d'un <sql-code>INSERT</sql-code>.</li>
  <li onslide="1-"><sql-code>NOT NULL</sql-code></li>
  <li onslide="2-"><sql-code>UNIQUE</sql-code> <i>‚ö† La colonne peut contenir plusieurs valeurs <sql-code>NULL</sql-code>.</i></li>
  <li onslide="3-"><sql-code>CHECK(<var>$COND</var>)</sql-code> : <sql-code><var>$COND</var></sql-code> doit √™tre vraie.</li>
  <li onslide="5-"><sql-code>AS (<var>$VAL</var>) <var onslide="6">[STORED]</var></sql-code> : valeur (re-)calcul√©e √† partir des autres colonnes.
    <ul><li onslide="6"><sql-code>STORED</sql-code> : valeur stock√©e et non-recalcul√©e sur demande.</li></ul>
  </li>
</ul>
</div>

<sql-system class="flex">
  <sql-queries>
CREATE TABLE T (ID INT $CSTRNT1, A TEXT $CSTRNT2) STRICT;
SELECT * FROM pragma_table_xinfo('T');
INSERT INTO  T $COLS VALUES $VAL;
SELECT * FROM T;
  </sql-queries>
  <sql-option onslide="0">
  {
    "CSTRNT1": "DEFAULT 0",
    "COLS": "(A)",
    "VAL": "('A')"
  }
  </sql-option>
  <sql-option onslide="1">
  {
    "CSTRNT1": "NOT NULL",
    "COLS": "(ID)",
    "VAL": "(NULL)"
  }
  </sql-option>
  <sql-option onslide="2">
  {
    "CSTRNT1": "UNIQUE",
    "COLS": "(ID)",
    "VAL": "(0), (0)"
  }
  </sql-option>
  <sql-option onslide="3">
  {
    "CSTRNT1": "CHECK(ID>0)",
    "COLS": "(ID)",
    "VAL": "(-1)"
  }
  </sql-option>
  <sql-option onslide="4">
  {
    "CSTRNT2": "CHECK(A == UPPER(A))",
    "COLS": "(A)",
    "VAL": "('a')"
  }
  </sql-option>
  <sql-option onslide="5">
  {
    "CSTRNT2": "AS ('ID:'||ID)",
    "COLS": "(ID)",
    "VAL": "(0)"
  }
  </sql-option>
  <sql-option onslide="6">
  {
    "CSTRNT2": "AS ('ID:'||ID) STORED",
    "COLS": "(ID)",
    "VAL": "(0)"
  }
  </sql-option>
  <sql-output>
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div>
    <div>
      <div class="sql_query"  q="2"></div>
      <div class="sql_result" q="2"></div>
    </div>
    <div class="sql_query"  q="3"></div>
    <div class="overlay">
      <div class="sql_result" q="3" onslide="1-4"></div>
      <div onslide="0,5-">
        <div class="sql_query"  q="4"></div>
        <div class="sql_result" q="4"></div>
      </div>
    </div>
  </sql-output>
</sql-system>

</frame-uca>
<frame-subsection>Contraintes sur la table</frame-subsection>
<frame-uca>

<div>

<p>üí° Les <strong>contraintes de tables</strong> sont des contraintes sur plusieurs colonnes :</p>
<br/>
<div class="flex">
  <div>
<sql-system>
  <sql-queries>
CREATE TABLE T (A INT, B INT, $CSTR) STRICT;
INSERT INTO  T VALUES $VALS;
  </sql-queries>
  <sql-option onslide="0">
  {
    "CSTR": "UNIQUE(A,B)",
    "VALS": "(0,1), (0,0)"
  }
  </sql-option>
  <sql-output>
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div>
    <div>
      <div class="sql_query"  q="2"></div>
      <div class="sql_result" q="2"></div>
    </div>
  </sql-output>
</sql-system>
<br/>
<sql-system>
  <sql-queries>
CREATE TABLE T (A INT, B INT, $CSTR) STRICT;
INSERT INTO  T VALUES $VALS;
  </sql-queries>
  <sql-option onslide="0">
  {
    "CSTR": "UNIQUE(A,B)",
    "VALS": "(0,1), (0,1)"
  }
  </sql-option>
  <sql-output>
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div>
    <div>
      <div class="sql_query"  q="2"></div>
      <div class="sql_result" q="2"></div>
    </div>
  </sql-output>
</sql-system>
<br/>
<sql-system>
  <sql-queries>
CREATE TABLE T (A INT, B INT, $CSTR) STRICT;
INSERT INTO  T VALUES $VALS;
  </sql-queries>
  <sql-option onslide="0">
  {
    "CSTR": "CHECK(A != B)",
    "VALS": "(0,0)"
  }
  </sql-option>
  <sql-output>
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div>
    <div>
      <div class="sql_query"  q="2"></div>
      <div class="sql_result" q="2"></div>
    </div>
  </sql-output>
</sql-system>
</div>
</div>
<br/>
üí° Elles s'√©crivent <b>apr√®s</b> la liste des colonnes.
</div>

</frame-uca>
<frame-section>Les index</frame-section>
<frame-uca>

<div>

<p><em><strong>Probl√®me</strong></em> : on veut r√©cup√©rer une entr√©e √† partir d&#39;un identifiant...</p>
<ul>
<li>... mais parcourir enti√®rement la table est <strong>co√ªteux</strong> O(N).</li>
</ul>
</div>

<div>

<p><em><strong>Solution</strong></em> : les index (contrainte de colonne ou de table).</p>
<ul>
<li>permet de rapidement trouver les entr√©es associ√©es √† un identifiant &lt;O(log2(N)).</li>
<li>comme un &quot;annuaire&quot;.</li>
</ul>
</div>

<p>üí° Il est fr√©quent que les SGBD cr√©ent automatiquement un index sur les colonnes <sql-code>UNIQUE</sql-code>. </p>
</frame-uca>
<frame-subsection>Les clefs primaires (PK)</frame-subsection>
<frame-uca>

<ul>
  <li><b>Clef primaire :</b> un index <sql-code>UNIQUE NOT NULL</sql-code>, encore plus rapide, un seul par table.
    <ul>
      <li>üí° Certains SGBD cr√©ent une clef primaire cach√©e nomm√©e <sql-code>ROWID</sql-code>.</li>
      <li onslide="3-"><sql-code>AUTOINCREMENT</sql-code> : incr√©mente automatiquement la clef primaire (recherche 0(1)).
      <ul><li>‚ö† que sur <sql-code>INTEGER¬†PRIMARY¬†KEY</sql-code>.</li></ul></lu>
    </ul>
  </li>
</ul>

<sql-system class="flex">
  <sql-queries>
CREATE TABLE T ( $PK ) STRICT;
SELECT * FROM pragma_table_xinfo('T');
INSERT INTO  T VALUES $VALS;
SELECT * FROM T;
  </sql-queries>
  <sql-option onslide="0">
  {
    "PK": "PK TEXT PRIMARY KEY",
    "VALS": "('A'), ('B')"
  }
  </sql-option>
  <sql-option onslide="1">
  {
    "PK": "PK TEXT PRIMARY KEY",
    "VALS": "(NULL)"
  }
  </sql-option>
  <sql-option onslide="2">
  {
    "PK": "PK TEXT PRIMARY KEY",
    "VALS": "('A'), ('A')"
  }
  </sql-option>
  <sql-option onslide="3">
  {
    "PK": "PK INTEGER PRIMARY KEY AUTOINCREMENT",
    "VALS": "(NULL), (NULL)"
  }
  </sql-option>
  <sql-option onslide="4">
  {
    "PK": "A TEXT, B TEXT, PRIMARY KEY(A,B)",
    "VALS": "('A', 'B'), ('A', 'A')"
  }
  </sql-option>
  <sql-option onslide="5">
  {
    "PK": "A TEXT, B TEXT, PRIMARY KEY(A,B)",
    "VALS": "('A', 'B'), ('A', 'B')"
  }
  </sql-option>
  <sql-output>
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div>
    <div>
      <div class="sql_query"  q="2"></div>
      <div class="sql_result" q="2"></div>
    </div>
    <div class="sql_query"  q="3"></div>
    <div class="overlay">
      <div onslide="1,2,5" class="sql_result" q="3"></div>
      <div onslide="0,3,4">
        <div class="sql_query"  q="4"></div>
        <div class="sql_result" q="4"></div>
      </div>
    </div>
  </sql-output>
</sql-system>

</frame-uca>
<frame-subsection>Les clefs √©trang√®res (FK)</frame-subsection>
<frame-uca>

<div>

<p><em><strong>Motivation :</strong></em> une <em>vente</em> est effectu√©e par un <em>vendeur</em> aupr√®s d&#39;un <em>client</em>.</p>
<ul class="flex-2">
  <li>Table <sql-code>Vendeur</sql-code></li>
  <li>Table <sql-code>Client</sql-code></li>
</ul>
<ul>
  <li>Table <sql-code>Vente</sql-code> : met en <b>relation</b> <sql-code>Vendeur</sql-code> et <sql-code>Client</sql-code> (<sql-code>ID_Vendeur</sql-code>, <sql-code>ID_Client</sql-code>, <sql-code>Date</sql-code>, etc.)</li>
</ul>
</div>

<p><em><strong>Probl√©matique :</strong></em> dans <sql-code>Vente</sql-code>, comment repr√©senter <sql-code>ID_Vendeur</sql-code> et <sql-code>ID_Client</sql-code> ?</p>
<div>

<p><em><strong>Solution :</strong></em> les <strong>clefs √©trang√®res</strong> (FK) <sql-code>FOREIGN KEY(<var>$FK[,...]</var>) REFERENCES <var>$T[($PK[,...])]</var></sql-code></p>
<ul>
<li>r√©f√©rence un/des colonne(s) <sql-code>UNIQUE</sql-code> d&#39;une autre table (l√©ger en m√©moire et en perfs).</li>
</ul>
<ul class="flex-2">
  <li><sql-code><var>$FK</var></sql-code> colonnes de la clef √©trang√®re.</li>
  <li><sql-code><var>$T($PK)</var></sql-code> table (et colonnes) r√©f√©renc√©e.</li>
</ul>

</div>

<sql-system class="flex">
  <sql-queries>
CREATE TABLE T (ID INT, $FK) STRICT;
INSERT INTO  T VALUES $VALS;
  </sql-queries>
  <sql-option onslide="0">
  {
    "FK": "FOREIGN KEY(ID) REFERENCES Users(ID)",
    "VALS": "(1)"
  }
  </sql-option>
  <sql-option onslide="1">
  {
    "FK": "FOREIGN KEY(ID) REFERENCES Users",
    "VALS": "(1)"
  }
  </sql-option>
  <sql-option onslide="2">
  {
    "FK": "FOREIGN KEY(ID) REFERENCES Users",
    "VALS": "(4)"
  }
  </sql-option>
  <sql-option onslide="3">
  {
    "FK": "FOREIGN KEY(ID) REFERENCES Users",
    "VALS": "(NULL)"
  }
  </sql-option>
  <sql-output>
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div>
    <div>
      <div class="sql_query"  q="2"></div>
      <div class="sql_result" q="2"></div>
    </div>
  </sql-output>
</sql-system>

<ul class="overlay">
  <li onslide="1">üí° Si les colonnes r√©f√©renc√©es ne sont pas sp√©cifi√©es, la clef primaire est utilis√©e.</li>
  <li onslide="2">
‚ö† <sql-code>PRAGMA foreign_keys = ON</sql-code> pour activer la v√©rification des clefs √©trang√®res sur SQLite.</li>
  <li onslide="3">
üí° La clef √©trang√®re peut √™tre nulle (sauf si contrainte <sql-code>NOT¬†NULL</sql-code>).</li>
</ul>

</frame-uca>
<frame-subsection>UML</frame-subsection>
<frame-uca>

<div>

<p><em><strong>Probl√©matique :</strong></em> difficile de se repr√©senter les relations entre de nombreuses tables.
<br/>
<br/>
<em><strong>Solution :</strong></em> diagramme UML pour repr√©senter visuellement les tables et leurs relations.
<br/>
<br/></p>
<div class="flex">
<pre>+------------+   +-----------+
|   Vente    |   |   Client  |
+------------+   +-----------+
| <i>ID_C: INT</i>  |-->| <b>ID  : INT</b> |
| <i>ID_V: INT</i>  |   | Nom: TEXT |
| Date: Date |   +-----------+
+------------+
</pre>

<div>Les tables sont repr√©sent√©es par un cadre en 3 parties :
<ul class="flex-2">
  <li>le <b>nom</b> de la table ;</li>
  <li>les <b>colonnes</b> ;</li>
  <li>les <b>contraintes</b> de table ;</li>
</ul><br/>
Les colonnes sont formatt√©es comme suit :
<ul class="flex">
  <li><b>clefs primaires</b></li>
  <li><i>clefs √©trang√®res</i></li>
  <li><u>unique</u>.</li>
</ul><br/>
La clef √©trang√®re est reli√©e √† la clef primaire r√©f√©renc√©e.</div>
</div></div>

<p>üí° En fonction des besoins, il est possible d&#39;ajouter plus ou moins de d√©tails.</p>
</frame-uca>
<frame-section>Op√©rations sur table avec contraintes</frame-section>
<frame-subsection>Modification/Suppression sur des colonnes r√©f√©renc√©es</frame-subsection>
<frame-uca>

<div>

<p><em><strong>Probl√®me :</strong></em> que faire lorsqu&#39;une clef primaire r√©f√©renc√©e est modifi√©e/supprim√©e ?</p>
<br/>
<ul>
  <li>C'est √† vous de le d√©finir via <sql-code>ON DELETE <var>$POLICY</var></sql-code> et <sql-code>ON UPDATE <var>$POLICY</var></sql-code> :
    <ul>
      <li><sql-code>RESTRICT</sql-code> : emp√™che la modification/suppression si r√©f√©renc√©e.</li>
      <li><sql-code>CASCADE</sql-code> : applique la modification/suppression √† la clef √©trang√®re.</li>
      <li><sql-code>SET <var>NULL|$DEFAULT</var></sql-code> : la clef √©trang√®re devient <sql-code>NULL</sql-code> (ou <sql-code><var>$DEFAULT</var></sql-code>).
    </ul>
  </li>
</ul>
</div>

<sql-system class="flex">
  <sql-queries>
CREATE TABLE T ( ID INT, A TEXT,
                 FOREIGN KEY(ID) REFERENCES Users
                    ON DELETE $POL
                    ON UPDATE $POL ) STRICT;
INSERT INTO T VALUES (2, 'A');
DELETE FROM Users WHERE ID == 2;
SELECT * FROM T;
  </sql-queries>
  <sql-option onslide="0">
  {
    "POL": "RESTRICT"
  }
  </sql-option>
  <sql-option onslide="1">
  {
    "POL": "CASCADE"
  }
  </sql-option>
  <sql-option onslide="2">
  {
    "POL": "SET NULL"
  }
  </sql-option>
  <sql-output>
    <div>
      <div class="sql_query"  q="1"></div>
      <div class="sql_result" q="1"></div>
    </div>
    <div>
      <div class="sql_query"  q="2"></div>
      <div class="sql_result" q="2"></div>
    </div>
    <div class="sql_query"  q="3"></div>
    <div class="overlay">
      <div class="sql_result" q="3"></div>
      <div onslide="1-">
        <div class="sql_query"  q="4"></div>
        <div class="sql_result" q="4"></div>
      </div>
    </div>
  </sql-output>
</sql-system>

</frame-uca>
<frame-subsection>Modifier les contraintes</frame-subsection>
<frame-uca>

<div>

<p>üí° Certains SGBD permettent de modifier les contraintes de colonnes et de tables :</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ALTER</span>¬†<span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ALTER</span><span class="hljs-operator">|</span>MODIFY <span class="hljs-keyword">COLUMN</span> $NAME $<span class="hljs-keyword">DESC</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CHECK</span> $<span class="hljs-keyword">DESC</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY ($COL);
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> $T <span class="hljs-keyword">ADD</span><span class="hljs-operator">|</span><span class="hljs-keyword">DROP</span> CONSTRAINST PK_$T <span class="hljs-keyword">PRIMARY</span> KEY ($COL[,...]);
</code></pre></div>

<p>‚ö† Modifier le sch√©ma et contraintes d&#39;une table existante/non-vide est dangereux.</p>
</frame-uca>

</html>