<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf8"/>
        <title>CM4 (Web1)</title>
        <link rel="stylesheet" href="./index.css">
        <script type="module" src="./index.js" defer></script>
    </head>
    <body>
        <style>
        </style>
        <header></header>
        <main>

<h1 id="cm4--architecture-clientserveur">CM4 : Architecture client/serveur</h1>
<p>Un site Web est g√©n√©ralement constitu√© d&#39;au moins 2 parties :</p>
<ul>
<li><em>le c√¥t√© client</em> (<em>front-end</em>) : dans le navigateur, affiche la page Web et g√®re les interactions avec l&#39;utilisateur. Il est usuellement d√©fini par un ensemble de fichiers HTML, CSS, JS, WASM, etc.</li>
<li><em>le c√¥t√© serveur</em> (<em>back-end</em>) : sur le serveur, r√©pond aux requ√™tes du navigateur afin de distribuer les fichiers n√©cessaires √† la page Web.</li>
</ul>
<p>Les √©changes entre le client et le serveur Web utilisent le protocole HTTP(S) :</p>
<ul>
<li>le client demande une ressource via une <em>requ√™te HTTP</em> ;</li>
<li>le serveur retourne la ressource demand√©e via une <em>r√©ponse HTTP</em>.</li>
</ul>
<h2 id="contenu-dynamique">Contenu dynamique</h2>
<p>Afin de tester nos pages Web en TP, nous utilisions jusqu&#39;√† pr√©sent <em>Live Server</em> comme serveur Web. Son fonctionnement est tr√®s simple : la racine du site Web est associ√©e √† un dossier <shell-code class="d4rk"><var>$ROOT</var></shell-code> du serveur. Chaque URL est alors associ√©e √† un fichier du serveur. Ainsi, lorsqu&#39;il re√ßoit une requ√™te HTTP, il retourne le fichier demand√©, e.g. :<br/>
<shell-code class="d4rk"><a href="http://localhost:5000/">http://localhost:5000/</a><var>$PATHNAME</var></shell-code> est associ√© au fichier <shell-code class="d4rk"><var>$ROOT</var>/<var>$PATHNAME</var></shell-code>.</p>
<p><em>Live Server</em> est ainsi un serveur web <em>statique</em> (<em>static web server</em>) distribuant des fichiers/ressources statiques (<em>static files/assets</em>). Il est cependant possible d&#39;avoir des serveurs <em>dynamiques</em> (<em>dynamic server</em>) g√©n√©rant le contenu renvoy√© en fonction de la requ√™te HTTP re√ßue.</p>
<p>GET $PATHNAME http1/1
Host: $SERVER
Content-Length: BODY_LEN</p>
<p>BODY</p>
<pre><code>-&gt; HTTP method.
-&gt; URL/Page // query string
-&gt; body/corps.
</code></pre><p>-&gt; UNIFORMIS√â
    -&gt; params (GET/POST)
    -&gt; URL routes
    -&gt; REST (state less : avoid DOS, cache)
    -&gt; X.</p>
<p>-&gt; fetch
    -&gt; mais aussi WebSocket/SSE.</p>
<p>-&gt; form</p>
<p>-&gt; impl server (?)
    -&gt; DOS ?</p>
<p>-&gt; opti (CM5?)</p>
<p>-&gt; distribue contenu <em>static</em>, quid <em>dynamique</em> e.g. g√©n√©r√© from BDD, from params, from command shell, etc.</p>
<p>[...]</p>
<p>Cela est bien utile lors de la phase de d√©veloppement, mais n&#39;est pas adapt√© pour la phase de production, i.e. lorsque le site Web sera mis sur un serveur afin d&#39;√™tre accessible via Internet. On utilise alors des serveurs Web, e.g. Apache, Nginx, qui offrent de nombreuses fonctionnalit√©s et possibilit√©s de configurations :</p>
<ul>
<li>r√©√©critures d&#39;URL/redirections ;</li>
<li>transfert du flux / reverse proxy ;</li>
<li>v√©rification des droits d&#39;acc√®s / authentification ;</li>
<li>gestion des caches ;</li>
<li>cgi/fastcgi ;</li>
<li>etc.</li>
</ul>
<p>Pour du contenu dynamique, i.e. g√©n√©r√© sur demande par le serveur, il existe plusieurs fa√ßons de proc√©der :</p>
<ul>
<li><p><em>CGI :</em>¬†le serveur Web execute le fichier au lieu de transmettre son contenu au client. Il √©crit sur l&#39;entr√©e standard le corps de la requ√™te, et transmet la sortie standard au client. Cette technique est simple mais peu performante.</p>
</li>
<li><p><em>fastCGI :</em>¬†analogue au CGI, mais plus performant. Un ou plusieurs processus s&#39;executent en contenu et communiquent avec le serveur Web via des sockets IPC, des sockets TCP, ou via des tubes nomm√©s. C&#39;est notamment ce qui est commun√©ment utilis√© pour PHP, Ruby on rails, etc.</p>
</li>
<li><p><em>impl√©menter son propre serveur</em> qui r√©pondra aux requ√™tes des clients. Le serveur peut alors supporter plusieurs protocoles en sus de HTTP, e.g. des WebSockets, des sockets TCP, etc. Il peut √™tre impl√©ment√© dans n&#39;importe quel langage (e.g. Python, JavaScript,  shell), et a donc acc√®s √† toutes leurs fonctionnalit√©s et biblioth√®ques.</p>
</li>
<li><p><em>rediriger le flux</em> vers un autre serveur (reverse proxy). Quasi-identique √† la solution pr√©c√©dente, il a l&#39;avantage de pouvoir b√©n√©ficier des fonctionnalit√©s du serveur Web (authentification, cache, etc), ainsi que d&#39;√©viter des probl√®mes de <em>Same Origin Policy</em> (SOP). Il peut aussi permettre de simplifier l&#39;impl√©mentation du serveur, en d√©l√©guant la s√©curisation de la communication au reverse proxy, i.e. le serveur  envoie et re√ßoit des donn√©es en clair, et le reverse proxy les chiffre et les d√©chiffre.</p>
</li>
</ul>
<h1 id="old">OLD</h1>
<p>La distribution du contenu statique est relativement simple, le serveur lit les fichiers, puis les envoie au client. Bien √©videmment, peut g√©rer des fonctionnalit√©s plus avanc√©es comme mettre les fichiers en RAM pour les distribuer plus rapidement, v√©rifier les droits d&#39;acc√®s aux fichiers (dont authentifications), r√©√©crire les URL, transmettre la requ√™te √† un autre serveur, personnaliser l&#39;en-t√™te de la r√©ponse HTTP, etc.</p>
<h1 id="le-serveur-web">Le serveur Web</h1>
<p>Le contenu g√©n√©r√© peut √™tre sous n&#39;importe quel format : de l&#39;HTML, des images, du texte brut, des donn√©es binaires, du JSON, etc. Cependant, il est pr√©f√©rable de s√©parer la structure de la page Web (HTML/CSS/JS/Images, etc.), des donn√©es dynamiques du site Web, cela pour plusieurs raisons :</p>
<ul>
<li><p>la <em>mise en cache facilit√©e</em> de la structure de la page Web statique ;</p>
</li>
<li><p><em>am√©liore la lisibilit√©</em> du code de votre site Web (notamment si la partie dynamique utilise une API¬†REST) ;</p>
</li>
<li><p><em>d√©coupler la structure de la page Web des donn√©es</em>, permettant ainsi de formatter les donn√©es afin de pouvoir facilement les r√©utiliser pour d&#39;autres usages tout en √©vitant qu&#39;une modification de la structure de la page Web ne casse tout.</p>
</li>
</ul>
<p><strong>‚ö†</strong> Vous ne devez <strong><u><em>JAMAIS</em></u></strong> faire confiance client. En effet, il est tr√®s ais√© d&#39;envoyer des donn√©es arbitraires au serveur. Vous devez ainsi <em><u><strong>SYST√âMATIQUEMENT</strong></u></em> v√©rifier la validit√© des donn√©es envoy√©es par le client (format, valeurs, autorisations, etc).</p>
<h2 id="serveur-http">Serveur HTTP</h2>
<p>Un serveur HTTP r√©pond aux <em>requ√™tes HTTP</em> du client par une <em>r√©ponse HTTP</em>. Les requ√™tes et r√©ponses HTTP se composent d&#39;un <em>en-t√™te</em> (header) contenant les m√©ta-donn√©es, et d&#39;un <em>corps</em> (body) contenant les donn√©es √©chang√©es.</p>
<p>L&#39;en-t√™te de la requ√™te contient ainsi l&#39;URI demand√©e et la <em>m√©thode HTTP</em>. L&#39;en-t√™te de la r√©ponse contient le <em>code de status</em> de la r√©ponse (200 si tout c&#39;est bien pass√©). Cf la section <em>&quot;Envoyer une requ√™te HTTP&quot;</em> de la fiche <em>API JS/DOM</em> pour plus de d√©tails.</p>
<p>C√¥t√© serveur HTTP, on manipule des routes. Une route repr√©sente un ensemble d&#39;URI qui seront trait√©es par le m√™me gestionnaire. Il peut contenir des param√®tres e.g. <code>/dir/$PARAM/foo</code> qui seront exploit√©s par le gestionnaire (handler).</p>
<p>Afin de rendre le code plus lisible, il est fr√©quent que les frameworks repr√©sentent les routes par une arborescence de fichiers. Au d√©marrage, le framework va ainsi lire de mani√®re r√©cursive un dossier e.g. <code>/routes/</code> et ajouter les diff√©rents gestionnaires en fonction des fichiers qui s&#39;y trouvent. Ainsi, le fichiers/dossier <code>/routes/dir/{PARAMS}/foo</code> contiendra le gestionnaire √† utiliser pour la route <code>/dir/$PARAM/foo</code>.</p>
<p>üö© [TODO] : outils network</p>
<h1 id="architecture-clientserveur">Architecture client/serveur</h1>
<p>L&#39;affichage d&#39;une page Web se d√©roule usuellement de la sorte :</p>
<pre><code class="hljs language-html"><span class="hljs-meta">&lt;!DOCTYPE&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&#x27;stylesheet&#x27;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;...&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><ol>
<li><p>Le navigateur demande au serveur le fichier HTML correspondant √† la page Web √† afficher.</p>
</li>
<li><p>Le navigateur commence √† lire et √† interpr√©ter le fichier HTML re√ßu.</p>
</li>
<li><p>Le navigateur lit la balise <code>&lt;script&gt;</code> et commence √† t√©l√©charger le fichier correspondant. Comme la balise a l&#39;attribut <code>defer</code>, le navigateur continue de lire et interpr√©ter le fichier HTML.</p>
</li>
<li><p>Le navigateur lit la balise <code>&lt;link&gt;</code> et commence √† t√©l√©charger le fichier CSS correspondant.</p>
</li>
<li><p>Le navigateur commence √† construire l&#39;arbre DOM √† partir du contenu de <code>&lt;body&gt;</code>.</p>
</li>
<li><p>Une fois l&#39;arbre DOM construit, il execute le script qui √©tait <code>defer</code>.</p>
</li>
<li><p>Une fois l&#39;ex√©cution du script fini, le navigateur dessine la page Web pour la premi√®re fois.</p>
</li>
</ol>
<h2 id="optimisations">Optimisations</h2>
<p>L&#39;un des objectifs des d√©veloppeur Web est de dessiner la page Web le plus t√¥t possible. Pour cela, il va user de diverses techniques :</p>
<ul>
<li><p><em>Compresser les fichiers</em> avant de les transmettre, r√©duisant le temps de t√©l√©chargement des ressources n√©cessaires.</p>
</li>
<li><p><em>R√©duire la taille des fichiers</em> en</p>
<ul>
<li><p>supprimant le code inutilis√©</p>
</li>
<li><p>le minimifiant (supprime les espaces et retours √† la ligne)</p>
</li>
<li><p>en l&#39;uglifiant (r√©duit la taille du code au prix de sa lisibilit√©, e.g. en renommant les variables).</p>
</li>
<li><p>pour les images, en r√©duisant sa r√©solution/qualit√©, ou en utilisant des formats vectoriels (SVG).</p>
</li>
<li><p>pour les images, afficher un <em>placeholder</em> ou version en basse r√©solution puis progressivement <a href="https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames/Loading#images">la remplacer une version de plus haute r√©solution</a>.</p>
</li>
</ul>
</li>
<li><p><em>T√©l√©charger ou ex√©cuter plus tard</em> les ressources non-n√©cessaires √† l&#39;affichage, via :</p>
<ul>
<li><p>du <em>lazy load</em>, e.g. ne t√©l√©charger les images que lorsqu&#39;elles apparaissent √† l&#39;√©cran.</p>
</li>
<li><p>de la <em>pagination</em>, e.g. sur un tableau ne t√©l√©charger/afficher que les X premi√®res entr√©es et proposer des boutons pour afficher les entr√©es suivantes.</p>
</li>
<li><p>en reportant l&#39;execution de certains bouts de codes √† plus tard.</p>
</li>
</ul>
</li>
<li><p><em>R√©duire le nombre de fichiers t√©l√©charg√©s</em> (on vise g√©n√©ralement 3-4 fichiers par page) :</p>
<ul>
<li><p>remplacer l&#39;URL d&#39;une image par <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">une cha√Æne de charact√®re en base64</a>.</p>
</li>
<li><p>fusionner les fichiers CSS en un seul.</p>
</li>
<li><p>fusionner les fichiers JS en un seul.</p>
</li>
<li><p>int√©grer certaines ressources (e.g. JSON) dans le fichier JS.</p>
</li>
<li><p>int√©grer le JS et/ou le CSS dans le fichier HTML.</p>
</li>
</ul>
</li>
<li><p><em>Utiliser des caches</em> pour √©viter de re-t√©l√©charger √† chaque fois certaines ressources :</p>
<ul>
<li><p>un cache bas√© le protocole HTTP (cf <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">Cache-Control</a>).</p>
</li>
<li><p>un cache local bas√© sur <code>localStorage</code>, <code>sessionStorage</code>, ou <code>indexDB</code>.</p>
</li>
<li><p>un cache c√¥t√© serveur en enregistrant des donn√©es dans la RAM afin de pouvoir r√©pondre plus rapidement aux requ√™tes qui s&#39;il fallait aller les lire directement sur le disque.</p>
</li>
</ul>
</li>
<li><p><em>Pr√©-t√©l√©charger les ressources</em>, en commen√ßant √† les t√©l√©charger le plus t√¥t possible :</p>
<ul>
<li><p>dans les balises <code>&lt;script&gt;</code>, l&#39;attribut <code>defer</code>.</p>
</li>
<li><p>pour d&#39;autres ressources utilis√©es plus tard, cf <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/preload"><link rel=preload href='...' as='...'/></a>.</p>
</li>
</ul>
</li>
<li><p>Pour les site Web massivement visit√©s :</p>
<ul>
<li><p><em>distribuer la charge</em> (load balancing) entre plusieurs serveurs (‚ö† engendre des probl√©matiques de synchronisations).</p>
</li>
<li><p><em>rapprocher le serveur du client</em>, <em>edge computing</em> (contenu dynamique), <em>content delivery network</em> (contenu statique).</p>
</li>
<li><p>d√©couper son site Web en plusieurs modules/services ind√©pendants h√©berg√©s sur plusieurs serveurs (‚ö† si les services doivent fr√©quemment communiquer entre eux cela peut s&#39;av√©rer contre-productif).</p>
</li>
</ul>
</li>
</ul>
<p>‚ö† L&#39;optimisation pr√©matur√©e est diabolique. Vous n&#39;avez, √† votre niveau, pas besoin d&#39;optimiser vos sites Web. Vous n&#39;avez pas non plus √† impl√©menter vous-m√™mes ces optimisations, de nombreux outils le font d√©j√† pour vous (e.g. Webpack).</p>
<p>üö© [TODO] : outils navigateur pour network / load performances (lighthouse)</p>
<p>üö© [TODO] : archi projet dev vs prod.</p>
<h3 id="serveur-http-bas-niveau">Serveur HTTP (bas niveau)</h3>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// [TS] TypeScript</span>
<span class="hljs-comment">// Ex√©cuter le fichier : deno run --allow-net --allow-env $FILE</span>

<span class="hljs-comment">// @deno-types=&quot;npm:@types/express@4&quot;</span>
<span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:express&quot;</span>;
<span class="hljs-keyword">import</span> cors    <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:cors&quot;</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>()) <span class="hljs-comment">// CORS - Autorise l&#x27;acc√®s √† partir d&#x27;autres domaines.</span>

<span class="hljs-comment">// Consid√©rer que le corps des requ√™tes est du texte brut.</span>
<span class="hljs-comment">// .raw() permet d&#x27;obtenir des donn√©es binaires.</span>
<span class="hljs-comment">// .json() si le corps des requ√™tes est syst√©matiquement du JSON.</span>
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">text</span>()); 

<span class="hljs-comment">// ---------------------------------------------</span>
<span class="hljs-comment">// ---------- ROUTES ---------------------------</span>
<span class="hljs-comment">// ---------------------------------------------</span>

<span class="hljs-comment">// Ajouter une route (m√©thode HTTP GET)</span>
app.<span class="hljs-title function_">get</span>($ROUTE, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> {

    <span class="hljs-comment">// Affiche les param√®tres de la requ√™te GET.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">query</span>);

    response.<span class="hljs-title function_">send</span>($DATA); <span class="hljs-comment">// $DATA est une cha√Æne de charact√®re.</span>
});

<span class="hljs-comment">// Ajouter une route (m√©thode HTTP POST)</span>
app.<span class="hljs-title function_">post</span>($ROUTE, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> {

    <span class="hljs-comment">// Affiche le corps de la requ√™te POST.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">body</span>);

    response.<span class="hljs-title function_">send</span>($DATA);
});

<span class="hljs-comment">// Renvoyer du JSON dans la r√©ponse</span>
app.<span class="hljs-title function_">get</span>($ROUTE, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> {
    response.<span class="hljs-title function_">json</span>($DATA); <span class="hljs-comment">// $DATA est un object.</span>
});

<span class="hljs-comment">// Avec un param√®tre dans la route</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/dir/:param/foo&quot;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> {
    response.<span class="hljs-title function_">send</span>(request.<span class="hljs-property">params</span>.<span class="hljs-property">param</span>);
});

<span class="hljs-comment">// Retourner un code d&#x27;erreur</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> {
    response.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Not found&quot;</span>);
});

<span class="hljs-comment">// ---------------------------------------------</span>

<span class="hljs-keyword">const</span> port = <span class="hljs-title class_">Number</span>(<span class="hljs-title class_">Deno</span>.<span class="hljs-property">env</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;PORT&quot;</span>)) || <span class="hljs-number">3000</span>;
app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Listening on http://localhost:<span class="hljs-subst">${port}</span>...`</span>);
});
</code></pre><pre><code class="hljs language-python"><span class="hljs-comment"># [üêç] Python</span>
<span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web

<span class="hljs-comment"># CORS</span>
<span class="hljs-keyword">import</span> aiohttp_cors

app = web.Application()

<span class="hljs-comment">#########################################################</span>
<span class="hljs-comment">########### ROUTES ######################################</span>
<span class="hljs-comment">#########################################################</span>

routes = web.RouteTableDef()

<span class="hljs-comment"># Ajouter une route (m√©thode HTTP GET)</span>
<span class="hljs-meta">@routes.get(<span class="hljs-params">$ROUTE</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myhandler</span>(<span class="hljs-params">request</span>):

    <span class="hljs-comment"># Affiche les param√®tres de la requ√™te GET.</span>
    <span class="hljs-built_in">print</span>(request.rel_url.query)

    <span class="hljs-keyword">return</span> web.Response(text=$DATA) <span class="hljs-comment"># $DATA est une cha√Æne de charact√®res.</span>

<span class="hljs-comment"># Ajouter une route (m√©thode HTTP POST)</span>
<span class="hljs-meta">@routes.post(<span class="hljs-params">$ROUTE</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myhandler</span>(<span class="hljs-params">request</span>):

    body = <span class="hljs-keyword">await</span> request.text <span class="hljs-comment"># pour du texte.</span>
    body = <span class="hljs-keyword">await</span> request.json <span class="hljs-comment"># pour du JSON.</span>
    <span class="hljs-built_in">print</span>(body)

    <span class="hljs-keyword">return</span> web.Response(text=$DATA)

<span class="hljs-comment"># Renvoyer du JSON dans la r√©ponse</span>
<span class="hljs-meta">@routes.get(<span class="hljs-params">$ROUTE</span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myhandler</span>(<span class="hljs-params">request</span>):
    web.json_response($DATA); <span class="hljs-comment"># $DATA est un dictionaire.</span>

<span class="hljs-comment"># Avec un param√®tre dans la route.</span>
<span class="hljs-meta">@routes.get(<span class="hljs-params"><span class="hljs-string">&quot;/dir/{param}/foo&quot;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myhandler</span>(<span class="hljs-params">request</span>):
    param = request.match_info.get(<span class="hljs-string">&#x27;param&#x27;</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-built_in">print</span>(param)
    web.Response(text=$DATA)

<span class="hljs-comment"># Retourner un code d&#x27;erreur</span>
<span class="hljs-meta">@routes.get(<span class="hljs-params"><span class="hljs-string">&quot;*&quot;</span></span>)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myhandler</span>(<span class="hljs-params">request</span>):
    <span class="hljs-keyword">raise</span> web.HTTPNotFound(<span class="hljs-string">&quot;Not found&quot;</span>)
    <span class="hljs-comment"># ou request.Response(text=&quot;Not found&quot;, status=404)</span>

app.add_routes(routes)

<span class="hljs-comment">#########################################################</span>

<span class="hljs-comment"># CORS - Autorise l&#x27;acc√®s √† partir d&#x27;autres domaines.</span>
cors = aiohttp_cors.setup(app, defaults={
    <span class="hljs-string">&quot;*&quot;</span>: aiohttp_cors.ResourceOptions(
        allow_credentials=<span class="hljs-literal">True</span>,
        expose_headers=<span class="hljs-string">&quot;*&quot;</span>,
¬†¬†¬†¬†¬†¬†¬†¬†allow_headers=<span class="hljs-string">&quot;*&quot;</span>
    )
})

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:
    web.run_app(app)
</code></pre><h3 id="serveur-http-avec-arborescence-de-routes">Serveur HTTP (avec arborescence de routes)</h3>
<h2 id="api-rest">API REST</h2>
<p>Une API REST est une mani√®re de concevoir les √©changes HTTP entre le client et le serveur de sorte √† les uniformaliser, les rendre plus compr√©hensibles, et faciliter les op√©rations de tests et de d√©boguages. Une API REST est donc impl√©ment√©e par un serveur HTTP.</p>
<p>Une requ√™te REST est compos√©e de 3 √©l√©ments :</p>
<ul>
<li><p><em>une URI</em> (ou route) qui d√©signe une ressource ;</p>
</li>
<li><p>la <em>m√©thode HTTP</em> qui indique le type d&#39;op√©ration √† effectuer ;</p>
</li>
<li><p>le <em>corps de la requ√™te</em> contenant des donn√©es envoy√©es au serveur.</p>
</li>
</ul>
<p>Une API REST supporte 5 m√©thodes HTTP :</p>
<ul>
<li><p><em>GET :</em> lire la ressource.</p>
</li>
<li><p>POST : ajouter une ressource √† une collection.</p>
</li>
<li><p><em>PUT :</em> cr√©er une ressource ou la remplacer si elle existe.</p>
</li>
<li><p><em>PATCH :</em> modifier partiellement une ressource.</p>
</li>
<li><p><em>DELETE :</em> supprimer une ressource.</p>
</li>
</ul>
<p>L&#39;URI/route des ressources doivent suivre le m√™me format. On appelle <em>collection</em> une ressource qui est elle-m√™me un ensemble de ressources. Les routes permettent aussi de g√©rer plus facilement les droits d&#39;acc√®s aux donn√©es, en autorisant/interdisant l&#39;acc√®s √† certaines routes, soit au niveau du serveur REST, soit via un reverse Proxy se pla√ßant entre le client et le serveur REST (e.g. apache, nginx).</p>
<p>La modification d&#39;une ressource est effectu√©e de la sorte :</p>
<ul>
<li><p><code>GET /$COLLECTION/</code> : obtenir la liste des ressources de la collection.</p>
</li>
<li><p><code>POST /$COLLECTION/</code> : cr√©er une nouvelle ressource dans la collection.</p>
</li>
<li><p><code>GET /$COLLECTION/$ID</code> : obtenir la ressource d&#39;identifiant <code>$ID</code> appartenant √† la collection.</p>
</li>
<li><p><code>PUT /$COLLECTION/$ID</code> : modifier ou cr√©er la ressource d&#39;identifiant <code>$ID</code> appartenant √† la collection.</p>
</li>
<li><p><code>PATCH /$COLLECTION/$ID</code> : modifier la ressource d&#39;identifiant <code>$ID</code> appartenant √† la collection.</p>
</li>
<li><p><code>DELETE /$COLLECTION/$ID</code> : supprimer la ressource d&#39;identifiant <code>$ID</code> appartenant √† la collection.</p>
</li>
</ul>
<p>Le corps de la requ√™te et de la r√©ponse REST sont usuellement au format JSON, mais peuvent utiliser n&#39;importe quel format (potentiellement d√©termin√© par la requ√™te REST) :</p>
<ul>
<li><p>URLSearchParams ;</p>
</li>
<li><p>texte brut ;</p>
</li>
<li><p>donn√©es binaires ;</p>
</li>
<li><p>XML ;</p>
</li>
<li><p>etc.</p>
</li>
</ul>
<p>Les API REST sont <em>sans √©tat</em>, c&#39;est √† dire que le serveur n&#39;enrigistre pas l&#39;√©tat de la connexion/session HTTP. L&#39;√©tat est stock√© c√¥t√© client et les donn√©es n√©cessaires sont inclues dans la requ√™te REST.</p>
<p>Le fait de ne pas stocker d&#39;√©tat c√¥t√© serveur permet d&#39;√©viter certaines attaques DoS de clients malicieux qui ouvriraient des connexions/sessions HTTP afin de surcharger le serveur. Cela permet aussi de mettre en cache la r√©ponse √† certaines requ√™tes REST, ainsi que de plus facilement r√©partir l&#39;API¬†REST sur plusieurs serveur en limitant les probl√©matiques de synchronisations.</p>
<p>Pour les op√©rations de tests et de d√©bogues, le fait qu&#39;il n&#39;y a pas d&#39;√©tat stock√© signifie qu&#39;une m√™me requ√™te REST produira le m√™me effet, quel que soit l&#39;√©tat de la connexion/session. Cela permet ainsi de mieux comprendre les √©changes entre le client et le serveur.</p>
<h2 id="websocket">Websocket</h2>
<p>üö© [TODO]</p>
<h2 id="server-send-event">Server Send Event</h2>
<p>Contrairement aux WebSockets, les <em>Server Send Events</em> ne permettent qu&#39;une communication unidirectionnelle du serveur vers le client. Il est utilis√© lorsque le serveur doit r√©guli√®rement envoyer des informations au client, sans attendre de r√©ponses, e.g. envoyer des logs en temps r√©el.</p>
<p>Le principe est tr√®s simple, il s&#39;agit d&#39;une requ√™te et d&#39;une r√©ponse HTTP normales, √† l&#39;exception que la r√©ponse HTTP est maintenue en vie (<code>keep-alive</code>) et est √©crite petit √† petit (<code>text/event-stream</code>). Le corps de la r√©ponse suit le format suivant :</p>
<pre><code>event: $EVENT_NAME
data: $DATA

event: $EVENT_NAME
data: $DATA

event: $EVENT_NAME
data: $DATA
</code></pre><p>C√¥t√© client, l&#39;utilisation est tr√®s simple, il suffit d&#39;√©couter des √©v√©nements d&#39;un <code>EventSource</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// [JS] JavaScript</span>

<span class="hljs-comment">// Client</span>
<span class="hljs-keyword">const</span> servEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>($URL);
servEvent.<span class="hljs-title function_">addEventListener</span>($EVENT_NAME, <span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ev.<span class="hljs-property">data</span>)
});
servEvent.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// termine la communication.</span>


<span class="hljs-comment">// Serveur (helper)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SSE</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">res</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">res</span> = res;
        <span class="hljs-variable language_">this</span>.#setHeaders
    }
    #<span class="hljs-title function_">setHeaders</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">res</span>.<span class="hljs-title function_">set</span>({
            <span class="hljs-string">&#x27;Cache-Control&#x27;</span>: <span class="hljs-string">&#x27;no-cache&#x27;</span>,
            <span class="hljs-string">&#x27;Content-Type&#x27;</span> : <span class="hljs-string">&#x27;text/event-stream&#x27;</span>,
            <span class="hljs-string">&#x27;Connection&#x27;</span>   : <span class="hljs-string">&#x27;keep-alive&#x27;</span>
        });
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">res</span>.<span class="hljs-title function_">flushHeaders</span>();
    }
    <span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-params">name, data</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">res</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`event: <span class="hljs-subst">${name}</span>\n<span class="hljs-subst">${data}</span>\n\n`</span>);
    }
}

<span class="hljs-comment">// Serveur</span>
app.<span class="hljs-title function_">get</span>($URL, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) {

    <span class="hljs-keyword">const</span> sse = <span class="hljs-keyword">new</span> <span class="hljs-title function_">SSE</span>(res);

    sse.<span class="hljs-title function_">dispatchEvent</span>($EVENT_NAME, $DATA); <span class="hljs-comment">// Envoyer un √©v√©nement.</span>
});
</code></pre><pre><code class="hljs language-python"><span class="hljs-comment"># [üêç] Python</span>

<span class="hljs-comment"># Client</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">ev</span>):
    console.log(ev.data)

const servEvent = EventSource.new($URL);
servEvent.addEventListener($EVENT_NAME, handler);
servEvent.close(); <span class="hljs-comment"># termine la communication.</span>

<span class="hljs-comment"># Serveur</span>
<span class="hljs-comment"># pip3 install aiohttp_sse</span>
<span class="hljs-keyword">from</span> aiohttp_sse <span class="hljs-keyword">import</span> sse_response


<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">GET</span>(<span class="hljs-params">request</span>):
    req = sse_response(request)

    req.send($DATA, event=$EVENT_NAME) <span class="hljs-comment"># Envoyer un √©v√©nement.</span>
</code></pre></main>
    </body>
</html>