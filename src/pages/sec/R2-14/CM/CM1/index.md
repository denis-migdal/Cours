<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf8"/>
        <title>CM1 (AdminSys)</title>
        <meta name="color-scheme" content="dark light">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link   href="/skeleton/index.css"  rel="stylesheet">
        <script  src="/skeleton/index.js"  type="module"     blocking="render" async></script>
    </head>
    <body>
        <main>

# Commandes SHELL

## Introduction

### Pourquoi administrer un serveur ?

L'administration d'un ordinateur a (entre autres) pour objectifs :
- d'installer et de configurer les outils n√©cessaire √† vos usages ;
- programmer (*schedule*) et automatiser des s√©ries d'actions (e.g. sauvegardes, g√©n√©rations de rapports, etc).

Ce module se concentrera sur le syst√®me d'exploitation Linux. En effet, si Windows domine les parts de march√©s pour les ordinateurs de bureaux (69% contre 4,5% pour Linux), Linux est majoritaire sur les serveurs (96,4%), et les mobiles (71% avec Android). Linux est aussi tr√®s utilis√© comme poste de travail par les d√©veloppeurs.

### Attentes et objectifs du module

Dans le cadre de votre formation, ce module vous permettra :
- d'acqu√©rir des notions de cybers√©curit√© relatives au fonctionnement d'un ordinateur ;
- administrer et personnaliser votre poste de travail ou un serveur (e.g. dans une PME) ;
- d'utiliser certains outils m√©tiers (e.g. serveurs de calculs).

Dans le cadre de ce module, il ne vous sera pas demand√© de retenir les √©tapes de configurations par coeur, mais d'√™tre capable de suivre des s√©ries d'instructions, en comprenant ce que vous faites, leur effets et raisons. Vous devrez ainsi :
- comprendre les diff√©rents concepts pr√©sent√©s dans ce module ;
- √™tre capable d'exploiter les documents fournis (e.g. cheat sheet) ;
- faire preuve de rigueur et de m√©thode.

### REPL et scripts

Dans le cadre de vos cours pr√©c√©dents, vous avez d√©j√† manipul√© plusieurs langages de scripts (R, Python, SQL). Vous utilisiez alors un interpr√©teur (Rscript, python3, sqlite3) pour ex√©cuter des instructions √©crites dans ces langages.

En Python, vous saisissiez vos instructions dans un fichier <script type="c-text">.py</script> qui √©tait lu et ex√©cut√© par l'interpr√©teur Python. On parlait alors de *script Python*.

En revanche, en SQL, vous utilisiez une interface *REPL* (*Read-Eval-Print Loop*). Vous √©criviez alors une ligne que sqlite3 lisait (*read*), interpr√©tait (*eval*), puis vous en affichait le r√©sultat (*print*). Apr√®s chaque ex√©cution, l'interpr√©teur vous affichait une **invite** (ici <script type="c-text">sqlite> </script>) pour vous indiquer que vous pouviez saisir une nouvelle instruction :

<script type="c-text">
    sqlite> SELECT 1+1 as result;
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ result ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ 2      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    sqlite> 
</script>

Les interpr√©teurs supportent bien souvent ces deux modes (scripts et REPL). Il est par exemple tout √† fait possible de donner un fichier SQL √† sqlite3, ou de lancer python3 en mode REPL :

<script type="c-python">
    >>> print("Hello")
    Hello
</script>

Pour administrer un syst√®me Linux, on utilise principalement *Shell* (un autre langage de script), avec l'interpr√©teur shell *Bash*. Comme pour les autres langages de script, il est possible de l'utiliser avec des *scripts Shell*, mais aussi via une interface REPL.

Cependant, le vocabulaire sera l√©g√®rement diff√©rent. On parlera de :
- *ligne de commande* pour la ligne saisie puis lue par l'interpr√©teur ;
- *invite de commande* (*prompt*) pour l'invite ;
- *interface en lignes de commande* (*CLI*) pour l'interface REPL.

### Pourquoi les lignes de commandes ?

On distingue 3 mani√®res d'int√©ragir avec un ordinateur :
- **CLI** : interface *en lignes de commande* (*Command Line Interface*) ;
- **GUI** : interface *graphique* (*Graphical User Interface*) ;
- **TUI** : interface *textuelle* (*Text-based User Interface*).

Pourquoi donc administrer un ordinateur en lignes de commande, plut√¥t que d'utiliser une interface graphique ?

Les interfaces en lignes de commandes comportent de nombreux avantages par rapport aux interfaces graphiques :
- on peut copier/coller des lignes de commandes (c'est du texte).
- les lignes de commandes sont ind√©pendantes de la langue de l'utilisateur (i.e. pas de traductions).
- on a toute la puissance qu'offre un langage de programmation (variables, conditions, boucles, etc).
- on peut automatiser une s√©rie d'instructions en enregistrant les lignes de commandes dans un fichier (script).

Une autre raison est tout simplement que l'ordinateur n'a pas n√©cessairement d'interface graphique install√©e. C'est g√©n√©ralement le cas pour les serveurs, afin d'en √©conomiser les ressources (GPU/CPU/RAM/r√©seau) et de r√©duire les surfaces d'attaques.

### Les serveurs

Les **serveurs** sont des ordinateurs fournissant divers **services** √† ses utilisateurs :
- *serveur Web* : h√©berge un site Web ;
- *serveur de messagerie* : permet d'envoyer et de recevoir des mails ;
- *serveurs d'applications* : permet d'utiliser des applications √† distances, sans installations, *e.g. Office 365*.
- *serveur de calculs* : permet d'effectuer des calculs longs et intensifs.

üí° Le terme **service** fait r√©f√©rence au *logiciel*, quand le terme **serveur** peut faire r√©f√©rence au *mat√©riel* ou au *logiciel*.

Les serveurs sont tr√®s utiles dans le cadre de vos activit√©s (notamment pour effectuer des calculs intensifs) :
- ils restent allum√©s h24 7j/7, avec des protections en cas de coupures d'√©lectricit√© (e.g. onduleur).
- ils ont des capacit√©s bien sup√©rieures √† un poste de travail classique (e.g. 100+ CPU, 1To+ de RAM, etc).
- ils mutualisent des ressources (CPU/RAM/licences logicielles) entre plusieurs utilisateurs.
- ils fournissent des services sans avoir √† les installer sur le poste de travail (e.g. Intranet, webmails, etc.).
- ils permettent de synchroniser des donn√©es entre plusieurs postes de travail (e.g. serveur de fichiers).
- etc.

## Le Shell

### L'invite de commande

L'invite de commande (ou *prompt*) indique que l'utilisateur peut saisir une ligne de commande. Elle se termine g√©n√©ralement par <script type="c-shell">$</script> ou <script type="c-shell">#</script>, et peut √™tre personnalis√©e. Par exemple <script type="c-shell">demigda@demigdal-Latitude-5400:~$</script> indique :
- l'utilisateur (<script type="c-shell">demigda</script>) ;
- le nom de l'ordinateur (<script type="c-shell">demigdal-Latitude-5400</script>) ;
- le r√©pertoire actuel (<script type="c-shell">~</script>), cf CM2.

üí° <script type="c-shell">@</script> se lit "at" en anglais et indique un lieu. Par exemple une adresse mail <script type="c-text">denis.migdal@uca.fr</script> signifie *"le compte <script type="c-text">denis.migdal</script> qui se trouve sur le serveur <script type="c-text">uca.fr</script>"*.

### La ligne de commande

Une ligne de commande est une mani√®re de formuler, par le biais d'une ligne de texte, une instruction √† ex√©cuter. Elle est assimilable √† l'appel d'une fonction, avec :
- une **commande** √† ex√©cuter (‚âà une fonction √† ex√©cuter) ;
- des **arguments** pass√©s en param√®tres de la commande.

üïÆ Les **arguments** sont les *valeurs* qu'on transmets (appel) aux **param√®tres** d'une commande/fonction (d√©finition).

Sa syntaxe est cependant diff√©rente des appels de fonction dont vous avez l'habitude en R ou en Python. En effet, les diff√©rents √©l√©ments ne sont pas s√©par√©s par une virgule, mais par un espace :
- <i>Fonction python :</i> <script type="c-python">foo(1, 2, 3)</script> ;
- <i>Ligne de commande :</i> <script type="c-bash">foo 1 2 3</script>.

Quand l'ordinateur interpr√®te une ligne de commande, il ex√©cute la commande indiqu√©e par le premier √©l√©ment, en lui transmettant les arguments sous la forme d'une liste.

### Les commandes

En soit, une commande n'est rien de plus qu'un ex√©cutable (i.e. un script ou un programme). Vous pouvez ainsi cr√©er une commande en √©crivant un simple script Python :

<script type="c-python">
    #!/usr/bin/env -S python3
    import sys

    print('args', sys.argv) # liste des arguments de la ligne de commande.
</script>

‚ö† <script type="c-python">sys.argv[0]</script> est le nom de la commande.

<script type="c-shell">
    $ foo 1 2 3
    args ['foo', '1', '2', '3']
</script>

Vous noterez la premi√®re ligne un peu bizarre du script :
<script type="c-python">
    #!/usr/bin/env -S python3
</script>

Cette ligne est le **Shebang**. Il permet d'indiquer √† l'ordinateur quel interpr√©teur utiliser pour ex√©cuter le script (ici python3).<br/>
Il est aussi possible d'indiquer des arguments √† transmettre √† l'interpr√©teur :
<script type="c-python">
    #!/usr/bin/env -S <h>$INTERPRETEUR</h> <h>[$INTERPRETEUR_ARGS...]</h>
</script>

### Les arguments

Comme nous l'avons vu, une commande re√ßoit ses diff√©rents arguments sous la forme d'un tableau. Elle peut ensuite les interpr√©ter de mani√®re totalement arbitraire.

Il est cependant pr√©f√©rable d'utiliser une biblioth√®que d√©di√©e (e.g. [argparse](https://docs.python.org/3/library/argparse.html) en Python) qui fournira diverses fonctionnalit√©s :
- interpr√©tation des arguments (*arguments parsing*) ;
- d√©tection et affichage des erreurs dans l'usage de la commande ;
- g√©n√©ration automatique de la documentation de la commande.

Il suffit alors de d√©clarer les diff√©rents arguments de la commande et la biblioth√®que se chargera alors du reste :

<script type="c-python">
    import sys
    from argparse import ArgumentParser

    parser = ArgumentParser()

    # d√©clarer ici les arguments de la commande

    args = parser.parse_args(sys.argv[1:])
    print(args) # les arguments apr√®s interpr√©tation
</script>

Les arguments/param√®tres **positionnels** suivent le m√™me principe qu'en Python : le i-√®me argument positionnel est mis dans le i-√®me param√®tre positionnel. Avec [argparse](https://docs.python.org/3/library/argparse.html), ils se d√©clarent ainsi :

<div class="flex-2">
    <script type="c-python">
        parser.add_argument("src")
        parser.add_argument("dst")
    </script>
    <script type="c-shell">
        $ foo 1 2
        Namespace(src='1', dst='2')
    </script>
</div>

De m√™me, les arguments/param√®tres **nomm√©s** fonctionnent de la m√™me mani√®re qu'en Python. Ils ont cependant une syntaxe diff√©rente : <script type="c-bash">--<h>$NAME</h> <h>$VALUE</h></script> ou <script type="c-bash">--<h>$NAME</h>=<h>$VALUE</h></script>. Avec [argparse](https://docs.python.org/3/library/argparse.html), ils se d√©clarent ainsi :

<div class="flex-2">
    <script type="c-python">
        parser.add_argument("--faa")
        parser.add_argument("--fuu")
    </script>
    <script type="c-shell">
        $ foo --fuu 42 --faa=toto
        Namespace(faa='toto', fuu='42')
    </script>
</div>

Petite nouveaut√©, les <b>drapeaux</b> (*flags*), o√π les param√®tres sont des bool√©ens mis √† vrai ou faux en fonction de la pr√©sence de l'argument. Avec [argparse](https://docs.python.org/3/library/argparse.html), ils se d√©clarent ainsi :

<div class="flex-2">
    <script type="c-python">
        parser.add_argument("--list",
                            action="store_true")
        parser.add_argument("--human",
                            action="store_true")
    </script>
    <script type="c-shell">
        $ foo --list
        Namespace(list=True, human=False)
        $ foo --list --human
        Namespace(list=True, human=True)
    </script>
</div>

Il est aussi possible d'associer une lettre √† un param√®tre. Il est alors possible de fusionner les arguments de drapeaux :

<div class="flex-2">
    <script type="c-python">
        parser.add_argument("-l", "--list",
                            action="store_true")
        parser.add_argument("-H", "--human",
                            action="store_true")
    </script>
    <script type="c-shell">
        $ foo -l
        Namespace(list=True, human=False)
        $ foo -lH
        Namespace(list=True, human=True)
    </script>
</div>

Une fois les param√®tres d√©clar√©s, vous pouvez alors utiliser la commande et en afficher l'usage :

<script type="c-shell">
$ foo --help
usage: foo [-h] [--faa FAA] [--fuu FUU] [-l] [-H] src dst

positional arguments:
  src
  dst

options:
  -h, --help   show this help message and exit
  --faa FAA
  --fuu FUU
  -l, --list
  -H, --human
</script>

üí° <script type="c-text">[]</script> indique le caract√®re facultatif d'un argument.

‚ö† √Ä l'inverse de Python, les arguments nomm√©s sont usuellement √©crits <b>avant</b> les arguments positionnels.

üí° <script type="c-python">add_argument()</script> a de nombreux autres arguments notamment :
- <script type="c-python">help</script> pour ajouter une description au param√®tre qui s'affichera dans l'usage.
- <script type="c-python">type</script> pour convertir l'argument en un type python (e.g. bool√©en, int, etc).
- <script type="c-python">choices</script> pour fixer les valeurs possibles pour l'argument.
- <script type="c-python">default</script> pour fixer une valeur par d√©faut si l'argument n'est pas fourni.
- <script type="c-python">required</script> pour indiquer si l'argument est requis.

üí° [argparse](https://docs.python.org/3/library/argparse.html) a encore bien d'autres options que vous pourrez d√©couvrir en lisant sa documentation.

##¬†R√©√©critures de la ligne de commande

### Les alias

<mark>todo</mark>
<mark>set -x (b4 espaces ?)</mark>


Avant d'ex√©cuter la ligne de commande, le shell (Bash) proc√®de √©ventuellement √† quelques r√©√©critures de la ligne de commande. La commande <script type="c-bash">set -x</script> permet d'afficher la ligne de commande r√©ellement ex√©cut√©e (<script type="c-bash">set +x</script> pour annuler) :
<script type='c-shell'>
$ set -x
$ foo a b
+ foo a b
</script>

üí° <script type="c-bash">set -x</script> est aussi utilis√© pour d√©boguer les scripts shell, en affichant l'execution du script pas √† pas.

Cela est par exemple le cas lorsqu'on utilise des *alias*, 

- alias (unalias) + liste

### Espaces dans les arguments

Pour inclure un espace dans un argument, il convient de soit les √©chapper, soit de mettre le texte entre guillements simples :
<script type="c-shell">
$ foo 'a b' c\ d
Namespace(src='a b', dst='c d')
</script>

üí° Il est aussi possible de ne mettre qu'une partie de l'argument entre guillements :
<script type="c-shell">
$ foo a' 'b c\ d
Namespace(src='a b', dst='c d')
</script>

üí° <script type="c-bash">$'<h>$TXT</h>'</script> permet d'interpr√©ter les caract√®res √©chapp√©s, e.g. :
- <script type="c-text">\n</script> : retour √† la ligne ;
- <script type="c-text">\t</script> : tabulation ;
- <script type="c-text">\e</script> : pour le formattage du texte (cf TP1).

<script type="c-python">
    #¬†commande faa :
    print( sys.argv[1] )
</script>

<div class="flex-2">
    <script type="c-shell">
        $ faa '-\n\t-'
        -\n\t-
    </script>
    <script type="c-shell">
        $ faa $'-\n\t-'
        -
	        -
    </script>
</div>

## Le terminal

### Shell vs Terminal

- Le *Shell* est le programme qui va **interpr√©ter** et **ex√©cuter** les commandes shell que vous entrerez.

- Le *Terminal* (ou *console*) est l'interface graphique qui permet de faire le lien entre l'utilisateur et le Shell. Il vous permet d'√©crire des *lignes de commandes* qui seront envoy√©es au *Shell*, puis d'en visualiser le r√©sultat.

üïÆ Historiquement, les premiers ordinateurs avaient la taille d'une pi√®ce (e.g. 160m¬≤). Des consoles constitu√©es d'un clavier et d'un √©cran permettaient d‚Äôinteragir avec l'ordinateur (mainframe). Vous pouvez voir le shell comme le mainframe, et le terminal comme la console permettant d'interagir avec le mainframe.

### CLI vs TUI

Vous pouvez utiliser deux types d'interfaces au sein d'un terminal :
- **CLI** (*Command-Line Interface*) : lignes de commande.
- **TUI** (*Terminal User Interface*) : interactif, avec le clavier et la souris.

<div class='flex-2'>
    <div>
        <center>
            <strong>CLI</strong> (commande <script type="c-bash">tree</script>)
        </center>
        <img src="../../../../assets/admsys/img/cli-example.png"/>
    </div>
    <div>
        <center>
            <strong>TUI</strong> (commande <script type="c-bash">gdu</script>)
        </center>
        <img src="../../../../assets/admsys/img/tui-example.png"/>
    </div>
</div>

üí° Les interfaces TUI sont moins "standard", mais sont plus ergonomiques. Dans le cadre de ce module, et afin de faciliter votre apprentissage, nous essayerons de proposer des alternatives ergonomique lorsque possible.

### Utilisation du terminal

Recopier √† la main des commandes est sources d'erreurs et de fautes de frappe. Il convient d'utiliser autant que possible les 3 fonctionnalit√©s suivantes :

- **Copier-coller** le texte s√©lectionn√© :<br/>
  ‚ö† Copier (<script type="c-text">^+‚áß+C</script>) et Coller (<script type="c-text">^+‚áß+V</script>) s'effectuent avec un <script type="c-text">‚áß</script>.<br/>
  üí° Le clic-milieu ou clic-molette de la souris copie/colle le texte s√©lectionn√©.
- **Auto-compl√©tion** des commandes et chemins (<script type="c-text">‚≠æ</script>).<br/>
  üí° <script type="c-text">‚≠æ+‚≠æ</script> affiche les diff√©rentes possibilit√©s d'auto-compl√©tion.
- **Historique** : <script type="c-text">‚Üë</script> ou <script type="c-text">‚Üì</script> permettent de naviguer parmi l'historique des lignes de commandes tap√©es (et potentiellement de les r√©ex√©cuter).<br/>
  üí° <script type="c-text">‚Üê</script> ou <script type="c-text">‚Üí</script> permettent ensuite de modifier la ligne de commande.


‚ö† <script type="c-text">^+C</script> permet d'arr√™ter une commande en cours d'ex√©cution.

### Quelques commandes utiles

#### La documentation

- <script type="c-bash">man  <h>$CMD</h></script> (<u>man</u>uel) : affiche la documentation de la commande <script type="c-bash"><h>$CMD</h></script>.
- <script type="c-bash">tldr <h>$CMD</h></script> (<u>t</u>oo <u>l</u>ong : <u>d</u>idn't <u>r</u>ead) : version simplifi√©e de <script type="c-bash">man</script>.
- <script type="c-bash">help <h>$CMD</h></script> : affiche la liste des commandes internes de bash.

#### Le terminal

- <script type="c-bash">clear</script> : replace l'invite de commande en haut de la fen√™tre.
- <script type="c-bash">reset</script> : efface compl√®tement le contenu du terminal.
- <script type="c-bash">exit</script> : quitte le terminal.

#### L'historique

- <script type="c-bash">history</script> : affiche l'historique des derni√®res lignes de commandes ex√©cut√©es.
- <script type="c-bash">!!</script> : r√©ex√©cuter la derni√®re commande entr√©e.
- <script type="c-bash">!<h>$CMD</h></script> : r√©ex√©cute la derni√®re commande <script type="c-bash"><h>$CMD</h></script> entr√©e.

## Acc√®s √† distance

Les serveurs sont usuellement install√©s dans une salle d√©di√©e avec contr√¥le d‚Äôacc√®s, parfois √† plusieurs centaines (ou milliers) de km de votre poste de travail. Par exemple, le serveur pourrait √™tre √† Clermont-Ferrand alors que votre bureau est √† Aurillac.

Bien √©videment, vous n'allez pas faire l'aller-retour √† Clermont-Ferrand, √† chaque ligne de commande que vous souhaitez ex√©cuter sur le serveur. Imaginez que vous deviez r√©guli√®rement intervenir sur le serveur, vous passeriez votre temps √† faire l‚Äôaller-retour Aurillac/Clermont-Ferrand !

Il est ainsi n√©cessaire de pouvoir acc√©der au serveur √† distance afin d‚Äô√©viter de tels d√©placements chronophages. Pour ce faire, on utilise **SSH** (<u>s</u>ecure <u>sh</u>ell) afin d‚Äôenvoyer, via Internet, des lignes de commande au serveur, ce en √† peine quelques millisecondes.


SSH suit une architecture client-serveur avec :
- un **client SSH** sur le poste de travail ;
- un **serveur SSH** sur le serveur.

Le *client SSH* permet d‚Äôinitier une connexion SSH (‚âà session SSH) avec le *serveur SSH*. Une fois la connexion √©tablie, le *client SSH* peut alors envoyer des commandes shell au *serveur SSH* qui les ex√©cutera, et en retournera le r√©sultat.

La commande <script type="c-bash">ssh <h>$USER</h>@<h>$SERVER</h></script> initie une session SSH. Les commandes entr√©es par la suite sont envoy√©es au serveur pour √™tre ex√©cut√©es. Dans les faits, cela revient √† ouvrir un terminal du serveur sur votre poste de travail :

<img src='/assets/admsys/img/scheme.svg'/>

üí° <script type="c-bash">ssh <h>$USER</h>@<h>$SERVER</h> "<h>$CMD</h>"</script> ex√©cute la commande <script type="c-bash">CMD</script> sur le serveur, et retourne imm√©diatement. 


        </main>
    </body>
</html>